(() => {
  var __webpack_modules__ = {
    99264: (module, __unused_webpack_exports, __webpack_require__) => {
      const BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        get isArboristCmd() {
          return !0;
        }
        static params=[ "workspace", "workspaces", "include-workspace-root", "install-links" ];
        static ignoreImplicitWorkspace=!1;
        async execWorkspaces(args, filters) {
          return await this.setWorkspaces(filters), this.exec(args);
        }
      };
    },
    2126: (module, __unused_webpack_exports, __webpack_require__) => {
      const profile = __webpack_require__(77969), log = __webpack_require__(86883), openUrlPrompt = __webpack_require__(7425), read = __webpack_require__(87121), loginPrompter = async creds => (creds.username = await read.username("Username:", creds.username), 
      creds.password = await read.password("Password:", creds.password), creds.email = await read.email("Email: (this IS public) ", creds.email), 
      creds);
      module.exports = async (npm, opts) => {
        let res;
        const requestOTP = async () => {
          const otp = await read.otp("Enter one-time password: ");
          return profile.loginCouch(opts.creds.username, opts.creds.password, {
            ...opts,
            otp
          });
        }, openerPromise = (url, emitter) => openUrlPrompt(npm, url, "Authenticate your account at", "Press ENTER to open in the browser...", emitter);
        try {
          res = await profile.login(openerPromise, loginPrompter, opts);
        } catch (err) {
          const needsMoreInfo = !(opts && opts.creds && opts.creds.username && opts.creds.password && opts.creds.email);
          if ("EOTP" === err.code) res = await requestOTP(); else {
            if (needsMoreInfo) throw err;
            res = await (async () => {
              let newUser;
              try {
                newUser = await profile.adduserCouch(opts.creds.username, opts.creds.email, opts.creds.password, opts);
              } catch (err) {
                if ("EOTP" !== err.code) throw err;
                newUser = await requestOTP();
              }
              return newUser;
            })();
          }
        }
        const newCreds = {};
        res && res.token ? newCreds.token = res.token : (newCreds.username = opts.creds.username, 
        newCreds.password = opts.creds.password, newCreds.email = opts.creds.email, newCreds.alwaysAuth = opts.creds.alwaysAuth);
        const usermsg = opts.creds.username ? ` user ${opts.creds.username}` : "", scopeMessage = opts.scope ? ` to scope ${opts.scope}` : "", message = `Logged in${opts.creds.username ? ` as ${opts.creds.username}` : ""}${scopeMessage} on ${opts.registry}.`;
        return log.info("login", `Authorized${usermsg}`), {
          message,
          newCreds
        };
      };
    },
    4620: (module, __unused_webpack_exports, __webpack_require__) => {
      const sso = __webpack_require__(14956);
      module.exports = (npm, opts) => (npm.config.set("sso-type", "oauth"), sso(npm, opts));
    },
    7474: (module, __unused_webpack_exports, __webpack_require__) => {
      const sso = __webpack_require__(14956);
      module.exports = (npm, opts) => (npm.config.set("sso-type", "saml"), sso(npm, opts));
    },
    14956: (module, __unused_webpack_exports, __webpack_require__) => {
      const profile = __webpack_require__(77969), npmFetch = __webpack_require__(92427), log = __webpack_require__(86883), openUrl = __webpack_require__(89562), otplease = __webpack_require__(83304), pollForSession = ({registry, token, opts}) => (log.info("adduser", "Polling for validated SSO session"), 
      npmFetch.json("/-/whoami", {
        ...opts,
        registry,
        forceAuth: {
          token
        }
      }).then((({username}) => username), (err => {
        if ("E401" === err.code) return (time = opts.ssoPollFrequency, new Promise((resolve => setTimeout(resolve, time)))).then((() => pollForSession({
          registry,
          token,
          opts
        })));
        throw err;
        var time;
      })));
      module.exports = async (npm, {creds, registry, scope}) => {
        const opts = {
          ...npm.flatOptions,
          creds,
          registry,
          scope
        }, {ssoType} = opts;
        if (!ssoType) throw new Error("Missing option: sso-type");
        const auth = {
          username: "npm_" + ssoType + "_auth_dummy_user",
          password: "placeholder",
          email: "support@npmjs.com",
          authType: ssoType
        }, {token, sso} = await otplease(npm, opts, (opts => profile.loginCouch(auth.username, auth.password, opts)));
        if (!token) throw new Error("no SSO token returned");
        if (!sso) throw new Error("no SSO URL returned by services");
        await openUrl(npm, sso, "to complete your login please visit");
        const username = await pollForSession({
          registry,
          token,
          opts
        });
        log.info("adduser", `Authorized user ${username}`);
        return {
          message: `Logged in as ${username}${scope ? " to scope " + scope : ""} on ${registry}.`,
          newCreds: {
            token
          }
        };
      };
    },
    26727: (module, __unused_webpack_exports, __webpack_require__) => {
      const {relative} = __webpack_require__(71017), ConfigDefinitions = __webpack_require__(18700), getWorkspaces = __webpack_require__(2143), cmdAliases = __webpack_require__(34456).aliases;
      module.exports = class {
        constructor(npm) {
          this.wrapWidth = 80, this.npm = npm;
        }
        get name() {
          return this.constructor.name;
        }
        get description() {
          return this.constructor.description;
        }
        get ignoreImplicitWorkspace() {
          return this.constructor.ignoreImplicitWorkspace;
        }
        get usage() {
          const usage = [ `${this.constructor.description}`, "", "Usage:" ];
          this.constructor.usage ? usage.push(...this.constructor.usage.map((u => `npm ${this.constructor.name} ${u}`))) : usage.push(`npm ${this.constructor.name}`), 
          this.constructor.params && (usage.push(""), usage.push("Options:"), usage.push(this.wrappedParams));
          const aliases = Object.keys(cmdAliases).reduce(((p, c) => (cmdAliases[c] === this.constructor.name && p.push(c), 
          p)), []);
          return 1 === aliases.length ? (usage.push(""), usage.push(`alias: ${aliases.join(", ")}`)) : aliases.length > 1 && (usage.push(""), 
          usage.push(`aliases: ${aliases.join(", ")}`)), usage.push(""), usage.push(`Run "npm help ${this.constructor.name}" for more info`), 
          usage.join("\n");
        }
        get wrappedParams() {
          let results = "", line = "";
          for (const param of this.constructor.params) {
            const usage = `[${ConfigDefinitions[param].usage}]`;
            line.length && line.length + usage.length > this.wrapWidth && (results = [ results, line ].filter(Boolean).join("\n"), 
            line = ""), line = [ line, usage ].filter(Boolean).join(" ");
          }
          return results = [ results, line ].filter(Boolean).join("\n"), results;
        }
        usageError(prefix = "") {
          return prefix && (prefix += "\n\n"), Object.assign(new Error(`\n${prefix}${this.usage}`), {
            code: "EUSAGE"
          });
        }
        async execWorkspaces(args, filters) {
          throw Object.assign(new Error("This command does not support workspaces."), {
            code: "ENOWORKSPACES"
          });
        }
        async setWorkspaces(filters) {
          this.isArboristCmd && (this.includeWorkspaceRoot = !1);
          const relativeFrom = relative(this.npm.localPrefix, process.cwd()).startsWith("..") ? this.npm.localPrefix : process.cwd(), ws = await getWorkspaces(filters, {
            path: this.npm.localPrefix,
            includeWorkspaceRoot: this.includeWorkspaceRoot,
            relativeFrom
          });
          this.workspaces = ws, this.workspaceNames = [ ...ws.keys() ], this.workspacePaths = [ ...ws.values() ];
        }
      };
    },
    65719: (module, __unused_webpack_exports, __webpack_require__) => {
      const path = __webpack_require__(71017), libaccess = __webpack_require__(63167), readPackageJson = __webpack_require__(1759), otplease = __webpack_require__(83304), getIdentity = __webpack_require__(18084), log = __webpack_require__(86883), BaseCommand = __webpack_require__(26727), subcommands = [ "public", "restricted", "grant", "revoke", "ls-packages", "ls-collaborators", "edit", "2fa-required", "2fa-not-required" ], deprecated = [ "2fa-not-required", "2fa-required", "ls-collaborators", "ls-packages", "public", "restricted" ];
      module.exports = class extends BaseCommand {
        static description="Set access level on published packages";
        static name="access";
        static params=[ "registry", "otp" ];
        static ignoreImplicitWorkspace=!0;
        static usage=[ "public [<package>]", "restricted [<package>]", "grant <read-only|read-write> <scope:team> [<package>]", "revoke <scope:team> [<package>]", "2fa-required [<package>]", "2fa-not-required [<package>]", "ls-packages [<user>|<scope>|<scope:team>]", "ls-collaborators [<package> [<user>]]", "edit [<package>]" ];
        async completion(opts) {
          const argv = opts.conf.argv.remain;
          if (2 === argv.length) return subcommands;
          switch (argv[2]) {
           case "grant":
            return 3 === argv.length ? [ "read-only", "read-write" ] : [];

           case "public":
           case "restricted":
           case "ls-packages":
           case "ls-collaborators":
           case "edit":
           case "2fa-required":
           case "2fa-not-required":
           case "revoke":
            return [];

           default:
            throw new Error(argv[2] + " not recognized");
          }
        }
        async exec([cmd, ...args]) {
          if (!cmd) throw this.usageError("Subcommand is required.");
          if (!subcommands.includes(cmd) || !this[cmd]) throw this.usageError(`${cmd} is not a recognized subcommand.`);
          return deprecated.includes(cmd) && log.warn("access", `${cmd} subcommand will be removed in the next version of npm`), 
          this[cmd](args, {
            ...this.npm.flatOptions
          });
        }
        public([pkg], opts) {
          return this.modifyPackage(pkg, opts, libaccess.public);
        }
        restricted([pkg], opts) {
          return this.modifyPackage(pkg, opts, libaccess.restricted);
        }
        async grant([perms, scopeteam, pkg], opts) {
          if (!perms || "read-only" !== perms && "read-write" !== perms) throw this.usageError("First argument must be either `read-only` or `read-write`.");
          if (!scopeteam) throw this.usageError("`<scope:team>` argument is required.");
          const [, scope, team] = scopeteam.match(/^@?([^:]+):(.*)$/) || [];
          if (!scope && !team) throw this.usageError("Second argument used incorrect format.\nExample: @example:developers");
          return this.modifyPackage(pkg, opts, ((pkgName, opts) => libaccess.grant(pkgName, scopeteam, perms, opts)), !1);
        }
        async revoke([scopeteam, pkg], opts) {
          if (!scopeteam) throw this.usageError("`<scope:team>` argument is required.");
          const [, scope, team] = scopeteam.match(/^@?([^:]+):(.*)$/) || [];
          if (!scope || !team) throw this.usageError("First argument used incorrect format.\nExample: @example:developers");
          return this.modifyPackage(pkg, opts, ((pkgName, opts) => libaccess.revoke(pkgName, scopeteam, opts)));
        }
        get "2fa-required"() {
          return this.tfaRequired;
        }
        tfaRequired([pkg], opts) {
          return this.modifyPackage(pkg, opts, libaccess.tfaRequired, !1);
        }
        get "2fa-not-required"() {
          return this.tfaNotRequired;
        }
        tfaNotRequired([pkg], opts) {
          return this.modifyPackage(pkg, opts, libaccess.tfaNotRequired, !1);
        }
        get "ls-packages"() {
          return this.lsPackages;
        }
        async lsPackages([owner], opts) {
          owner || (owner = await getIdentity(this.npm, opts));
          const pkgs = await libaccess.lsPackages(owner, opts);
          this.npm.output(JSON.stringify(pkgs, null, 2));
        }
        get "ls-collaborators"() {
          return this.lsCollaborators;
        }
        async lsCollaborators([pkg, usr], opts) {
          const pkgName = await this.getPackage(pkg, !1), collabs = await libaccess.lsCollaborators(pkgName, usr, opts);
          this.npm.output(JSON.stringify(collabs, null, 2));
        }
        async edit() {
          throw new Error("edit subcommand is not implemented");
        }
        modifyPackage(pkg, opts, fn, requireScope = !0) {
          return this.getPackage(pkg, requireScope).then((pkgName => otplease(this.npm, opts, (opts => fn(pkgName, opts)))));
        }
        async getPackage(name, requireScope) {
          if (name && name.trim()) return name.trim();
          try {
            name = (await readPackageJson(path.resolve(this.npm.prefix, "package.json"))).name;
          } catch (err) {
            throw "ENOENT" === err.code ? new Error("no package name passed to command and no package.json found") : err;
          }
          if (requireScope && !name.match(/^@[^/]+\/.*$/)) throw this.usageError("This command is only available for scoped packages.");
          return name;
        }
      };
    },
    90128: (module, __unused_webpack_exports, __webpack_require__) => {
      const log = __webpack_require__(86883), replaceInfo = __webpack_require__(45042), BaseCommand = __webpack_require__(26727), authTypes = {
        legacy: __webpack_require__(2126),
        web: __webpack_require__(2126),
        webauthn: __webpack_require__(2126),
        oauth: __webpack_require__(4620),
        saml: __webpack_require__(7474),
        sso: __webpack_require__(14956)
      };
      module.exports = class extends BaseCommand {
        static description="Add a registry user account";
        static name="adduser";
        static params=[ "registry", "scope", "auth-type" ];
        static ignoreImplicitWorkspace=!0;
        async exec(args) {
          const {scope} = this.npm.flatOptions, registry = this.getRegistry(this.npm.flatOptions), auth = this.getAuthType(this.npm.flatOptions), creds = this.npm.config.getCredentialsByURI(registry);
          log.disableProgress(), log.warn("adduser", "`adduser` will be split into `login` and `register` in a future version. `adduser` will become an alias of `register`. `login` (currently an alias) will become its own command."), 
          log.notice("", `Log in on ${replaceInfo(registry)}`);
          const {message, newCreds} = await auth(this.npm, {
            ...this.npm.flatOptions,
            creds,
            registry,
            scope
          });
          await this.updateConfig({
            newCreds,
            registry,
            scope
          }), this.npm.output(message);
        }
        getRegistry({scope, registry}) {
          if (scope) {
            const scopedRegistry = this.npm.config.get(`${scope}:registry`), cliRegistry = this.npm.config.get("registry", "cli");
            if (scopedRegistry && !cliRegistry) return scopedRegistry;
          }
          return registry;
        }
        getAuthType({authType}) {
          const type = authTypes[authType];
          if (!type) throw new Error("no such auth module");
          return type;
        }
        async updateConfig({newCreds, registry, scope}) {
          this.npm.config.delete("_token", "user"), this.npm.config.setCredentialsByURI(registry, newCreds), 
          scope && this.npm.config.set(scope + ":registry", registry, "user"), await this.npm.config.save("user");
        }
      };
    },
    43020: (module, __unused_webpack_exports, __webpack_require__) => {
      const Arborist = __webpack_require__(22290), auditReport = __webpack_require__(75126), fetch = __webpack_require__(92427), localeCompare = __webpack_require__(51031)("en"), npa = __webpack_require__(19932), pacote = __webpack_require__(86585), pMap = __webpack_require__(94812), ArboristWorkspaceCmd = __webpack_require__(99264), auditError = __webpack_require__(21674), log = __webpack_require__(86883), reifyFinish = __webpack_require__(2648), sortAlphabetically = (a, b) => localeCompare(a.name, b.name);
      class VerifySignatures {
        constructor(tree, filterSet, npm, opts) {
          this.tree = tree, this.filterSet = filterSet, this.npm = npm, this.opts = opts, 
          this.keys = new Map, this.invalid = [], this.missing = [], this.checkedPackages = new Set, 
          this.auditedWithKeysCount = 0, this.verifiedCount = 0, this.output = [], this.exitCode = 0;
        }
        async run() {
          const start = process.hrtime.bigint(), {edges, registries} = this.getEdgesOut(this.tree.inventory.values(), this.filterSet);
          if (0 === edges.size) throw new Error("found no installed dependencies to audit");
          await Promise.all([ ...registries ].map((registry => this.setKeys({
            registry
          }))));
          const progress = log.newItem("verifying registry signatures", edges.size);
          if (await pMap(edges, (async edge => {
            progress.completeWork(1), await this.getVerifiedInfo(edge);
          }), {
            concurrency: 20,
            stopOnError: !0
          }), !this.auditedWithKeysCount) throw new Error("found no dependencies to audit that where installed from a supported registry");
          const invalid = this.invalid.sort(sortAlphabetically), missing = this.missing.sort(sortAlphabetically);
          if (0 === invalid.length && 0 === missing.length || (this.exitCode = 1), this.npm.config.get("json")) return void this.appendOutput(JSON.stringify({
            invalid: this.makeJSON(invalid),
            missing: this.makeJSON(missing)
          }, null, 2));
          const elapsed = process.hrtime.bigint() - start, auditedPlural = this.auditedWithKeysCount > 1 ? "s" : "", timing = `audited ${this.auditedWithKeysCount} package${auditedPlural} in ${Math.floor(Number(elapsed) / 1e9)}s`;
          if (this.appendOutput(`${timing}\n`), this.verifiedCount) {
            const verifiedBold = this.npm.chalk.bold("verified"), msg = 1 === this.verifiedCount ? `${this.verifiedCount} package has a ${verifiedBold} registry signature\n` : `${this.verifiedCount} packages have ${verifiedBold} registry signatures\n`;
            this.appendOutput(msg);
          }
          if (missing.length) {
            const missingClr = this.npm.chalk.bold(this.npm.chalk.red("missing")), msg = 1 === missing.length ? `package has a ${missingClr} registry signature` : `packages have ${missingClr} registry signatures`;
            this.appendOutput(`${missing.length} ${msg} but the registry is providing signing keys:\n`), 
            this.appendOutput(this.humanOutput(missing));
          }
          if (invalid.length) {
            const invalidClr = this.npm.chalk.bold(this.npm.chalk.red("invalid")), msg = 1 === invalid.length ? `${invalid.length} package has an ${invalidClr} registry signature:\n` : `${invalid.length} packages have ${invalidClr} registry signatures:\n`;
            this.appendOutput(`${missing.length ? "\n" : ""}${msg}`), this.appendOutput(this.humanOutput(invalid));
            const tamperMsg = 1 === invalid.length ? "\nSomeone might have tampered with this package since it was published on the registry!\n" : "\nSomeone might have tampered with these packages since they where published on the registry!\n";
            this.appendOutput(tamperMsg);
          }
        }
        appendOutput(...args) {
          this.output.push(...args.flat());
        }
        report() {
          return {
            report: this.output.join("\n"),
            exitCode: this.exitCode
          };
        }
        getEdgesOut(nodes, filterSet) {
          const edges = new Set, registries = new Set;
          for (const node of nodes) for (const edge of node.edgesOut.values()) {
            if (!(edge.from && filterSet && filterSet.size > 0 && !filterSet.has(edge.from.target))) {
              const spec = this.getEdgeSpec(edge);
              spec && registries.add(this.getSpecRegistry(spec)), edges.add(edge);
            }
          }
          return {
            edges,
            registries
          };
        }
        async setKeys({registry}) {
          const keys = await fetch.json("/-/npm/v1/keys", {
            ...this.npm.flatOptions,
            registry
          }).then((({keys}) => keys.map((key => ({
            ...key,
            pemkey: `-----BEGIN PUBLIC KEY-----\n${key.key}\n-----END PUBLIC KEY-----`
          }))))).catch((err => {
            if ("E404" === err.code) return null;
            throw err;
          }));
          keys && this.keys.set(registry, keys);
        }
        getEdgeType(edge) {
          return edge.optional ? "optionalDependencies" : edge.peer ? "peerDependencies" : edge.dev ? "devDependencies" : "dependencies";
        }
        getEdgeSpec(edge) {
          let name = edge.name;
          try {
            name = npa(edge.spec).subSpec.name;
          } catch {}
          try {
            return npa(`${name}@${edge.spec}`);
          } catch {}
        }
        buildRegistryConfig(registry) {
          const keys = this.keys.get(registry) || [], parsedRegistry = new URL(registry);
          return {
            [`${`//${parsedRegistry.host}${parsedRegistry.pathname}`}:_keys`]: keys
          };
        }
        getSpecRegistry(spec) {
          return fetch.pickRegistry(spec, this.npm.flatOptions);
        }
        getValidPackageInfo(edge) {
          const type = this.getEdgeType(edge);
          if ("MISSING" === edge.error && "dependencies" !== type) return;
          const spec = this.getEdgeSpec(edge);
          if (!spec) return;
          const node = edge.to || edge, {version} = node.package || {};
          if (!node.isWorkspace && version && spec.registry) {
            for (const omitType of this.npm.config.get("omit")) if (node[omitType]) return;
            return {
              name: spec.name,
              version,
              type,
              location: node.location,
              registry: this.getSpecRegistry(spec)
            };
          }
        }
        async verifySignatures(name, version, registry) {
          const {_integrity: integrity, _signatures, _resolved: resolved} = await pacote.manifest(`${name}@${version}`, {
            verifySignatures: !0,
            ...this.buildRegistryConfig(registry),
            ...this.npm.flatOptions
          });
          return {
            integrity,
            signatures: _signatures || [],
            resolved
          };
        }
        async getVerifiedInfo(edge) {
          const info = this.getValidPackageInfo(edge);
          if (!info) return;
          const {name, version, location, registry, type} = info;
          if (this.checkedPackages.has(location)) return;
          this.checkedPackages.add(location);
          const keys = this.keys.get(registry) || [];
          keys.length && (this.auditedWithKeysCount += 1);
          try {
            const {integrity, signatures, resolved} = await this.verifySignatures(name, version, registry);
            signatures.length ? this.verifiedCount += 1 : keys.length && this.missing.push({
              name,
              version,
              location,
              resolved,
              integrity,
              registry
            });
          } catch (e) {
            if ("EINTEGRITYSIGNATURE" !== e.code) throw e;
            {
              const {signature, keyid, integrity, resolved} = e;
              this.invalid.push({
                name,
                type,
                version,
                resolved,
                location,
                integrity,
                registry,
                signature,
                keyid
              });
            }
          }
        }
        humanOutput(list) {
          return list.map((v => `${this.npm.chalk.red(`${v.name}@${v.version}`)} (${v.registry})`)).join("\n");
        }
        makeJSON(deps) {
          return deps.map((d => ({
            name: d.name,
            version: d.version,
            location: d.location,
            resolved: d.resolved,
            integrity: d.integrity,
            signature: d.signature,
            keyid: d.keyid
          })));
        }
      }
      class Audit extends ArboristWorkspaceCmd {
        static description="Run a security audit";
        static name="audit";
        static params=[ "audit-level", "dry-run", "force", "json", "package-lock-only", "omit", "foreground-scripts", "ignore-scripts", ...super.params ];
        static usage=[ "[fix|signatures]" ];
        async completion(opts) {
          const argv = opts.conf.argv.remain;
          if (2 === argv.length) return [ "fix" ];
          if ("fix" === argv[2]) return [];
          throw Object.assign(new Error(argv[2] + " not recognized"), {
            code: "EUSAGE"
          });
        }
        async exec(args) {
          "signatures" === args[0] ? await this.auditSignatures() : await this.auditAdvisories(args);
        }
        async auditAdvisories(args) {
          const reporter = this.npm.config.get("json") ? "json" : "detail", opts = {
            ...this.npm.flatOptions,
            audit: !0,
            path: this.npm.prefix,
            reporter,
            workspaces: this.workspaceNames
          }, arb = new Arborist(opts), fix = "fix" === args[0];
          if (await arb.audit({
            fix
          }), fix) await reifyFinish(this.npm, arb); else {
            auditError(this.npm, arb.auditReport);
            const result = auditReport(arb.auditReport, opts);
            process.exitCode = process.exitCode || result.exitCode, this.npm.output(result.report);
          }
        }
        async auditSignatures() {
          if (this.npm.global) throw Object.assign(new Error("`npm audit signatures` does not support global packages"), {
            code: "EAUDITGLOBAL"
          });
          log.verbose("loading installed dependencies");
          const opts = {
            ...this.npm.flatOptions,
            path: this.npm.prefix,
            workspaces: this.workspaceNames
          }, arb = new Arborist(opts), tree = await arb.loadActual();
          let filterSet = new Set;
          opts.workspaces && opts.workspaces.length ? filterSet = arb.workspaceDependencySet(tree, opts.workspaces, this.npm.flatOptions.includeWorkspaceRoot) : this.npm.flatOptions.workspacesEnabled || (filterSet = arb.excludeWorkspacesDependencySet(tree));
          const verify = new VerifySignatures(tree, filterSet, this.npm, {
            ...opts
          });
          await verify.run();
          const result = verify.report();
          process.exitCode = process.exitCode || result.exitCode, this.npm.output(result.report);
        }
      }
      module.exports = Audit;
    },
    66128: (module, __unused_webpack_exports, __webpack_require__) => {
      const log = __webpack_require__(86883), BaseCommand = __webpack_require__(26727), path = process.env.path || process.env.Path || process.env.PATH, {delimiter} = __webpack_require__(71017);
      module.exports = class extends BaseCommand {
        static description="Display npm bin folder";
        static name="bin";
        static params=[ "global" ];
        static ignoreImplicitWorkspace=!0;
        async exec(args) {
          const b = this.npm.bin;
          this.npm.output(b), this.npm.global && !path.split(delimiter).includes(b) && log.error("bin", "(not in PATH env variable)");
        }
      };
    },
    7782: (module, __unused_webpack_exports, __webpack_require__) => {
      const BaseCommand = __webpack_require__(26727), log = __webpack_require__(86883);
      module.exports = class extends BaseCommand {
        static name="birthday";
        static description="Birthday, deprecated";
        static ignoreImplicitWorkspace=!0;
        static isShellout=!0;
        async exec() {
          return this.npm.config.set("yes", !0), log.warn("birthday", "birthday is deprecated and will be removed in a future release"), 
          this.npm.exec("exec", [ "@npmcli/npm-birthday" ]);
        }
      };
    },
    78164: (module, __unused_webpack_exports, __webpack_require__) => {
      const PackageUrlCmd = __webpack_require__(40064);
      module.exports = class extends PackageUrlCmd {
        static description="Report bugs for a package in a web browser";
        static name="bugs";
        getUrl(spec, mani) {
          if (mani.bugs) {
            if ("string" == typeof mani.bugs) return mani.bugs;
            if ("object" == typeof mani.bugs && mani.bugs.url) return mani.bugs.url;
            if ("object" == typeof mani.bugs && mani.bugs.email) return `mailto:${mani.bugs.email}`;
          }
          const info = this.hostedFromMani(mani);
          return info ? info.bugs() : `https://www.npmjs.com/package/${mani.name}`;
        }
      };
    },
    41288: (module, __unused_webpack_exports, __webpack_require__) => {
      const cacache = __webpack_require__(99269), {promisify} = __webpack_require__(73837), pacote = __webpack_require__(86585), path = __webpack_require__(71017), rimraf = promisify(__webpack_require__(11567)), semver = __webpack_require__(5870), BaseCommand = __webpack_require__(26727), npa = __webpack_require__(19932), jsonParse = __webpack_require__(40295), localeCompare = __webpack_require__(51031)("en"), log = __webpack_require__(86883), searchCachePackage = async (path, parsed, cacheKeys) => {
        const searchMFH = new RegExp(`^make-fetch-happen:request-cache:.*(?<!/[@a-zA-Z]+)/${parsed.name}/-/(${parsed.name}[^/]+.tgz)$`), searchPack = new RegExp(`^make-fetch-happen:request-cache:.*/${parsed.escapedName}$`), results = new Set;
        cacheKeys = new Set(cacheKeys);
        for (const key of cacheKeys) {
          if (searchMFH.test(key)) {
            const noExt = key.match(searchMFH)[1].slice(0, -4), noScope = `${parsed.name.split("/").pop()}-`, ver = noExt.slice(noScope.length);
            semver.satisfies(ver, parsed.rawSpec) && results.add(key);
            continue;
          }
          if (!searchPack.test(key)) continue;
          let packument, details;
          results.add(key);
          try {
            details = await cacache.get(path, key), packument = jsonParse(details.data);
          } catch (_) {
            continue;
          }
          if (packument.versions && "object" == typeof packument.versions) for (const ver of Object.keys(packument.versions)) semver.satisfies(ver, parsed.rawSpec) && packument.versions[ver].dist && "object" == typeof packument.versions[ver].dist && void 0 !== packument.versions[ver].dist.tarball && cacheKeys.has(`make-fetch-happen:request-cache:${packument.versions[ver].dist.tarball}`) && results.add(`make-fetch-happen:request-cache:${packument.versions[ver].dist.tarball}`);
        }
        return results;
      };
      module.exports = class extends BaseCommand {
        static description="Manipulates packages cache";
        static name="cache";
        static params=[ "cache" ];
        static usage=[ "add <package-spec>", "clean [<key>]", "ls [<name>@<version>]", "verify" ];
        static ignoreImplicitWorkspace=!0;
        async completion(opts) {
          const argv = opts.conf.argv.remain;
          if (2 === argv.length) return [ "add", "clean", "verify", "ls", "delete" ];
          switch (argv[2]) {
           case "verify":
           case "clean":
           case "add":
           case "ls":
           case "delete":
            return [];
          }
        }
        async exec(args) {
          switch (args.shift()) {
           case "rm":
           case "clear":
           case "clean":
            return await this.clean(args);

           case "add":
            return await this.add(args);

           case "verify":
           case "check":
            return await this.verify();

           case "ls":
            return await this.ls(args);

           default:
            throw this.usageError();
          }
        }
        async clean(args) {
          const cachePath = path.join(this.npm.cache, "_cacache");
          if (0 === args.length) {
            if (!this.npm.config.get("force")) throw new Error("As of npm@5, the npm cache self-heals from corruption issues\n  by treating integrity mismatches as cache misses.  As a result,\n  data extracted from the cache is guaranteed to be valid.  If you\n  want to make sure everything is consistent, use `npm cache verify`\n  instead.  Deleting the cache can only make npm go slower, and is\n  not likely to correct any problems you may be encountering!\n\n  On the other hand, if you're debugging an issue with the installer,\n  or race conditions that depend on the timing of writing to an empty\n  cache, you can use `npm install --cache /tmp/empty-cache` to use a\n  temporary cache instead of nuking the actual one.\n\n  If you're sure you want to delete the entire cache, rerun this command\n  with --force.");
            return rimraf(cachePath);
          }
          for (const key of args) {
            let entry;
            try {
              entry = await cacache.get(cachePath, key);
            } catch (err) {
              log.warn(`Not Found: ${key}`);
              break;
            }
            this.npm.output(`Deleted: ${key}`), await cacache.rm.entry(cachePath, key), await cacache.rm.content(cachePath, entry.integrity);
          }
        }
        async add(args) {
          if (log.silly("cache add", "args", args), 0 === args.length) throw this.usageError("First argument to `add` is required");
          return Promise.all(args.map((spec => (log.silly("cache add", "spec", spec), pacote.tarball.stream(spec, (stream => (stream.resume(), 
          stream.promise())), this.npm.flatOptions)))));
        }
        async verify() {
          const cache = path.join(this.npm.cache, "_cacache"), prefix = 0 === cache.indexOf(process.env.HOME) ? `~${cache.slice(process.env.HOME.length)}` : cache, stats = await cacache.verify(cache);
          this.npm.output(`Cache verified and compressed (${prefix})`), this.npm.output(`Content verified: ${stats.verifiedContent} (${stats.keptSize} bytes)`), 
          stats.badContentCount && this.npm.output(`Corrupted content removed: ${stats.badContentCount}`), 
          stats.reclaimedCount && this.npm.output(`Content garbage-collected: ${stats.reclaimedCount} (${stats.reclaimedSize} bytes)`), 
          stats.missingContent && this.npm.output(`Missing content: ${stats.missingContent}`), 
          this.npm.output(`Index entries: ${stats.totalEntries}`), this.npm.output(`Finished in ${stats.runTime.total / 1e3}s`);
        }
        async ls(specs) {
          const cachePath = path.join(this.npm.cache, "_cacache"), cacheKeys = Object.keys(await cacache.ls(cachePath));
          if (specs.length > 0) {
            const results = new Set;
            for (const spec of specs) {
              const parsed = npa(spec);
              if ("" !== parsed.rawSpec && "tag" === parsed.type) throw this.usageError("Cannot list cache keys for a tagged package.");
              const keySet = await searchCachePackage(cachePath, parsed, cacheKeys);
              for (const key of keySet) results.add(key);
            }
            [ ...results ].sort(localeCompare).forEach((key => this.npm.output(key)));
          } else cacheKeys.sort(localeCompare).forEach((key => this.npm.output(key)));
        }
      };
    },
    70244: (module, __unused_webpack_exports, __webpack_require__) => {
      const util = __webpack_require__(73837), Arborist = __webpack_require__(22290), rimraf = util.promisify(__webpack_require__(11567)), reifyFinish = __webpack_require__(2648), runScript = __webpack_require__(63036), fs = __webpack_require__(57147), readdir = util.promisify(fs.readdir), log = __webpack_require__(86883), validateLockfile = __webpack_require__(85326), ArboristWorkspaceCmd = __webpack_require__(99264), Install = __webpack_require__(92514);
      class CI extends ArboristWorkspaceCmd {
        static description="Clean install a project";
        static name="ci";
        static params=Install.params;
        async exec() {
          if (this.npm.global) throw Object.assign(new Error("`npm ci` does not work for global packages"), {
            code: "ECIGLOBAL"
          });
          const where = this.npm.prefix, opts = {
            ...this.npm.flatOptions,
            packageLock: !0,
            path: where,
            save: !1,
            workspaces: this.workspaceNames
          }, arb = new Arborist(opts);
          await arb.loadVirtual().catch((er => {
            log.verbose("loadVirtual", er.stack);
            throw this.usageError("The `npm ci` command can only install with an existing package-lock.json or\nnpm-shrinkwrap.json with lockfileVersion >= 1. Run an install with npm@5 or\nlater to generate a package-lock.json file, then try again.");
          }));
          const virtualInventory = new Map(arb.virtualTree.inventory);
          await arb.buildIdealTree();
          const errors = validateLockfile(virtualInventory, arb.idealTree.inventory);
          if (errors.length) throw this.usageError("`npm ci` can only install packages when your package.json and package-lock.json or npm-shrinkwrap.json are in sync. Please update your lock file with `npm install` before continuing.\n\n" + errors.join("\n"));
          await this.npm.time("npm-ci:rm", (async () => {
            const path = `${where}/node_modules`, entries = await readdir(path, null).catch((er => []));
            return Promise.all(entries.map((f => rimraf(`${path}/${f}`, {
              glob: !1
            }))));
          })), await arb.reify(opts);
          if (!this.npm.config.get("ignore-scripts")) {
            const scripts = [ "preinstall", "install", "postinstall", "prepublish", "preprepare", "prepare", "postprepare" ], scriptShell = this.npm.config.get("script-shell") || void 0;
            for (const event of scripts) await runScript({
              path: where,
              args: [],
              scriptShell,
              stdio: "inherit",
              stdioString: !0,
              banner: !this.npm.silent,
              event
            });
          }
          await reifyFinish(this.npm, arb);
        }
      }
      module.exports = CI;
    },
    74470: (module, __unused_webpack_exports, __webpack_require__) => {
      const configDefs = __webpack_require__(70506), mkdirp = __webpack_require__(87700), {dirname, resolve} = __webpack_require__(71017), {promisify} = __webpack_require__(73837), fs = __webpack_require__(57147), readFile = promisify(fs.readFile), writeFile = promisify(fs.writeFile), {spawn} = __webpack_require__(32081), {EOL} = __webpack_require__(22037), ini = __webpack_require__(92869), localeCompare = __webpack_require__(51031)("en"), rpj = __webpack_require__(1759), log = __webpack_require__(86883), publicVar = k => !k.startsWith("_") && (!k.startsWith("//") || !k.includes(":_")), BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Manage the npm configuration files";
        static name="config";
        static usage=[ "set <key>=<value> [<key>=<value> ...]", "get [<key> [<key> ...]]", "delete <key> [<key> ...]", "list [--json]", "edit" ];
        static params=[ "json", "global", "editor", "location", "long" ];
        static ignoreImplicitWorkspace=!1;
        async completion(opts) {
          const argv = opts.conf.argv.remain;
          if ("config" !== argv[1] && argv.unshift("config"), 2 === argv.length) {
            const cmds = [ "get", "set", "delete", "ls", "rm", "edit" ];
            return "l" !== opts.partialWord && cmds.push("list"), cmds;
          }
          switch (argv[2]) {
           case "set":
            if (argv.length > 3) return [];

           case "get":
           case "delete":
           case "rm":
            return Object.keys(configDefs.definitions);

           default:
            return [];
          }
        }
        async execWorkspaces(args, filters) {
          return log.warn("config", "This command does not support workspaces."), this.exec(args);
        }
        async exec([action, ...args]) {
          log.disableProgress();
          try {
            switch (action) {
             case "set":
              await this.set(args);
              break;

             case "get":
              await this.get(args);
              break;

             case "delete":
             case "rm":
             case "del":
              await this.del(args);
              break;

             case "list":
             case "ls":
              await (this.npm.flatOptions.json ? this.listJson() : this.list());
              break;

             case "edit":
              await this.edit();
              break;

             default:
              throw this.usageError();
            }
          } finally {
            log.enableProgress();
          }
        }
        async set(args) {
          if (!args.length) throw this.usageError();
          const where = this.npm.flatOptions.location;
          for (const [key, val] of Object.entries((args => {
            const kv = {};
            for (let i = 0; i < args.length; i++) {
              const arg = args[i].split("="), key = arg.shift(), val = arg.length ? arg.join("=") : i < args.length - 1 ? args[++i] : "";
              kv[key.trim()] = val.trim();
            }
            return kv;
          })(args))) log.info("config", "set %j %j", key, val), this.npm.config.set(key, val || "", where), 
          this.npm.config.validate(where) || log.warn("config", "omitting invalid config values");
          await this.npm.config.save(where);
        }
        async get(keys) {
          if (!keys.length) return this.list();
          const out = [];
          for (const key of keys) {
            if (!publicVar(key)) throw new Error(`The ${key} option is protected, and cannot be retrieved in this way`);
            const pref = keys.length > 1 ? `${key}=` : "";
            out.push(pref + this.npm.config.get(key));
          }
          this.npm.output(out.join("\n"));
        }
        async del(keys) {
          if (!keys.length) throw this.usageError();
          const where = this.npm.flatOptions.location;
          for (const key of keys) this.npm.config.delete(key, where);
          await this.npm.config.save(where);
        }
        async edit() {
          const e = this.npm.flatOptions.editor, where = this.npm.flatOptions.location, file = this.npm.config.data.get(where).source;
          await this.npm.config.save(where);
          const data = (await readFile(file, "utf8").catch((() => ""))).replace(/\r\n/g, "\n"), defData = Object.entries(configDefs.defaults).reduce(((str, [key, val]) => {
            const obj = {
              [key]: val
            };
            return str + "\n" + ini.stringify(obj).replace(/\r\n/g, "\n").replace(/\n$/m, "").replace(/^/g, "; ").replace(/\n/g, "\n; ").split("\n");
          }), ""), tmpData = `;;;;\n; npm ${where}config file: ${file}\n; this is a simple ini-formatted file\n; lines that start with semi-colons are comments\n; run \`npm help 7 config\` for documentation of the various options\n;\n; Configs like \`@scope:registry\` map a scope to a given registry url.\n;\n; Configs like \`//<hostname>/:_authToken\` are auth that is restricted\n; to the registry host specified.\n\n${data.split("\n").sort(localeCompare).join("\n").trim()}\n\n;;;;\n; all available options shown below with default values\n;;;;\n\n${defData}\n`.split("\n").join(EOL);
          await mkdirp(dirname(file)), await writeFile(file, tmpData, "utf8"), await new Promise(((resolve, reject) => {
            const [bin, ...args] = e.split(/\s+/);
            spawn(bin, [ ...args, file ], {
              stdio: "inherit"
            }).on("exit", (code => code ? reject(new Error(`editor process exited with code: ${code}`)) : resolve()));
          }));
        }
        async list() {
          const msg = [], long = this.npm.config.get("long");
          for (const [where, {data, source}] of this.npm.config.data.entries()) {
            if ("default" === where && !long) continue;
            const keys = Object.keys(data).sort(localeCompare);
            if (keys.length) {
              msg.push(`; "${where}" config from ${source}`, "");
              for (const k of keys) {
                const v = publicVar(k) ? JSON.stringify(data[k]) : "(protected)", src = this.npm.config.find(k), overridden = src !== where;
                msg.push((overridden ? "; " : "") + `${k} = ${v} ${overridden ? `; overridden by ${src}` : ""}`);
              }
              msg.push("");
            }
          }
          if (long || (msg.push(`; node bin location = ${process.execPath}`, `; node version = ${process.version}`, `; npm local prefix = ${this.npm.localPrefix}`, `; npm version = ${this.npm.version}`, `; cwd = ${process.cwd()}`, `; HOME = ${process.env.HOME}`, "; Run `npm config ls -l` to show all defaults."), 
          msg.push("")), !this.npm.global) {
            const pkgPath = resolve(this.npm.prefix, "package.json"), pkg = await rpj(pkgPath).catch((() => ({})));
            if (pkg.publishConfig) {
              msg.push(`; "publishConfig" from ${pkgPath}`), msg.push("; This set of config values will be used at publish-time.", "");
              const pkgKeys = Object.keys(pkg.publishConfig).sort(localeCompare);
              for (const k of pkgKeys) {
                const v = publicVar(k) ? JSON.stringify(pkg.publishConfig[k]) : "(protected)";
                msg.push(`${k} = ${v}`);
              }
              msg.push("");
            }
          }
          this.npm.output(msg.join("\n").trim());
        }
        async listJson() {
          const publicConf = {};
          for (const key in this.npm.config.list[0]) publicVar(key) && (publicConf[key] = this.npm.config.get(key));
          this.npm.output(JSON.stringify(publicConf, null, 2));
        }
      };
    },
    6352: (module, __unused_webpack_exports, __webpack_require__) => {
      const Arborist = __webpack_require__(22290), reifyFinish = __webpack_require__(2648), ArboristWorkspaceCmd = __webpack_require__(99264);
      class Dedupe extends ArboristWorkspaceCmd {
        static description="Reduce duplication in the package tree";
        static name="dedupe";
        static params=[ "global-style", "legacy-bundling", "strict-peer-deps", "package-lock", "omit", "ignore-scripts", "audit", "bin-links", "fund", "dry-run", ...super.params ];
        async exec(args) {
          if (this.npm.global) {
            const er = new Error("`npm dedupe` does not work in global mode.");
            throw er.code = "EDEDUPEGLOBAL", er;
          }
          const dryRun = this.npm.config.get("dry-run"), where = this.npm.prefix, opts = {
            ...this.npm.flatOptions,
            path: where,
            dryRun,
            save: !1,
            workspaces: this.workspaceNames
          }, arb = new Arborist(opts);
          await arb.dedupe(opts), await reifyFinish(this.npm, arb);
        }
      }
      module.exports = Dedupe;
    },
    66202: (module, __unused_webpack_exports, __webpack_require__) => {
      const fetch = __webpack_require__(92427), otplease = __webpack_require__(83304), npa = __webpack_require__(19932), semver = __webpack_require__(5870), getIdentity = __webpack_require__(18084), libaccess = __webpack_require__(63167), BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Deprecate a version of a package";
        static name="deprecate";
        static usage=[ "<package-spec> <message>" ];
        static params=[ "registry", "otp" ];
        static ignoreImplicitWorkspace=!1;
        async completion(opts) {
          if (opts.conf.argv.remain.length > 1) return [];
          const username = await getIdentity(this.npm, this.npm.flatOptions), packages = await libaccess.lsPackages(username, this.npm.flatOptions);
          return Object.keys(packages).filter((name => "read-write" === packages[name] && (0 === opts.conf.argv.remain.length || name.startsWith(opts.conf.argv.remain[0]))));
        }
        async exec([pkg, msg]) {
          if (!pkg || null == msg) throw this.usageError();
          const p = npa(pkg), spec = "" === p.rawSpec ? "*" : p.fetchSpec;
          if (null === semver.validRange(spec, !0)) throw new Error(`invalid version range: ${spec}`);
          const uri = "/" + p.escapedName, packument = await fetch.json(uri, {
            ...this.npm.flatOptions,
            spec: p,
            query: {
              write: !0
            }
          });
          return Object.keys(packument.versions).filter((v => semver.satisfies(v, spec, {
            includePrerelease: !0
          }))).forEach((v => {
            packument.versions[v].deprecated = msg;
          })), otplease(this.npm, this.npm.flatOptions, (opts => fetch(uri, {
            ...opts,
            spec: p,
            method: "PUT",
            body: packument,
            ignoreBody: !0
          })));
        }
      };
    },
    72548: (module, __unused_webpack_exports, __webpack_require__) => {
      const {resolve} = __webpack_require__(71017), semver = __webpack_require__(5870), libnpmdiff = __webpack_require__(69956), npa = __webpack_require__(19932), Arborist = __webpack_require__(22290), pacote = __webpack_require__(86585), pickManifest = __webpack_require__(65732), log = __webpack_require__(86883), readPackage = __webpack_require__(1759), BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="The registry diff command";
        static name="diff";
        static usage=[ "[...<paths>]" ];
        static params=[ "diff", "diff-name-only", "diff-unified", "diff-ignore-all-space", "diff-no-prefix", "diff-src-prefix", "diff-dst-prefix", "diff-text", "global", "tag", "workspace", "workspaces", "include-workspace-root" ];
        static ignoreImplicitWorkspace=!1;
        async exec(args) {
          const specs = this.npm.config.get("diff").filter((d => d));
          if (specs.length > 2) throw this.usageError("Can't use more than two --diff arguments.");
          this.prefix || (this.prefix = this.npm.prefix), this.npm.global ? this.top = resolve(this.npm.globalDir, "..") : this.top = this.prefix;
          const [a, b] = await this.retrieveSpecs(specs);
          log.info("diff", {
            src: a,
            dst: b
          });
          const res = await libnpmdiff([ a, b ], {
            ...this.npm.flatOptions,
            diffFiles: args,
            where: this.top
          });
          return this.npm.output(res);
        }
        async execWorkspaces(args, filters) {
          await this.setWorkspaces(filters);
          for (const workspacePath of this.workspacePaths) this.top = workspacePath, this.prefix = workspacePath, 
          await this.exec(args);
        }
        async packageName(path) {
          let name;
          try {
            name = (await readPackage(resolve(this.prefix, "package.json"))).name;
          } catch (e) {
            log.verbose("diff", "could not read project dir package.json");
          }
          if (!name) throw this.usageError("Needs multiple arguments to compare or run from a project dir.");
          return name;
        }
        async retrieveSpecs([a, b]) {
          if (a && b) {
            const specs = await this.convertVersionsToSpecs([ a, b ]);
            return this.findVersionsByPackageName(specs);
          }
          if (!a) {
            return [ `${await this.packageName(this.prefix)}@${this.npm.config.get("tag")}`, `file:${this.prefix.replace(/#/g, "%23")}` ];
          }
          let noPackageJson, pkgName;
          try {
            pkgName = (await readPackage(resolve(this.prefix, "package.json"))).name;
          } catch (e) {
            log.verbose("diff", "could not read project dir package.json"), noPackageJson = !0;
          }
          const missingPackageJson = this.usageError("Needs multiple arguments to compare or run from a project dir.");
          if (semver.validRange(a)) {
            if (!pkgName) throw missingPackageJson;
            return [ `${pkgName}@${a}`, `file:${this.prefix.replace(/#/g, "%23")}` ];
          }
          const spec = npa(a);
          if (spec.registry) {
            let actualTree, node;
            try {
              const opts = {
                ...this.npm.flatOptions,
                path: this.top
              }, arb = new Arborist(opts);
              actualTree = await arb.loadActual(opts), node = actualTree && actualTree.inventory.query("name", spec.name).values().next().value;
            } catch (e) {
              log.verbose("diff", "failed to load actual install tree");
            }
            if (!(node && node.name && node.package && node.package.version)) {
              if (noPackageJson) throw missingPackageJson;
              return [ `${spec.name}@${spec.fetchSpec}`, `file:${this.prefix.replace(/#/g, "%23")}` ];
            }
            const tryRootNodeSpec = () => (actualTree && actualTree.edgesOut.get(spec.name) || {}).spec, tryAnySpec = () => {
              for (const edge of node.edgesIn) return edge.spec;
            }, aSpec = `file:${node.realpath.replace(/#/g, "%23")}`;
            let bSpec;
            if (spec.rawSpec) bSpec = spec.rawSpec; else {
              const bTargetVersion = tryRootNodeSpec() || tryAnySpec(), packument = await pacote.packument(spec, {
                ...this.npm.flatOptions,
                preferOnline: !0
              });
              bSpec = pickManifest(packument, bTargetVersion, {
                ...this.npm.flatOptions
              }).version;
            }
            return [ `${spec.name}@${aSpec}`, `${spec.name}@${bSpec}` ];
          }
          if ("directory" === spec.type) return [ `file:${spec.fetchSpec.replace(/#/g, "%23")}`, `file:${this.prefix.replace(/#/g, "%23")}` ];
          throw this.usageError(`Spec type ${spec.type} not supported.`);
        }
        async convertVersionsToSpecs([a, b]) {
          const semverA = semver.validRange(a), semverB = semver.validRange(b);
          if (semverA && semverB) {
            let pkgName;
            try {
              pkgName = (await readPackage(resolve(this.prefix, "package.json"))).name;
            } catch (e) {
              log.verbose("diff", "could not read project dir package.json");
            }
            if (!pkgName) throw this.usageError("Needs to be run from a project dir in order to diff two versions.");
            return [ `${pkgName}@${a}`, `${pkgName}@${b}` ];
          }
          return !semverA && semverB ? [ a, `${npa(a).name}@${b}` ] : semverA && !semverB ? [ `${npa(b).name}@${a}`, b ] : [ a, b ];
        }
        async findVersionsByPackageName(specs) {
          let actualTree;
          try {
            const opts = {
              ...this.npm.flatOptions,
              path: this.top
            }, arb = new Arborist(opts);
            actualTree = await arb.loadActual(opts);
          } catch (e) {
            log.verbose("diff", "failed to load actual install tree");
          }
          return specs.map((i => {
            const spec = npa(i);
            if (spec.rawSpec) return i;
            const node = actualTree && actualTree.inventory.query("name", spec.name).values().next().value, res = node && node.package && node.package.version ? `file:${node.realpath.replace(/#/g, "%23")}` : spec.fetchSpec;
            return `${spec.name}@${res}`;
          }));
        }
      };
    },
    23499: (module, __unused_webpack_exports, __webpack_require__) => {
      const npa = __webpack_require__(19932), path = __webpack_require__(71017), regFetch = __webpack_require__(92427), semver = __webpack_require__(5870), log = __webpack_require__(86883), otplease = __webpack_require__(83304), readPackage = __webpack_require__(1759), BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Modify package distribution tags";
        static params=[ "workspace", "workspaces", "include-workspace-root" ];
        static name="dist-tag";
        static usage=[ "add <package-spec (with version)> [<tag>]", "rm <package-spec> <tag>", "ls [<package-spec>]" ];
        static ignoreImplicitWorkspace=!1;
        async completion(opts) {
          const argv = opts.conf.argv.remain;
          return 2 === argv.length ? [ "add", "rm", "ls" ] : (argv[2], []);
        }
        async exec([cmdName, pkg, tag]) {
          const opts = {
            ...this.npm.flatOptions
          };
          if ([ "add", "a", "set", "s" ].includes(cmdName)) return this.add(pkg, tag, opts);
          if ([ "rm", "r", "del", "d", "remove" ].includes(cmdName)) return this.remove(pkg, tag, opts);
          if ([ "ls", "l", "sl", "list" ].includes(cmdName)) return this.list(pkg, opts);
          if (pkg) throw this.usageError();
          return this.list(cmdName, opts);
        }
        async execWorkspaces([cmdName, pkg, tag], filters) {
          return (![ "ls", "l", "sl", "list" ].includes(cmdName) || pkg && "." !== pkg && !/^\.@/.test(pkg)) && (pkg || cmdName && "." !== cmdName && !/^\.@/.test(cmdName)) ? (log.warn("Ignoring workspaces for specified package"), 
          this.exec([ cmdName, pkg, tag ])) : this.listWorkspaces(filters);
        }
        async add(spec, tag, opts) {
          const version = (spec = npa(spec || "")).rawSpec, defaultTag = tag || this.npm.config.get("tag");
          if (log.verbose("dist-tag add", defaultTag, "to", spec.name + "@" + version), !spec.name || !version || !defaultTag) throw this.usageError("must provide a spec with a name and version, and a tag to add");
          const t = defaultTag.trim();
          if (semver.validRange(t)) throw new Error("Tag name must not be a valid SemVer range: " + t);
          const tags = await this.fetchTags(spec, opts);
          if (tags[t] === version) return void log.warn("dist-tag add", t, "is already set to version", version);
          tags[t] = version;
          const url = `/-/package/${spec.escapedName}/dist-tags/${encodeURIComponent(t)}`, reqOpts = {
            ...opts,
            method: "PUT",
            body: JSON.stringify(version),
            headers: {
              "content-type": "application/json"
            },
            spec
          };
          await otplease(this.npm, reqOpts, (reqOpts => regFetch(url, reqOpts))), this.npm.output(`+${t}: ${spec.name}@${version}`);
        }
        async remove(spec, tag, opts) {
          if (spec = npa(spec || ""), log.verbose("dist-tag del", tag, "from", spec.name), 
          !spec.name) throw this.usageError();
          const tags = await this.fetchTags(spec, opts);
          if (!tags[tag]) throw log.info("dist-tag del", tag, "is not a dist-tag on", spec.name), 
          new Error(tag + " is not a dist-tag on " + spec.name);
          const version = tags[tag];
          delete tags[tag];
          const url = `/-/package/${spec.escapedName}/dist-tags/${encodeURIComponent(tag)}`, reqOpts = {
            ...opts,
            method: "DELETE",
            spec
          };
          await otplease(this.npm, reqOpts, (reqOpts => regFetch(url, reqOpts))), this.npm.output(`-${tag}: ${spec.name}@${version}`);
        }
        async list(spec, opts) {
          if (!spec) {
            if (this.npm.global) throw this.usageError();
            const {name} = await readPackage(path.resolve(this.npm.prefix, "package.json"));
            if (!name) throw this.usageError();
            return this.list(name, opts);
          }
          spec = npa(spec);
          try {
            const tags = await this.fetchTags(spec, opts), msg = Object.keys(tags).map((k => `${k}: ${tags[k]}`)).sort().join("\n");
            return this.npm.output(msg), tags;
          } catch (err) {
            throw log.error("dist-tag ls", "Couldn't get dist-tag data for", spec), err;
          }
        }
        async listWorkspaces(filters) {
          await this.setWorkspaces(filters);
          for (const name of this.workspaceNames) try {
            this.npm.output(`${name}:`), await this.list(npa(name), this.npm.flatOptions);
          } catch (err) {
            process.exitCode = 1;
          }
        }
        async fetchTags(spec, opts) {
          const data = await regFetch.json(`/-/package/${spec.escapedName}/dist-tags`, {
            ...opts,
            "prefer-online": !0,
            spec
          });
          if (data && "object" == typeof data && delete data._etag, !data || !Object.keys(data).length) throw new Error("No dist-tags found for " + spec.name);
          return data;
        }
      };
    },
    46973: (module, __unused_webpack_exports, __webpack_require__) => {
      const PackageUrlCmd = __webpack_require__(40064);
      module.exports = class extends PackageUrlCmd {
        static description="Open documentation for a package in a web browser";
        static name="docs";
        getUrl(spec, mani) {
          if (mani.homepage) return mani.homepage;
          const info = this.hostedFromMani(mani);
          return info ? info.docs() : `https://www.npmjs.com/package/${mani.name}`;
        }
      };
    },
    13781: (module, __unused_webpack_exports, __webpack_require__) => {
      const cacache = __webpack_require__(99269), fs = __webpack_require__(57147), fetch = __webpack_require__(14936), table = __webpack_require__(5371), which = __webpack_require__(7017), pacote = __webpack_require__(86585), {resolve} = __webpack_require__(71017), semver = __webpack_require__(5870), {promisify} = __webpack_require__(73837), log = __webpack_require__(86883), ansiTrim = __webpack_require__(82576), ping = __webpack_require__(24087), {registry: {default: defaultRegistry}} = __webpack_require__(18700), lstat = promisify(fs.lstat), readdir = promisify(fs.readdir), access = promisify(fs.access), {R_OK, W_OK, X_OK} = fs.constants, maskLabel = mask => {
        const label = [];
        return mask & R_OK && label.push("readable"), mask & W_OK && label.push("writable"), 
        mask & X_OK && label.push("executable"), label.join(", ");
      }, BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Check your npm environment";
        static name="doctor";
        static params=[ "registry" ];
        static ignoreImplicitWorkspace=!1;
        async exec(args) {
          log.info("Running checkup");
          const messages = [], actions = [ [ "npm ping", "checkPing", [] ], [ "npm -v", "getLatestNpmVersion", [] ], [ "node -v", "getLatestNodejsVersion", [] ], [ "npm config get registry", "checkNpmRegistry", [] ], [ "which git", "getGitPath", [] ], ..."win32" === process.platform ? [] : [ [ "Perms check on cached files", "checkFilesPermission", [ this.npm.cache, !0, R_OK ] ], [ "Perms check on local node_modules", "checkFilesPermission", [ this.npm.localDir, !0, R_OK | W_OK, !0 ] ], [ "Perms check on global node_modules", "checkFilesPermission", [ this.npm.globalDir, !1, R_OK ] ], [ "Perms check on local bin folder", "checkFilesPermission", [ this.npm.localBin, !1, R_OK | W_OK | X_OK, !0 ] ], [ "Perms check on global bin folder", "checkFilesPermission", [ this.npm.globalBin, !1, X_OK ] ] ], [ "Verify cache contents", "verifyCachedFiles", [ this.npm.flatOptions.cache ] ] ];
          for (const [msg, fn, args] of actions) {
            const line = [ msg ];
            try {
              line.push(!0, await this[fn](...args));
            } catch (er) {
              line.push(!1, er);
            }
            messages.push(line);
          }
          const outHead = [ "Check", "Value", "Recommendation/Notes" ].map((h => this.npm.chalk.underline(h)));
          let allOk = !0;
          const outTable = [ outHead, ...messages.map((item => (item[1] ? item[1] = this.npm.chalk.green("ok") : (allOk = !1, 
          item[0] = this.npm.chalk.red(item[0]), item[1] = this.npm.chalk.red("not ok"), item[2] = this.npm.chalk.magenta(String(item[2]))), 
          item))) ], tableOpts = {
            stringLength: s => ansiTrim(s).length
          };
          if (this.npm.silent || this.npm.output(table(outTable, tableOpts)), !allOk) throw new Error("Some problems found. See above for recommendations.");
        }
        async checkPing() {
          const tracker = log.newItem("checkPing", 1);
          tracker.info("checkPing", "Pinging registry");
          try {
            return await ping({
              ...this.npm.flatOptions,
              retry: !1
            }), "";
          } catch (er) {
            throw /^E\d{3}$/.test(er.code || "") ? er.code.slice(1) + " " + er.message : er.message;
          } finally {
            tracker.finish();
          }
        }
        async getLatestNpmVersion() {
          const tracker = log.newItem("getLatestNpmVersion", 1);
          tracker.info("getLatestNpmVersion", "Getting npm package information");
          try {
            const latest = (await pacote.manifest("npm@latest", this.npm.flatOptions)).version;
            if (semver.gte(this.npm.version, latest)) return `current: v${this.npm.version}, latest: v${latest}`;
            throw `Use npm v${latest}`;
          } finally {
            tracker.finish();
          }
        }
        async getLatestNodejsVersion() {
          const current = process.version, currentRange = `^${current}`, tracker = log.newItem("getLatestNodejsVersion", 1);
          tracker.info("getLatestNodejsVersion", "Getting Node.js release information");
          try {
            const res = await fetch("https://nodejs.org/dist/index.json", {
              method: "GET",
              ...this.npm.flatOptions
            }), data = await res.json();
            let maxCurrent = "0.0.0", maxLTS = "0.0.0";
            for (const {lts, version} of data) lts && semver.gt(version, maxLTS) && (maxLTS = version), 
            semver.satisfies(version, currentRange) && semver.gt(version, maxCurrent) && (maxCurrent = version);
            const recommended = semver.gt(maxCurrent, maxLTS) ? maxCurrent : maxLTS;
            if (semver.gte(process.version, recommended)) return `current: ${current}, recommended: ${recommended}`;
            throw `Use node ${recommended} (current: ${current})`;
          } finally {
            tracker.finish();
          }
        }
        async checkFilesPermission(root, shouldOwn, mask, missingOk) {
          let ok = !0;
          const tracker = log.newItem(root, 1);
          try {
            const uid = process.getuid(), gid = process.getgid(), files = new Set([ root ]);
            for (const f of files) {
              tracker.silly("checkFilesPermission", f.slice(root.length + 1));
              const st = await lstat(f).catch((er => {
                missingOk && "ENOENT" === er.code || (ok = !1, tracker.warn("checkFilesPermission", "error getting info for " + f));
              }));
              if (tracker.completeWork(1), st && (!shouldOwn || uid === st.uid && gid === st.gid || (tracker.warn("checkFilesPermission", "should be owner of " + f), 
              ok = !1), st.isDirectory() || st.isFile())) {
                try {
                  await access(f, mask);
                } catch (er) {
                  ok = !1;
                  const msg = `Missing permissions on ${f} (expect: ${maskLabel(mask)})`;
                  tracker.error("checkFilesPermission", msg);
                  continue;
                }
                if (st.isDirectory()) {
                  const entries = await readdir(f).catch((er => (ok = !1, tracker.warn("checkFilesPermission", "error reading directory " + f), 
                  [])));
                  for (const entry of entries) files.add(resolve(f, entry));
                }
              }
            }
          } finally {
            if (tracker.finish(), ok) return "";
            throw `Check the permissions of files in ${root}` + (shouldOwn ? " (should be owned by current user)" : "");
          }
        }
        async getGitPath() {
          const tracker = log.newItem("getGitPath", 1);
          tracker.info("getGitPath", "Finding git in your PATH");
          try {
            return await which("git").catch((er => {
              throw tracker.warn(er), "Install git and ensure it's in your PATH.";
            }));
          } finally {
            tracker.finish();
          }
        }
        async verifyCachedFiles() {
          const tracker = log.newItem("verifyCachedFiles", 1);
          tracker.info("verifyCachedFiles", "Verifying the npm cache");
          try {
            const stats = await cacache.verify(this.npm.flatOptions.cache), {badContentCount, reclaimedCount, missingContent, reclaimedSize} = stats;
            return (badContentCount || reclaimedCount || missingContent) && (badContentCount && tracker.warn("verifyCachedFiles", `Corrupted content removed: ${badContentCount}`), 
            reclaimedCount && tracker.warn("verifyCachedFiles", `Content garbage-collected: ${reclaimedCount} (${reclaimedSize} bytes)`), 
            missingContent && tracker.warn("verifyCachedFiles", `Missing content: ${missingContent}`), 
            tracker.warn("verifyCachedFiles", "Cache issues have been fixed")), tracker.info("verifyCachedFiles", `Verification complete. Stats: ${JSON.stringify(stats, null, 2)}`), 
            `verified ${stats.verifiedContent} tarballs`;
          } finally {
            tracker.finish();
          }
        }
        async checkNpmRegistry() {
          if (this.npm.flatOptions.registry !== defaultRegistry) throw `Try \`npm config set registry=${defaultRegistry}\``;
          return `using default registry (${defaultRegistry})`;
        }
      };
    },
    68543: (module, __unused_webpack_exports, __webpack_require__) => {
      const {resolve} = __webpack_require__(71017), fs = __webpack_require__(49809), cp = __webpack_require__(32081), completion = __webpack_require__(73486), BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Edit an installed package";
        static name="edit";
        static usage=[ "<pkg>[/<subpkg>...]" ];
        static params=[ "editor" ];
        static ignoreImplicitWorkspace=!1;
        async completion(opts) {
          return completion(this.npm, opts);
        }
        async exec(args) {
          if (1 !== args.length) throw this.usageError();
          const path = (path => path.split("/").reduce(((parts, part) => {
            if (0 === parts.length) return [ part ];
            const lastPart = parts[parts.length - 1];
            return "@" !== lastPart[0] || lastPart.includes("/") ? parts.push(part) : parts[parts.length - 1] += "/" + part, 
            parts;
          }), []).join("/node_modules/").replace(/(\/node_modules)+/, "/node_modules"))(args[0]), dir = resolve(this.npm.dir, path);
          await new Promise(((resolve, reject) => {
            fs.lstat(dir, (err => {
              if (err) return reject(err);
              const [bin, ...args] = this.npm.config.get("editor").split(/\s+/);
              cp.spawn(bin, [ ...args, dir ], {
                stdio: "inherit"
              }).on("exit", (async code => {
                if (code) return reject(new Error(`editor process exited with code: ${code}`));
                try {
                  await this.npm.exec("rebuild", [ dir ]);
                } catch (err) {
                  reject(err);
                }
                resolve();
              }));
            }));
          }));
        }
      };
    },
    81500: (module, __unused_webpack_exports, __webpack_require__) => {
      const path = __webpack_require__(71017), libexec = __webpack_require__(97050), BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Run a command from a local or remote npm package";
        static params=[ "package", "call", "workspace", "workspaces", "include-workspace-root" ];
        static name="exec";
        static usage=[ "-- <pkg>[@<version>] [args...]", "--package=<pkg>[@<version>] -- <cmd> [args...]", "-c '<cmd> [args...]'", "--package=foo -c '<cmd> [args...]'" ];
        static ignoreImplicitWorkspace=!1;
        static isShellout=!0;
        async exec(_args, {locationMsg, runPath} = {}) {
          const localPrefix = this.npm.localPrefix;
          runPath || (runPath = process.cwd());
          const args = [ ..._args ], call = this.npm.config.get("call");
          let globalPath;
          const {flatOptions, localBin, globalBin, globalDir} = this.npm, output = this.npm.output.bind(this.npm), scriptShell = this.npm.config.get("script-shell") || void 0, packages = this.npm.config.get("package"), yes = this.npm.config.get("yes");
          if (this.npm.localPrefix !== this.npm.globalPrefix && (globalPath = path.resolve(globalDir, "..")), 
          call && _args.length) throw this.usageError();
          return libexec({
            ...flatOptions,
            packageLockOnly: !1,
            args,
            call,
            localBin,
            locationMsg,
            globalBin,
            globalPath,
            output,
            packages,
            path: localPrefix,
            runPath,
            scriptShell,
            yes
          });
        }
        async execWorkspaces(args, filters) {
          await this.setWorkspaces(filters);
          for (const [name, path] of this.workspaces) {
            const locationMsg = `in workspace ${this.npm.chalk.green(name)} at location:\n${this.npm.chalk.dim(path)}`;
            await this.exec(args, {
              locationMsg,
              runPath: path
            });
          }
        }
      };
    },
    35034: (module, __unused_webpack_exports, __webpack_require__) => {
      const {explainNode} = __webpack_require__(53975), completion = __webpack_require__(46624), Arborist = __webpack_require__(22290), npa = __webpack_require__(19932), semver = __webpack_require__(5870), {relative, resolve} = __webpack_require__(71017), validName = __webpack_require__(74980), ArboristWorkspaceCmd = __webpack_require__(99264);
      module.exports = class extends ArboristWorkspaceCmd {
        static description="Explain installed packages";
        static name="explain";
        static usage=[ "<package-spec>" ];
        static params=[ "json", "workspace" ];
        static ignoreImplicitWorkspace=!1;
        async completion(opts) {
          return completion(this.npm, opts);
        }
        async exec(args) {
          if (!args.length) throw this.usageError();
          const arb = new Arborist({
            path: this.npm.prefix,
            ...this.npm.flatOptions
          }), tree = await arb.loadActual();
          this.npm.flatOptions.workspacesEnabled && this.workspaceNames && this.workspaceNames.length ? this.filterSet = arb.workspaceDependencySet(tree, this.workspaceNames) : this.npm.flatOptions.workspacesEnabled || (this.filterSet = arb.excludeWorkspacesDependencySet(tree));
          const nodes = new Set;
          for (const arg of args) for (const node of this.getNodes(tree, arg)) {
            this.filterSet && this.filterSet.size > 0 && !this.filterSet.has(node) || nodes.add(node);
          }
          if (0 === nodes.size) throw new Error(`No dependencies found matching ${args.join(", ")}`);
          const expls = [];
          for (const node of nodes) {
            const {extraneous, dev, optional, devOptional, peer, inBundle, overridden} = node, expl = node.explain();
            extraneous ? expl.extraneous = !0 : (expl.dev = dev, expl.optional = optional, expl.devOptional = devOptional, 
            expl.peer = peer, expl.bundled = inBundle, expl.overridden = overridden), expls.push(expl);
          }
          this.npm.flatOptions.json ? this.npm.output(JSON.stringify(expls, null, 2)) : this.npm.output(expls.map((expl => explainNode(expl, 1 / 0, this.npm.color))).join("\n\n"));
        }
        getNodes(tree, arg) {
          const {validForOldPackages: valid} = validName(arg);
          if (valid) return tree.inventory.query("packageName", arg);
          const maybeLoc = arg.replace(/\\/g, "/").replace(/\/+$/, ""), nodeByLoc = tree.inventory.get(maybeLoc);
          if (nodeByLoc) return [ nodeByLoc ];
          const maybePath = relative(this.npm.prefix, resolve(maybeLoc)).replace(/\\/g, "/").replace(/\/+$/, ""), nodeByPath = tree.inventory.get(maybePath);
          if (nodeByPath) return [ nodeByPath ];
          try {
            return this.getNodesByVersion(tree, arg);
          } catch (er) {
            return [];
          }
        }
        getNodesByVersion(tree, arg) {
          const spec = npa(arg, this.npm.prefix);
          return "version" !== spec.type && "range" !== spec.type ? [] : tree.inventory.filter((node => node.package.name === spec.name && semver.satisfies(node.package.version, spec.rawSpec)));
        }
      };
    },
    73586: (module, __unused_webpack_exports, __webpack_require__) => {
      const rpj = __webpack_require__(1759), runScript = __webpack_require__(63036), {join, resolve, relative} = __webpack_require__(71017), log = __webpack_require__(86883), completion = __webpack_require__(73486), BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Browse an installed package";
        static name="explore";
        static usage=[ "<pkg> [ -- <command>]" ];
        static params=[ "shell" ];
        static ignoreImplicitWorkspace=!1;
        async completion(opts) {
          return completion(this.npm, opts);
        }
        async exec(args) {
          if (args.length < 1 || !args[0]) throw this.usageError();
          const pkgname = args.shift(), path = join(this.npm.dir, join("/", pkgname));
          if ("" === relative(path, this.npm.dir)) throw this.usageError();
          const pkg = await rpj(resolve(path, "package.json")).catch((er => {
            throw log.error("explore", `It doesn't look like ${pkgname} is installed.`), er;
          })), {shell} = this.npm.flatOptions;
          pkg.scripts = {
            ...pkg.scripts || {},
            _explore: args.join(" ").trim() || shell
          }, args.length || this.npm.output(`\nExploring ${path}\nType 'exit' or ^D when finished\n`), 
          log.disableProgress();
          try {
            return await runScript({
              ...this.npm.flatOptions,
              pkg,
              banner: !1,
              path,
              stdioString: !0,
              event: "_explore",
              stdio: "inherit"
            }).catch((er => {
              process.exitCode = "number" == typeof er.code && 0 !== er.code ? er.code : 1;
              const isProcExit = "command failed" === er.message && ("number" == typeof er.code || /^SIG/.test(er.signal || ""));
              if (args.length || !isProcExit) throw er;
            }));
          } finally {
            log.enableProgress();
          }
        }
      };
    },
    86429: (module, __unused_webpack_exports, __webpack_require__) => {
      const ArboristWorkspaceCmd = __webpack_require__(99264);
      class FindDupes extends ArboristWorkspaceCmd {
        static description="Find duplication in the package tree";
        static name="find-dupes";
        static params=[ "global-style", "legacy-bundling", "strict-peer-deps", "package-lock", "omit", "ignore-scripts", "audit", "bin-links", "fund", ...super.params ];
        async exec(args, cb) {
          return this.npm.config.set("dry-run", !0), this.npm.exec("dedupe", []);
        }
      }
      module.exports = FindDupes;
    },
    68465: (module, __unused_webpack_exports, __webpack_require__) => {
      const archy = __webpack_require__(84032), Arborist = __webpack_require__(22290), chalk = __webpack_require__(25433), pacote = __webpack_require__(86585), semver = __webpack_require__(5870), npa = __webpack_require__(19932), {depth} = __webpack_require__(75476), {readTree: getFundingInfo, normalizeFunding, isValidFunding} = __webpack_require__(77881), completion = __webpack_require__(46624), openUrl = __webpack_require__(89562), ArboristWorkspaceCmd = __webpack_require__(99264);
      module.exports = class extends ArboristWorkspaceCmd {
        static description="Retrieve funding information";
        static name="fund";
        static params=[ "json", "browser", "unicode", "workspace", "which" ];
        static usage=[ "[<package-spec>]" ];
        async completion(opts) {
          return completion(this.npm, opts);
        }
        async exec(args) {
          const spec = args[0], numberArg = this.npm.config.get("which"), fundingSourceNumber = numberArg && parseInt(numberArg, 10);
          if (null !== numberArg && (String(fundingSourceNumber) !== numberArg || fundingSourceNumber < 1)) {
            const err = new Error("`npm fund [<@scope>/]<pkg> [--which=fundingSourceNumber]` must be given a positive integer");
            throw err.code = "EFUNDNUMBER", err;
          }
          if (this.npm.global) {
            const err = new Error("`npm fund` does not support global packages");
            throw err.code = "EFUNDGLOBAL", err;
          }
          const where = this.npm.prefix, arb = new Arborist({
            ...this.npm.flatOptions,
            path: where
          }), tree = await arb.loadActual();
          if (spec) return void await this.openFundingUrl({
            path: where,
            tree,
            spec,
            fundingSourceNumber
          });
          const fundingInfo = getFundingInfo(tree, {
            ...this.flatOptions,
            workspaces: this.workspaceNames
          });
          this.npm.config.get("json") ? this.npm.output(this.printJSON(fundingInfo)) : this.npm.output(this.printHuman(fundingInfo));
        }
        printJSON(fundingInfo) {
          return JSON.stringify(fundingInfo, null, 2);
        }
        printHuman(fundingInfo) {
          const color = this.npm.color, unicode = this.npm.config.get("unicode"), seenUrls = new Map, tree = obj => archy(obj, "", {
            unicode
          }), result = depth({
            tree: fundingInfo,
            visit: ({name, version, funding}) => {
              const [fundingSource] = [].concat(normalizeFunding(funding)).filter(isValidFunding), {url} = fundingSource || {}, pkgRef = (({name, version}) => `${name}${version ? `@${version}` : ""}`)({
                name,
                version
              });
              let item = {
                label: pkgRef
              };
              if (url) {
                if (item.label = tree({
                  label: color ? chalk.bgBlack.white(url) : url,
                  nodes: [ pkgRef ]
                }).trim(), seenUrls.has(url)) return item = seenUrls.get(url), item.label += `, ${pkgRef}`, 
                null;
                seenUrls.set(url, item);
              }
              return item;
            },
            leave: (item, children) => (item && (item.nodes = children.filter(Boolean)), item),
            getChildren: node => Object.keys(node.dependencies || {}).map((key => ({
              name: key,
              ...node.dependencies[key]
            })))
          }), res = tree(result);
          return color ? chalk.reset(res) : res;
        }
        async openFundingUrl({path, tree, spec, fundingSourceNumber}) {
          const arg = npa(spec, path), {funding} = (() => {
            if ("directory" === arg.type) {
              if (tree.path === arg.fetchSpec) return tree.package;
              for (const item of tree.inventory.values()) if (item.path === arg.fetchSpec) return item.package;
            } else {
              const [item] = [ ...tree.inventory.query("name", arg.name) ].filter((i => semver.valid(i.package.version))).sort(((a, b) => semver.rcompare(a.package.version, b.package.version)));
              if (item) return item.package;
            }
          })() || await pacote.manifest(arg, this.npm.flatOptions).catch((() => ({}))), validSources = [].concat(normalizeFunding(funding)).filter(isValidFunding);
          if (1 === validSources.length || fundingSourceNumber > 0 && fundingSourceNumber <= validSources.length) {
            const index = fundingSourceNumber ? fundingSourceNumber - 1 : 0, {type, url} = validSources[index], msg = `${type ? `${type} funding` : "Funding"} available at the following URL`;
            return openUrl(this.npm, url, msg);
          }
          if (!validSources.length || fundingSourceNumber >= 1) {
            const noFundingError = new Error(`No valid funding method available for: ${spec}`);
            throw noFundingError.code = "ENOFUND", noFundingError;
          }
          validSources.forEach((({type, url}, i) => {
            const msg = `${type ? `${type} funding` : "Funding"} available at the following URL`;
            this.npm.output(`${i + 1}: ${msg}: ${url}`);
          })), this.npm.output("Run `npm fund [<@scope>/]<pkg> --which=1`, for example, to open the first funding URL listed in that package");
        }
      };
    },
    57508: (module, __unused_webpack_exports, __webpack_require__) => {
      const BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Get a value from the npm configuration";
        static name="get";
        static usage=[ "[<key> ...] (See `npm config`)" ];
        static ignoreImplicitWorkspace=!1;
        async completion(opts) {
          return (await this.npm.cmd("config")).completion(opts);
        }
        async exec(args) {
          return this.npm.exec("config", [ "get" ].concat(args));
        }
      };
    },
    30581: (module, __unused_webpack_exports, __webpack_require__) => {
      const hookApi = __webpack_require__(76837), otplease = __webpack_require__(83304), relativeDate = __webpack_require__(38100), Table = __webpack_require__(27275), BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Manage registry hooks";
        static name="hook";
        static params=[ "registry", "otp" ];
        static usage=[ "add <pkg> <url> <secret> [--type=<type>]", "ls [pkg]", "rm <id>", "update <id> <url> <secret>" ];
        static ignoreImplicitWorkspace=!0;
        async exec(args) {
          return otplease(this.npm, {
            ...this.npm.flatOptions
          }, (opts => {
            switch (args[0]) {
             case "add":
              return this.add(args[1], args[2], args[3], opts);

             case "ls":
              return this.ls(args[1], opts);

             case "rm":
              return this.rm(args[1], opts);

             case "update":
             case "up":
              return this.update(args[1], args[2], args[3], opts);

             default:
              throw this.usageError();
            }
          }));
        }
        async add(pkg, uri, secret, opts) {
          const hook = await hookApi.add(pkg, uri, secret, opts);
          opts.json ? this.npm.output(JSON.stringify(hook, null, 2)) : opts.parseable ? (this.npm.output(Object.keys(hook).join("\t")), 
          this.npm.output(Object.keys(hook).map((k => hook[k])).join("\t"))) : this.npm.silent || this.npm.output(`+ ${this.hookName(hook)} ${opts.unicode ? "  " : " -> "} ${hook.endpoint}`);
        }
        async ls(pkg, opts) {
          const hooks = await hookApi.ls({
            ...opts,
            package: pkg
          });
          if (opts.json) this.npm.output(JSON.stringify(hooks, null, 2)); else if (opts.parseable) this.npm.output(Object.keys(hooks[0]).join("\t")), 
          hooks.forEach((hook => {
            this.npm.output(Object.keys(hook).map((k => hook[k])).join("\t"));
          })); else if (hooks.length) {
            if (!this.npm.silent) {
              1 === hooks.length ? this.npm.output("You have one hook configured.") : this.npm.output(`You have ${hooks.length} hooks configured.`);
              const table = new Table({
                head: [ "id", "target", "endpoint" ]
              });
              hooks.forEach((hook => {
                table.push([ {
                  rowSpan: 2,
                  content: hook.id
                }, this.hookName(hook), hook.endpoint ]), hook.last_delivery ? table.push([ {
                  colSpan: 1,
                  content: `triggered ${relativeDate(hook.last_delivery)}`
                }, hook.response_code ]) : table.push([ {
                  colSpan: 2,
                  content: "never triggered"
                } ]);
              })), this.npm.output(table.toString());
            }
          } else this.npm.output("You don't have any hooks configured yet.");
        }
        async rm(id, opts) {
          const hook = await hookApi.rm(id, opts);
          opts.json ? this.npm.output(JSON.stringify(hook, null, 2)) : opts.parseable ? (this.npm.output(Object.keys(hook).join("\t")), 
          this.npm.output(Object.keys(hook).map((k => hook[k])).join("\t"))) : this.npm.silent || this.npm.output(`- ${this.hookName(hook)} ${opts.unicode ? "  " : " X "} ${hook.endpoint}`);
        }
        async update(id, uri, secret, opts) {
          const hook = await hookApi.update(id, uri, secret, opts);
          opts.json ? this.npm.output(JSON.stringify(hook, null, 2)) : opts.parseable ? (this.npm.output(Object.keys(hook).join("\t")), 
          this.npm.output(Object.keys(hook).map((k => hook[k])).join("\t"))) : this.npm.silent || this.npm.output(`+ ${this.hookName(hook)} ${opts.unicode ? "  " : " -> "} ${hook.endpoint}`);
        }
        hookName(hook) {
          let target = hook.name;
          return "scope" === hook.type && (target = "@" + target), "owner" === hook.type && (target = "~" + target), 
          target;
        }
      };
    },
    20633: (module, __unused_webpack_exports, __webpack_require__) => {
      const fs = __webpack_require__(57147), {relative, resolve} = __webpack_require__(71017), mkdirp = __webpack_require__(87700), initJson = __webpack_require__(37477), npa = __webpack_require__(19932), rpj = __webpack_require__(1759), libexec = __webpack_require__(97050), mapWorkspaces = __webpack_require__(69960), PackageJson = __webpack_require__(66096), log = __webpack_require__(86883), updateWorkspaces = __webpack_require__(43644), BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Create a package.json file";
        static params=[ "yes", "force", "scope", "workspace", "workspaces", "workspaces-update", "include-workspace-root" ];
        static name="init";
        static usage=[ "<package-spec> (same as `npx <package-spec>)", "<@scope> (same as `npx <@scope>/create`)" ];
        static ignoreImplicitWorkspace=!1;
        async exec(args) {
          if (args.length) return await this.execCreate({
            args,
            path: process.cwd()
          });
          await this.template();
        }
        async execWorkspaces(args, filters) {
          this.npm.flatOptions.includeWorkspaceRoot && await this.exec(args);
          const pkg = await rpj(resolve(this.npm.localPrefix, "package.json")), wPath = filterArg => resolve(this.npm.localPrefix, filterArg), workspacesPaths = [];
          if (args.length) for (const filterArg of filters) {
            const path = wPath(filterArg);
            await mkdirp(path), workspacesPaths.push(path), await this.execCreate({
              args,
              path
            }), await this.setWorkspace({
              pkg,
              workspacePath: path
            });
          } else {
            for (const filterArg of filters) {
              const path = wPath(filterArg);
              await mkdirp(path), workspacesPaths.push(path), await this.template(path), await this.setWorkspace({
                pkg,
                workspacePath: path
              });
            }
            await this.update(workspacesPaths);
          }
        }
        async execCreate({args, path}) {
          const [initerName, ...otherArgs] = args;
          let packageName = initerName;
          if (/^@[^/]+$/.test(initerName)) {
            const [, scope, version] = initerName.split("@");
            packageName = `@${scope}/create`, version && (packageName = `${packageName}@${version}`);
          } else {
            const req = npa(initerName);
            if ("git" === req.type && req.hosted) {
              const {user, project} = req.hosted;
              packageName = initerName.replace(user + "/" + project, user + "/create-" + project);
            } else {
              if (!req.registry) throw Object.assign(new Error("Unrecognized initializer: " + initerName + "\nFor more package binary executing power check out `npx`:\nhttps://www.npmjs.com/package/npx"), {
                code: "EUNSUPPORTED"
              });
              packageName = req.name.replace(/^(@[^/]+\/)?/, "$1create-"), req.rawSpec && (packageName += "@" + req.rawSpec);
            }
          }
          const newArgs = [ packageName, ...otherArgs ], {color} = this.npm.flatOptions, {flatOptions, localBin, globalBin} = this.npm, output = this.npm.output.bind(this.npm), runPath = path, scriptShell = this.npm.config.get("script-shell") || void 0, yes = this.npm.config.get("yes");
          await libexec({
            ...flatOptions,
            args: newArgs,
            color,
            localBin,
            globalBin,
            output,
            path,
            runPath,
            scriptShell,
            yes
          });
        }
        async template(path = process.cwd()) {
          log.pause(), log.disableProgress();
          const initFile = this.npm.config.get("init-module");
          this.npm.config.get("yes") || this.npm.config.get("force") || this.npm.output([ "This utility will walk you through creating a package.json file.", "It only covers the most common items, and tries to guess sensible defaults.", "", "See `npm help init` for definitive documentation on these fields", "and exactly what they do.", "", "Use `npm install <pkg>` afterwards to install a package and", "save it as a dependency in the package.json file.", "", "Press ^C at any time to quit." ].join("\n")), 
          await new Promise(((res, rej) => {
            initJson(path, initFile, this.npm.config, ((er, data) => {
              if (log.resume(), log.enableProgress(), log.silly("package data", data), er && "canceled" === er.message) return log.warn("init", "canceled"), 
              res();
              er ? rej(er) : (log.info("init", "written successfully"), res(data));
            }));
          }));
        }
        async setWorkspace({pkg, workspacePath}) {
          const workspaces = await mapWorkspaces({
            cwd: this.npm.localPrefix,
            pkg
          });
          for (const wPath of workspaces.values()) if (wPath === workspacePath) return;
          try {
            fs.statSync(resolve(workspacePath, "package.json"));
          } catch (err) {
            return;
          }
          const pkgJson = await PackageJson.load(this.npm.localPrefix);
          pkgJson.update({
            workspaces: [ ...pkgJson.content.workspaces || [], relative(this.npm.localPrefix, workspacePath) ]
          }), await pkgJson.save();
        }
        async update(workspacesPaths) {
          const workspaces = [];
          for (const path of workspacesPaths) {
            const pkgPath = resolve(path, "package.json"), {name} = await rpj(pkgPath).catch((() => ({})));
            name && workspaces.push(name);
          }
          const {config, flatOptions, localPrefix} = this.npm;
          await updateWorkspaces({
            config,
            flatOptions,
            localPrefix,
            npm: this.npm,
            workspaces
          });
        }
      };
    },
    27678: (module, __unused_webpack_exports, __webpack_require__) => {
      const CI = __webpack_require__(70244);
      module.exports = class extends CI {
        static description="Install a project with a clean slate and run tests";
        static name="install-ci-test";
        async exec(args, cb) {
          return await this.npm.exec("ci", args), this.npm.exec("test", []);
        }
      };
    },
    52610: (module, __unused_webpack_exports, __webpack_require__) => {
      const Install = __webpack_require__(92514);
      module.exports = class extends Install {
        static description="Install package(s) and run tests";
        static name="install-test";
        async exec(args, cb) {
          return await this.npm.exec("install", args), this.npm.exec("test", []);
        }
      };
    },
    92514: (module, __unused_webpack_exports, __webpack_require__) => {
      const fs = __webpack_require__(57147), readdir = __webpack_require__(73837).promisify(fs.readdir), reifyFinish = __webpack_require__(2648), log = __webpack_require__(86883), {resolve, join} = __webpack_require__(71017), Arborist = __webpack_require__(22290), runScript = __webpack_require__(63036), pacote = __webpack_require__(86585), checks = __webpack_require__(91126), ArboristWorkspaceCmd = __webpack_require__(99264);
      class Install extends ArboristWorkspaceCmd {
        static description="Install a package";
        static name="install";
        static params=[ "save", "save-exact", "global", "global-style", "legacy-bundling", "omit", "strict-peer-deps", "package-lock", "foreground-scripts", "ignore-scripts", "audit", "bin-links", "fund", "dry-run", ...super.params ];
        static usage=[ "[<package-spec> ...]" ];
        async completion(opts) {
          const {partialWord} = opts;
          if (/^https?:\/\//.test(partialWord)) return [];
          if (/\//.test(partialWord)) {
            const lastSlashIdx = partialWord.lastIndexOf("/"), partialName = partialWord.slice(lastSlashIdx + 1), partialPath = partialWord.slice(0, lastSlashIdx) || "/", isDirMatch = async sibling => {
              if (sibling.slice(0, partialName.length) !== partialName) return !1;
              try {
                const contents = await readdir(join(partialPath, sibling));
                return -1 !== contents.indexOf("package.json");
              } catch (er) {
                return !1;
              }
            };
            try {
              const siblings = await readdir(partialPath), matches = [];
              for (const sibling of siblings) await isDirMatch(sibling) && matches.push(sibling);
              return 1 === matches.length ? [ join(partialPath, matches[0]) ] : [];
            } catch (er) {
              return [];
            }
          }
        }
        async exec(args) {
          const globalTop = resolve(this.npm.globalDir, ".."), ignoreScripts = this.npm.config.get("ignore-scripts"), isGlobalInstall = this.npm.global, where = isGlobalInstall ? globalTop : this.npm.prefix, forced = this.npm.config.get("force"), scriptShell = this.npm.config.get("script-shell") || void 0, npmInstall = args.find((arg => arg.startsWith("npm@") || "npm" === arg));
          if (isGlobalInstall && npmInstall) {
            const npmOptions = this.npm.flatOptions, npmManifest = await pacote.manifest(npmInstall, npmOptions);
            try {
              checks.checkEngine(npmManifest, npmManifest.version, process.version);
            } catch (e) {
              if (!forced) throw e;
              log.warn("install", `Forcing global npm install with incompatible version ${npmManifest.version} into node ${process.version}`);
            }
          }
          if (args = args.filter((a => resolve(a) !== this.npm.prefix)), where !== globalTop || args.length || (args = [ "." ]), 
          where === globalTop && !args.every(Boolean)) throw this.usageError();
          const opts = {
            ...this.npm.flatOptions,
            auditLevel: null,
            path: where,
            add: args,
            workspaces: this.workspaceNames
          }, arb = new Arborist(opts);
          if (await arb.reify(opts), !args.length && !isGlobalInstall && !ignoreScripts) {
            const scripts = [ "preinstall", "install", "postinstall", "prepublish", "preprepare", "prepare", "postprepare" ];
            for (const event of scripts) await runScript({
              path: where,
              args: [],
              scriptShell,
              stdio: "inherit",
              stdioString: !0,
              banner: !this.npm.silent,
              event
            });
          }
          await reifyFinish(this.npm, arb);
        }
      }
      module.exports = Install;
    },
    25485: (module, __unused_webpack_exports, __webpack_require__) => {
      const fs = __webpack_require__(57147), readdir = __webpack_require__(73837).promisify(fs.readdir), {resolve} = __webpack_require__(71017), Arborist = __webpack_require__(22290), npa = __webpack_require__(19932), rpj = __webpack_require__(1759), semver = __webpack_require__(5870), reifyFinish = __webpack_require__(2648), ArboristWorkspaceCmd = __webpack_require__(99264);
      class Link extends ArboristWorkspaceCmd {
        static description="Symlink a package folder";
        static name="link";
        static usage=[ "[<package-spec>]" ];
        static params=[ "save", "save-exact", "global", "global-style", "legacy-bundling", "strict-peer-deps", "package-lock", "omit", "ignore-scripts", "audit", "bin-links", "fund", "dry-run", ...super.params ];
        async completion(opts) {
          const dir = this.npm.globalDir;
          return (await readdir(dir)).filter((f => !/^[._-]/.test(f)));
        }
        async exec(args) {
          if (this.npm.global) throw Object.assign(new Error("link should never be --global.\nPlease re-run this command with --local"), {
            code: "ELINKGLOBAL"
          });
          return (args = args.filter((a => resolve(a) !== this.npm.prefix))).length ? this.linkInstall(args) : this.linkPkg();
        }
        async linkInstall(args) {
          const globalTop = resolve(this.npm.globalDir, ".."), globalOpts = {
            ...this.npm.flatOptions,
            path: globalTop,
            global: !0,
            prune: !1
          }, globalArb = new Arborist(globalOpts), globals = await globalArb.loadActual({
            filter: (node, kid) => !node.isRoot || args.some((a => npa(a).name === kid))
          }), missing = this.missingArgsFromTree(globals, args);
          missing.length && await globalArb.reify({
            ...globalOpts,
            add: missing
          });
          const names = [];
          for (const a of args) {
            const arg = npa(a);
            names.push("directory" === arg.type ? (await rpj(resolve(arg.fetchSpec, "package.json"))).name : arg.name);
          }
          const save = Boolean("default" !== this.npm.config.find("save") || this.npm.config.get("save-optional") || this.npm.config.get("save-peer") || this.npm.config.get("save-dev") || this.npm.config.get("save-prod")), localArb = new Arborist({
            ...this.npm.flatOptions,
            prune: !1,
            path: this.npm.prefix,
            save
          });
          await localArb.reify({
            ...this.npm.flatOptions,
            prune: !1,
            path: this.npm.prefix,
            add: names.map((l => `file:${resolve(globalTop, "node_modules", l).replace(/#/g, "%23")}`)),
            save,
            workspaces: this.workspaceNames
          }), await reifyFinish(this.npm, localArb);
        }
        async linkPkg() {
          const wsp = this.workspacePaths, add = (wsp && wsp.length ? wsp : [ this.npm.prefix ]).map((path => `file:${path.replace(/#/g, "%23")}`)), globalTop = resolve(this.npm.globalDir, ".."), arb = new Arborist({
            ...this.npm.flatOptions,
            path: globalTop,
            global: !0
          });
          await arb.reify({
            add
          }), await reifyFinish(this.npm, arb);
        }
        missingArgsFromTree(tree, args) {
          if (tree.isLink) return this.missingArgsFromTree(tree.target, args);
          const foundNodes = [], missing = args.filter((a => {
            const arg = npa(a);
            return [ ...tree.children.values() ].every((node => {
              if (arg.name !== node.name || arg.version && !semver.satisfies(node.version, arg.version)) return foundNodes.push(node), 
              !0;
            }));
          }));
          for (const node of foundNodes) node.parent = null;
          return missing;
        }
      }
      module.exports = Link;
    },
    96292: (module, __unused_webpack_exports, __webpack_require__) => {
      const LS = __webpack_require__(33581);
      module.exports = class extends LS {
        static name="ll";
        static usage=[ "[[<@scope>/]<pkg> ...]" ];
        async exec(args) {
          return this.npm.config.set("long", !0), super.exec(args);
        }
      };
    },
    3314: (module, __unused_webpack_exports, __webpack_require__) => {
      const getAuth = __webpack_require__(35425), npmFetch = __webpack_require__(92427), log = __webpack_require__(86883), BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Log out of the registry";
        static name="logout";
        static params=[ "registry", "scope" ];
        static ignoreImplicitWorkspace=!0;
        async exec(args) {
          const registry = this.npm.config.get("registry"), scope = this.npm.config.get("scope"), regRef = scope ? `${scope}:registry` : "registry", reg = this.npm.config.get(regRef) || registry, auth = getAuth(reg, this.npm.flatOptions);
          if (auth.token) log.verbose("logout", `clearing token for ${reg}`), await npmFetch(`/-/user/token/${encodeURIComponent(auth.token)}`, {
            ...this.npm.flatOptions,
            method: "DELETE",
            ignoreBody: !0
          }); else {
            if (!auth.isBasicAuth) {
              const msg = `not logged in to ${reg}, so can't log out!`;
              throw Object.assign(new Error(msg), {
                code: "ENEEDAUTH"
              });
            }
            log.verbose("logout", `clearing user credentials for ${reg}`);
          }
          scope && this.npm.config.delete(regRef, "user"), this.npm.config.clearCredentialsByURI(reg), 
          await this.npm.config.save("user");
        }
      };
    },
    33581: (module, __unused_webpack_exports, __webpack_require__) => {
      const {resolve, relative, sep} = __webpack_require__(71017), relativePrefix = `.${sep}`, {EOL} = __webpack_require__(22037), archy = __webpack_require__(84032), chalk = __webpack_require__(25433), Arborist = __webpack_require__(22290), {breadth} = __webpack_require__(75476), npa = __webpack_require__(19932), completion = __webpack_require__(46624), _depth = Symbol("depth"), _dedupe = Symbol("dedupe"), _filteredBy = Symbol("filteredBy"), _include = Symbol("include"), _invalid = Symbol("invalid"), _name = Symbol("name"), _missing = Symbol("missing"), _parent = Symbol("parent"), _problems = Symbol("problems"), _required = Symbol("required"), _type = Symbol("type"), ArboristWorkspaceCmd = __webpack_require__(99264), localeCompare = __webpack_require__(51031)("en");
      class LS extends ArboristWorkspaceCmd {
        static description="List installed packages";
        static name="ls";
        static usage=[ "<package-spec>" ];
        static params=[ "all", "json", "long", "parseable", "global", "depth", "omit", "link", "package-lock-only", "unicode", ...super.params ];
        async completion(opts) {
          return completion(this.npm, opts);
        }
        async exec(args) {
          const all = this.npm.config.get("all"), color = this.npm.color, depth = this.npm.config.get("depth"), global = this.npm.global, json = this.npm.config.get("json"), link = this.npm.config.get("link"), long = this.npm.config.get("long"), omit = this.npm.flatOptions.omit, parseable = this.npm.config.get("parseable"), unicode = this.npm.config.get("unicode"), packageLockOnly = this.npm.config.get("package-lock-only"), workspacesEnabled = this.npm.flatOptions.workspacesEnabled, path = global ? resolve(this.npm.globalDir, "..") : this.npm.prefix, arb = new Arborist({
            global,
            ...this.npm.flatOptions,
            legacyPeerDeps: !1,
            path
          }), tree = await this.initTree({
            arb,
            args,
            packageLockOnly
          });
          let wsNodes;
          this.workspaceNames && this.workspaceNames.length && (wsNodes = arb.workspaceNodes(tree, this.workspaceNames));
          const filterBySelectedWorkspaces = edge => !(!workspacesEnabled && edge.from.isProjectRoot && edge.to.isWorkspace) && (!wsNodes || !wsNodes.length || (!(!this.npm.flatOptions.includeWorkspaceRoot || !edge.to || edge.to.isWorkspace) || (!edge.from.isProjectRoot || edge.to && edge.to.isWorkspace && wsNodes.includes(edge.to.target)))), seenItems = new Set, seenNodes = new Map, problems = new Set, filterDefaultDepth = null === depth ? 1 / 0 : depth, depthToPrint = all || args.length ? filterDefaultDepth : depth || 0;
          seenNodes.set(tree.path, tree);
          const result = await breadth({
            tree,
            getChildren(node, nodeResult) {
              const seenPaths = new Set, currentDepth = node.isWorkspace ? 0 : node[_depth];
              return !(node instanceof Arborist.Node) || currentDepth > depthToPrint ? [] : [ ...node.target.edgesOut.values() ].filter(filterBySelectedWorkspaces).filter(0 === currentDepth ? filterByEdgesTypes({
                link,
                omit
              }) : () => !0).map(mapEdgesToNodes({
                seenPaths
              })).concat(appendExtraneousChildren({
                node,
                seenPaths
              })).sort(sortAlphabetically).map(augmentNodesWithMetadata({
                args,
                currentDepth,
                nodeResult,
                seenNodes
              }));
            },
            visit(node) {
              node[_problems] = getProblems(node, {
                global
              });
              const item = json ? getJsonOutputItem(node, {
                global,
                long
              }) : parseable ? null : getHumanOutputItem(node, {
                args,
                color,
                global,
                long
              });
              if (node[_include]) for (const problem of node[_problems]) problems.add(problem);
              return seenItems.add(item), Promise.resolve(item);
            }
          }), [rootError] = tree.errors.filter((e => "EJSONPARSE" === e.code && e.path === resolve(path, "package.json")));
          if (this.npm.output(json ? jsonOutput({
            path,
            problems,
            result,
            rootError,
            seenItems
          }) : parseable ? parseableOutput({
            seenNodes,
            global,
            long
          }) : humanOutput({
            color,
            result,
            seenItems,
            unicode
          })), result && !result[_include] && args.length && (process.exitCode = 1), rootError) throw Object.assign(new Error("Failed to parse root package.json"), {
            code: "EJSONPARSE"
          });
          if (problems.size && ![ ...problems ].every((problem => problem.startsWith("extraneous:")))) throw Object.assign(new Error([ ...problems ].join(EOL)), {
            code: "ELSPROBLEMS"
          });
        }
        async initTree({arb, args, packageLockOnly}) {
          const tree = await (packageLockOnly ? arb.loadVirtual() : arb.loadActual());
          return tree[_include] = 0 === args.length, tree[_depth] = 0, tree;
        }
      }
      module.exports = LS;
      const isOptional = node => "optional" === node[_type] || "peerOptional" === node[_type], isExtraneous = (node, {global}) => node.extraneous && !global, getProblems = (node, {global}) => {
        const problems = new Set;
        return node[_missing] && !isOptional(node) && problems.add(`missing: ${node.pkgid}, required by ${node[_missing]}`), 
        node[_invalid] && problems.add(`invalid: ${node.pkgid} ${node.path}`), isExtraneous(node, {
          global
        }) && problems.add(`extraneous: ${node.pkgid} ${node.path}`), problems;
      }, augmentItemWithIncludeMetadata = (node, item) => {
        if (item[_parent] = node[_parent], item[_include] = node[_include], node[_include]) {
          let p = node[_parent];
          for (;p; ) p[_include] = !0, p = p[_parent];
        }
        return item;
      }, getHumanOutputItem = (node, {args, color, global, long}) => {
        const {pkgid, path} = node, workspacePkgId = color ? chalk.green(pkgid) : pkgid;
        let printable = node.isWorkspace ? workspacePkgId : pkgid;
        if (node.isRoot) {
          !Object.keys(node.package).length || global ? printable = path : printable += `${long ? EOL : " "}${path}`;
        }
        const highlightDepName = color && args.length && node[_filteredBy], missingColor = isOptional(node) ? chalk.yellow.bgBlack : chalk.red.bgBlack, missingMsg = `UNMET ${isOptional(node) ? "OPTIONAL " : ""}DEPENDENCY`, targetLocation = node.root ? relative(node.root.realpath, node.realpath) : node.targetLocation, invalid = node[_invalid] ? `invalid: ${node[_invalid]}` : "", label = (node[_missing] ? (color ? missingColor(missingMsg) : missingMsg) + " " : "") + `${highlightDepName ? chalk.yellow.bgBlack(printable) : printable}` + (node[_dedupe] ? " " + (color ? chalk.gray("deduped") : "deduped") : "") + (invalid ? " " + (color ? chalk.red.bgBlack(invalid) : invalid) : "") + (isExtraneous(node, {
          global
        }) ? " " + (color ? chalk.green.bgBlack("extraneous") : "extraneous") : "") + (node.overridden ? " " + (color ? chalk.gray("overridden") : "overridden") : "") + ((node => {
          if (node.resolved) try {
            const {type} = npa(node.resolved);
            return "git" === type || "hosted" === type;
          } catch (err) {
            return !1;
          }
        })(node) ? ` (${node.resolved})` : "") + (node.isLink ? ` -> ${relativePrefix}${targetLocation}` : "") + (long ? `${EOL}${node.package.description || ""}` : "");
        return augmentItemWithIncludeMetadata(node, {
          label,
          nodes: []
        });
      }, getJsonOutputItem = (node, {global, long}) => {
        const item = {};
        node.version && (item.version = node.version), node.resolved && (item.resolved = node.resolved), 
        node.isProjectRoot || (item.overridden = node.overridden), item[_name] = node.name;
        const hasPackageJson = node && node.package && Object.keys(node.package).length;
        if (node.isRoot && hasPackageJson && (item.name = node.package.name || node.name), 
        long && !node[_missing]) {
          item.name = item[_name];
          const {dependencies, ...packageInfo} = node.package;
          Object.assign(item, packageInfo), item.extraneous = !1, item.path = node.path, item._dependencies = {
            ...node.package.dependencies,
            ...node.package.optionalDependencies
          }, item.devDependencies = node.package.devDependencies || {}, item.peerDependencies = node.package.peerDependencies || {};
        }
        return isExtraneous(node, {
          global
        }) && (item.extraneous = !0), node[_invalid] && (item.invalid = node[_invalid]), 
        node[_missing] && !isOptional(node) && (item.required = node[_required], item.missing = !0), 
        node[_include] && node[_problems] && node[_problems].size && (item.problems = [ ...node[_problems] ]), 
        augmentItemWithIncludeMetadata(node, item);
      }, filterByEdgesTypes = ({link, omit = []}) => edge => {
        for (const omitType of omit) if (edge[omitType]) return !1;
        return !link || edge.to && edge.to.isLink;
      }, appendExtraneousChildren = ({node, seenPaths}) => [ ...node.children.values() ].filter((i => !seenPaths.has(i.path) && i.extraneous)), mapEdgesToNodes = ({seenPaths}) => edge => {
        let node = edge.to;
        if (edge.missing || edge.optional && !node) {
          const {name, spec} = edge;
          node = {
            name,
            pkgid: `${name}@${spec}`,
            [_missing]: edge.from.pkgid
          };
        }
        if (node.path && seenPaths.add(node.path), node[_required] = edge.spec || "*", node[_type] = edge.type, 
        edge.invalid) {
          const spec = JSON.stringify(node[_required]), from = edge.from.location || "the root project";
          node[_invalid] = (node[_invalid] ? node[_invalid] + ", " : "") + `${spec} from ${from}`;
        }
        return node;
      }, augmentNodesWithMetadata = ({args, currentDepth, nodeResult, seenNodes}) => node => {
        if (seenNodes.has(node.path)) {
          const {realpath, root} = node, targetLocation = root ? relative(root.realpath, realpath) : node.targetLocation;
          node = {
            name: node.name,
            version: node.version,
            pkgid: node.pkgid,
            package: node.package,
            path: node.path,
            isLink: node.isLink,
            realpath: node.realpath,
            targetLocation,
            [_type]: node[_type],
            [_invalid]: node[_invalid],
            [_missing]: node[_missing],
            [_dedupe]: !node[_missing]
          };
        } else seenNodes.set(node.path, node);
        return node[_parent] = nodeResult, node[_filteredBy] = node[_include] = ((args, {node}) => !(args.length > 0) || args.some((spec => node.satisfies && node.satisfies(spec))))(args, {
          node: seenNodes.get(node.path)
        }), node[_depth] = currentDepth + 1, node;
      }, sortAlphabetically = ({pkgid: a}, {pkgid: b}) => localeCompare(a, b), humanOutput = ({color, result, seenItems, unicode}) => {
        for (const item of seenItems) item[_include] && item[_parent] && item[_parent].nodes.push(item);
        result.nodes.length || (result.nodes = [ "(empty)" ]);
        const archyOutput = archy(result, "", {
          unicode
        });
        return color ? chalk.reset(archyOutput) : archyOutput;
      }, jsonOutput = ({path, problems, result, rootError, seenItems}) => {
        problems.size && (result.problems = [ ...problems ]), rootError && (result.problems = [ ...result.problems || [], `error in ${path}: Failed to parse root package.json` ], 
        result.invalid = !0);
        for (const item of seenItems) item[_include] && item[_parent] && (item[_parent].dependencies || (item[_parent].dependencies = {}), 
        item[_parent].dependencies[item[_name]] = item);
        return JSON.stringify(result, null, 2);
      }, parseableOutput = ({global, long, seenNodes}) => {
        let out = "";
        for (const node of seenNodes.values()) node.path && node[_include] && (out += node.path, 
        long && (out += `:${node.pkgid}`, out += node.path !== node.realpath ? `:${node.realpath}` : "", 
        out += isExtraneous(node, {
          global
        }) ? ":EXTRANEOUS" : "", out += node[_invalid] ? ":INVALID" : "", out += node.overridden ? ":OVERRIDDEN" : ""), 
        out += EOL);
        return out.trim();
      };
    },
    98757: (module, __unused_webpack_exports, __webpack_require__) => {
      const liborg = __webpack_require__(88624), otplease = __webpack_require__(83304), Table = __webpack_require__(27275), BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Manage orgs";
        static name="org";
        static usage=[ "set orgname username [developer | admin | owner]", "rm orgname username", "ls orgname [<username>]" ];
        static params=[ "registry", "otp", "json", "parseable" ];
        static ignoreImplicitWorkspace=!0;
        async completion(opts) {
          const argv = opts.conf.argv.remain;
          if (2 === argv.length) return [ "set", "rm", "ls" ];
          switch (argv[2]) {
           case "ls":
           case "add":
           case "rm":
           case "set":
            return [];

           default:
            throw new Error(argv[2] + " not recognized");
          }
        }
        async exec([cmd, orgname, username, role], cb) {
          return otplease(this.npm, {
            ...this.npm.flatOptions
          }, (opts => {
            switch (cmd) {
             case "add":
             case "set":
              return this.set(orgname, username, role, opts);

             case "rm":
              return this.rm(orgname, username, opts);

             case "ls":
              return this.ls(orgname, username, opts);

             default:
              throw this.usageError();
            }
          }));
        }
        async set(org, user, role, opts) {
          if (role = role || "developer", !org) throw new Error("First argument `orgname` is required.");
          if (!user) throw new Error("Second argument `username` is required.");
          if (![ "owner", "admin", "developer" ].find((x => x === role))) throw new Error("Third argument `role` must be one of `owner`, `admin`, or `developer`, with `developer` being the default value if omitted.");
          const memDeets = await liborg.set(org, user, role, opts);
          return opts.json ? this.npm.output(JSON.stringify(memDeets, null, 2)) : opts.parseable ? (this.npm.output([ "org", "orgsize", "user", "role" ].join("\t")), 
          this.npm.output([ memDeets.org.name, memDeets.org.size, memDeets.user, memDeets.role ].join("\t"))) : this.npm.silent || this.npm.output(`Added ${memDeets.user} as ${memDeets.role} to ${memDeets.org.name}. You now have ${memDeets.org.size} member${1 === memDeets.org.size ? "" : "s"} in this org.`), 
          memDeets;
        }
        async rm(org, user, opts) {
          if (!org) throw new Error("First argument `orgname` is required.");
          if (!user) throw new Error("Second argument `username` is required.");
          await liborg.rm(org, user, opts);
          const roster = await liborg.ls(org, opts);
          user = user.replace(/^[~@]?/, ""), org = org.replace(/^[~@]?/, "");
          const userCount = Object.keys(roster).length;
          opts.json ? this.npm.output(JSON.stringify({
            user,
            org,
            userCount,
            deleted: !0
          })) : opts.parseable ? (this.npm.output([ "user", "org", "userCount", "deleted" ].join("\t")), 
          this.npm.output([ user, org, userCount, !0 ].join("\t"))) : this.npm.silent || this.npm.output(`Successfully removed ${user} from ${org}. You now have ${userCount} member${1 === userCount ? "" : "s"} in this org.`);
        }
        async ls(org, user, opts) {
          if (!org) throw new Error("First argument `orgname` is required.");
          let roster = await liborg.ls(org, opts);
          if (user) {
            const newRoster = {};
            roster[user] && (newRoster[user] = roster[user]), roster = newRoster;
          }
          if (opts.json) this.npm.output(JSON.stringify(roster, null, 2)); else if (opts.parseable) this.npm.output([ "user", "role" ].join("\t")), 
          Object.keys(roster).forEach((user => {
            this.npm.output([ user, roster[user] ].join("\t"));
          })); else if (!this.npm.silent) {
            const table = new Table({
              head: [ "user", "role" ]
            });
            Object.keys(roster).sort().forEach((user => {
              table.push([ user, roster[user] ]);
            })), this.npm.output(table.toString());
          }
        }
      };
    },
    24175: (module, __unused_webpack_exports, __webpack_require__) => {
      const os = __webpack_require__(22037), path = __webpack_require__(71017), pacote = __webpack_require__(86585), table = __webpack_require__(5371), chalk = __webpack_require__(25433), npa = __webpack_require__(19932), pickManifest = __webpack_require__(65732), localeCompare = __webpack_require__(51031)("en"), Arborist = __webpack_require__(22290), ansiTrim = __webpack_require__(82576), ArboristWorkspaceCmd = __webpack_require__(99264);
      module.exports = class extends ArboristWorkspaceCmd {
        static description="Check for outdated packages";
        static name="outdated";
        static usage=[ "[<package-spec> ...]" ];
        static params=[ "all", "json", "long", "parseable", "global", "workspace" ];
        async exec(args) {
          const global = path.resolve(this.npm.globalDir, ".."), where = this.npm.global ? global : this.npm.prefix, arb = new Arborist({
            ...this.npm.flatOptions,
            path: where
          });
          if (this.edges = new Set, this.list = [], this.tree = await arb.loadActual(), this.workspaceNames && this.workspaceNames.length ? this.filterSet = arb.workspaceDependencySet(this.tree, this.workspaceNames, this.npm.flatOptions.includeWorkspaceRoot) : this.npm.flatOptions.workspacesEnabled || (this.filterSet = arb.excludeWorkspacesDependencySet(this.tree)), 
          0 !== args.length) for (let i = 0; i < args.length; i++) {
            const nodes = this.tree.inventory.query("name", args[i]);
            this.getEdges(nodes, "edgesIn");
          } else {
            if (this.npm.config.get("all")) {
              const nodes = this.tree.inventory.values();
              this.getEdges(nodes, "edgesOut");
            }
            this.getEdges();
          }
          await Promise.all(Array.from(this.edges).map((edge => this.getOutdatedInfo(edge))));
          const outdated = this.list.sort(((a, b) => localeCompare(a.name, b.name)));
          if (outdated.length > 0 && (process.exitCode = 1), 0 !== outdated.length || this.npm.config.get("json")) if (this.npm.config.get("json")) this.npm.output(this.makeJSON(outdated)); else if (this.npm.config.get("parseable")) this.npm.output(this.makeParseable(outdated)); else {
            const outList = outdated.map((x => this.makePretty(x))), outHead = [ "Package", "Current", "Wanted", "Latest", "Location", "Depended by" ];
            this.npm.config.get("long") && outHead.push("Package Type", "Homepage");
            const outTable = [ outHead ].concat(outList);
            this.npm.color && (outTable[0] = outTable[0].map((heading => chalk.underline(heading))));
            const tableOpts = {
              align: [ "l", "r", "r", "r", "l" ],
              stringLength: s => ansiTrim(s).length
            };
            this.npm.output(table(outTable, tableOpts));
          }
        }
        getEdges(nodes, type) {
          if (!nodes) return this.getEdgesOut(this.tree), void this.getWorkspacesEdges();
          for (const node of nodes) "edgesOut" === type ? this.getEdgesOut(node) : this.getEdgesIn(node);
        }
        getEdgesIn(node) {
          for (const edge of node.edgesIn) this.trackEdge(edge);
        }
        getEdgesOut(node) {
          if (this.npm.global) for (const child of node.children.values()) this.trackEdge(child); else for (const edge of node.edgesOut.values()) this.trackEdge(edge);
        }
        trackEdge(edge) {
          edge.from && this.filterSet && this.filterSet.size > 0 && !this.filterSet.has(edge.from.target) || this.edges.add(edge);
        }
        getWorkspacesEdges(node) {
          if (!this.npm.global) for (const edge of this.tree.edgesOut.values()) {
            edge && edge.to && edge.to.target && edge.to.target.isWorkspace && this.getEdgesOut(edge.to.target);
          }
        }
        async getPackument(spec) {
          return await pacote.packument(spec, {
            ...this.npm.flatOptions,
            fullMetadata: this.npm.config.get("long"),
            preferOnline: !0
          });
        }
        async getOutdatedInfo(edge) {
          let alias = !1;
          try {
            alias = npa(edge.spec).subSpec;
          } catch (err) {}
          const spec = npa(alias ? alias.name : edge.name), node = edge.to || edge, {path, location} = node, {version: current} = node.package || {}, type = edge.optional ? "optionalDependencies" : edge.peer ? "peerDependencies" : edge.dev ? "devDependencies" : "dependencies";
          for (const omitType of this.npm.flatOptions.omit) if (node[omitType]) return;
          if ("MISSING" !== edge.error || "dependencies" === type) try {
            const packument = await this.getPackument(spec), expected = alias ? alias.fetchSpec : edge.spec;
            try {
              if (!npa(`${edge.name}@${edge.spec}`).registry) return null;
            } catch (err) {
              return null;
            }
            const wanted = pickManifest(packument, expected, this.npm.flatOptions), latest = pickManifest(packument, "*", this.npm.flatOptions);
            if (!current || current !== wanted.version || wanted.version !== latest.version) {
              const dependent = edge.from ? this.maybeWorkspaceName(edge.from) : "global";
              this.list.push({
                name: alias ? edge.spec.replace("npm", edge.name) : edge.name,
                path,
                type,
                current,
                location,
                wanted: wanted.version,
                latest: latest.version,
                dependent,
                homepage: packument.homepage
              });
            }
          } catch (err) {
            if ("ETARGET" !== err.code && "E403" !== err.code && "E404" !== err.code) throw err;
          }
        }
        maybeWorkspaceName(node) {
          if (!node.isWorkspace) return node.name;
          const humanOutput = !this.npm.config.get("json") && !this.npm.config.get("parseable"), workspaceName = humanOutput ? node.pkgid : node.name;
          return this.npm.color && humanOutput ? chalk.green(workspaceName) : workspaceName;
        }
        makePretty(dep) {
          const {current = "MISSING", location = "-", homepage = "", name, wanted, latest, type, dependent} = dep, columns = [ name, current, wanted, latest, location, dependent ];
          return this.npm.config.get("long") && (columns[6] = type, columns[7] = homepage), 
          this.npm.color && (columns[0] = chalk[current === wanted ? "yellow" : "red"](columns[0]), 
          columns[2] = chalk.green(columns[2]), columns[3] = chalk.magenta(columns[3])), columns;
        }
        makeParseable(list) {
          return list.map((dep => {
            const {name, current, wanted, latest, path, dependent, type, homepage} = dep, out = [ path, name + "@" + wanted, current ? name + "@" + current : "MISSING", name + "@" + latest, dependent ];
            return this.npm.config.get("long") && out.push(type, homepage), out.join(":");
          })).join(os.EOL);
        }
        makeJSON(list) {
          const out = {};
          return list.forEach((dep => {
            const {name, current, wanted, latest, path, type, dependent, homepage} = dep;
            out[name] = {
              current,
              wanted,
              latest,
              dependent,
              location: path
            }, this.npm.config.get("long") && (out[name].type = type, out[name].homepage = homepage);
          })), JSON.stringify(out, null, 2);
        }
      };
    },
    82189: (module, __unused_webpack_exports, __webpack_require__) => {
      const npa = __webpack_require__(19932), npmFetch = __webpack_require__(92427), pacote = __webpack_require__(86585), log = __webpack_require__(86883), otplease = __webpack_require__(83304), readPackageJsonFast = __webpack_require__(1759), BaseCommand = __webpack_require__(26727), {resolve} = __webpack_require__(71017), readJson = async pkg => {
        try {
          return await readPackageJsonFast(pkg);
        } catch {
          return {};
        }
      };
      module.exports = class extends BaseCommand {
        static description="Manage package owners";
        static name="owner";
        static params=[ "registry", "otp", "workspace", "workspaces" ];
        static usage=[ "add <user> <package-spec>", "rm <user> <package-spec>", "ls <package-spec>" ];
        static ignoreImplicitWorkspace=!1;
        async completion(opts) {
          const argv = opts.conf.argv.remain;
          if (argv.length > 3) return [];
          if ("owner" !== argv[1] && argv.unshift("owner"), 2 === argv.length) return [ "add", "rm", "ls" ];
          if ("rm" === argv[2]) {
            if (this.npm.global) return [];
            const {name} = await readJson(resolve(this.npm.prefix, "package.json"));
            if (!name) return [];
            const spec = npa(name), data = await pacote.packument(spec, {
              ...this.npm.flatOptions,
              fullMetadata: !0
            });
            if (data && data.maintainers && data.maintainers.length) return data.maintainers.map((m => m.name));
          }
          return [];
        }
        async exec([action, ...args]) {
          if ("ls" === action || "list" === action) await this.ls(args[0]); else if ("add" === action) await this.changeOwners(args[0], args[1], "add"); else {
            if ("rm" !== action && "remove" !== action) throw this.usageError();
            await this.changeOwners(args[0], args[1], "rm");
          }
        }
        async execWorkspaces([action, ...args], filters) {
          if (await this.setWorkspaces(filters), "ls" === action && args.length > 0 || args.length > 1) {
            return 0 === this.npm.config.get("workspace", "default").length && log.warn("Ignoring specified workspace(s)"), 
            this.exec([ action, ...args ]);
          }
          for (const [name] of this.workspaces) if ("ls" === action || "list" === action) await this.ls(name); else if ("add" === action) await this.changeOwners(args[0], name, "add"); else {
            if ("rm" !== action && "remove" !== action) throw this.usageError();
            await this.changeOwners(args[0], name, "rm");
          }
        }
        async ls(pkg) {
          pkg = await this.getPkg(this.npm.prefix, pkg);
          const spec = npa(pkg);
          try {
            const packumentOpts = {
              ...this.npm.flatOptions,
              fullMetadata: !0,
              preferOnline: !0
            }, {maintainers} = await pacote.packument(spec, packumentOpts);
            maintainers && maintainers.length ? this.npm.output(maintainers.map((m => `${m.name} <${m.email}>`)).join("\n")) : this.npm.output("no admin found");
          } catch (err) {
            throw log.error("owner ls", "Couldn't get owner data", pkg), err;
          }
        }
        async getPkg(prefix, pkg) {
          if (!pkg) {
            if (this.npm.global) throw this.usageError();
            const {name} = await readJson(resolve(prefix, "package.json"));
            if (!name) throw this.usageError();
            return name;
          }
          return pkg;
        }
        async changeOwners(user, pkg, addOrRm) {
          if (!user) throw this.usageError();
          pkg = await this.getPkg(this.npm.prefix, pkg), log.verbose(`owner ${addOrRm}`, "%s to %s", user, pkg);
          const spec = npa(pkg), uri = `/-/user/org.couchdb.user:${encodeURIComponent(user)}`;
          let u;
          try {
            u = await npmFetch.json(uri, this.npm.flatOptions);
          } catch (err) {
            throw log.error("owner mutate", `Error getting user data for ${user}`), err;
          }
          u = {
            name: u.name,
            email: u.email
          };
          const data = await pacote.packument(spec, {
            ...this.npm.flatOptions,
            fullMetadata: !0,
            preferOnline: !0
          }), owners = data.maintainers || [];
          let maintainers;
          if ("add" === addOrRm) {
            const existing = owners.find((o => o.name === u.name));
            if (existing) return void log.info("owner add", `Already a package owner: ${existing.name} <${existing.email}>`);
            maintainers = [ ...owners, u ];
          } else {
            if (maintainers = owners.filter((o => o.name !== u.name)), maintainers.length === owners.length) return log.info("owner rm", "Not a package owner: " + u.name), 
            !1;
            if (!maintainers.length) throw Object.assign(new Error("Cannot remove all owners of a package. Add someone else first."), {
              code: "EOWNERRM"
            });
          }
          const dataPath = `/${spec.escapedName}/-rev/${encodeURIComponent(data._rev)}`;
          try {
            const res = await otplease(this.npm, this.npm.flatOptions, (opts => npmFetch.json(dataPath, {
              ...opts,
              method: "PUT",
              body: {
                _id: data._id,
                _rev: data._rev,
                maintainers
              },
              spec
            })));
            return "add" === addOrRm ? this.npm.output(`+ ${user} (${spec.name})`) : this.npm.output(`- ${user} (${spec.name})`), 
            res;
          } catch (err) {
            throw Object.assign(new Error("Failed to update package: " + JSON.stringify(err.message)), {
              code: "EOWNERMUTATE"
            });
          }
        }
      };
    },
    30266: (module, __unused_webpack_exports, __webpack_require__) => {
      const pacote = __webpack_require__(86585), libpack = __webpack_require__(67647), npa = __webpack_require__(19932), log = __webpack_require__(86883), {getContents, logTar} = __webpack_require__(31988), BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Create a tarball from a package";
        static name="pack";
        static params=[ "dry-run", "json", "pack-destination", "workspace", "workspaces", "include-workspace-root" ];
        static usage=[ "<package-spec>" ];
        static ignoreImplicitWorkspace=!1;
        async exec(args) {
          0 === args.length && (args = [ "." ]);
          const unicode = this.npm.config.get("unicode"), json = this.npm.config.get("json"), manifests = [];
          for (const arg of args) {
            const spec = npa(arg), manifest = await pacote.manifest(spec, this.npm.flatOptions);
            if (!manifest._id) throw new Error("Invalid package, must have name and version");
            manifests.push({
              arg,
              manifest
            });
          }
          const tarballs = [];
          for (const {arg, manifest} of manifests) {
            const tarballData = await libpack(arg, {
              ...this.npm.flatOptions,
              prefix: this.npm.localPrefix,
              workspaces: this.workspacePaths
            }), pkgContents = await getContents(manifest, tarballData);
            tarballs.push(pkgContents);
          }
          if (json) this.npm.output(JSON.stringify(tarballs, null, 2)); else for (const tar of tarballs) logTar(tar, {
            unicode
          }), this.npm.output(tar.filename.replace(/^@/, "").replace(/\//, "-"));
        }
        async execWorkspaces(args, filters) {
          return 0 === args.length || args.includes(".") ? (await this.setWorkspaces(filters), 
          this.exec([ ...this.workspacePaths, ...args.filter((a => "." !== a)) ])) : (log.warn("Ignoring workspaces for specified package(s)"), 
          this.exec(args));
        }
      };
    },
    5922: (module, __unused_webpack_exports, __webpack_require__) => {
      const log = __webpack_require__(86883), pingUtil = __webpack_require__(24087), BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Ping npm registry";
        static params=[ "registry" ];
        static name="ping";
        static ignoreImplicitWorkspace=!0;
        async exec(args) {
          log.notice("PING", this.npm.config.get("registry"));
          const start = Date.now(), details = await pingUtil({
            ...this.npm.flatOptions
          }), time = Date.now() - start;
          log.notice("PONG", `${time}ms`), this.npm.config.get("json") ? this.npm.output(JSON.stringify({
            registry: this.npm.config.get("registry"),
            time,
            details
          }, null, 2)) : Object.keys(details).length && log.notice("PONG", `${JSON.stringify(details, null, 2)}`);
        }
      };
    },
    9785: (module, __unused_webpack_exports, __webpack_require__) => {
      const PackageJson = __webpack_require__(66096), BaseCommand = __webpack_require__(26727), Queryable = __webpack_require__(58113);
      module.exports = class extends BaseCommand {
        static description="Manages your package.json";
        static name="pkg";
        static usage=[ "set <key>=<value> [<key>=<value> ...]", "get [<key> [<key> ...]]", "delete <key> [<key> ...]", "set [<array>[<index>].<key>=<value> ...]", "set [<array>[].<key>=<value> ...]" ];
        static params=[ "force", "json", "workspace", "workspaces" ];
        static ignoreImplicitWorkspace=!1;
        async exec(args, {prefix} = {}) {
          if (this.prefix = prefix || this.npm.localPrefix, this.npm.global) throw Object.assign(new Error("There's no package.json file to manage on global mode"), {
            code: "EPKGGLOBAL"
          });
          const [cmd, ..._args] = args;
          switch (cmd) {
           case "get":
            return this.get(_args);

           case "set":
            return this.set(_args);

           case "delete":
            return this.delete(_args);

           default:
            throw this.usageError();
          }
        }
        async execWorkspaces(args, filters) {
          await this.setWorkspaces(filters);
          const result = {};
          for (const [workspaceName, workspacePath] of this.workspaces.entries()) this.prefix = workspacePath, 
          result[workspaceName] = await this.exec(args, {
            prefix: workspacePath
          });
          this.npm.output(JSON.stringify(result, null, 2));
        }
        async get(args) {
          const pkgJson = await PackageJson.load(this.prefix), {content} = pkgJson;
          let result = !args.length && content;
          if (!result) {
            result = new Queryable(content).query(args), 1 === Object.keys(result).length && (result = result[args]);
          }
          return this.workspaces || this.npm.output(JSON.stringify(result, null, 2)), result;
        }
        async set(args) {
          const setError = () => this.usageError("npm pkg set expects a key=value pair of args.");
          if (!args.length) throw setError();
          const force = this.npm.config.get("force"), json = this.npm.config.get("json"), pkgJson = await PackageJson.load(this.prefix), q = new Queryable(pkgJson.content);
          for (const arg of args) {
            const [key, ...rest] = arg.split("="), value = rest.join("=");
            if (!key || !value) throw setError();
            q.set(key, json ? JSON.parse(value) : value, {
              force
            });
          }
          pkgJson.update(q.toJSON()), await pkgJson.save();
        }
        async delete(args) {
          const setError = () => this.usageError("npm pkg delete expects key args.");
          if (!args.length) throw setError();
          const pkgJson = await PackageJson.load(this.prefix), q = new Queryable(pkgJson.content);
          for (const key of args) {
            if (!key) throw setError();
            q.delete(key);
          }
          pkgJson.update(q.toJSON()), await pkgJson.save();
        }
      };
    },
    77662: (module, __unused_webpack_exports, __webpack_require__) => {
      const BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Display prefix";
        static name="prefix";
        static params=[ "global" ];
        static usage=[ "[-g]" ];
        static ignoreImplicitWorkspace=!0;
        async exec(args) {
          return this.npm.output(this.npm.prefix);
        }
      };
    },
    47099: (module, __unused_webpack_exports, __webpack_require__) => {
      const inspect = __webpack_require__(73837).inspect, {URL} = __webpack_require__(57310), chalk = __webpack_require__(25433), log = __webpack_require__(86883), npmProfile = __webpack_require__(77969), qrcodeTerminal = __webpack_require__(50860), Table = __webpack_require__(27275), otplease = __webpack_require__(83304), pulseTillDone = __webpack_require__(26549), readUserInfo = __webpack_require__(87121), knownProfileKeys = [ "name", "email", "two-factor auth", "fullname", "homepage", "freenode", "twitter", "github", "created", "updated" ], writableProfileKeys = [ "email", "password", "fullname", "homepage", "freenode", "twitter", "github" ], BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Change settings on your registry profile";
        static name="profile";
        static usage=[ "enable-2fa [auth-only|auth-and-writes]", "disable-2fa", "get [<key>]", "set <key> <value>" ];
        static params=[ "registry", "json", "parseable", "otp" ];
        static ignoreImplicitWorkspace=!0;
        async completion(opts) {
          var argv = opts.conf.argv.remain;
          if (!argv[2]) return [ "enable-2fa", "disable-2fa", "get", "set" ];
          switch (argv[2]) {
           case "enable-2fa":
           case "enable-tfa":
            return [ "auth-and-writes", "auth-only" ];

           case "disable-2fa":
           case "disable-tfa":
           case "get":
           case "set":
            return [];

           default:
            throw new Error(argv[2] + " not recognized");
          }
        }
        async exec(args) {
          if (0 === args.length) throw this.usageError();
          log.gauge.show("profile");
          const [subcmd, ...opts] = args;
          switch (subcmd) {
           case "enable-2fa":
           case "enable-tfa":
           case "enable2fa":
           case "enabletfa":
            return this.enable2fa(opts);

           case "disable-2fa":
           case "disable-tfa":
           case "disable2fa":
           case "disabletfa":
            return this.disable2fa();

           case "get":
            return this.get(opts);

           case "set":
            return this.set(opts);

           default:
            throw new Error("Unknown profile command: " + subcmd);
          }
        }
        async get(args) {
          const tfa = "two-factor auth", info = await pulseTillDone.withPromise(npmProfile.get({
            ...this.npm.flatOptions
          }));
          if (info.cidr_whitelist || delete info.cidr_whitelist, this.npm.config.get("json")) return void this.npm.output(JSON.stringify(info, null, 2));
          const cleaned = {};
          for (const key of knownProfileKeys) cleaned[key] = info[key] || "";
          const unknownProfileKeys = Object.keys(info).filter((k => !(k in cleaned)));
          for (const key of unknownProfileKeys) cleaned[key] = info[key] || "";
          if (delete cleaned.tfa, delete cleaned.email_verified, cleaned.email += info.email_verified ? " (verified)" : "(unverified)", 
          info.tfa && !info.tfa.pending ? cleaned[tfa] = info.tfa.mode : cleaned[tfa] = "disabled", 
          args.length) {
            const values = args.join(",").split(/,/).filter((arg => "" !== arg.trim())).map((arg => cleaned[arg])).join("\t");
            this.npm.output(values);
          } else if (this.npm.config.get("parseable")) for (const key of Object.keys(info)) "tfa" === key ? this.npm.output(`${key}\t${cleaned[tfa]}`) : this.npm.output(`${key}\t${info[key]}`); else {
            const table = new Table;
            for (const key of Object.keys(cleaned)) table.push({
              [chalk.bold(key)]: cleaned[key]
            });
            this.npm.output(table.toString());
          }
        }
        async set(args) {
          const conf = {
            ...this.npm.flatOptions
          }, prop = (args[0] || "").toLowerCase().trim();
          let value = args.length > 1 ? args.slice(1).join(" ") : null;
          const readPasswords = async () => {
            const newpassword = await readUserInfo.password("New password: ");
            return newpassword !== await readUserInfo.password("       Again:     ") ? (log.warn("profile", "Passwords do not match, please try again."), 
            readPasswords()) : newpassword;
          };
          if ("password" !== prop && null === value) throw new Error("npm profile set <prop> <value>");
          if ("password" === prop && null !== value) throw new Error("npm profile set password\nDo not include your current or new passwords on the command line.");
          if (-1 === writableProfileKeys.indexOf(prop)) throw new Error(`"${prop}" is not a property we can set. Valid properties are: ` + writableProfileKeys.join(", "));
          if ("password" === prop) {
            value = {
              old: await readUserInfo.password("Current password: "),
              new: await readPasswords()
            };
          }
          const user = await pulseTillDone.withPromise(npmProfile.get(conf)), newUser = {};
          for (const key of writableProfileKeys) newUser[key] = user[key];
          newUser[prop] = value;
          const result = await otplease(this.npm, conf, (conf => npmProfile.set(newUser, conf)));
          this.npm.config.get("json") ? this.npm.output(JSON.stringify({
            [prop]: result[prop]
          }, null, 2)) : this.npm.config.get("parseable") ? this.npm.output(prop + "\t" + result[prop]) : null != result[prop] ? this.npm.output("Set", prop, "to", result[prop]) : this.npm.output("Set", prop);
        }
        async enable2fa(args) {
          if (args.length > 1) throw new Error("npm profile enable-2fa [auth-and-writes|auth-only]");
          const mode = args[0] || "auth-and-writes";
          if ("auth-only" !== mode && "auth-and-writes" !== mode) throw new Error(`Invalid two-factor authentication mode "${mode}".\nValid modes are:\n  auth-only - Require two-factor authentication only when logging in\n  auth-and-writes - Require two-factor authentication when logging in AND when publishing`);
          if (this.npm.config.get("json") || this.npm.config.get("parseable")) throw new Error("Enabling two-factor authentication is an interactive operation and " + (this.npm.config.get("json") ? "JSON" : "parseable") + " output mode is not available");
          const info = {
            tfa: {
              mode
            }
          }, creds = this.npm.config.getCredentialsByURI(this.npm.config.get("registry")), auth = {};
          if (creds.token) auth.token = creds.token; else if (creds.username) auth.basic = {
            username: creds.username,
            password: creds.password
          }; else if (creds.auth) {
            const basic = Buffer.from(creds.auth, "base64").toString().split(":", 2);
            auth.basic = {
              username: basic[0],
              password: basic[1]
            };
          }
          if (!auth.basic && !auth.token) throw new Error(`You need to be logged in to registry ${this.npm.config.get("registry")} in order to enable 2fa`);
          if (auth.basic) {
            log.info("profile", "Updating authentication to bearer token");
            const result = await npmProfile.createToken(auth.basic.password, !1, [], {
              ...this.npm.flatOptions
            });
            if (!result.token) throw new Error(`Your registry ${this.npm.config.get("registry")} does not seem to support bearer tokens. Bearer tokens are required for two-factor authentication`);
            this.npm.config.setCredentialsByURI(this.npm.config.get("registry"), {
              token: result.token
            }), await this.npm.config.save("user");
          }
          log.notice("profile", "Enabling two factor authentication for " + mode);
          const password = await readUserInfo.password();
          info.tfa.password = password, log.info("profile", "Determine if tfa is pending");
          const userInfo = await pulseTillDone.withPromise(npmProfile.get({
            ...this.npm.flatOptions
          })), conf = {
            ...this.npm.flatOptions
          };
          userInfo && userInfo.tfa && userInfo.tfa.pending ? (log.info("profile", "Resetting two-factor authentication"), 
          await pulseTillDone.withPromise(npmProfile.set({
            tfa: {
              password,
              mode: "disable"
            }
          }, conf))) : userInfo && userInfo.tfa && (conf.otp || (conf.otp = await readUserInfo.otp("Enter one-time password: "))), 
          log.info("profile", "Setting two-factor authentication to " + mode);
          const challenge = await pulseTillDone.withPromise(npmProfile.set(info, conf));
          if (null === challenge.tfa) return void this.npm.output("Two factor authentication mode changed to: " + mode);
          if ("string" != typeof challenge.tfa || !/^otpauth:[/][/]/.test(challenge.tfa)) throw new Error("Unknown error enabling two-factor authentication. Expected otpauth URL, got: " + inspect(challenge.tfa));
          const secret = new URL(challenge.tfa).searchParams.get("secret"), code = await (url = challenge.tfa, 
          new Promise((resolve => qrcodeTerminal.generate(url, resolve))));
          var url;
          this.npm.output("Scan into your authenticator app:\n" + code + "\n Or enter code:", secret);
          const interactiveOTP = await readUserInfo.otp("And an OTP code from your authenticator: ");
          log.info("profile", "Finalizing two-factor authentication");
          const result = await npmProfile.set({
            tfa: [ interactiveOTP ]
          }, conf);
          this.npm.output("2FA successfully enabled. Below are your recovery codes, please print these out."), 
          this.npm.output("You will need these to recover access to your account if you lose your authentication device.");
          for (const tfaCode of result.tfa) this.npm.output("\t" + tfaCode);
        }
        async disable2fa(args) {
          const conf = {
            ...this.npm.flatOptions
          }, info = await pulseTillDone.withPromise(npmProfile.get(conf));
          if (!info.tfa || info.tfa.pending) return void this.npm.output("Two factor authentication not enabled.");
          const password = await readUserInfo.password();
          if (!conf.otp) {
            const msg = "Enter one-time password: ";
            conf.otp = await readUserInfo.otp(msg);
          }
          log.info("profile", "disabling tfa"), await pulseTillDone.withPromise(npmProfile.set({
            tfa: {
              password,
              mode: "disable"
            }
          }, conf)), this.npm.config.get("json") ? this.npm.output(JSON.stringify({
            tfa: !1
          }, null, 2)) : this.npm.config.get("parseable") ? this.npm.output("tfa\tfalse") : this.npm.output("Two factor authentication disabled.");
        }
      };
    },
    20649: (module, __unused_webpack_exports, __webpack_require__) => {
      const Arborist = __webpack_require__(22290), reifyFinish = __webpack_require__(2648), ArboristWorkspaceCmd = __webpack_require__(99264);
      class Prune extends ArboristWorkspaceCmd {
        static description="Remove extraneous packages";
        static name="prune";
        static params=[ "omit", "dry-run", "json", "foreground-scripts", "ignore-scripts", ...super.params ];
        static usage=[ "[[<@scope>/]<pkg>...]" ];
        async exec() {
          const where = this.npm.prefix, opts = {
            ...this.npm.flatOptions,
            path: where,
            workspaces: this.workspaceNames
          }, arb = new Arborist(opts);
          await arb.prune(opts), await reifyFinish(this.npm, arb);
        }
      }
      module.exports = Prune;
    },
    58759: (module, __unused_webpack_exports, __webpack_require__) => {
      const util = __webpack_require__(73837), log = __webpack_require__(86883), semver = __webpack_require__(5870), pack = __webpack_require__(67647), libpub = __webpack_require__(76919).publish, runScript = __webpack_require__(63036), pacote = __webpack_require__(86585), npa = __webpack_require__(19932), npmFetch = __webpack_require__(92427), replaceInfo = __webpack_require__(45042), otplease = __webpack_require__(83304), {getContents, logTar} = __webpack_require__(31988), {flatten} = __webpack_require__(70506), readJson = util.promisify(__webpack_require__(62965)), BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Publish a package";
        static name="publish";
        static params=[ "tag", "access", "dry-run", "otp", "workspace", "workspaces", "include-workspace-root" ];
        static usage=[ "<package-spec>" ];
        static ignoreImplicitWorkspace=!1;
        async exec(args) {
          if (0 === args.length && (args = [ "." ]), 1 !== args.length) throw this.usageError();
          log.verbose("publish", replaceInfo(args));
          const unicode = this.npm.config.get("unicode"), dryRun = this.npm.config.get("dry-run"), json = this.npm.config.get("json"), defaultTag = this.npm.config.get("tag"), ignoreScripts = this.npm.config.get("ignore-scripts"), {silent} = this.npm;
          if (semver.validRange(defaultTag)) throw new Error("Tag name must not be a valid SemVer range: " + defaultTag.trim());
          const opts = {
            ...this.npm.flatOptions,
            progress: !1
          };
          log.disableProgress();
          const spec = npa(args[0]);
          let manifest = await this.getManifest(spec, opts);
          "directory" !== spec.type || ignoreScripts || await runScript({
            event: "prepublishOnly",
            path: spec.fetchSpec,
            stdio: "inherit",
            pkg: manifest,
            banner: !silent
          });
          const tarballData = await pack(spec, {
            ...opts,
            dryRun: !0,
            prefix: this.npm.localPrefix,
            workspaces: this.workspacePaths
          }), pkgContents = await getContents(manifest, tarballData);
          manifest = await this.getManifest(spec, opts), json || logTar(pkgContents, {
            unicode
          });
          const resolved = npa.resolve(manifest.name, manifest.version), registry = npmFetch.pickRegistry(resolved, opts), creds = this.npm.config.getCredentialsByURI(registry), noCreds = !(creds.token || creds.username || creds.certfile && creds.keyfile), outputRegistry = replaceInfo(registry);
          if (noCreds) {
            const msg = `This command requires you to be logged in to ${outputRegistry}`;
            if (!dryRun) throw Object.assign(new Error(msg), {
              code: "ENEEDAUTH"
            });
            log.warn("", `${msg} (dry-run)`);
          }
          return log.notice("", `Publishing to ${outputRegistry}${dryRun ? " (dry-run)" : ""}`), 
          dryRun || await otplease(this.npm, opts, (opts => libpub(manifest, tarballData, opts))), 
          "directory" !== spec.type || ignoreScripts || (await runScript({
            event: "publish",
            path: spec.fetchSpec,
            stdio: "inherit",
            pkg: manifest,
            banner: !silent
          }), await runScript({
            event: "postpublish",
            path: spec.fetchSpec,
            stdio: "inherit",
            pkg: manifest,
            banner: !silent
          })), this.suppressOutput || (!silent && json ? this.npm.output(JSON.stringify(pkgContents, null, 2)) : silent || this.npm.output(`+ ${pkgContents.id}`)), 
          pkgContents;
        }
        async execWorkspaces(args, filters) {
          this.suppressOutput = !0;
          const results = {}, json = this.npm.config.get("json"), {silent} = this.npm;
          await this.setWorkspaces(filters);
          for (const [name, workspace] of this.workspaces.entries()) {
            let pkgContents;
            try {
              pkgContents = await this.exec([ workspace ]);
            } catch (err) {
              if ("EPRIVATE" === err.code) {
                log.warn("publish", `Skipping workspace ${this.npm.chalk.green(name)}, marked as ${this.npm.chalk.bold("private")}`);
                continue;
              }
              throw err;
            }
            silent || json ? results[name] = pkgContents : this.npm.output(`+ ${pkgContents.id}`);
          }
          !silent && json && this.npm.output(JSON.stringify(results, null, 2));
        }
        async getManifest(spec, opts) {
          let manifest;
          return manifest = "directory" === spec.type ? await readJson(`${spec.fetchSpec}/package.json`) : await pacote.manifest(spec, {
            ...opts,
            fullmetadata: !0,
            fullReadJson: !0
          }), manifest.publishConfig && flatten(manifest.publishConfig, opts), manifest;
        }
      };
    },
    46080: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const {resolve} = __webpack_require__(71017), Arborist = __webpack_require__(22290), BaseCommand = __webpack_require__(26727);
      class QuerySelectorItem {
        constructor(node) {
          Object.assign(this, node.target.package), this.pkgid = node.target.pkgid, this.location = node.target.location, 
          this.path = node.target.path, this.realpath = node.target.realpath, this.resolved = node.target.resolved, 
          this.from = [], this.to = [], this.dev = node.target.dev, this.inBundle = node.target.inBundle, 
          this.deduped = this.from.length > 1, this.overridden = node.overridden;
          for (const edge of node.target.edgesIn) this.from.push(edge.from.location);
          for (const [, edge] of node.target.edgesOut) edge.to && this.to.push(edge.to.location);
        }
      }
      module.exports = class extends BaseCommand {
        #response=[];
        #seen=new Set;
        static description="Retrieve a filtered list of packages";
        static name="query";
        static usage=[ "<selector>" ];
        static ignoreImplicitWorkspace=!1;
        static params=[ "global", "workspace", "workspaces", "include-workspace-root" ];
        get parsedResponse() {
          return JSON.stringify(this.#response, null, 2);
        }
        async exec(args) {
          const where = resolve(this.npm.dir, ".."), opts = {
            ...this.npm.flatOptions,
            path: where,
            forceActual: !0
          }, arb = new Arborist(opts), tree = await arb.loadActual(opts), items = await tree.querySelectorAll(args[0]);
          this.buildResponse(items), this.npm.output(this.parsedResponse);
        }
        async execWorkspaces(args, filters) {
          await this.setWorkspaces(filters);
          const opts = {
            ...this.npm.flatOptions,
            path: this.npm.prefix
          }, arb = new Arborist(opts), tree = await arb.loadActual(opts);
          for (const workspacePath of this.workspacePaths) {
            let items;
            if (workspacePath === tree.root.path) items = await tree.querySelectorAll(args[0]); else {
              const [workspace] = await tree.querySelectorAll(`.workspace:path(${workspacePath})`);
              items = await workspace.target.querySelectorAll(args[0]);
            }
            this.buildResponse(items);
          }
          this.npm.output(this.parsedResponse);
        }
        buildResponse(items) {
          for (const node of items) if (!this.#seen.has(node.target.location)) {
            const item = new QuerySelectorItem(node);
            this.#response.push(item), this.#seen.add(item.location);
          }
        }
      };
    },
    7618: (module, __unused_webpack_exports, __webpack_require__) => {
      const {resolve} = __webpack_require__(71017), Arborist = __webpack_require__(22290), npa = __webpack_require__(19932), semver = __webpack_require__(5870), completion = __webpack_require__(46624), ArboristWorkspaceCmd = __webpack_require__(99264);
      class Rebuild extends ArboristWorkspaceCmd {
        static description="Rebuild a package";
        static name="rebuild";
        static params=[ "global", "bin-links", "foreground-scripts", "ignore-scripts", ...super.params ];
        static usage=[ "[<package-spec>] ...]" ];
        async completion(opts) {
          return completion(this.npm, opts);
        }
        async exec(args) {
          const globalTop = resolve(this.npm.globalDir, ".."), where = this.npm.global ? globalTop : this.npm.prefix, arb = new Arborist({
            ...this.npm.flatOptions,
            path: where
          });
          if (args.length) {
            const tree = await arb.loadActual(), specs = args.map((arg => {
              const spec = npa(arg);
              if ("tag" === spec.type && "" === spec.rawSpec) return spec;
              if ("range" !== spec.type && "version" !== spec.type && "directory" !== spec.type) throw new Error("`npm rebuild` only supports SemVer version/range specifiers");
              return spec;
            })), nodes = tree.inventory.filter((node => this.isNode(specs, node)));
            await arb.rebuild({
              nodes
            });
          } else await arb.rebuild();
          this.npm.output("rebuilt dependencies successfully");
        }
        isNode(specs, node) {
          return specs.some((spec => {
            if ("directory" === spec.type) return node.path === spec.fetchSpec;
            if (spec.name !== node.name) return !1;
            if ("" === spec.rawSpec || "*" === spec.rawSpec) return !0;
            const {version} = node.package;
            return semver.satisfies(version, spec.fetchSpec);
          }));
        }
      }
      module.exports = Rebuild;
    },
    44448: (module, __unused_webpack_exports, __webpack_require__) => {
      const {URL} = __webpack_require__(57310), PackageUrlCmd = __webpack_require__(40064);
      module.exports = class extends PackageUrlCmd {
        static description="Open package repository page in the browser";
        static name="repo";
        getUrl(spec, mani) {
          const r = mani.repository, rurl = r ? "string" == typeof r ? r : "object" == typeof r && "string" == typeof r.url ? r.url : null : null;
          if (!rurl) throw Object.assign(new Error("no repository"), {
            pkgid: spec
          });
          const info = this.hostedFromMani(mani), url = info ? info.browse(mani.repository.directory) : unknownHostedUrl(rurl);
          if (!url) throw Object.assign(new Error("no repository: could not get url"), {
            pkgid: spec
          });
          return url;
        }
      };
      const unknownHostedUrl = url => {
        try {
          const {protocol, hostname, pathname} = new URL(url);
          if (!protocol || !hostname) return null;
          const proto = /(git\+)http:$/.test(protocol) ? "http:" : "https:";
          return `${proto}//${hostname}${pathname.replace(/\.git$/, "")}`;
        } catch (e) {
          return null;
        }
      };
    },
    61612: (module, __unused_webpack_exports, __webpack_require__) => {
      const LifecycleCmd = __webpack_require__(46117);
      module.exports = class extends LifecycleCmd {
        static description="Restart a package";
        static name="restart";
        static params=[ "ignore-scripts", "script-shell" ];
        static ignoreImplicitWorkspace=!1;
      };
    },
    31270: (module, __unused_webpack_exports, __webpack_require__) => {
      const BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Display npm root";
        static name="root";
        static params=[ "global" ];
        static ignoreImplicitWorkspace=!0;
        async exec() {
          this.npm.output(this.npm.dir);
        }
      };
    },
    43889: (module, __unused_webpack_exports, __webpack_require__) => {
      const {resolve} = __webpack_require__(71017), chalk = __webpack_require__(25433), runScript = __webpack_require__(63036), {isServerPackage} = runScript, rpj = __webpack_require__(1759), log = __webpack_require__(86883), didYouMean = __webpack_require__(90594), {isWindowsShell} = __webpack_require__(52290), cmdList = [ "publish", "install", "uninstall", "test", "stop", "start", "restart", "version" ].reduce(((l, p) => l.concat([ "pre" + p, p, "post" + p ])), []), nocolor = {
        reset: s => s,
        bold: s => s,
        dim: s => s,
        blue: s => s,
        green: s => s
      }, BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Run arbitrary package scripts";
        static params=[ "workspace", "workspaces", "include-workspace-root", "if-present", "ignore-scripts", "foreground-scripts", "script-shell" ];
        static name="run-script";
        static usage=[ "<command> [-- <args>]" ];
        static ignoreImplicitWorkspace=!1;
        static isShellout=!0;
        async completion(opts) {
          if (2 === opts.conf.argv.remain.length) {
            const json = resolve(this.npm.localPrefix, "package.json"), {scripts = {}} = await rpj(json).catch((er => ({})));
            return Object.keys(scripts);
          }
        }
        async exec(args) {
          return args.length ? this.run(args) : this.list(args);
        }
        async execWorkspaces(args, filters) {
          return args.length ? this.runWorkspaces(args, filters) : this.listWorkspaces(args, filters);
        }
        async run([event, ...args], {path = this.npm.localPrefix, pkg} = {}) {
          const scriptShell = this.npm.config.get("script-shell") || void 0;
          pkg = pkg || await rpj(`${path}/package.json`);
          const {scripts = {}} = pkg;
          if ("restart" !== event || scripts.restart ? "env" !== event || scripts.env || (scripts.env = isWindowsShell ? "SET" : "env") : scripts.restart = "npm stop --if-present && npm start", 
          pkg.scripts = scripts, !(Object.prototype.hasOwnProperty.call(scripts, event) || "start" === event && await isServerPackage(path))) {
            if (this.npm.config.get("if-present")) return;
            const suggestions = await didYouMean(this.npm, path, event);
            throw new Error(`Missing script: "${event}"${suggestions}\n\nTo see a list of scripts, run:\n  npm run`);
          }
          const events = [ [ event, args ] ];
          this.npm.config.get("ignore-scripts") || (scripts[`pre${event}`] && events.unshift([ `pre${event}`, [] ]), 
          scripts[`post${event}`] && events.push([ `post${event}`, [] ]));
          const opts = {
            path,
            args,
            scriptShell,
            stdio: "inherit",
            stdioString: !0,
            pkg,
            banner: !this.npm.silent
          };
          for (const [event, args] of events) await runScript({
            ...opts,
            event,
            args
          });
        }
        async list(args, path) {
          path = path || this.npm.localPrefix;
          const {scripts, name, _id} = await rpj(`${path}/package.json`), pkgid = _id || name, color = this.npm.color;
          if (!scripts) return [];
          const allScripts = Object.keys(scripts);
          if (this.npm.silent) return allScripts;
          if (this.npm.config.get("json")) return this.npm.output(JSON.stringify(scripts, null, 2)), 
          allScripts;
          if (this.npm.config.get("parseable")) {
            for (const [script, cmd] of Object.entries(scripts)) this.npm.output(`${script}:${cmd}`);
            return allScripts;
          }
          const cmds = [], runScripts = [];
          for (const script of allScripts) {
            (cmdList.includes(script) ? cmds : runScripts).push(script);
          }
          const colorize = color ? chalk : nocolor;
          cmds.length && this.npm.output(`${colorize.reset(colorize.bold("Lifecycle scripts"))} included in ${colorize.green(pkgid)}:`);
          for (const script of cmds) this.npm.output("  " + script + "\n    " + colorize.dim(scripts[script]));
          !cmds.length && runScripts.length ? this.npm.output(`${colorize.bold("Scripts")} available in ${colorize.green(pkgid)} via \`${colorize.blue("npm run-script")}\`:`) : runScripts.length && this.npm.output(`\navailable via \`${colorize.blue("npm run-script")}\`:`);
          for (const script of runScripts) this.npm.output("  " + script + "\n    " + colorize.dim(scripts[script]));
          return this.npm.output(""), allScripts;
        }
        async runWorkspaces(args, filters) {
          const res = [];
          await this.setWorkspaces(filters);
          for (const workspacePath of this.workspacePaths) {
            const pkg = await rpj(`${workspacePath}/package.json`), runResult = await this.run(args, {
              path: workspacePath,
              pkg
            }).catch((err => {
              log.error(`Lifecycle script \`${args[0]}\` failed with error:`), log.error(err), 
              log.error(`  in workspace: ${pkg._id || pkg.name}`), log.error(`  at location: ${workspacePath}`);
              const scriptMissing = err.message.startsWith("Missing script");
              return scriptMissing || (process.exitCode = 1), scriptMissing;
            }));
            res.push(runResult);
          }
          if (res.every(Boolean)) throw new Error(`Missing script: ${args[0]}`);
        }
        async listWorkspaces(args, filters) {
          if (await this.setWorkspaces(filters), !this.npm.silent) if (this.npm.config.get("json")) {
            const res = {};
            for (const workspacePath of this.workspacePaths) {
              const {scripts, name} = await rpj(`${workspacePath}/package.json`);
              res[name] = {
                ...scripts
              };
            }
            this.npm.output(JSON.stringify(res, null, 2));
          } else if (this.npm.config.get("parseable")) for (const workspacePath of this.workspacePaths) {
            const {scripts, name} = await rpj(`${workspacePath}/package.json`);
            for (const [script, cmd] of Object.entries(scripts || {})) this.npm.output(`${name}:${script}:${cmd}`);
          } else for (const workspacePath of this.workspacePaths) await this.list(args, workspacePath);
        }
      };
    },
    32303: (module, __unused_webpack_exports, __webpack_require__) => {
      const Minipass = __webpack_require__(45018), Pipeline = __webpack_require__(31791), libSearch = __webpack_require__(8895), log = __webpack_require__(86883), formatSearchStream = __webpack_require__(14269);
      function filter(data, include, exclude) {
        const words = [ data.name ].concat(data.maintainers.map((m => `=${m.username}`))).concat(data.keywords || []).map((f => f && f.trim && f.trim())).filter((f => f)).join(" ").toLowerCase();
        return !exclude.find((e => function(words, pattern) {
          if (pattern.startsWith("/")) return pattern.endsWith("/") && (pattern = pattern.slice(0, -1)), 
          pattern = new RegExp(pattern.slice(1)), words.match(pattern);
          return -1 !== words.indexOf(pattern);
        }(words, e)));
      }
      const BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Search for packages";
        static name="search";
        static params=[ "long", "json", "color", "parseable", "description", "searchopts", "searchexclude", "registry", "prefer-online", "prefer-offline", "offline" ];
        static usage=[ "[search terms ...]" ];
        static ignoreImplicitWorkspace=!0;
        async exec(args) {
          const opts = {
            ...this.npm.flatOptions,
            ...this.npm.flatOptions.search,
            include: args.map((s => s.toLowerCase())).filter((s => s)),
            exclude: this.npm.flatOptions.search.exclude.split(/\s+/)
          };
          if (0 === opts.include.length) throw new Error("search must be called with arguments");
          let anyOutput = !1;
          const filterStream = new class extends Minipass {
            write(pkg) {
              filter(pkg, opts.include, opts.exclude) && super.write(pkg);
            }
          }, outputStream = formatSearchStream({
            args,
            ...opts
          });
          log.silly("search", "searching packages");
          const p = new Pipeline(libSearch.stream(opts.include, opts), filterStream, outputStream);
          p.on("data", (chunk => {
            anyOutput || (anyOutput = !0), this.npm.output(chunk.toString("utf8"));
          })), await p.promise(), anyOutput || this.npm.config.get("json") || this.npm.config.get("parseable") || this.npm.output("No matches found for " + args.map(JSON.stringify).join(" ")), 
          log.silly("search", "search completed"), log.clearProgress();
        }
      };
    },
    95410: (module, __unused_webpack_exports, __webpack_require__) => {
      const {resolve} = __webpack_require__(71017), rpj = __webpack_require__(1759), PackageJson = __webpack_require__(66096), log = __webpack_require__(86883), BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Set tasks in the scripts section of package.json, deprecated";
        static params=[ "workspace", "workspaces", "include-workspace-root" ];
        static name="set-script";
        static usage=[ "[<script>] [<command>]" ];
        static ignoreImplicitWorkspace=!1;
        async completion(opts) {
          if (2 === opts.conf.argv.remain.length) {
            const json = resolve(this.npm.localPrefix, "package.json"), {scripts = {}} = await rpj(json).catch((er => ({})));
            return Object.keys(scripts);
          }
        }
        validate(args) {
          if ("postinstall" === process.env.npm_lifecycle_event) throw new Error("Scripts cant set from the postinstall script");
          if (2 !== args.length) throw new Error(`Expected 2 arguments: got ${args.length}`);
        }
        async exec(args) {
          this.validate(args), log.warn("set-script", 'set-script is deprecated, use `npm pkg set scripts.scriptname="cmd" instead.');
          await this.doSetScript(this.npm.localPrefix, args[0], args[1]) && log.warn("set-script", `Script "${args[0]}" was overwritten`);
        }
        async execWorkspaces(args, filters) {
          this.validate(args), await this.setWorkspaces(filters);
          for (const [name, path] of this.workspaces) try {
            await this.doSetScript(path, args[0], args[1]) && (log.warn("set-script", `Script "${args[0]}" was overwritten`), 
            log.warn(`  in workspace: ${name}`), log.warn(`  at location: ${path}`));
          } catch (err) {
            log.error("set-script", err.message), log.error(`  in workspace: ${name}`), log.error(`  at location: ${path}`), 
            process.exitCode = 1;
          }
        }
        async doSetScript(path, name, value) {
          let warn = !1;
          const pkgJson = await PackageJson.load(path), {scripts} = pkgJson.content;
          return scripts && scripts[name] && scripts[name] !== value && (warn = !0), pkgJson.update({
            scripts: {
              ...scripts,
              [name]: value
            }
          }), await pkgJson.save(), warn;
        }
      };
    },
    22636: (module, __unused_webpack_exports, __webpack_require__) => {
      const BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Set a value in the npm configuration";
        static name="set";
        static usage=[ "<key>=<value> [<key>=<value> ...] (See `npm config`)" ];
        static ignoreImplicitWorkspace=!1;
        async completion(opts) {
          return this.npm.cmd("config").completion(opts);
        }
        async exec(args) {
          if (!args.length) throw this.usageError();
          return this.npm.exec("config", [ "set" ].concat(args));
        }
      };
    },
    88582: (module, __unused_webpack_exports, __webpack_require__) => {
      const {resolve, basename} = __webpack_require__(71017), {unlink} = __webpack_require__(57147).promises, Arborist = __webpack_require__(22290), log = __webpack_require__(86883), BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Lock down dependency versions for publication";
        static name="shrinkwrap";
        static ignoreImplicitWorkspace=!1;
        async exec() {
          if (this.npm.global) {
            const er = new Error("`npm shrinkwrap` does not work for global packages");
            throw er.code = "ESHRINKWRAPGLOBAL", er;
          }
          const path = this.npm.prefix, sw = resolve(path, "npm-shrinkwrap.json"), arb = new Arborist({
            ...this.npm.flatOptions,
            path
          }), tree = await arb.loadVirtual().catch((() => arb.loadActual())), {meta} = tree, newFile = meta.hiddenLockfile || !meta.loadedFromDisk, oldFilename = meta.filename, notSW = !newFile && "npm-shrinkwrap.json" !== basename(oldFilename);
          meta.hiddenLockfile && (meta.lockfileVersion = arb.options.lockfileVersion || meta.originalLockfileVersion), 
          meta.hiddenLockfile = !1, meta.filename = sw, await meta.save();
          const updatedVersion = meta.originalLockfileVersion !== meta.lockfileVersion ? meta.lockfileVersion : null;
          if (newFile) {
            let message = "created a lockfile as npm-shrinkwrap.json";
            updatedVersion && (message += ` with version ${updatedVersion}`), log.notice("", message);
          } else if (notSW) {
            await unlink(oldFilename);
            let message = "package-lock.json has been renamed to npm-shrinkwrap.json";
            updatedVersion && (message += ` and updated to version ${updatedVersion}`), log.notice("", message);
          } else updatedVersion ? log.notice("", `npm-shrinkwrap.json updated to version ${updatedVersion}`) : log.notice("", "npm-shrinkwrap.json up to date");
        }
      };
    },
    53886: (module, __unused_webpack_exports, __webpack_require__) => {
      const fetch = __webpack_require__(92427), npa = __webpack_require__(19932), log = __webpack_require__(86883), getIdentity = __webpack_require__(18084), BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Mark your favorite packages";
        static name="star";
        static usage=[ "[<package-spec>...]" ];
        static params=[ "registry", "unicode", "otp" ];
        static ignoreImplicitWorkspace=!1;
        async exec(args) {
          if (!args.length) throw this.usageError();
          const unicode = this.npm.config.get("unicode"), full = unicode ? " " : "(*)", empty = unicode ? " " : "( )", show = "star" === this.name ? full : empty, pkgs = args.map(npa), username = await getIdentity(this.npm, this.npm.flatOptions);
          for (const pkg of pkgs) {
            const fullData = await fetch.json(pkg.escapedName, {
              ...this.npm.flatOptions,
              spec: pkg,
              query: {
                write: !0
              },
              preferOnline: !0
            }), body = {
              _id: fullData._id,
              _rev: fullData._rev,
              users: fullData.users || {}
            };
            "star" === this.name ? (log.info("star", "starring", body._id), body.users[username] = !0, 
            log.verbose("star", "starring", body)) : (delete body.users[username], log.info("unstar", "unstarring", body._id), 
            log.verbose("unstar", "unstarring", body));
            const data = await fetch.json(pkg.escapedName, {
              ...this.npm.flatOptions,
              spec: pkg,
              method: "PUT",
              body
            });
            return this.npm.output(show + " " + pkg.name), log.verbose("star", data), data;
          }
        }
      };
    },
    34660: (module, __unused_webpack_exports, __webpack_require__) => {
      const fetch = __webpack_require__(92427), log = __webpack_require__(86883), getIdentity = __webpack_require__(18084), BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="View packages marked as favorites";
        static name="stars";
        static usage=[ "[<user>]" ];
        static params=[ "registry" ];
        static ignoreImplicitWorkspace=!1;
        async exec([user]) {
          try {
            user || (user = await getIdentity(this.npm, this.npm.flatOptions));
            const {rows} = await fetch.json("/-/_view/starredByUser", {
              ...this.npm.flatOptions,
              query: {
                key: `"${user}"`
              }
            });
            0 === rows.length && log.warn("stars", "user has not starred any packages");
            for (const row of rows) this.npm.output(row.value);
          } catch (err) {
            throw "ENEEDAUTH" === err.code && log.warn("stars", "auth is required to look up your username"), 
            err;
          }
        }
      };
    },
    6299: (module, __unused_webpack_exports, __webpack_require__) => {
      const LifecycleCmd = __webpack_require__(46117);
      module.exports = class extends LifecycleCmd {
        static description="Start a package";
        static name="start";
        static params=[ "ignore-scripts", "script-shell" ];
        static ignoreImplicitWorkspace=!1;
      };
    },
    73340: (module, __unused_webpack_exports, __webpack_require__) => {
      const LifecycleCmd = __webpack_require__(46117);
      module.exports = class extends LifecycleCmd {
        static description="Stop a package";
        static name="stop";
        static params=[ "ignore-scripts", "script-shell" ];
        static ignoreImplicitWorkspace=!1;
      };
    },
    72500: (module, __unused_webpack_exports, __webpack_require__) => {
      const columns = __webpack_require__(33998), libteam = __webpack_require__(88166), otplease = __webpack_require__(83304), BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Manage organization teams and team memberships";
        static name="team";
        static usage=[ "create <scope:team> [--otp <otpcode>]", "destroy <scope:team> [--otp <otpcode>]", "add <scope:team> <user> [--otp <otpcode>]", "rm <scope:team> <user> [--otp <otpcode>]", "ls <scope>|<scope:team>" ];
        static params=[ "registry", "otp", "parseable", "json" ];
        static ignoreImplicitWorkspace=!1;
        async completion(opts) {
          const {conf: {argv: {remain: argv}}} = opts, subcommands = [ "create", "destroy", "add", "rm", "ls" ];
          if (2 === argv.length) return subcommands;
          if (subcommands.includes(argv[2])) return [];
          throw new Error(argv[2] + " not recognized");
        }
        async exec([cmd, entity = "", user = ""]) {
          await otplease(this.npm, {
            ...this.npm.flatOptions
          }, (opts => {
            switch (entity = entity.replace(/^@/, ""), cmd) {
             case "create":
              return this.create(entity, opts);

             case "destroy":
              return this.destroy(entity, opts);

             case "add":
              return this.add(entity, user, opts);

             case "rm":
              return this.rm(entity, user, opts);

             case "ls":
              return entity.match(/[^:]+:.+/) ? this.listUsers(entity, opts) : this.listTeams(entity, opts);

             default:
              throw this.usageError();
            }
          }));
        }
        async create(entity, opts) {
          await libteam.create(entity, opts), opts.json ? this.npm.output(JSON.stringify({
            created: !0,
            team: entity
          })) : opts.parseable ? this.npm.output(`${entity}\tcreated`) : this.npm.silent || this.npm.output(`+@${entity}`);
        }
        async destroy(entity, opts) {
          await libteam.destroy(entity, opts), opts.json ? this.npm.output(JSON.stringify({
            deleted: !0,
            team: entity
          })) : opts.parseable ? this.npm.output(`${entity}\tdeleted`) : this.npm.silent || this.npm.output(`-@${entity}`);
        }
        async add(entity, user, opts) {
          await libteam.add(user, entity, opts), opts.json ? this.npm.output(JSON.stringify({
            added: !0,
            team: entity,
            user
          })) : opts.parseable ? this.npm.output(`${user}\t${entity}\tadded`) : this.npm.silent || this.npm.output(`${user} added to @${entity}`);
        }
        async rm(entity, user, opts) {
          await libteam.rm(user, entity, opts), opts.json ? this.npm.output(JSON.stringify({
            removed: !0,
            team: entity,
            user
          })) : opts.parseable ? this.npm.output(`${user}\t${entity}\tremoved`) : this.npm.silent || this.npm.output(`${user} removed from @${entity}`);
        }
        async listUsers(entity, opts) {
          const users = (await libteam.lsUsers(entity, opts)).sort();
          if (opts.json) this.npm.output(JSON.stringify(users, null, 2)); else if (opts.parseable) this.npm.output(users.join("\n")); else if (!this.npm.silent) {
            const plural = 1 === users.length ? "" : "s", more = 0 === users.length ? "" : ":\n";
            this.npm.output(`\n@${entity} has ${users.length} user${plural}${more}`), this.npm.output(columns(users, {
              padding: 1
            }));
          }
        }
        async listTeams(entity, opts) {
          const teams = (await libteam.lsTeams(entity, opts)).sort();
          if (opts.json) this.npm.output(JSON.stringify(teams, null, 2)); else if (opts.parseable) this.npm.output(teams.join("\n")); else if (!this.npm.silent) {
            const plural = 1 === teams.length ? "" : "s", more = 0 === teams.length ? "" : ":\n";
            this.npm.output(`\n@${entity} has ${teams.length} team${plural}${more}`), this.npm.output(columns(teams.map((t => `@${t}`)), {
              padding: 1
            }));
          }
        }
      };
    },
    9977: (module, __unused_webpack_exports, __webpack_require__) => {
      const LifecycleCmd = __webpack_require__(46117);
      module.exports = class extends LifecycleCmd {
        static description="Test a package";
        static name="test";
        static params=[ "ignore-scripts", "script-shell" ];
        static ignoreImplicitWorkspace=!1;
      };
    },
    99436: (module, __unused_webpack_exports, __webpack_require__) => {
      const Table = __webpack_require__(27275), chalk = __webpack_require__(25433), {v4: isCidrV4, v6: isCidrV6} = __webpack_require__(24173), log = __webpack_require__(86883), profile = __webpack_require__(77969), otplease = __webpack_require__(83304), pulseTillDone = __webpack_require__(26549), readUserInfo = __webpack_require__(87121), BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Manage your authentication tokens";
        static name="token";
        static usage=[ "list", "revoke <id|token>", "create [--read-only] [--cidr=list]" ];
        static params=[ "read-only", "cidr", "registry", "otp" ];
        static ignoreImplicitWorkspace=!0;
        async completion(opts) {
          const argv = opts.conf.argv.remain, subcommands = [ "list", "revoke", "create" ];
          if (2 === argv.length) return subcommands;
          if (subcommands.includes(argv[2])) return [];
          throw new Error(argv[2] + " not recognized");
        }
        async exec(args, cb) {
          if (log.gauge.show("token"), 0 === args.length) return this.list();
          switch (args[0]) {
           case "list":
           case "ls":
            return this.list();

           case "delete":
           case "revoke":
           case "remove":
           case "rm":
            return this.rm(args.slice(1));

           case "create":
            return this.create(args.slice(1));

           default:
            throw this.usageError(`${args[0]} is not a recognized subcommand.`);
          }
        }
        async list() {
          const conf = this.config();
          log.info("token", "getting list");
          const tokens = await pulseTillDone.withPromise(profile.listTokens(conf));
          if (conf.json) return void this.npm.output(JSON.stringify(tokens, null, 2));
          if (conf.parseable) return this.npm.output([ "key", "token", "created", "readonly", "CIDR whitelist" ].join("\t")), 
          void tokens.forEach((token => {
            this.npm.output([ token.key, token.token, token.created, token.readonly ? "true" : "false", token.cidr_whitelist ? token.cidr_whitelist.join(",") : "" ].join("\t"));
          }));
          this.generateTokenIds(tokens, 6);
          const idWidth = tokens.reduce(((acc, token) => Math.max(acc, token.id.length)), 0), table = new Table({
            head: [ "id", "token", "created", "readonly", "CIDR whitelist" ],
            colWidths: [ Math.max(idWidth, 2) + 2, 9, 12, 10 ]
          });
          tokens.forEach((token => {
            table.push([ token.id, token.token + "", String(token.created).slice(0, 10), token.readonly ? "yes" : "no", token.cidr_whitelist ? token.cidr_whitelist.join(", ") : "" ]);
          })), this.npm.output(table.toString());
        }
        async rm(args) {
          if (0 === args.length) throw this.usageError("`<tokenKey>` argument is required.");
          const conf = this.config(), toRemove = [];
          log.newItem("removing tokens", toRemove.length).info("token", "getting existing list");
          const tokens = await pulseTillDone.withPromise(profile.listTokens(conf));
          args.forEach((id => {
            const matches = tokens.filter((token => 0 === token.key.indexOf(id)));
            if (1 === matches.length) toRemove.push(matches[0].key); else {
              if (matches.length > 1) throw new Error(`Token ID "${id}" was ambiguous, a new token may have been created since you last ran \`npm token list\`.`);
              if (!tokens.some((t => 0 === id.indexOf(t.token)))) throw new Error(`Unknown token id or value "${id}".`);
              toRemove.push(id);
            }
          })), await Promise.all(toRemove.map((key => otplease(this.npm, conf, (conf => profile.removeToken(key, conf)))))), 
          conf.json ? this.npm.output(JSON.stringify(toRemove)) : conf.parseable ? this.npm.output(toRemove.join("\t")) : this.npm.output("Removed " + toRemove.length + " token" + (1 !== toRemove.length ? "s" : ""));
        }
        async create(args) {
          const conf = this.config(), cidr = conf.cidr, readonly = conf.readOnly, password = await readUserInfo.password(), validCIDR = this.validateCIDRList(cidr);
          log.info("token", "creating");
          const result = await pulseTillDone.withPromise(otplease(this.npm, conf, (conf => profile.createToken(password, readonly, validCIDR, conf))));
          if (delete result.key, delete result.updated, conf.json) this.npm.output(JSON.stringify(result)); else if (conf.parseable) Object.keys(result).forEach((k => this.npm.output(k + "\t" + result[k]))); else {
            const table = new Table;
            for (const k of Object.keys(result)) table.push({
              [chalk.bold(k)]: String(result[k])
            });
            this.npm.output(table.toString());
          }
        }
        config() {
          const conf = {
            ...this.npm.flatOptions
          }, creds = this.npm.config.getCredentialsByURI(conf.registry);
          if (creds.token) conf.auth = {
            token: creds.token
          }; else if (creds.username) conf.auth = {
            basic: {
              username: creds.username,
              password: creds.password
            }
          }; else if (creds.auth) {
            const auth = Buffer.from(creds.auth, "base64").toString().split(":", 2);
            conf.auth = {
              basic: {
                username: auth[0],
                password: auth[1]
              }
            };
          } else conf.auth = {};
          return conf.otp && (conf.auth.otp = conf.otp), conf;
        }
        invalidCIDRError(msg) {
          return Object.assign(new Error(msg), {
            code: "EINVALIDCIDR"
          });
        }
        generateTokenIds(tokens, minLength) {
          const byId = {};
          for (const token of tokens) {
            token.id = token.key;
            for (let ii = minLength; ii < token.key.length; ++ii) {
              if (!tokens.some((ot => ot !== token && ot.key.slice(0, ii) === token.key.slice(0, ii)))) {
                token.id = token.key.slice(0, ii);
                break;
              }
            }
            byId[token.id] = token;
          }
          return byId;
        }
        validateCIDRList(cidrs) {
          const maybeList = cidrs ? Array.isArray(cidrs) ? cidrs : [ cidrs ] : [], list = 1 === maybeList.length ? maybeList[0].split(/,\s*/) : maybeList;
          for (const cidr of list) {
            if (isCidrV6(cidr)) throw this.invalidCIDRError("CIDR whitelist can only contain IPv4 addresses, " + cidr + " is IPv6");
            if (!isCidrV4(cidr)) throw this.invalidCIDRError("CIDR whitelist contains invalid CIDR entry: " + cidr);
          }
          return list;
        }
      };
    },
    52292: (module, __unused_webpack_exports, __webpack_require__) => {
      const {resolve} = __webpack_require__(71017), Arborist = __webpack_require__(22290), rpj = __webpack_require__(1759), reifyFinish = __webpack_require__(2648), completion = __webpack_require__(73486), ArboristWorkspaceCmd = __webpack_require__(99264);
      class Uninstall extends ArboristWorkspaceCmd {
        static description="Remove a package";
        static name="uninstall";
        static params=[ "save", ...super.params ];
        static usage=[ "[<@scope>/]<pkg>..." ];
        static ignoreImplicitWorkspace=!1;
        async completion(opts) {
          return completion(this.npm, opts);
        }
        async exec(args) {
          const path = this.npm.global ? resolve(this.npm.globalDir, "..") : this.npm.localPrefix;
          if (!args.length) {
            if (!this.npm.global) throw new Error("Must provide a package name to remove");
            {
              let pkg;
              try {
                pkg = await rpj(resolve(this.npm.localPrefix, "package.json"));
              } catch (er) {
                throw "ENOENT" !== er.code && "ENOTDIR" !== er.code ? er : this.usageError();
              }
              args.push(pkg.name);
            }
          }
          const opts = {
            ...this.npm.flatOptions,
            path,
            rm: args,
            workspaces: this.workspaceNames
          }, arb = new Arborist(opts);
          await arb.reify(opts), await reifyFinish(this.npm, arb);
        }
      }
      module.exports = Uninstall;
    },
    2197: (module, __unused_webpack_exports, __webpack_require__) => {
      const libaccess = __webpack_require__(63167), libunpub = __webpack_require__(76919).unpublish, npa = __webpack_require__(19932), npmFetch = __webpack_require__(92427), path = __webpack_require__(71017), readJson = __webpack_require__(73837).promisify(__webpack_require__(62965)), {flatten} = __webpack_require__(70506), getIdentity = __webpack_require__(18084), log = __webpack_require__(86883), otplease = __webpack_require__(83304), BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Remove a package from the registry";
        static name="unpublish";
        static params=[ "dry-run", "force", "workspace", "workspaces" ];
        static usage=[ "[<package-spec>]" ];
        static ignoreImplicitWorkspace=!1;
        async getKeysOfVersions(name, opts) {
          const pkgUri = npa(name).escapedName, json = await npmFetch.json(`${pkgUri}?write=true`, opts);
          return Object.keys(json.versions);
        }
        async completion(args) {
          const {partialWord, conf} = args;
          if (conf.argv.remain.length >= 3) return [];
          const opts = {
            ...this.npm.flatOptions
          }, username = await getIdentity(this.npm, {
            ...opts
          }).catch((() => null));
          if (!username) return [];
          const access = await libaccess.lsPackages(username, opts);
          let pkgs = Object.keys(access || {});
          if (!partialWord || !pkgs.length) return pkgs;
          const pp = npa(partialWord).name;
          if (pkgs = pkgs.filter((p => !p.indexOf(pp))), pkgs.length > 1) return pkgs;
          const versions = await this.getKeysOfVersions(pkgs[0], opts);
          return versions.length ? versions.map((v => `${pkgs[0]}@${v}`)) : pkgs;
        }
        async exec(args) {
          if (args.length > 1) throw this.usageError();
          let spec = args.length && npa(args[0]);
          const force = this.npm.config.get("force"), {silent} = this.npm, dryRun = this.npm.config.get("dry-run");
          if (log.silly("unpublish", "args[0]", args[0]), log.silly("unpublish", "spec", spec), 
          !(spec && spec.rawSpec || force)) throw this.usageError("Refusing to delete entire project.\nRun with --force to do this.");
          const opts = {
            ...this.npm.flatOptions
          };
          let pkgName, pkgVersion, manifest, manifestErr;
          try {
            const pkgJson = path.join(this.npm.localPrefix, "package.json");
            manifest = await readJson(pkgJson);
          } catch (err) {
            manifestErr = err;
          }
          if (spec) {
            manifest && manifest.name === spec.name && manifest.publishConfig && flatten(manifest.publishConfig, opts);
            if (1 === (await this.getKeysOfVersions(spec.name, opts)).length && !force) throw this.usageError("Refusing to delete the last version of the package. It will block from republishing a new version for 24 hours.\nRun with --force to do this.");
            pkgName = spec.name, pkgVersion = "version" === spec.type ? `@${spec.rawSpec}` : "";
          } else {
            if (manifestErr) throw "ENOENT" === manifestErr.code || "ENOTDIR" === manifestErr.code ? this.usageError() : manifestErr;
            log.verbose("unpublish", manifest), spec = npa.resolve(manifest.name, manifest.version), 
            manifest.publishConfig && flatten(manifest.publishConfig, opts), pkgName = manifest.name, 
            pkgVersion = manifest.version ? `@${manifest.version}` : "";
          }
          dryRun || await otplease(this.npm, opts, (opts => libunpub(spec, opts))), silent || this.npm.output(`- ${pkgName}${pkgVersion}`);
        }
        async execWorkspaces(args, filters) {
          await this.setWorkspaces(filters);
          if (!this.npm.config.get("force")) throw this.usageError("Refusing to delete entire project(s).\nRun with --force to do this.");
          for (const name of this.workspaceNames) await this.exec([ name ]);
        }
      };
    },
    76594: (module, __unused_webpack_exports, __webpack_require__) => {
      const Star = __webpack_require__(53886);
      module.exports = class extends Star {
        static description="Remove an item from your favorite packages";
        static name="unstar";
      };
    },
    34400: (module, __unused_webpack_exports, __webpack_require__) => {
      const path = __webpack_require__(71017), Arborist = __webpack_require__(22290), log = __webpack_require__(86883), reifyFinish = __webpack_require__(2648), completion = __webpack_require__(46624), ArboristWorkspaceCmd = __webpack_require__(99264);
      class Update extends ArboristWorkspaceCmd {
        static description="Update packages";
        static name="update";
        static params=[ "save", "global", "global-style", "legacy-bundling", "omit", "strict-peer-deps", "package-lock", "foreground-scripts", "ignore-scripts", "audit", "bin-links", "fund", "dry-run", ...super.params ];
        static usage=[ "[<pkg>...]" ];
        async completion(opts) {
          return completion(this.npm, opts);
        }
        async exec(args) {
          const update = 0 === args.length || args, global = path.resolve(this.npm.globalDir, ".."), where = this.npm.global ? global : this.npm.prefix, save = !this.npm.config.isDefault("save") && this.npm.config.get("save");
          this.npm.config.get("depth") && log.warn("update", "The --depth option no longer has any effect. See RFC0019.\nhttps://github.com/npm/rfcs/blob/latest/implemented/0019-remove-update-depth-option.md");
          const opts = {
            ...this.npm.flatOptions,
            path: where,
            save,
            workspaces: this.workspaceNames
          }, arb = new Arborist(opts);
          await arb.reify({
            ...opts,
            update
          }), await reifyFinish(this.npm, arb);
        }
      }
      module.exports = Update;
    },
    67182: (module, __unused_webpack_exports, __webpack_require__) => {
      const libnpmversion = __webpack_require__(25970), {resolve} = __webpack_require__(71017), {promisify} = __webpack_require__(73837), readFile = promisify(__webpack_require__(57147).readFile), updateWorkspaces = __webpack_require__(43644), BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Bump a package version";
        static name="version";
        static params=[ "allow-same-version", "commit-hooks", "git-tag-version", "json", "preid", "sign-git-tag", "workspace", "workspaces", "workspaces-update", "include-workspace-root" ];
        static ignoreImplicitWorkspace=!1;
        static usage=[ "[<newversion> | major | minor | patch | premajor | preminor | prepatch | prerelease | from-git]" ];
        async completion(opts) {
          const {conf: {argv: {remain}}} = opts;
          return remain.length > 2 ? [] : [ "major", "minor", "patch", "premajor", "preminor", "prepatch", "prerelease", "from-git" ];
        }
        async exec(args) {
          switch (args.length) {
           case 0:
            return this.list();

           case 1:
            return this.change(args);

           default:
            throw this.usageError();
          }
        }
        async execWorkspaces(args, filters) {
          switch (args.length) {
           case 0:
            return this.listWorkspaces(filters);

           case 1:
            return this.changeWorkspaces(args, filters);

           default:
            throw this.usageError();
          }
        }
        async change(args) {
          const prefix = this.npm.config.get("tag-version-prefix"), version = await libnpmversion(args[0], {
            ...this.npm.flatOptions,
            path: this.npm.prefix
          });
          return this.npm.output(`${prefix}${version}`);
        }
        async changeWorkspaces(args, filters) {
          const prefix = this.npm.config.get("tag-version-prefix");
          await this.setWorkspaces(filters);
          const updatedWorkspaces = [];
          for (const [name, path] of this.workspaces) {
            this.npm.output(name);
            const version = await libnpmversion(args[0], {
              ...this.npm.flatOptions,
              "git-tag-version": !1,
              path
            });
            updatedWorkspaces.push(name), this.npm.output(`${prefix}${version}`);
          }
          return this.update(updatedWorkspaces);
        }
        async list(results = {}) {
          const pj = resolve(this.npm.prefix, "package.json"), pkg = await readFile(pj, "utf8").then((data => JSON.parse(data))).catch((() => ({})));
          pkg.name && pkg.version && (results[pkg.name] = pkg.version), results.npm = this.npm.version;
          for (const [key, version] of Object.entries(process.versions)) results[key] = version;
          this.npm.config.get("json") ? this.npm.output(JSON.stringify(results, null, 2)) : this.npm.output(results);
        }
        async listWorkspaces(filters) {
          const results = {};
          await this.setWorkspaces(filters);
          for (const path of this.workspacePaths) {
            const pj = resolve(path, "package.json"), pkg = await readFile(pj, "utf8").then((data => JSON.parse(data)));
            pkg.name && pkg.version && (results[pkg.name] = pkg.version);
          }
          return this.list(results);
        }
        async update(workspaces) {
          const {config, flatOptions, localPrefix} = this.npm;
          await updateWorkspaces({
            config,
            flatOptions,
            localPrefix,
            npm: this.npm,
            workspaces
          });
        }
      };
    },
    11613: (module, __unused_webpack_exports, __webpack_require__) => {
      const chalk = __webpack_require__(25433), columns = __webpack_require__(33998), fs = __webpack_require__(57147), jsonParse = __webpack_require__(40295), log = __webpack_require__(86883), npa = __webpack_require__(19932), {resolve} = __webpack_require__(71017), formatBytes = __webpack_require__(76761), relativeDate = __webpack_require__(38100), semver = __webpack_require__(5870), {inspect, promisify} = __webpack_require__(73837), {packument} = __webpack_require__(86585), readFile = promisify(fs.readFile), Queryable = __webpack_require__(58113), BaseCommand = __webpack_require__(26727);
      function cleanBlanks(obj) {
        const clean = {};
        return Object.keys(obj).forEach((version => {
          clean[version] = obj[version][""];
        })), clean;
      }
      function reducer(acc, cur) {
        return cur && Object.keys(cur).forEach((v => {
          acc[v] = acc[v] || {}, Object.keys(cur[v]).forEach((t => {
            acc[v][t] = cur[v][t];
          }));
        })), acc;
      }
      function cleanup(data) {
        if (Array.isArray(data)) return data.map(cleanup);
        if (!data || "object" != typeof data) return data;
        const keys = Object.keys(data);
        return keys.length <= 3 && data.name && (1 === keys.length || 3 === keys.length && data.email && data.url || 2 === keys.length && (data.email || data.url)) && (data = unparsePerson(data)), 
        data;
      }
      function unparsePerson(d) {
        return d.name + (d.email ? " <" + d.email + ">" : "") + (d.url ? " (" + d.url + ")" : "");
      }
      module.exports = class extends BaseCommand {
        static description="View registry info";
        static name="view";
        static params=[ "json", "workspace", "workspaces", "include-workspace-root" ];
        static ignoreImplicitWorkspace=!1;
        static usage=[ "[<package-spec>] [<field>[.subfield]...]" ];
        async completion(opts) {
          if (opts.conf.argv.remain.length <= 2) return;
          const config = {
            ...this.npm.flatOptions,
            fullMetadata: !0,
            preferOnline: !0
          }, spec = npa(opts.conf.argv.remain[2]), pckmnt = await packument(spec, config), defaultTag = this.npm.config.get("tag"), dv = pckmnt.versions[pckmnt["dist-tags"][defaultTag]];
          return pckmnt.versions = Object.keys(pckmnt.versions).sort(semver.compareLoose), 
          getFields(pckmnt).concat(getFields(dv));
          function getFields(d, f, pref) {
            return f = f || [], pref = pref || [], Object.keys(d).forEach((k => {
              if ("_" === k.charAt(0) || -1 !== k.indexOf(".")) return;
              const p = pref.concat(k).join(".");
              f.push(p), Array.isArray(d[k]) ? d[k].forEach(((val, i) => {
                const pi = p + "[" + i + "]";
                val && "object" == typeof val ? getFields(val, f, [ p ]) : f.push(pi);
              })) : "object" == typeof d[k] && getFields(d[k], f, [ p ]);
            })), f;
          }
        }
        async exec(args) {
          args.length || (args = [ "." ]);
          let pkg = args.shift();
          if (/^\.@/.test(pkg) || "." === pkg) {
            if (this.npm.global) throw new Error("Cannot use view command in global mode.");
            const dir = this.npm.prefix, manifest = await (async file => jsonParse(await readFile(file, "utf8")))(resolve(dir, "package.json"));
            if (!manifest.name) throw new Error('Invalid package.json, no "name" field');
            pkg = `${manifest.name}${pkg.slice(1)}`;
          }
          let wholePackument = !1;
          args.length || (args = [ "" ], wholePackument = !0);
          const [pckmnt, data] = await this.getData(pkg, args);
          if (!this.npm.config.get("json") && wholePackument) data.map((v => this.prettyView(pckmnt, v[Object.keys(v)[0]][""]))); else {
            let reducedData = data.reduce(reducer, {});
            wholePackument && (reducedData = cleanBlanks(reducedData), log.silly("view", reducedData)), 
            log.disableProgress();
            const msg = await this.jsonData(reducedData, pckmnt._id);
            "" !== msg && console.log(msg);
          }
        }
        async execWorkspaces(args, filters) {
          args.length || (args = [ "." ]);
          const pkg = args.shift();
          if (!(/^\.@/.test(pkg) || "." === pkg)) return log.warn("Ignoring workspaces for specified package(s)"), 
          this.exec([ pkg, ...args ]);
          let wholePackument = !1;
          args.length || (wholePackument = !0, args = [ "" ]);
          const results = {};
          await this.setWorkspaces(filters);
          for (const name of this.workspaceNames) {
            const wsPkg = `${name}${pkg.slice(1)}`, [pckmnt, data] = await this.getData(wsPkg, args);
            let reducedData = data.reduce(reducer, {});
            if (wholePackument && (reducedData = cleanBlanks(reducedData), log.silly("view", reducedData)), 
            this.npm.config.get("json")) {
              const msg = await this.jsonData(reducedData, pckmnt._id);
              "" !== msg && (results[name] = JSON.parse(msg));
            } else if (wholePackument) data.map((v => this.prettyView(pckmnt, v[Object.keys(v)[0]][""]))); else {
              console.log(`${name}:`);
              const msg = await this.jsonData(reducedData, pckmnt._id);
              "" !== msg && console.log(msg);
            }
          }
          Object.keys(results).length > 0 && console.log(JSON.stringify(results, null, 2));
        }
        async getData(pkg, args) {
          const opts = {
            ...this.npm.flatOptions,
            preferOnline: !0,
            fullMetadata: !0
          }, spec = npa(pkg);
          let version = this.npm.config.get("tag");
          "git" !== spec.type && "directory" !== spec.type && spec.rawSpec && (version = spec.rawSpec);
          const pckmnt = await packument(spec, opts);
          if (pckmnt["dist-tags"] && pckmnt["dist-tags"][version] && (version = pckmnt["dist-tags"][version]), 
          pckmnt.time && pckmnt.time.unpublished) {
            const u = pckmnt.time.unpublished, er = new Error(`Unpublished on ${u.time}`);
            throw er.statusCode = 404, er.code = "E404", er.pkgid = pckmnt._id, er;
          }
          const data = [], versions = pckmnt.versions || {};
          if (pckmnt.versions = Object.keys(versions).sort(semver.compareLoose), -1 === args.indexOf("readme") && delete pckmnt.readme, 
          Object.keys(versions).forEach((v => {
            semver.satisfies(v, version, !0) && args.forEach((arg => {
              -1 !== args.indexOf("readme") && delete versions[v].readme, data.push(function(data, version, fields) {
                const o = {};
                [ data, version ].forEach((s => {
                  Object.keys(s).forEach((k => {
                    o[k] = s[k];
                  }));
                }));
                const s = new Queryable(o).query(fields), res = {
                  [version.version]: s
                };
                if (s) return res;
              }(pckmnt, versions[v], arg));
            }));
          })), 0 === data.length && "latest" !== version) {
            const er = new Error(`No match found for version ${version}`);
            throw er.statusCode = 404, er.code = "E404", er.pkgid = `${pckmnt._id}@${version}`, 
            er;
          }
          return this.npm.config.get("json") || 1 !== args.length || "" !== args[0] || (pckmnt.version = version), 
          [ pckmnt, data ];
        }
        async jsonData(data, name) {
          const versions = Object.keys(data);
          let msg = "", msgJson = [];
          const includeVersions = versions.length > 1;
          let includeFields;
          const json = this.npm.config.get("json");
          if (versions.forEach((v => {
            const fields = Object.keys(data[v]);
            includeFields = includeFields || fields.length > 1, json && msgJson.push({}), fields.forEach((f => {
              let d = cleanup(data[v][f]);
              1 === fields.length && json && (msgJson[msgJson.length - 1][f] = d), includeVersions || includeFields || "string" != typeof d ? json ? msgJson[msgJson.length - 1][f] = d : d = inspect(d, {
                showHidden: !1,
                depth: 5,
                colors: this.npm.color,
                maxArrayLength: null
              }) : "string" == typeof d && json && (d = JSON.stringify(d)), json || (f && includeFields && (f += " = "), 
              msg += (includeVersions ? name + "@" + v + " " : "") + (includeFields ? f : "") + d + "\n");
            }));
          })), json) {
            if (msgJson.length && 1 === Object.keys(msgJson[0]).length) {
              const k = Object.keys(msgJson[0])[0];
              msgJson = msgJson.map((m => m[k]));
            }
            1 === msgJson.length ? msg = JSON.stringify(msgJson[0], null, 2) + "\n" : msgJson.length > 1 && (msg = JSON.stringify(msgJson, null, 2) + "\n");
          }
          return msg.trim();
        }
        prettyView(packument, manifest) {
          const unicode = this.npm.config.get("unicode"), tags = [];
          Object.keys(packument["dist-tags"]).forEach((t => {
            const version = packument["dist-tags"][t];
            tags.push(`${chalk.bold.green(t)}: ${version}`);
          }));
          const unpackedSize = manifest.dist.unpackedSize && formatBytes(manifest.dist.unpackedSize, !0), licenseField = manifest.license || "Proprietary", info = {
            name: chalk.green(manifest.name),
            version: chalk.green(manifest.version),
            bins: Object.keys(manifest.bin || {}),
            versions: chalk.yellow(packument.versions.length + ""),
            description: manifest.description,
            deprecated: manifest.deprecated,
            keywords: packument.keywords || [],
            license: "string" == typeof licenseField ? licenseField : licenseField.type || "Proprietary",
            deps: Object.keys(manifest.dependencies || {}).map((dep => `${chalk.yellow(dep)}: ${manifest.dependencies[dep]}`)),
            publisher: manifest._npmUser && unparsePerson({
              name: chalk.yellow(manifest._npmUser.name),
              email: chalk.cyan(manifest._npmUser.email)
            }),
            modified: packument.time ? chalk.yellow(relativeDate(packument.time[manifest.version])) : void 0,
            maintainers: (packument.maintainers || []).map((u => unparsePerson({
              name: chalk.yellow(u.name),
              email: chalk.cyan(u.email)
            }))),
            repo: manifest.bugs && (manifest.bugs.url || manifest.bugs) || manifest.repository && (manifest.repository.url || manifest.repository),
            site: manifest.homepage && (manifest.homepage.url || manifest.homepage),
            tags,
            tarball: chalk.cyan(manifest.dist.tarball),
            shasum: chalk.yellow(manifest.dist.shasum),
            integrity: manifest.dist.integrity && chalk.yellow(manifest.dist.integrity),
            fileCount: manifest.dist.fileCount && chalk.yellow(manifest.dist.fileCount),
            unpackedSize: unpackedSize && chalk.yellow(unpackedSize)
          };
          "proprietary" === info.license.toLowerCase().trim() ? info.license = chalk.bold.red(info.license) : info.license = chalk.green(info.license), 
          console.log(""), console.log(chalk.underline.bold(`${info.name}@${info.version}`) + " | " + info.license + " | deps: " + (info.deps.length ? chalk.cyan(info.deps.length) : chalk.green("none")) + " | versions: " + info.versions), 
          info.description && console.log(info.description), (info.repo || info.site) && info.site && console.log(chalk.cyan(info.site));
          const warningSign = unicode ? "  " : "!!";
          info.deprecated && console.log(`\n${chalk.bold.red("DEPRECATED")}${warningSign} - ${info.deprecated}`), 
          info.keywords.length && (console.log(""), console.log("keywords:", chalk.yellow(info.keywords.join(", ")))), 
          info.bins.length && (console.log(""), console.log("bin:", chalk.yellow(info.bins.join(", ")))), 
          console.log(""), console.log("dist"), console.log(".tarball:", info.tarball), console.log(".shasum:", info.shasum), 
          info.integrity && console.log(".integrity:", info.integrity), info.unpackedSize && console.log(".unpackedSize:", info.unpackedSize);
          if (info.deps.length && (console.log(""), console.log("dependencies:"), console.log(columns(info.deps.slice(0, 24), {
            padding: 1
          })), info.deps.length > 24 && console.log(`(...and ${info.deps.length - 24} more.)`)), 
          info.maintainers && info.maintainers.length && (console.log(""), console.log("maintainers:"), 
          info.maintainers.forEach((u => console.log("-", u)))), console.log(""), console.log("dist-tags:"), 
          console.log(columns(info.tags)), info.publisher || info.modified) {
            let publishInfo = "published";
            info.modified && (publishInfo += ` ${info.modified}`), info.publisher && (publishInfo += ` by ${info.publisher}`), 
            console.log(""), console.log(publishInfo);
          }
        }
      };
    },
    27558: (module, __unused_webpack_exports, __webpack_require__) => {
      const getIdentity = __webpack_require__(18084), BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Display npm username";
        static name="whoami";
        static params=[ "registry" ];
        static ignoreImplicitWorkspace=!0;
        async exec(args) {
          const username = await getIdentity(this.npm, {
            ...this.npm.flatOptions
          });
          this.npm.output(this.npm.config.get("json") ? JSON.stringify(username) : username);
        }
      };
    },
    25879: (module, __unused_webpack_exports, __webpack_require__) => {
      var map = {
        "./access.js": 65719,
        "./adduser.js": 90128,
        "./audit.js": 43020,
        "./bin.js": 66128,
        "./birthday.js": 7782,
        "./bugs.js": 78164,
        "./cache.js": 41288,
        "./ci.js": 70244,
        "./completion.js": 24744,
        "./config.js": 74470,
        "./dedupe.js": 6352,
        "./deprecate.js": 66202,
        "./diff.js": 72548,
        "./dist-tag.js": 23499,
        "./docs.js": 46973,
        "./doctor.js": 13781,
        "./edit.js": 68543,
        "./exec.js": 81500,
        "./explain.js": 35034,
        "./explore.js": 73586,
        "./find-dupes.js": 86429,
        "./fund.js": 68465,
        "./get.js": 57508,
        "./help-search.js": 61423,
        "./help.js": 17240,
        "./hook.js": 30581,
        "./init.js": 20633,
        "./install-ci-test.js": 27678,
        "./install-test.js": 52610,
        "./install.js": 92514,
        "./link.js": 25485,
        "./ll.js": 96292,
        "./logout.js": 3314,
        "./ls.js": 33581,
        "./org.js": 98757,
        "./outdated.js": 24175,
        "./owner.js": 82189,
        "./pack.js": 30266,
        "./ping.js": 5922,
        "./pkg.js": 9785,
        "./prefix.js": 77662,
        "./profile.js": 47099,
        "./prune.js": 20649,
        "./publish.js": 58759,
        "./query.js": 46080,
        "./rebuild.js": 7618,
        "./repo.js": 44448,
        "./restart.js": 61612,
        "./root.js": 31270,
        "./run-script.js": 43889,
        "./search.js": 32303,
        "./set-script.js": 95410,
        "./set.js": 22636,
        "./shrinkwrap.js": 88582,
        "./star.js": 53886,
        "./stars.js": 34660,
        "./start.js": 6299,
        "./stop.js": 73340,
        "./team.js": 72500,
        "./test.js": 9977,
        "./token.js": 99436,
        "./uninstall.js": 52292,
        "./unpublish.js": 2197,
        "./unstar.js": 76594,
        "./update.js": 34400,
        "./version.js": 67182,
        "./view.js": 11613,
        "./whoami.js": 27558
      };
      function webpackContext(req) {
        var id = webpackContextResolve(req);
        return __webpack_require__(id);
      }
      function webpackContextResolve(req) {
        if (!__webpack_require__.o(map, req)) {
          var e = new Error("Cannot find module '" + req + "'");
          throw e.code = "MODULE_NOT_FOUND", e;
        }
        return map[req];
      }
      webpackContext.keys = function() {
        return Object.keys(map);
      }, webpackContext.resolve = webpackContextResolve, module.exports = webpackContext, 
      webpackContext.id = 25879;
    },
    46117: (module, __unused_webpack_exports, __webpack_require__) => {
      const BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static usage=[ "[-- <args>]" ];
        static isShellout=!0;
        async exec(args, cb) {
          return this.npm.exec("run-script", [ this.constructor.name, ...args ]);
        }
        async execWorkspaces(args, filters, cb) {
          return this.npm.exec("run-script", [ this.constructor.name, ...args ]);
        }
      };
    },
    82576: module => {
      const r = new RegExp("(?:\\[(?:\\d+[ABCDEFGJKSTm]|\\d+;\\d+[Hfm]|\\d+;\\d+;\\d+m|6n|s|u|\\?25[lh])|\\w)", "g");
      module.exports = str => str.replace(r, "");
    },
    21674: (module, __unused_webpack_exports, __webpack_require__) => {
      const log = __webpack_require__(86883);
      module.exports = (npm, report) => {
        if (!report || !report.error) return !1;
        if ("audit" !== npm.command) return !0;
        const {error} = report;
        log.warn("audit", error.message);
        const {body: errBody} = error, body = Buffer.isBuffer(errBody) ? errBody.toString() : errBody;
        throw npm.flatOptions.json ? npm.output(JSON.stringify({
          message: error.message,
          method: error.method,
          uri: error.uri,
          headers: error.headers,
          statusCode: error.statusCode,
          body
        }, null, 2)) : npm.output(body), "audit endpoint returned an error";
      };
    },
    34456: (module, __unused_webpack_exports, __webpack_require__) => {
      const abbrev = __webpack_require__(70143), localeCompare = __webpack_require__(51031)("en"), aliases = {
        login: "adduser",
        author: "owner",
        home: "docs",
        issues: "bugs",
        info: "view",
        show: "view",
        find: "search",
        add: "install",
        unlink: "uninstall",
        remove: "uninstall",
        rm: "uninstall",
        r: "uninstall",
        un: "uninstall",
        rb: "rebuild",
        list: "ls",
        ln: "link",
        create: "init",
        i: "install",
        it: "install-test",
        cit: "install-ci-test",
        up: "update",
        c: "config",
        s: "search",
        se: "search",
        tst: "test",
        t: "test",
        ddp: "dedupe",
        v: "view",
        run: "run-script",
        "clean-install": "ci",
        "clean-install-test": "cit",
        x: "exec",
        why: "explain",
        la: "ll",
        verison: "version",
        ic: "ci",
        innit: "init",
        in: "install",
        ins: "install",
        inst: "install",
        insta: "install",
        instal: "install",
        isnt: "install",
        isnta: "install",
        isntal: "install",
        isntall: "install",
        "install-clean": "ci",
        "isntall-clean": "ci",
        hlep: "help",
        "dist-tags": "dist-tag",
        upgrade: "update",
        udpate: "update",
        rum: "run-script",
        sit: "cit",
        urn: "run-script",
        ogr: "org",
        "add-user": "adduser"
      }, commands = [ "access", "adduser", "audit", "bin", "bugs", "cache", "ci", "completion", "config", "dedupe", "deprecate", "diff", "dist-tag", "docs", "doctor", "edit", "exec", "explain", "explore", "find-dupes", "fund", "get", "help", "hook", "init", "install", "install-ci-test", "install-test", "link", "ll", "login", "logout", "ls", "org", "outdated", "owner", "pack", "ping", "pkg", "prefix", "profile", "prune", "publish", "query", "rebuild", "repo", "restart", "root", "run-script", "search", "set", "set-script", "shrinkwrap", "star", "stars", "start", "stop", "team", "test", "token", "uninstall", "unpublish", "unstar", "update", "version", "view", "whoami" ], plumbing = [ "birthday", "help-search" ], allCommands = [ ...commands, ...plumbing ].sort(localeCompare), abbrevs = abbrev(commands.concat(Object.keys(aliases)));
      module.exports = {
        abbrevs,
        aliases,
        commands,
        plumbing,
        allCommands
      };
    },
    46624: (module, __unused_webpack_exports, __webpack_require__) => {
      const {resolve} = __webpack_require__(71017), Arborist = __webpack_require__(22290), localeCompare = __webpack_require__(51031)("en");
      module.exports = async npm => {
        const {depth, global, prefix, workspacesEnabled} = npm.flatOptions, getValues = tree => [ ...tree.inventory.values() ].filter((i => "" !== i.location && !i.isRoot)).map((i => i)).filter((i => i.depth - 1 <= depth)).sort(((a, b) => a.depth - b.depth || localeCompare(a.name, b.name))), res = new Set, gArb = new Arborist({
          global: !0,
          path: resolve(npm.globalDir, ".."),
          workspacesEnabled
        }), gTree = await gArb.loadActual({
          global: !0
        });
        for (const node of getValues(gTree)) res.add(global ? node.name : [ node.name, "-g" ]);
        if (!global) {
          const arb = new Arborist({
            global: !1,
            path: prefix,
            workspacesEnabled
          }), tree = await arb.loadActual();
          for (const node of getValues(tree)) res.add(node.name);
        }
        return [ ...res ];
      };
    },
    73486: (module, __unused_webpack_exports, __webpack_require__) => {
      const {promisify} = __webpack_require__(73837), readdir = promisify(__webpack_require__(51981));
      module.exports = async (npm, opts) => {
        const names = global => readdir(global ? npm.globalDir : npm.localDir), {conf: {argv: {remain}}} = opts;
        if (remain.length > 3) return null;
        const {global} = npm.flatOptions;
        return [ ...global ? [] : await names(!1), ...(await names(!0)).map((n => global ? n : `${n} -g`)) ];
      };
    },
    1726: (module, __unused_webpack_exports, __webpack_require__) => {
      const required = [ "type", "description", "default", "key" ], allowed = [ "default", "defaultDescription", "deprecated", "description", "flatten", "hint", "key", "short", "type", "typeDescription", "usage", "envExport" ], {typeDefs: {semver: {type: semver}, Umask: {type: Umask}, url: {type: url}, path: {type: path}}} = __webpack_require__(18919);
      const describeUsage = def => {
        let key = "";
        if (!Array.isArray(def.type)) return def.short && (key = `-${def.short}|`), key = def.type === Boolean && !1 !== def.default ? `${key}--no-${def.key}` : `${key}--${def.key}`, 
        def.type !== Boolean && (key = `${key} ${def.hint}`), key;
        key = `--${def.key}`, def.short && (key = `-${def.short}|--${def.key}`);
        let types = def.type;
        const multiple = types.includes(Array), bool = types.includes(Boolean);
        if (types = types.filter((t => null !== t && t !== Array && t !== Boolean)), !types.length) return key;
        let description;
        description = types.some((t => "string" != typeof t)) ? def.hint : `<${types.filter((d => d)).join("|")}>`, 
        bool && (key = `--no-${def.key}|${key}`);
        const usage = `${key} ${description}`;
        return multiple ? `${usage} [${usage} ...]` : usage;
      }, describeType = type => {
        if (Array.isArray(type)) {
          const descriptions = type.filter((t => t !== Array)).map((t => describeType(t))), last = descriptions.length > 1 ? [ descriptions.pop() ] : [], oxford = descriptions.length > 1 ? ", or " : " or ";
          return `${[ descriptions.join(", ") ].concat(last).join(oxford)}${type.includes(Array) ? " (can be set multiple times)" : ""}`;
        }
        switch (type) {
         case String:
          return "String";

         case Number:
          return "Number";

         case Umask:
          return "Octal numeric string in range 0000..0777 (0..511)";

         case Boolean:
          return "Boolean";

         case Date:
          return "Date";

         case path:
          return "Path";

         case semver:
          return "SemVer string";

         case url:
          return "URL";

         default:
          return describeValue(type);
        }
      }, describeValue = val => "string" == typeof val ? JSON.stringify(val) : String(val), unindent = s => {
        const match = s.match(/\n +/);
        return match ? s.split(match[0]).join("\n").trim() : s.trim();
      }, wrap = s => {
        const cols = Math.min(Math.max(20, process.stdout.columns) || 80, 80) - 5;
        return unindent(s).split(/[ \n]+/).reduce(((left, right) => {
          const last = left.split("\n").pop();
          return left + (last.length && last.length + right.length > cols ? "\n" : " ") + right;
        }));
      }, wrapAll = s => {
        let inCodeBlock = !1;
        return s.split("\n\n").map((block => inCodeBlock || block.startsWith("```") ? (inCodeBlock = !block.endsWith("```"), 
        block) : "*" === block.charAt(0) ? "* " + block.slice(1).trim().split("\n* ").map((li => wrap(li).replace(/\n/g, "\n  "))).join("\n* ") : wrap(block))).join("\n\n");
      };
      module.exports = class {
        constructor(key, def) {
          this.key = key, this.envExport = !0, Object.assign(this, def), this.validate(), 
          this.defaultDescription || (this.defaultDescription = describeValue(this.default)), 
          this.typeDescription || (this.typeDescription = describeType(this.type)), this.hint || (this.type === Number ? this.hint = "<number>" : this.hint = `<${this.key}>`), 
          this.usage || (this.usage = describeUsage(this));
        }
        validate() {
          for (const req of required) if (!Object.prototype.hasOwnProperty.call(this, req)) throw new Error(`config lacks ${req}: ${this.key}`);
          if (!this.key) throw new Error(`config lacks key: ${this.key}`);
          for (const field of Object.keys(this)) if (!allowed.includes(field)) throw new Error(`config defines unknown field ${field}: ${this.key}`);
        }
        describe() {
          const description = unindent(this.description), noEnvExport = this.envExport ? "" : "\nThis value is not exported to the environment for child processes.\n", deprecated = this.deprecated ? `* DEPRECATED: ${unindent(this.deprecated)}\n` : "";
          return wrapAll(`#### \`${this.key}\`\n\n* Default: ${unindent(this.defaultDescription)}\n* Type: ${unindent(this.typeDescription)}\n${deprecated}\n${description}\n${noEnvExport}`);
        }
      };
    },
    70506: (module, __unused_webpack_exports, __webpack_require__) => {
      const definitions = __webpack_require__(18700), shorthands = {
        "enjoy-by": [ "--before" ],
        d: [ "--loglevel", "info" ],
        dd: [ "--loglevel", "verbose" ],
        ddd: [ "--loglevel", "silly" ],
        quiet: [ "--loglevel", "warn" ],
        q: [ "--loglevel", "warn" ],
        s: [ "--loglevel", "silent" ],
        silent: [ "--loglevel", "silent" ],
        verbose: [ "--loglevel", "verbose" ],
        desc: [ "--description" ],
        help: [ "--usage" ],
        local: [ "--no-global" ],
        n: [ "--no-yes" ],
        no: [ "--no-yes" ],
        porcelain: [ "--parseable" ],
        readonly: [ "--read-only" ],
        reg: [ "--registry" ],
        iwr: [ "--include-workspace-root" ],
        ...Object.entries(definitions).reduce(((acc, [key, {short = []}]) => {
          for (const s of [].concat(short)) acc[s] = [ `--${key}` ];
          return acc;
        }), {})
      };
      module.exports = {
        get defaults() {
          return Object.entries(definitions).reduce(((acc, [key, {default: d}]) => (acc[key] = d, 
          acc)), {});
        },
        definitions,
        flatten: (obj, flat = {}) => {
          for (const [key, val] of Object.entries(obj)) {
            const def = definitions[key];
            def && def.flatten ? def.flatten(key, obj, flat) : (/@.*:registry$/i.test(key) || /^\/\//.test(key)) && (flat[key] = val);
          }
          return flat.npmBin = __webpack_require__.c[__webpack_require__.s] ? __webpack_require__.c[__webpack_require__.s].filename : void 0, 
          flat.nodeBin = process.env.NODE || process.execPath, flat.hashAlgorithm = "sha1", 
          flat;
        },
        shorthands
      };
    },
    90594: (module, __unused_webpack_exports, __webpack_require__) => {
      const {distance} = __webpack_require__(18787), readJson = __webpack_require__(1759), {commands} = __webpack_require__(34456);
      module.exports = async (npm, path, scmd) => {
        const close = commands.filter((cmd => distance(scmd, cmd) < .4 * scmd.length && scmd !== cmd));
        let best = [];
        for (const str of close) {
          const cmd = await npm.cmd(str);
          best.push(`    npm ${str} # ${cmd.description}`);
        }
        const runScripts = [ "stop", "start", "test", "restart" ];
        try {
          const {bin, scripts} = await readJson(`${path}/package.json`);
          best = best.concat(Object.keys(scripts || {}).filter((cmd => distance(scmd, cmd) < .4 * scmd.length && !runScripts.includes(cmd))).map((str => `    npm run ${str} # run the "${str}" package script`)), Object.keys(bin || {}).filter((cmd => distance(scmd, cmd) < .4 * scmd.length)).map((str => `    npm exec ${str} # run the "${str}" command from either this or a remote npm package`)));
        } catch (_) {}
        if (0 === best.length) return "";
        return 1 === best.length ? `\n\nDid you mean this?\n${best[0]}` : `\n\nDid you mean one of these?\n${best.slice(0, 3).join("\n")}`;
      };
    },
    55969: (module, __unused_webpack_exports, __webpack_require__) => {
      const {inspect} = __webpack_require__(73837), npmlog = __webpack_require__(19334), log = __webpack_require__(86883), {explain} = __webpack_require__(62387), _logHandler = Symbol("logHandler"), _eresolveWarn = Symbol("eresolveWarn"), _log = Symbol("log"), _npmlog = Symbol("npmlog");
      module.exports = class {
        constructor() {
          this.on(), log.pause();
        }
        on() {
          process.on("log", this[_logHandler]);
        }
        off() {
          process.off("log", this[_logHandler]), log.tracker.removeAllListeners();
        }
        load(config) {
          const {color, timing, loglevel, unicode, progress, silent, heading = "npm"} = config;
          log.level = timing && "notice" === loglevel ? "timing" : loglevel, log.heading = heading, 
          color ? log.enableColor() : log.disableColor(), unicode ? log.enableUnicode() : log.disableUnicode(), 
          progress && !silent ? log.enableProgress() : log.disableProgress(), log.resume();
        }
        log(...args) {
          this[_logHandler](...args);
        }
        [_logHandler]=(level, ...args) => {
          try {
            this[_log](level, ...args);
          } catch (ex) {
            try {
              this[_npmlog]("verbose", `attempt to log ${inspect(args)} crashed`, ex);
            } catch (ex2) {
              console.error(`attempt to log ${inspect(args)} crashed`, ex, ex2);
            }
          }
        };
        [_log](...args) {
          return this[_eresolveWarn](...args) || this[_npmlog](...args);
        }
        [_npmlog](level, ...args) {
          npmlog[level](...args);
        }
        [_eresolveWarn](level, heading, message, expl) {
          if ("warn" === level && "ERESOLVE" === heading && expl && "object" == typeof expl) return this[_npmlog](level, heading, message), 
          this[_npmlog](level, "", explain(expl, log.useColor(), 2)), !0;
        }
      };
    },
    78611: (module, __unused_webpack_exports, __webpack_require__) => {
      const {format} = __webpack_require__(73837), {resolve} = __webpack_require__(71017), nameValidator = __webpack_require__(74980), replaceInfo = __webpack_require__(45042), {report} = __webpack_require__(62387), log = __webpack_require__(86883);
      module.exports = (er, npm) => {
        const short = [], detail = [];
        switch (er.message && (er.message = replaceInfo(er.message)), er.stack && (er.stack = replaceInfo(er.stack)), 
        er.code) {
         case "ERESOLVE":
          short.push([ "ERESOLVE", er.message ]), detail.push([ "", "" ]), detail.push([ "", report(er, !!npm.logColor, resolve(npm.cache, "eresolve-report.txt")) ]);
          break;

         case "ENOLOCK":
          {
            const cmd = npm.command || "";
            short.push([ cmd, "This command requires an existing lockfile." ]), detail.push([ cmd, "Try creating one first with: npm i --package-lock-only" ]), 
            detail.push([ cmd, `Original error: ${er.message}` ]);
            break;
          }

         case "ENOAUDIT":
          short.push([ "audit", er.message ]);
          break;

         case "ECONNREFUSED":
          short.push([ "", er ]), detail.push([ "", [ "\nIf you are behind a proxy, please make sure that the", "'proxy' config is set properly.  See: 'npm help config'" ].join("\n") ]);
          break;

         case "EACCES":
         case "EPERM":
          {
            const isCachePath = "string" == typeof er.path && npm.config.loaded && er.path.startsWith(npm.config.get("cache")), isCacheDest = "string" == typeof er.dest && npm.config.loaded && er.dest.startsWith(npm.config.get("cache")), {isWindows} = __webpack_require__(52290);
            isWindows || !isCachePath && !isCacheDest ? (short.push([ "", er ]), detail.push([ "", [ "\nThe operation was rejected by your operating system.", isWindows ? "It's possible that the file was already in use (by a text editor or antivirus),\nor that you lack permissions to access it." : "It is likely you do not have the permissions to access this file as the current user", "\nIf you believe this might be a permissions issue, please double-check the", "permissions of the file and its containing directories, or try running", "the command again as root/Administrator." ].join("\n") ])) : (log.verbose(er.stack), 
            short.push([ "", [ "", "Your cache folder contains root-owned files, due to a bug in", "previous versions of npm which has since been addressed.", "", "To permanently fix this problem, please run:", `  sudo chown -R ${process.getuid()}:${process.getgid()} ${JSON.stringify(npm.config.get("cache"))}` ].join("\n") ]));
            break;
          }

         case "ENOGIT":
          short.push([ "", er.message ]), detail.push([ "", [ "", "Failed using git.", "Please check if you have git installed and in your PATH." ].join("\n") ]);
          break;

         case "EJSONPARSE":
          if (er.path === resolve(npm.prefix, "package.json")) {
            const {isDiff} = __webpack_require__(67697);
            if (isDiff(__webpack_require__(57147).readFileSync(er.path, "utf8").replace(/\r\n/g, "\n"))) {
              detail.push([ "", [ "Merge conflict detected in your package.json.", "", "Please resolve the package.json conflict and retry." ].join("\n") ]);
              break;
            }
          }
          short.push([ "JSON.parse", er.message ]), detail.push([ "JSON.parse", [ "Failed to parse JSON data.", "Note: package.json must be actual JSON, not just JavaScript." ].join("\n") ]);
          break;

         case "EOTP":
         case "E401":
          if ("EOTP" === er.code || /one-time pass/.test(er.message)) short.push([ "", "This operation requires a one-time password from your authenticator." ]), 
          detail.push([ "", [ "You can provide a one-time password by passing --otp=<code> to the command you ran.", "If you already provided a one-time password then it is likely that you either typoed", "it, or it timed out. Please try again." ].join("\n") ]); else {
            const auth = er.headers && er.headers["www-authenticate"] ? er.headers["www-authenticate"].map((au => au.split(/[,\s]+/)))[0] : [];
            auth.includes("Bearer") ? (short.push([ "", "Unable to authenticate, your authentication token seems to be invalid." ]), 
            detail.push([ "", [ "To correct this please trying logging in again with:", "    npm login" ].join("\n") ])) : auth.includes("Basic") ? (short.push([ "", "Incorrect or missing password." ]), 
            detail.push([ "", [ "If you were trying to login, change your password, create an", "authentication token or enable two-factor authentication then", "that means you likely typed your password in incorrectly.", "Please try again, or recover your password at:", "    https://www.npmjs.com/forgot", "", "If you were doing some other operation then your saved credentials are", "probably out of date. To correct this please try logging in again with:", "    npm login" ].join("\n") ])) : short.push([ "", er.message || er ]);
          }
          break;

         case "E404":
          if (short.push([ "404", er.message.replace(/^404\s+/, "") ]), er.pkgid && "-" !== er.pkgid) {
            const pkg = er.pkgid.replace(/(?!^)@.*$/, "");
            detail.push([ "404", "" ]), detail.push([ "404", "", `'${replaceInfo(er.pkgid)}' is not in this registry.` ]);
            const valResult = nameValidator(pkg);
            if (!valResult.validForNewPackages) {
              detail.push([ "404", "This package name is not valid, because", "" ]);
              [ ...valResult.errors || [], ...valResult.warnings || [] ].forEach(((item, idx) => detail.push([ "404", " " + (idx + 1) + ". " + item ])));
            }
            detail.push([ "404", "\nNote that you can also install from a" ]), detail.push([ "404", "tarball, folder, http url, or git url." ]);
          }
          break;

         case "EPUBLISHCONFLICT":
          short.push([ "publish fail", "Cannot publish over existing version." ]), detail.push([ "publish fail", "Update the 'version' field in package.json and try again." ]), 
          detail.push([ "publish fail", "" ]), detail.push([ "publish fail", "To automatically increment version numbers, see:" ]), 
          detail.push([ "publish fail", "    npm help version" ]);
          break;

         case "EISGIT":
          short.push([ "git", er.message ]), short.push([ "git", "    " + er.path ]), detail.push([ "git", [ "Refusing to remove it. Update manually,", "or move it out of the way first." ].join("\n") ]);
          break;

         case "EBADPLATFORM":
          {
            const validOs = er.required && er.required.os && er.required.os.join ? er.required.os.join(",") : er.required.os, validArch = er.required && er.required.cpu && er.required.cpu.join ? er.required.cpu.join(",") : er.required.cpu, expected = {
              os: validOs,
              arch: validArch
            }, actual = {
              os: process.platform,
              arch: process.arch
            };
            short.push([ "notsup", [ format("Unsupported platform for %s: wanted %j (current: %j)", er.pkgid, expected, actual) ].join("\n") ]), 
            detail.push([ "notsup", [ "Valid OS:    " + validOs, "Valid Arch:  " + validArch, "Actual OS:   " + process.platform, "Actual Arch: " + process.arch ].join("\n") ]);
            break;
          }

         case "EEXIST":
          short.push([ "", er.message ]), short.push([ "", "File exists: " + (er.dest || er.path) ]), 
          detail.push([ "", "Remove the existing file and try again, or run npm" ]), detail.push([ "", "with --force to overwrite files recklessly." ]);
          break;

         case "ENEEDAUTH":
          short.push([ "need auth", er.message ]), detail.push([ "need auth", "You need to authorize this machine using `npm adduser`" ]);
          break;

         case "ECONNRESET":
         case "ENOTFOUND":
         case "ETIMEDOUT":
         case "ERR_SOCKET_TIMEOUT":
         case "EAI_FAIL":
          short.push([ "network", er.message ]), detail.push([ "network", [ "This is a problem related to network connectivity.", "In most cases you are behind a proxy or have bad network settings.", "\nIf you are behind a proxy, please make sure that the", "'proxy' config is set properly.  See: 'npm help config'" ].join("\n") ]);
          break;

         case "ETARGET":
          short.push([ "notarget", er.message ]), detail.push([ "notarget", [ "In most cases you or one of your dependencies are requesting", "a package version that doesn't exist." ].join("\n") ]);
          break;

         case "E403":
          short.push([ "403", er.message ]), detail.push([ "403", [ "In most cases, you or one of your dependencies are requesting", "a package version that is forbidden by your security policy, or", "on a server you do not have access to." ].join("\n") ]);
          break;

         case "EBADENGINE":
          short.push([ "engine", er.message ]), short.push([ "engine", "Not compatible with your version of node/npm: " + er.pkgid ]), 
          detail.push([ "notsup", [ "Not compatible with your version of node/npm: " + er.pkgid, "Required: " + JSON.stringify(er.required), "Actual:   " + JSON.stringify({
            npm: npm.version,
            node: npm.config.loaded ? npm.config.get("node-version") : process.version
          }) ].join("\n") ]);
          break;

         case "ENOSPC":
          short.push([ "nospc", er.message ]), detail.push([ "nospc", [ "There appears to be insufficient space on your system to finish.", "Clear up some disk space and try again." ].join("\n") ]);
          break;

         case "EROFS":
          short.push([ "rofs", er.message ]), detail.push([ "rofs", [ "Often virtualized file systems, or other file systems", "that don't support symlinks, give this error." ].join("\n") ]);
          break;

         case "ENOENT":
          short.push([ "enoent", er.message ]), detail.push([ "enoent", [ "This is related to npm not being able to find a file.", er.file ? "\nCheck if the file '" + er.file + "' is present." : "" ].join("\n") ]);
          break;

         case "EMISSINGARG":
         case "EUNKNOWNTYPE":
         case "EINVALIDTYPE":
         case "ETOOMANYARGS":
          short.push([ "typeerror", er.stack ]), detail.push([ "typeerror", [ "This is an error with npm itself. Please report this error at:", "    https://github.com/npm/cli/issues" ].join("\n") ]);
          break;

         default:
          short.push([ "", er.message || er ]), er.signal && detail.push([ "signal", er.signal ]), 
          er.cmd && Array.isArray(er.args) && detail.push([ "command", er.cmd, ...er.args.map(replaceInfo) ]), 
          er.stdout && detail.push([ "", er.stdout.trim() ]), er.stderr && detail.push([ "", er.stderr.trim() ]);
        }
        return {
          summary: short,
          detail
        };
      };
    },
    28685: (module, __unused_webpack_exports, __webpack_require__) => {
      const os = __webpack_require__(22037), log = __webpack_require__(86883), errorMessage = __webpack_require__(78611), replaceInfo = __webpack_require__(45042), messageText = msg => msg.map((line => line.slice(1).join(" "))).join("\n"), indent = val => Array.isArray(val) ? val.map((v => indent(v))) : `    ${val}`;
      let npm = null, exitHandlerCalled = !1, showLogFileError = !1;
      process.on("exit", (code => {
        log.disableProgress(), process.emit("timeEnd", "npm");
        const hasNpm = !!npm, hasLoadedNpm = hasNpm && npm.config.loaded;
        if (hasNpm) for (const [name, timer] of npm.unfinishedTimers) log.verbose("unfinished npm timer", name, timer);
        if (code ? log.verbose("code", code) : log.info("ok"), exitHandlerCalled || (process.exitCode = code || 1, 
        log.error("", "Exit handler never called!"), console.error(""), log.error("", "This is an error with npm itself. Please report this error at:"), 
        log.error("", "    <https://github.com/npm/cli/issues>"), showLogFileError = !0), 
        hasLoadedNpm) {
          npm.writeTimingFile();
          const logsDir = npm.logsDir, logFiles = npm.logFiles, timingDir = npm.timingDir, timingFile = npm.timingFile, timing = npm.config.get("timing"), logsMax = npm.config.get("logs-max"), logMethod = showLogFileError ? "error" : timing ? "info" : null;
          if (logMethod) {
            npm.silent || console.error("");
            const message = [];
            timingFile ? message.push("Timing info written to:", indent(timingFile)) : timing && message.push(`The timing file was not written due to an error writing to the directory: ${timingDir}`), 
            logFiles.length ? message.push("A complete log of this run can be found in:", ...indent(logFiles)) : logsMax <= 0 ? message.push(`Log files were not written due to the config logs-max=${logsMax}`) : message.push(`Log files were not written due to an error writing to the directory: ${logsDir}`, "You can rerun the command with `--loglevel=verbose` to see the logs in your terminal"), 
            log[logMethod]("", message.join("\n"));
          }
          npm.unload();
        }
        exitHandlerCalled = !1, showLogFileError = !1;
      }));
      module.exports = err => {
        exitHandlerCalled = !0, log.disableProgress();
        const hasNpm = !!npm, hasLoadedNpm = hasNpm && npm.config.loaded;
        if (!hasNpm) return err = err || new Error("Exit prior to setting npm in exit handler"), 
        console.error(err.stack || err.message), process.exit(1);
        if (hasLoadedNpm || (err = err || new Error("Exit prior to config file resolving."), 
        console.error(err.stack || err.message)), "string" == typeof npm.updateNotification) {
          const {level} = log;
          log.level = "notice", log.notice("", npm.updateNotification), log.level = level;
        }
        let exitCode, noLogMessage;
        if (err) {
          exitCode = 1;
          if (npm.commandInstance && npm.commandInstance.constructor.isShellout && "number" == typeof err.code && err.code) exitCode = err.code, 
          noLogMessage = !0; else if ("string" == typeof err) log.error("", err), noLogMessage = !0; else if (err instanceof Error) {
            if (!err.code) {
              const matchErrorCode = err.message.match(/^(?:Error: )?(E[A-Z]+)/);
              err.code = matchErrorCode && matchErrorCode[1];
            }
            for (const k of [ "type", "stack", "statusCode", "pkgid" ]) {
              const v = err[k];
              v && log.verbose(k, replaceInfo(v));
            }
            log.verbose("cwd", process.cwd()), log.verbose("", os.type() + " " + os.release()), 
            log.verbose("node", process.version), log.verbose("npm ", "v" + npm.version);
            for (const k of [ "code", "syscall", "file", "path", "dest", "errno" ]) {
              const v = err[k];
              v && log.error(k, v);
            }
            const msg = errorMessage(err, npm);
            for (const errline of [ ...msg.summary, ...msg.detail ]) log.error(...errline);
            if (hasLoadedNpm && npm.config.get("json")) {
              const error = {
                error: {
                  code: err.code,
                  summary: messageText(msg.summary),
                  detail: messageText(msg.detail)
                }
              };
              npm.outputError(JSON.stringify(error, null, 2));
            }
            "number" == typeof err.errno ? exitCode = err.errno : "number" == typeof err.code && (exitCode = err.code);
          } else log.error("weird error", err), noLogMessage = !0;
        }
        log.verbose("exit", exitCode || 0), showLogFileError = !(hasLoadedNpm && npm.silent || noLogMessage) && !!exitCode;
        let flushed = 0;
        const flush = [ process.stderr, process.stdout ], exit = () => ++flushed === flush.length && process.exit(exitCode);
        flush.forEach((f => f.write("", exit)));
      }, module.exports.setNpm = n => npm = n;
    },
    53975: (module, __unused_webpack_exports, __webpack_require__) => {
      const chalk = __webpack_require__(25433), nocolor = {
        bold: s => s,
        dim: s => s,
        red: s => s,
        yellow: s => s,
        cyan: s => s,
        magenta: s => s,
        blue: s => s,
        green: s => s,
        gray: s => s
      }, {relative} = __webpack_require__(71017), explainNode = (node, depth, color) => printNode(node, color) + explainDependents(node, depth, color) + explainLinksIn(node, depth, color), colorType = (type, color) => {
        const {red, yellow, cyan, magenta, blue, green, gray} = color ? chalk : nocolor;
        return ("extraneous" === type ? red : "dev" === type ? yellow : "optional" === type ? cyan : "peer" === type ? magenta : "bundled" === type ? blue : "workspace" === type ? green : "overridden" === type ? gray : s => s)(type);
      }, printNode = (node, color) => {
        const {name, version, location, extraneous, dev, optional, peer, bundled, isWorkspace, overridden} = node, {bold, dim, green} = color ? chalk : nocolor, extra = [];
        extraneous && extra.push(" " + bold(colorType("extraneous", color))), dev && extra.push(" " + bold(colorType("dev", color))), 
        optional && extra.push(" " + bold(colorType("optional", color))), peer && extra.push(" " + bold(colorType("peer", color))), 
        bundled && extra.push(" " + bold(colorType("bundled", color))), overridden && extra.push(" " + bold(colorType("overridden", color)));
        return `${isWorkspace ? green(`${name}@${version}`) : `${bold(name)}@${bold(version)}`}${extra.join("")}` + (location ? dim(`\n${location}`) : "");
      }, explainLinksIn = ({linksIn}, depth, color) => {
        if (!linksIn || !linksIn.length || depth <= 0) return "";
        return ("\n" + linksIn.map((link => explainNode(link, depth - 1, color))).join("\n")).split("\n").join("\n  ");
      }, explainDependents = ({name, dependents}, depth, color) => {
        if (!dependents || !dependents.length || depth <= 0) return "";
        const max = Math.ceil(depth / 2), messages = dependents.slice(0, max).map((edge => explainEdge(edge, depth, color)));
        if (dependents.length > max) {
          let len = 0;
          const maxLen = 50, showNames = [];
          for (let i = max; i < dependents.length; i++) {
            const {from: {name = "the root project"}} = dependents[i];
            if (len += name.length, len >= maxLen && i < dependents.length - 1) {
              showNames.push("...");
              break;
            }
            showNames.push(name);
          }
          const show = `(${showNames.join(", ")})`;
          messages.push(`${dependents.length - max} more ${show}`);
        }
        return ("\n" + messages.join("\n")).split("\n").join("\n  ");
      }, explainEdge = ({name, type, bundled, from, spec, rawSpec, overridden}, depth, color) => {
        const {bold} = color ? chalk : nocolor;
        let dep = "workspace" === type ? bold(relative(from.location, spec.slice("file:".length))) : `${bold(name)}@"${bold(spec)}"`;
        overridden && (dep = `${colorType("overridden", color)} ${dep} (was "${rawSpec}")`);
        const fromMsg = ` from ${explainFrom(from, depth, color)}`;
        return ("prod" === type ? "" : `${colorType(type, color)} `) + (bundled ? `${colorType("bundled", color)} ` : "") + `${dep}${fromMsg}`;
      }, explainFrom = (from, depth, color) => from.name || from.version ? printNode(from, color) + explainDependents(from, depth - 1, color) + explainLinksIn(from, depth - 1, color) : "the root project";
      module.exports = {
        explainNode,
        printNode,
        explainEdge
      };
    },
    62387: (module, __unused_webpack_exports, __webpack_require__) => {
      const {writeFileSync} = __webpack_require__(57147), {explainEdge, explainNode, printNode} = __webpack_require__(53975), explain = (expl, color, depth) => {
        const {edge, dep, current, peerConflict, currentEdge} = expl, out = [], whileInstalling = dep && dep.whileInstalling || current && current.whileInstalling || edge && edge.from && edge.from.whileInstalling;
        if (whileInstalling && out.push("While resolving: " + printNode(whileInstalling, color)), 
        current ? out.push("Found: " + explainNode(current, depth, color)) : peerConflict && peerConflict.current ? out.push("Found: " + explainNode(peerConflict.current, depth, color)) : currentEdge ? out.push("Found: " + explainEdge(currentEdge, depth, color)) : edge && out.push("Found: " + explainEdge(edge, depth, color)), 
        out.push("\nCould not resolve dependency:\n" + explainEdge(edge, depth, color)), 
        peerConflict) {
          const heading = "\nConflicting peer dependency:", pc = explainNode(peerConflict.peer, depth, color);
          out.push(heading + " " + pc);
        }
        return out.join("\n");
      };
      module.exports = {
        explain,
        report: (expl, color, fullReport) => {
          const fix = `Fix the upstream dependency conflict, or retry\nthis command with ${expl.strictPeerDeps ? "--no-strict-peer-deps, " : ""}--force, or --legacy-peer-deps\nto accept an incorrect (and potentially broken) dependency resolution.`;
          return writeFileSync(fullReport, `# npm resolution error report\n\n${(new Date).toISOString()}\n\n${explain(expl, !1, 1 / 0)}\n\n${fix}\n\nRaw JSON explanation object:\n\n${JSON.stringify(expl, null, 2)}\n`, "utf8"), 
          explain(expl, color, 4) + `\n\n${fix}\n\nSee ${fullReport} for a full report.`;
        }
      };
    },
    76761: module => {
      module.exports = (bytes, space = !0) => {
        let spacer = "";
        return space && (spacer = " "), bytes < 1e3 ? `${bytes}${spacer}B` : bytes < 1e6 ? `${(bytes / 1e3).toFixed(1)}${spacer}kB` : bytes < 1e9 ? `${(bytes / 1e6).toFixed(1)}${spacer}MB` : `${(bytes / 1e9).toFixed(1)}${spacer}GB`;
      };
    },
    14269: (module, __unused_webpack_exports, __webpack_require__) => {
      const Minipass = __webpack_require__(45018), columnify = __webpack_require__(75231);
      module.exports = opts => opts.json ? new JSONOutputStream : new TextOutputStream(opts);
      class JSONOutputStream extends Minipass {
        #didFirst=!1;
        write(obj) {
          return this.#didFirst ? super.write("\n,\n") : (super.write("[\n"), this.#didFirst = !0), 
          super.write(JSON.stringify(obj));
        }
        end() {
          super.write(this.#didFirst ? "]\n" : "\n[]\n"), super.end();
        }
      }
      class TextOutputStream extends Minipass {
        constructor(opts) {
          super(), this._opts = opts, this._line = 0;
        }
        write(pkg) {
          return super.write(function(data, num, opts) {
            var truncate = !opts.long, pkg = function(data, opts) {
              return {
                name: data.name,
                description: data.description,
                author: data.maintainers.map((m => `=${m.username}`)).join(" "),
                keywords: Array.isArray(data.keywords) ? data.keywords.join(" ") : "string" == typeof data.keywords ? data.keywords.replace(/[,\s]+/, " ") : "",
                version: data.version,
                date: data.date && data.date.toISOString().split("T").join(" ").replace(/:[0-9]{2}\.[0-9]{3}Z$/, "").slice(0, -5) || "prehistoric"
              };
            }(data), columns = [ "name", "description", "author", "date", "version", "keywords" ];
            if (opts.parseable) return columns.map((function(col) {
              return pkg[col] && ("" + pkg[col]).replace(/\t/g, " ");
            })).join("\t");
            const maxWidth = process.stdout.isTTY ? process.stdout.getWindowSize()[0] : 1 / 0;
            let output = columnify([ pkg ], {
              include: columns,
              showHeaders: num <= 1,
              columnSplitter: " | ",
              truncate,
              config: {
                name: {
                  minWidth: 25,
                  maxWidth: 25,
                  truncate: !1,
                  truncateMarker: ""
                },
                description: {
                  minWidth: 20,
                  maxWidth: 20
                },
                author: {
                  minWidth: 15,
                  maxWidth: 15
                },
                date: {
                  maxWidth: 11
                },
                version: {
                  minWidth: 8,
                  maxWidth: 8
                },
                keywords: {
                  maxWidth: 1 / 0
                }
              }
            }).split("\n").map((line => line.slice(0, maxWidth))).join("\n");
            opts.color && (str = output, opts.args.forEach((function(arg, i) {
              str = function(str, arg, i) {
                var m = i % cl + 1, markStart = String.fromCharCode(m), markEnd = String.fromCharCode(0);
                if ("/" === arg.charAt(0)) return str.replace(new RegExp(arg.slice(1, -1), "gi"), (bit => markStart + bit + markEnd));
                var pieces = str.toLowerCase().split(arg.toLowerCase()), p = 0;
                return pieces.map((function(piece) {
                  piece = str.slice(p, p + piece.length);
                  var mark = markStart + str.slice(p + piece.length, p + piece.length + arg.length) + markEnd;
                  return p += piece.length + arg.length, piece + mark;
                })).join("");
              }(str, arg, i);
            })), output = function(line) {
              for (var i = 0; i < cl; i++) {
                var m = i + 1, color = "[" + colors[i] + "m";
                line = line.split(String.fromCharCode(m)).join(color);
              }
              var uncolor = "[0m";
              return line.split("\0").join(uncolor);
            }(str).trim());
            var str;
            return output;
          }(pkg, ++this._line, this._opts));
        }
      }
      var colors = [ 31, 33, 32, 36, 34, 35 ], cl = colors.length;
    },
    18084: (module, __unused_webpack_exports, __webpack_require__) => {
      const npmFetch = __webpack_require__(92427);
      module.exports = async (npm, opts) => {
        const {registry} = opts, creds = npm.config.getCredentialsByURI(registry);
        if (creds.username) return creds.username;
        if (creds.token || creds.certfile && creds.keyfile) {
          return (await npmFetch.json("/-/whoami", {
            ...opts
          })).username;
        }
        throw Object.assign(new Error("This command requires you to be logged in."), {
          code: "ENEEDAUTH"
        });
      };
    },
    52290: (__unused_webpack_module, exports) => {
      const isWindows = "win32" === process.platform, isWindowsShell = isWindows && !/^MINGW(32|64)$/.test(process.env.MSYSTEM) && "cygwin" !== process.env.TERM;
      exports.isWindows = isWindows, exports.isWindowsShell = isWindowsShell;
    },
    7341: (module, __unused_webpack_exports, __webpack_require__) => {
      const os = __webpack_require__(22037), path = __webpack_require__(71017), {format, promisify} = __webpack_require__(73837), rimraf = promisify(__webpack_require__(11567)), glob = promisify(__webpack_require__(34436)), MiniPass = __webpack_require__(45018), fsMiniPass = __webpack_require__(33975), fs = __webpack_require__(45264), log = __webpack_require__(86883), globify = pattern => pattern.split("\\").join("/"), _logHandler = Symbol("logHandler"), _formatLogItem = Symbol("formatLogItem"), _getLogFilePath = Symbol("getLogFilePath"), _openLogFile = Symbol("openLogFile"), _cleanLogs = Symbol("cleanlogs"), _endStream = Symbol("endStream"), _isBuffered = Symbol("isBuffered");
      class LogFiles {
        #logId=null;
        #logStream=null;
        #MAX_LOGS_PER_FILE=null;
        #MAX_FILES_PER_PROCESS=null;
        #fileLogCount=0;
        #totalLogCount=0;
        #dir=null;
        #logsMax=null;
        #files=[];
        constructor({maxLogsPerFile = 5e4, maxFilesPerProcess = 5} = {}) {
          this.#logId = LogFiles.logId(new Date), this.#MAX_LOGS_PER_FILE = maxLogsPerFile, 
          this.#MAX_FILES_PER_PROCESS = maxFilesPerProcess, this.on();
        }
        static logId(d) {
          return d.toISOString().replace(/[.:]/g, "_");
        }
        static format(count, level, title, ...args) {
          let prefix = `${count} ${level}`;
          return title && (prefix += ` ${title}`), format(...args).split(/\r?\n/).reduce(((lines, line) => lines + (prefix + (line ? " " : "")) + line + os.EOL), "");
        }
        on() {
          this.#logStream = new MiniPass, process.on("log", this[_logHandler]);
        }
        off() {
          process.off("log", this[_logHandler]), this[_endStream]();
        }
        load({dir, logsMax = 1 / 0} = {}) {
          if (this.#dir = dir, this.#logsMax = logsMax, this.#logStream) {
            if (log.verbose("logfile", `logs-max:${logsMax} dir:${dir}`), this.#logsMax > 0) {
              const initialFile = this[_openLogFile]();
              initialFile && (this.#logStream = this.#logStream.pipe(initialFile));
            }
            return this[_cleanLogs]();
          }
        }
        log(...args) {
          this[_logHandler](...args);
        }
        get files() {
          return this.#files;
        }
        get [_isBuffered]() {
          return this.#logStream instanceof MiniPass;
        }
        [_endStream](output) {
          this.#logStream && (this.#logStream.end(output), this.#logStream = null);
        }
        [_logHandler]=(level, ...args) => {
          if ("pause" === level || "resume" === level) return;
          if (!this.#logStream) return;
          const logOutput = this[_formatLogItem](level, ...args);
          this[_isBuffered] ? this.#logStream.write(logOutput) : this.#fileLogCount >= this.#MAX_LOGS_PER_FILE ? (this[_endStream](logOutput), 
          this.#files.length >= this.#MAX_FILES_PER_PROCESS ? this.off() : this.#logStream = this[_openLogFile]()) : this.#logStream.write(logOutput);
        };
        [_formatLogItem](...args) {
          return this.#fileLogCount += 1, LogFiles.format(this.#totalLogCount++, ...args);
        }
        [_getLogFilePath](count = "") {
          return path.resolve(this.#dir, `${this.#logId}-debug-${count}.log`);
        }
        [_openLogFile]() {
          const count = this.#files.length;
          try {
            const f = this[_getLogFilePath]((n = count, length = this.#MAX_FILES_PER_PROCESS, 
            n.toString().padStart(length.toString().length, "0"))), logStream = fs.withOwnerSync(f, (() => new fsMiniPass.WriteStreamSync(f, {
              flags: "a"
            })), {
              owner: "inherit"
            });
            return count > 0 && (this.#fileLogCount = 0), this.#files.push(logStream.path), 
            logStream;
          } catch (e) {
            log.verbose("logfile", `could not be created: ${e}`);
          }
          var n, length;
        }
        async [_cleanLogs]() {
          try {
            const logPath = this[_getLogFilePath](), logGlob = path.join(path.dirname(logPath), path.basename(logPath).replace(/\d/g, "[0123456789]").replace(/-\.log$/, "*.log")), files = await glob(globify(logGlob), {
              ignore: this.#files.map(globify),
              silent: !0
            }), toDelete = files.length - this.#logsMax;
            if (toDelete <= 0) return;
            log.silly("logfile", `start cleaning logs, removing ${toDelete} files`);
            for (const file of files.slice(0, toDelete)) try {
              await rimraf(file, {
                glob: !1
              });
            } catch (e) {
              log.silly("logfile", "error removing log file", file, e);
            }
          } catch (e) {
            log.warn("logfile", "error cleaning log files", e);
          } finally {
            log.silly("logfile", "done cleaning log files");
          }
        }
      }
      module.exports = LogFiles;
    },
    86883: (module, __unused_webpack_exports, __webpack_require__) => {
      const NPMLOG = __webpack_require__(19334), PROCLOG = __webpack_require__(46521), accessors = (obj, set) => k => ({
        get: () => obj[k],
        set: set ? v => obj[k] = v : () => {
          throw new Error(`Cant set ${k}`);
        }
      }), value = obj => k => ({
        value: (...args) => obj[k].apply(obj, args)
      }), properties = {
        level: accessors(NPMLOG, !0),
        heading: accessors(NPMLOG, !0),
        levels: accessors(NPMLOG),
        gauge: accessors(NPMLOG),
        stream: accessors(NPMLOG),
        tracker: accessors(NPMLOG),
        progressEnabled: accessors(NPMLOG),
        useColor: value(NPMLOG),
        enableColor: value(NPMLOG),
        disableColor: value(NPMLOG),
        enableUnicode: value(NPMLOG),
        disableUnicode: value(NPMLOG),
        enableProgress: value(NPMLOG),
        disableProgress: value(NPMLOG),
        clearProgress: value(NPMLOG),
        showProgress: value(NPMLOG),
        newItem: value(NPMLOG),
        newGroup: value(NPMLOG),
        notice: value(PROCLOG),
        error: value(PROCLOG),
        warn: value(PROCLOG),
        info: value(PROCLOG),
        verbose: value(PROCLOG),
        http: value(PROCLOG),
        silly: value(PROCLOG),
        pause: value(PROCLOG),
        resume: value(PROCLOG)
      }, descriptors = Object.entries(properties).reduce(((acc, [k, v]) => (acc[k] = {
        enumerable: !0,
        ...v(k)
      }, acc)), {});
      module.exports = Object.freeze(Object.defineProperties({}, descriptors));
    },
    7425: (module, __unused_webpack_exports, __webpack_require__) => {
      const readline = __webpack_require__(14521), opener = __webpack_require__(95815);
      module.exports = async (npm, url, title, prompt, emitter) => {
        const browser = npm.config.get("browser"), isInteractive = !0 === process.stdin.isTTY && !0 === process.stdout.isTTY;
        try {
          if (!/^https?:$/.test(new URL(url).protocol)) throw new Error;
        } catch (_) {
          throw new Error("Invalid URL: " + url);
        }
        if (function(npm, title, url) {
          const message = npm.config.get("json") ? JSON.stringify({
            title,
            url
          }) : `${title}:\n${url}`;
          npm.output(message);
        }(npm, title, url), !1 === browser || !isInteractive) return;
        const rl = readline.createInterface({
          input: process.stdin,
          output: process.stdout
        }), tryOpen = await new Promise((resolve => {
          rl.on("SIGINT", (() => {
            rl.close(), resolve("SIGINT");
          })), rl.question(prompt, (() => {
            resolve(!0);
          })), emitter && emitter.addListener && emitter.addListener("abort", (() => {
            rl.close(), npm.output(""), resolve(!1);
          }));
        }));
        if ("SIGINT" === tryOpen) throw new Error("canceled");
        if (!tryOpen) return;
        const command = !0 === browser ? null : browser;
        await new Promise(((resolve, reject) => {
          opener(url, {
            command
          }, (err => err ? reject(err) : resolve()));
        }));
      };
    },
    89562: (module, __unused_webpack_exports, __webpack_require__) => {
      const opener = __webpack_require__(95815), {URL} = __webpack_require__(57310);
      module.exports = async (npm, url, errMsg, isFile) => {
        url = encodeURI(url);
        const browser = npm.config.get("browser");
        function printAlternateMsg() {
          const alternateMsg = npm.config.get("json") ? JSON.stringify({
            title: errMsg,
            url
          }, null, 2) : `${errMsg}:\n  ${url}\n`;
          npm.output(alternateMsg);
        }
        if (!1 === browser) return void printAlternateMsg();
        if (!isFile) try {
          if (!/^https?:$/.test(new URL(url).protocol)) throw new Error;
        } catch (_) {
          throw new Error("Invalid URL: " + url);
        }
        const command = !0 === browser ? null : browser;
        await new Promise(((resolve, reject) => {
          opener(url, {
            command
          }, (err => {
            if (err) {
              if ("ENOENT" !== err.code) return reject(err);
              printAlternateMsg();
            }
            return resolve();
          }));
        }));
      };
    },
    83304: (module, __unused_webpack_exports, __webpack_require__) => {
      const log = __webpack_require__(86883);
      module.exports = async function(npm, opts, fn) {
        try {
          return await fn(opts);
        } catch (err) {
          if (!process.stdin.isTTY || !process.stdout.isTTY) throw err;
          if (function(err) {
            if ("EOTP" === !err.code || !err.body) return !1;
            return err.body.authUrl && err.body.doneUrl;
          }(err)) {
            log.disableProgress();
            const webAuth = __webpack_require__(50934), openUrlPrompt = __webpack_require__(7425), openerPromise = (url, emitter) => openUrlPrompt(npm, url, "Authenticate your account at", "Press ENTER to open in the browser...", emitter), otp = await webAuth(openerPromise, err.body.authUrl, err.body.doneUrl, opts);
            return await fn({
              ...opts,
              otp
            });
          }
          if (function(err) {
            return "EOTP" === err.code || "E401" === err.code && /one-time pass/.test(err.body);
          }(err)) {
            const readUserInfo = __webpack_require__(87121), otp = await readUserInfo.otp("This operation requires a one-time password.\nEnter OTP:");
            return await fn({
              ...opts,
              otp
            });
          }
          throw err;
        }
      };
    },
    24087: (module, __unused_webpack_exports, __webpack_require__) => {
      const fetch = __webpack_require__(92427);
      module.exports = async flatOptions => (await fetch("/-/ping?write=true", flatOptions)).json().catch((() => ({})));
    },
    26549: (module, __unused_webpack_exports, __webpack_require__) => {
      const log = __webpack_require__(86883);
      let pulseTimer = null;
      const pulseStart = () => {
        pulseTimer = pulseTimer || setInterval((() => {
          log.gauge.pulse("");
        }), 150);
      }, pulseStop = () => {
        clearInterval(pulseTimer), pulseTimer = null;
      };
      module.exports = {
        withPromise: async promise => {
          pulseStart();
          try {
            return await promise;
          } finally {
            pulseStop();
          }
        }
      };
    },
    58113: (module, __unused_webpack_exports, __webpack_require__) => {
      const util = __webpack_require__(73837), _data = Symbol("data"), _delete = Symbol("delete"), _append = Symbol("append"), replaceAppendSymbols = str => {
        const matchEmptyBracket = str.match(/^(.*)\[\]\.?(.*)$/);
        if (matchEmptyBracket) {
          const [, pre, post] = matchEmptyBracket;
          return [ ...replaceAppendSymbols(pre), _append, post ].filter(Boolean);
        }
        return [ str ];
      }, parseKeys = key => {
        const sqBracketItems = new Set;
        sqBracketItems.add(_append);
        const parseSqBrackets = str => {
          const index = (str => str.match(/(.+)\[([^\]]+)\]\.?(.*)$/))(str);
          if (index) {
            const preSqBracketPortion = index[1], foundKey = new String(index[2]), postSqBracketPortion = index[3];
            return sqBracketItems.add(foundKey), [ ...parseSqBrackets(preSqBracketPortion), foundKey, ...postSqBracketPortion ? parseSqBrackets(postSqBracketPortion) : [] ];
          }
          return replaceAppendSymbols(str);
        }, res = [], sqBracketKeys = parseSqBrackets(key.trim());
        for (const k of sqBracketKeys) if (sqBracketItems.has(k)) res.push(k); else for (const splitKey of k.split(".")) res.push(String(splitKey));
        return res;
      }, setter = ({data, key, value, force}) => {
        const keys = parseKeys(key), setKeys = (_data, _key) => {
          let maybeIndex = Number.NaN;
          try {
            maybeIndex = Number(_key);
          } catch {}
          Number.isNaN(maybeIndex) || (_key = maybeIndex);
          const keyIsAnArrayIndex = _key === maybeIndex || _key === _append, dataHasNoItems = !Object.keys(_data).length;
          if (keyIsAnArrayIndex && dataHasNoItems && !Array.isArray(_data) && (_data = []), 
          force && Array.isArray(_data) && !keyIsAnArrayIndex && (_data = {
            ..._data
          }), _key === _append) {
            if (!Array.isArray(_data)) throw Object.assign(new Error("Can't use append syntax in non-Array element"), {
              code: "ENOAPPEND"
            });
            _key = _data.length;
          }
          return keys.length ? _data[_key] = setKeys((() => {
            const haveContents = !force && null != _data[_key] && value !== _delete, shouldNotOverrideLiteralValue = !("object" == typeof _data[_key]), shouldNotAddPropsToArrays = "symbol" != typeof keys[0] && Array.isArray(_data[_key]) && Number.isNaN(Number(keys[0]));
            if (haveContents && shouldNotOverrideLiteralValue) throw Object.assign(new Error(`Property ${_key} already exists and is not an Array or Object.`), {
              code: "EOVERRIDEVALUE"
            });
            if (haveContents && shouldNotAddPropsToArrays) throw Object.assign(new Error(`Can't add property ${key} to an Array.`), {
              code: "ENOADDPROP"
            });
            return "object" == typeof _data[_key] && _data[_key] || {};
          })(), keys.shift()) : value === _delete ? Array.isArray(_data) ? _data.splice(_key, 1) : delete _data[_key] : _data[_key] = value, 
          _data;
        };
        setKeys(data, keys.shift());
      };
      class Queryable {
        constructor(obj) {
          if (!obj || "object" != typeof obj) throw Object.assign(new Error("Queryable needs an object to query properties from."), {
            code: "ENOQUERYABLEOBJ"
          });
          this[_data] = obj;
        }
        query(queries) {
          if ("" === queries) return {
            "": this[_data]
          };
          const q = query => (({data, key}) => {
            const keys = parseKeys(key);
            let _data = data, label = "";
            for (const k of keys) {
              if (k === _append) throw Object.assign(new Error("Empty brackets are not valid syntax for retrieving values."), {
                code: "EINVALIDSYNTAX"
              });
              const maybeIndex = Number(k);
              if (Array.isArray(_data) && !Number.isInteger(maybeIndex)) return _data = _data.reduce(((acc, i, index) => (acc[`${label}[${index}].${k}`] = i[k], 
              acc)), {}), _data;
              if (!_data[k]) return;
              _data = _data[k], label += k;
            }
            return Array.isArray(_data) && _data.length <= 1 && (_data = _data[0]), {
              [key]: _data
            };
          })({
            data: this[_data],
            key: query
          });
          if (Array.isArray(queries)) {
            let res = {};
            for (const query of queries) res = {
              ...res,
              ...q(query)
            };
            return res;
          }
          return q(queries);
        }
        get(query) {
          const obj = this.query(query);
          if (obj) return obj[query];
        }
        set(query, value, {force} = {}) {
          setter({
            data: this[_data],
            key: query,
            value,
            force
          });
        }
        delete(query) {
          setter({
            data: this[_data],
            key: query,
            value: _delete
          });
        }
        toJSON() {
          return this[_data];
        }
        [util.inspect.custom]() {
          return this.toJSON();
        }
      }
      module.exports = Queryable;
    },
    87121: (__unused_webpack_module, exports, __webpack_require__) => {
      const {promisify} = __webpack_require__(73837), readAsync = promisify(__webpack_require__(9547)), userValidate = __webpack_require__(49598), log = __webpack_require__(86883);
      exports.otp = function readOTP(msg = "This command requires a one-time password (OTP) from your authenticator app.\nEnter one below. You can also pass one on the command line by appending --otp=123456.\nFor more information, see:\nhttps://docs.npmjs.com/getting-started/using-two-factor-authentication\nEnter OTP: ", otp, isRetry) {
        if (isRetry && otp && /^[\d ]+$|^[A-Fa-f0-9]{64,64}$/.test(otp)) return otp.replace(/\s+/g, "");
        return read({
          prompt: msg,
          default: otp || ""
        }).then((otp => readOTP(msg, otp, !0)));
      }, exports.password = function readPassword(msg = "npm password: ", password, isRetry) {
        if (isRetry && password) return password;
        return read({
          prompt: msg,
          silent: !0,
          default: password || ""
        }).then((password => readPassword(msg, password, !0)));
      }, exports.username = function readUsername(msg = "npm username: ", username, isRetry) {
        if (isRetry && username) {
          const error = userValidate.username(username);
          if (!error) return Promise.resolve(username.trim());
          log.warn(error.message);
        }
        return read({
          prompt: msg,
          default: username || ""
        }).then((username => readUsername(msg, username, !0)));
      }, exports.email = function readEmail(msg = "email (this IS public): ", email, isRetry) {
        if (isRetry && email) {
          const error = userValidate.email(email);
          if (!error) return email.trim();
          log.warn(error.message);
        }
        return read({
          prompt: msg,
          default: email || ""
        }).then((username => readEmail(msg, username, !0)));
      };
      function read(opts) {
        return log.clearProgress(), readAsync(opts).finally((() => log.showProgress()));
      }
    },
    2648: (module, __unused_webpack_exports, __webpack_require__) => {
      const reifyOutput = __webpack_require__(3220), ini = __webpack_require__(92869), {writeFile} = __webpack_require__(57147).promises, {resolve} = __webpack_require__(71017), saveBuiltinConfig = async (npm, arb) => {
        const {options: {global}, actualTree} = arb;
        if (!global) return;
        const npmNode = actualTree.inventory.get("node_modules/npm");
        if (!npmNode) return;
        const builtinConf = npm.config.data.get("builtin");
        if (builtinConf.loadError) return;
        const content = ini.stringify(builtinConf.raw).trim() + "\n";
        await writeFile(resolve(npmNode.path, "npmrc"), content);
      };
      module.exports = async (npm, arb) => {
        await saveBuiltinConfig(npm, arb), reifyOutput(npm, arb);
      };
    },
    3220: (module, __unused_webpack_exports, __webpack_require__) => {
      const log = __webpack_require__(86883), {depth} = __webpack_require__(75476), ms = __webpack_require__(4682), auditReport = __webpack_require__(75126), {readTree: getFundingInfo} = __webpack_require__(77881), auditError = __webpack_require__(21674), printAuditReport = (npm, report) => {
        const res = getAuditReport(npm, report);
        res && res.report && npm.output(`\n${res.report}`);
      }, getAuditReport = (npm, report) => {
        if (!report) return;
        const reporter = npm.silent || npm.flatOptions.json ? "quiet" : "audit" !== npm.command ? "install" : "detail", defaultAuditLevel = "audit" !== npm.command ? "none" : "low", auditLevel = npm.flatOptions.auditLevel || defaultAuditLevel, res = auditReport(report, {
          reporter,
          ...npm.flatOptions,
          auditLevel
        });
        return "audit" === npm.command && (process.exitCode = process.exitCode || res.exitCode), 
        res;
      }, packagesChangedMessage = (npm, {added, removed, changed, audited}) => {
        const msg = [ "\n" ];
        0 === added && 0 === removed && 0 === changed ? (msg.push("up to date"), audited && msg.push(", ")) : (added && msg.push(`added ${added} package${1 === added ? "" : "s"}`), 
        removed && (added && msg.push(", "), !added || audited || changed || msg.push("and "), 
        msg.push(`removed ${removed} package${1 === removed ? "" : "s"}`)), changed && ((added || removed) && msg.push(", "), 
        audited || !added && !removed || msg.push("and "), msg.push(`changed ${changed} package${1 === changed ? "" : "s"}`)), 
        audited && msg.push(", and ")), audited && msg.push(`audited ${audited} package${1 === audited ? "" : "s"}`), 
        msg.push(` in ${ms(Date.now() - npm.started)}`), npm.output(msg.join(""));
      }, packagesFundingMessage = (npm, {funding}) => {
        if (!funding) return;
        npm.output("");
        const pkg = 1 === funding ? "package" : "packages", is = 1 === funding ? "is" : "are";
        npm.output(`${funding} ${pkg} ${is} looking for funding`), npm.output("  run `npm fund` for details");
      };
      module.exports = (npm, arb) => {
        const {diff, actualTree} = arb, auditReport = auditError(npm, arb.auditReport) ? null : arb.auditReport;
        if (npm.silent) return void getAuditReport(npm, auditReport);
        const summary = {
          added: 0,
          removed: 0,
          changed: 0,
          audited: auditReport && !auditReport.error ? actualTree.inventory.size : 0,
          funding: 0
        };
        if (diff && depth({
          tree: diff,
          visit: d => {
            switch (d.action) {
             case "REMOVE":
              summary.removed++;
              break;

             case "ADD":
              actualTree.inventory.has(d.ideal) && summary.added++;
              break;

             case "CHANGE":
              summary.changed++;
              break;

             default:
              return;
            }
            const node = d.actual || d.ideal;
            log.silly(d.action, node.location);
          },
          getChildren: d => d.children
        }), npm.flatOptions.fund) {
          const fundingInfo = getFundingInfo(actualTree, {
            countOnly: !0
          });
          summary.funding = fundingInfo.length;
        }
        npm.flatOptions.json ? (auditReport && (getAuditReport(npm, auditReport), summary.audit = "audit" === npm.command ? auditReport : auditReport.toJSON().metadata), 
        npm.output(JSON.stringify(summary, 0, 2))) : (packagesChangedMessage(npm, summary), 
        packagesFundingMessage(npm, summary), printAuditReport(npm, auditReport));
      };
    },
    45042: (module, __unused_webpack_exports, __webpack_require__) => {
      const {cleanUrl} = __webpack_require__(92427), isString = v => "string" == typeof v, splitAndReplace = str => {
        const splitChars = /[\s=]/g;
        let match = null, result = "", index = 0;
        for (;match = splitChars.exec(str); ) result += cleanUrl(str.slice(index, match.index)) + match[0], 
        index = splitChars.lastIndex;
        return result + cleanUrl(str.slice(index));
      };
      module.exports = function(arg) {
        return isString(arg) ? splitAndReplace(arg) : Array.isArray(arg) ? arg.map((a => isString(a) ? splitAndReplace(a) : a)) : arg;
      };
    },
    31988: (module, __unused_webpack_exports, __webpack_require__) => {
      const tar = __webpack_require__(39148), ssri = __webpack_require__(60440), log = __webpack_require__(86883), formatBytes = __webpack_require__(76761), columnify = __webpack_require__(75231), localeCompare = __webpack_require__(51031)("en", {
        sensitivity: "case",
        numeric: !0
      });
      module.exports = {
        logTar: (tarball, opts = {}) => {
          const {unicode = !1} = opts;
          log.notice(""), log.notice("", `${unicode ? " " : "package:"} ${tarball.name}@${tarball.version}`), 
          log.notice("=== Tarball Contents ==="), tarball.files.length && log.notice("", columnify(tarball.files.map((f => {
            const bytes = formatBytes(f.size, !1);
            return /^node_modules\//.test(f.path) ? null : {
              path: f.path,
              size: `${bytes}`
            };
          })).filter((f => f)), {
            include: [ "size", "path" ],
            showHeaders: !1
          })), tarball.bundled.length && (log.notice("=== Bundled Dependencies ==="), tarball.bundled.forEach((name => log.notice("", name)))), 
          log.notice("=== Tarball Details ==="), log.notice("", columnify([ {
            name: "name:",
            value: tarball.name
          }, {
            name: "version:",
            value: tarball.version
          }, tarball.filename && {
            name: "filename:",
            value: tarball.filename
          }, {
            name: "package size:",
            value: formatBytes(tarball.size)
          }, {
            name: "unpacked size:",
            value: formatBytes(tarball.unpackedSize)
          }, {
            name: "shasum:",
            value: tarball.shasum
          }, {
            name: "integrity:",
            value: tarball.integrity.toString().slice(0, 20) + "[...]" + tarball.integrity.toString().slice(80)
          }, tarball.bundled.length && {
            name: "bundled deps:",
            value: tarball.bundled.length
          }, tarball.bundled.length && {
            name: "bundled files:",
            value: tarball.entryCount - tarball.files.length
          }, tarball.bundled.length && {
            name: "own files:",
            value: tarball.files.length
          }, {
            name: "total files:",
            value: tarball.entryCount
          } ].filter((x => x)), {
            include: [ "name", "value" ],
            showHeaders: !1
          })), log.notice("", "");
        },
        getContents: async (manifest, tarball) => {
          const files = [], bundled = new Set;
          let totalEntries = 0, totalEntrySize = 0;
          tar.t({
            onentry(entry) {
              totalEntries++, totalEntrySize += entry.size;
              const p = entry.path;
              if (p.startsWith("package/node_modules/")) {
                const name = p.match(/^package\/node_modules\/((?:@[^/]+\/)?[^/]+)/)[1];
                bundled.add(name);
              }
              files.push({
                path: entry.path.replace(/^package\//, ""),
                size: entry.size,
                mode: entry.mode
              });
            }
          }).end(tarball);
          const integrity = await ssri.fromData(tarball, {
            algorithms: [ "sha1", "sha512" ]
          }), comparator = ({path: a}, {path: b}) => localeCompare(a, b), isUpper = str => {
            const ch = str.charAt(0);
            return ch === ch.toUpperCase();
          }, uppers = files.filter((file => isUpper(file.path))), others = files.filter((file => !isUpper(file.path)));
          uppers.sort(comparator), others.sort(comparator);
          const shasum = integrity.sha1[0].hexDigest();
          return {
            id: manifest._id || `${manifest.name}@${manifest.version}`,
            name: manifest.name,
            version: manifest.version,
            size: tarball.length,
            unpackedSize: totalEntrySize,
            shasum,
            integrity: ssri.parse(integrity.sha512[0]),
            filename: `${manifest.name}-${manifest.version}.tgz`,
            files: uppers.concat(others),
            entryCount: totalEntries,
            bundled: Array.from(bundled)
          };
        }
      };
    },
    61682: (module, __unused_webpack_exports, __webpack_require__) => {
      const EE = __webpack_require__(82361), {resolve} = __webpack_require__(71017), fs = __webpack_require__(45264), log = __webpack_require__(86883), _timeListener = Symbol("timeListener"), _timeEndListener = Symbol("timeEndListener"), _init = Symbol("init");
      module.exports = class extends EE {
        file=null;
        #unfinished=new Map;
        #finished={};
        #onTimeEnd=Symbol("onTimeEnd");
        #initialListener=null;
        #initialTimer=null;
        constructor({listener = null, start = "npm"} = {}) {
          super(), this.#initialListener = listener, this.#initialTimer = start, this[_init]();
        }
        get unfinished() {
          return this.#unfinished;
        }
        get finished() {
          return this.#finished;
        }
        [_init]() {
          this.on(), this.#initialListener && this.on(this.#initialListener), process.emit("time", this.#initialTimer), 
          this.started = this.#unfinished.get(this.#initialTimer);
        }
        on(listener) {
          listener ? super.on(this.#onTimeEnd, listener) : (process.on("time", this[_timeListener]), 
          process.on("timeEnd", this[_timeEndListener]));
        }
        off(listener) {
          listener ? super.off(this.#onTimeEnd, listener) : (this.removeAllListeners(this.#onTimeEnd), 
          process.off("time", this[_timeListener]), process.off("timeEnd", this[_timeEndListener]));
        }
        time(name, fn) {
          process.emit("time", name);
          const end = () => process.emit("timeEnd", name);
          if ("function" == typeof fn) {
            const res = fn();
            return res && res.finally ? res.finally(end) : (end(), res);
          }
          return end;
        }
        load({dir} = {}) {
          dir && (this.file = resolve(dir, "_timing.json"));
        }
        writeFile(fileData) {
          if (this.file) try {
            const globalStart = this.started, globalEnd = this.#finished.npm || Date.now(), content = {
              ...fileData,
              ...this.#finished,
              unfinished: [ ...this.#unfinished.entries() ].reduce(((acc, [name, start]) => (acc[name] = [ start - globalStart, globalEnd - globalStart ], 
              acc)), {})
            };
            fs.withOwnerSync(this.file, (() => fs.appendFileSync(this.file, JSON.stringify(content) + "\n")), {
              owner: "inherit"
            });
          } catch (e) {
            this.file = null, log.warn("timing", `could not write timing file: ${e}`);
          }
        }
        [_timeListener]=name => {
          this.#unfinished.set(name, Date.now());
        };
        [_timeEndListener]=name => {
          if (this.#unfinished.has(name)) {
            const ms = Date.now() - this.#unfinished.get(name);
            this.#finished[name] = ms, this.#unfinished.delete(name), this.emit(this.#onTimeEnd, name, ms);
          } else log.silly("timing", "Tried to end timer that doesn't exist:", name);
        };
      };
    },
    36533: (module, __unused_webpack_exports, __webpack_require__) => {
      const pacote = __webpack_require__(86585), ciDetect = __webpack_require__(21811), semver = __webpack_require__(5870), chalk = __webpack_require__(25433), {promisify} = __webpack_require__(73837), stat = promisify(__webpack_require__(57147).stat), writeFile = promisify(__webpack_require__(57147).writeFile), {resolve} = __webpack_require__(71017), SKIP = Symbol("SKIP"), lastCheckedFile = npm => resolve(npm.flatOptions.cache, "../_update-notifier-last-checked"), updateNotifier = async (npm, spec = "latest") => {
        if (!npm.config.get("update-notifier") || (npm => npm.flatOptions.global && [ "install", "update" ].includes(npm.command) && npm.argv.some((arg => /^npm(@|$)/.test(arg))))(npm) || ciDetect()) return SKIP;
        const {version} = npm, current = semver.parse(version);
        current.prerelease.length && (spec = `^${version}`);
        const duration = "latest" !== spec ? 864e5 : 6048e5;
        if (!await (async (npm, duration) => {
          const t = new Date(Date.now() - duration), f = lastCheckedFile(npm), st = await stat(f).catch((() => ({
            mtime: t - 1
          })));
          return t > st.mtime;
        })(npm, duration)) return null;
        const useColor = npm.logColor, mani = await pacote.manifest(`npm@${spec}`, {
          defaultTag: "latest",
          ...npm.flatOptions
        }).catch((() => null));
        if (!mani) return null;
        const latest = mani.version;
        if (semver.gt(version, latest) && "latest" === spec) return updateNotifier(npm, `^${version}`);
        if (semver.gte(version, latest)) return null;
        const update = semver.parse(mani.version), type = update.major !== current.major ? "major" : update.minor !== current.minor ? "minor" : update.patch !== current.patch ? "patch" : "prerelease", changelog = `https://github.com/npm/cli/releases/tag/v${latest}`, cmd = `npm install -g npm@${latest}`;
        return `\nNew ${useColor ? "major" === type ? chalk.red(type) : "minor" === type ? chalk.yellow(type) : chalk.green(type) : type} version of npm available! ${useColor ? chalk.red(current) : current} -> ${useColor ? chalk.green(latest) : latest}\nChangelog: ${useColor ? chalk.cyan(changelog) : `<${changelog}>`}\nRun ${useColor ? chalk.green(cmd) : `\`${cmd}\``} to update!\n`;
      };
      module.exports = async npm => {
        const notification = await updateNotifier(npm);
        return notification === SKIP ? null : (writeFile(lastCheckedFile(npm), "").catch((() => {})), 
        notification);
      };
    },
    85326: module => {
      module.exports = function(virtualTree, idealTree) {
        const errors = [];
        for (const [key, entry] of idealTree.entries()) {
          const lock = virtualTree.get(key);
          lock ? entry.version !== lock.version && errors.push(`Invalid: lock file's ${lock.name}@${lock.version} does not satisfy ${entry.name}@${entry.version}`) : errors.push(`Missing: ${entry.name}@${entry.version} from lock file`);
        }
        return errors;
      };
    },
    50934: (module, __unused_webpack_exports, __webpack_require__) => {
      const EventEmitter = __webpack_require__(82361), {webAuthCheckLogin} = __webpack_require__(77969);
      module.exports = async function(opener, initialUrl, doneUrl, opts) {
        const doneEmitter = new EventEmitter, openPromise = opener(initialUrl, doneEmitter), webAuthCheckPromise = webAuthCheckLogin(doneUrl, {
          ...opts,
          cache: !1
        }).then((authResult => (doneEmitter.emit("abort"), authResult.token)));
        return await openPromise, await webAuthCheckPromise;
      };
    },
    2143: (module, __unused_webpack_exports, __webpack_require__) => {
      const {resolve, relative} = __webpack_require__(71017), mapWorkspaces = __webpack_require__(69960), minimatch = __webpack_require__(51191), rpj = __webpack_require__(1759), globify = pattern => pattern.split("\\").join("/");
      module.exports = async (filters, {path, includeWorkspaceRoot, relativeFrom}) => {
        const pkg = await rpj(resolve(path, "package.json")), workspaces = await mapWorkspaces({
          cwd: path,
          pkg
        });
        let res = new Map;
        includeWorkspaceRoot && res.set(pkg.name, path), filters.length || (res = new Map([ ...res, ...workspaces ]));
        for (const filterArg of filters) for (const [workspaceName, workspacePath] of workspaces.entries()) {
          let relativePath = relative(relativeFrom, workspacePath);
          filterArg.startsWith("./") && (relativePath = `./${relativePath}`);
          const relativeFilter = relative(path, filterArg);
          (filterArg === workspaceName || resolve(relativeFrom, filterArg) === workspacePath || minimatch(relativePath, `${globify(relativeFilter)}/*`) || minimatch(relativePath, `${globify(filterArg)}/*`)) && res.set(workspaceName, workspacePath);
        }
        if (!res.size) {
          let msg = "!";
          throw filters.length && (msg = `:\n ${filters.reduce(((res, filterArg) => `${res} --workspace=${filterArg}`), "")}`), 
          new Error(`No workspaces found${msg}`);
        }
        return res;
      };
    },
    43644: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const Arborist = __webpack_require__(22290), reifyFinish = __webpack_require__(2648);
      module.exports = async function({config, flatOptions, localPrefix, npm, workspaces}) {
        if (!flatOptions.workspacesUpdate || !workspaces.length) return;
        const save = !config.isDefault("save") && config.get("save"), opts = {
          ...flatOptions,
          audit: !1,
          fund: !1,
          path: localPrefix,
          save
        }, arb = new Arborist(opts);
        await arb.reify({
          ...opts,
          update: workspaces
        }), await reifyFinish(npm, arb);
      };
    },
    21845: (module, __unused_webpack_exports, __webpack_require__) => {
      var colors = {};
      module.exports = colors, colors.themes = {};
      var util = __webpack_require__(73837), ansiStyles = colors.styles = __webpack_require__(28585), defineProps = Object.defineProperties, newLineRegex = new RegExp(/[\r\n]+/g);
      colors.supportsColor = __webpack_require__(47011).supportsColor, void 0 === colors.enabled && (colors.enabled = !1 !== colors.supportsColor()), 
      colors.enable = function() {
        colors.enabled = !0;
      }, colors.disable = function() {
        colors.enabled = !1;
      }, colors.stripColors = colors.strip = function(str) {
        return ("" + str).replace(/\x1B\[\d+m/g, "");
      };
      colors.stylize = function(str, style) {
        if (!colors.enabled) return str + "";
        var styleMap = ansiStyles[style];
        return !styleMap && style in colors ? colors[style](str) : styleMap.open + str + styleMap.close;
      };
      var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
      function build(_styles) {
        var builder = function builder() {
          return applyStyle.apply(builder, arguments);
        };
        return builder._styles = _styles, builder.__proto__ = proto, builder;
      }
      var ret, styles = (ret = {}, ansiStyles.grey = ansiStyles.gray, Object.keys(ansiStyles).forEach((function(key) {
        ansiStyles[key].closeRe = new RegExp(function(str) {
          if ("string" != typeof str) throw new TypeError("Expected a string");
          return str.replace(matchOperatorsRe, "\\$&");
        }(ansiStyles[key].close), "g"), ret[key] = {
          get: function() {
            return build(this._styles.concat(key));
          }
        };
      })), ret), proto = defineProps((function() {}), styles);
      function applyStyle() {
        var args = Array.prototype.slice.call(arguments), str = args.map((function(arg) {
          return null != arg && arg.constructor === String ? arg : util.inspect(arg);
        })).join(" ");
        if (!colors.enabled || !str) return str;
        for (var newLinesPresent = -1 != str.indexOf("\n"), nestedStyles = this._styles, i = nestedStyles.length; i--; ) {
          var code = ansiStyles[nestedStyles[i]];
          str = code.open + str.replace(code.closeRe, code.open) + code.close, newLinesPresent && (str = str.replace(newLineRegex, (function(match) {
            return code.close + match + code.open;
          })));
        }
        return str;
      }
      colors.setTheme = function(theme) {
        if ("string" != typeof theme) for (var style in theme) !function(style) {
          colors[style] = function(str) {
            if ("object" == typeof theme[style]) {
              var out = str;
              for (var i in theme[style]) out = colors[theme[style][i]](out);
              return out;
            }
            return colors[theme[style]](str);
          };
        }(style); else console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
      };
      var sequencer = function(map, str) {
        var exploded = str.split("");
        return (exploded = exploded.map(map)).join("");
      };
      for (var map in colors.trap = __webpack_require__(91301), colors.zalgo = __webpack_require__(50627), 
      colors.maps = {}, colors.maps.america = __webpack_require__(94713)(colors), colors.maps.zebra = __webpack_require__(76026)(colors), 
      colors.maps.rainbow = __webpack_require__(76466)(colors), colors.maps.random = __webpack_require__(82644)(colors), 
      colors.maps) !function(map) {
        colors[map] = function(str) {
          return sequencer(colors.maps[map], str);
        };
      }(map);
      defineProps(colors, function() {
        var ret = {};
        return Object.keys(styles).forEach((function(name) {
          ret[name] = {
            get: function() {
              return build([ name ]);
            }
          };
        })), ret;
      }());
    },
    91301: module => {
      module.exports = function(text, options) {
        var result = "";
        text = (text = text || "Run the trap, drop the bass").split("");
        var trap = {
          a: [ "@", "", "", "", "", "", "" ],
          b: [ "", "", "", "", "", "" ],
          c: [ "", "", "" ],
          d: [ "", "", "", "", "", "" ],
          e: [ "", "", "", "", "", "", "", "" ],
          f: [ "" ],
          g: [ "" ],
          h: [ "", "", "", "", "", "" ],
          i: [ "" ],
          j: [ "" ],
          k: [ "", "", "", "" ],
          l: [ "" ],
          m: [ "", "", "", "", "", "" ],
          n: [ "", "", "", "", "", "" ],
          o: [ "", "", "", "", "", "", "", "", "" ],
          p: [ "", "" ],
          q: [ "" ],
          r: [ "", "", "", "", "", "" ],
          s: [ "", "", "", "" ],
          t: [ "", "", "" ],
          u: [ "", "" ],
          v: [ "" ],
          w: [ "", "", "", "" ],
          x: [ "", "", "", "" ],
          y: [ "", "", "" ],
          z: [ "", "" ]
        };
        return text.forEach((function(c) {
          c = c.toLowerCase();
          var chars = trap[c] || [ " " ], rand = Math.floor(Math.random() * chars.length);
          result += void 0 !== trap[c] ? trap[c][rand] : c;
        })), result;
      };
    },
    50627: module => {
      module.exports = function(text, options) {
        text = text || "   he is here   ";
        var soul = {
          up: [ "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "" ],
          down: [ "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "" ],
          mid: [ "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", " " ]
        }, all = [].concat(soul.up, soul.down, soul.mid);
        function randomNumber(range) {
          return Math.floor(Math.random() * range);
        }
        function isChar(character) {
          var bool = !1;
          return all.filter((function(i) {
            bool = i === character;
          })), bool;
        }
        return function(text, options) {
          var counts, l, result = "";
          for (l in (options = options || {}).up = void 0 === options.up || options.up, options.mid = void 0 === options.mid || options.mid, 
          options.down = void 0 === options.down || options.down, options.size = void 0 !== options.size ? options.size : "maxi", 
          text = text.split("")) if (!isChar(l)) {
            switch (result += text[l], counts = {
              up: 0,
              down: 0,
              mid: 0
            }, options.size) {
             case "mini":
              counts.up = randomNumber(8), counts.mid = randomNumber(2), counts.down = randomNumber(8);
              break;

             case "maxi":
              counts.up = randomNumber(16) + 3, counts.mid = randomNumber(4) + 1, counts.down = randomNumber(64) + 3;
              break;

             default:
              counts.up = randomNumber(8) + 1, counts.mid = randomNumber(6) / 2, counts.down = randomNumber(8) + 1;
            }
            var arr = [ "up", "mid", "down" ];
            for (var d in arr) for (var index = arr[d], i = 0; i <= counts[index]; i++) options[index] && (result += soul[index][randomNumber(soul[index].length)]);
          }
          return result;
        }(text, options);
      };
    },
    94713: module => {
      module.exports = function(colors) {
        return function(letter, i, exploded) {
          if (" " === letter) return letter;
          switch (i % 3) {
           case 0:
            return colors.red(letter);

           case 1:
            return colors.white(letter);

           case 2:
            return colors.blue(letter);
          }
        };
      };
    },
    76466: module => {
      module.exports = function(colors) {
        var rainbowColors = [ "red", "yellow", "green", "blue", "magenta" ];
        return function(letter, i, exploded) {
          return " " === letter ? letter : colors[rainbowColors[i++ % rainbowColors.length]](letter);
        };
      };
    },
    82644: module => {
      module.exports = function(colors) {
        var available = [ "underline", "inverse", "grey", "yellow", "red", "green", "blue", "white", "cyan", "magenta", "brightYellow", "brightRed", "brightGreen", "brightBlue", "brightWhite", "brightCyan", "brightMagenta" ];
        return function(letter, i, exploded) {
          return " " === letter ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
        };
      };
    },
    76026: module => {
      module.exports = function(colors) {
        return function(letter, i, exploded) {
          return i % 2 == 0 ? letter : colors.inverse(letter);
        };
      };
    },
    28585: module => {
      var styles = {};
      module.exports = styles;
      var codes = {
        reset: [ 0, 0 ],
        bold: [ 1, 22 ],
        dim: [ 2, 22 ],
        italic: [ 3, 23 ],
        underline: [ 4, 24 ],
        inverse: [ 7, 27 ],
        hidden: [ 8, 28 ],
        strikethrough: [ 9, 29 ],
        black: [ 30, 39 ],
        red: [ 31, 39 ],
        green: [ 32, 39 ],
        yellow: [ 33, 39 ],
        blue: [ 34, 39 ],
        magenta: [ 35, 39 ],
        cyan: [ 36, 39 ],
        white: [ 37, 39 ],
        gray: [ 90, 39 ],
        grey: [ 90, 39 ],
        brightRed: [ 91, 39 ],
        brightGreen: [ 92, 39 ],
        brightYellow: [ 93, 39 ],
        brightBlue: [ 94, 39 ],
        brightMagenta: [ 95, 39 ],
        brightCyan: [ 96, 39 ],
        brightWhite: [ 97, 39 ],
        bgBlack: [ 40, 49 ],
        bgRed: [ 41, 49 ],
        bgGreen: [ 42, 49 ],
        bgYellow: [ 43, 49 ],
        bgBlue: [ 44, 49 ],
        bgMagenta: [ 45, 49 ],
        bgCyan: [ 46, 49 ],
        bgWhite: [ 47, 49 ],
        bgGray: [ 100, 49 ],
        bgGrey: [ 100, 49 ],
        bgBrightRed: [ 101, 49 ],
        bgBrightGreen: [ 102, 49 ],
        bgBrightYellow: [ 103, 49 ],
        bgBrightBlue: [ 104, 49 ],
        bgBrightMagenta: [ 105, 49 ],
        bgBrightCyan: [ 106, 49 ],
        bgBrightWhite: [ 107, 49 ],
        blackBG: [ 40, 49 ],
        redBG: [ 41, 49 ],
        greenBG: [ 42, 49 ],
        yellowBG: [ 43, 49 ],
        blueBG: [ 44, 49 ],
        magentaBG: [ 45, 49 ],
        cyanBG: [ 46, 49 ],
        whiteBG: [ 47, 49 ]
      };
      Object.keys(codes).forEach((function(key) {
        var val = codes[key], style = styles[key] = [];
        style.open = "[" + val[0] + "m", style.close = "[" + val[1] + "m";
      }));
    },
    1379: module => {
      "use strict";
      module.exports = function(flag, argv) {
        var terminatorPos = (argv = argv || process.argv).indexOf("--"), prefix = /^-{1,2}/.test(flag) ? "" : "--", pos = argv.indexOf(prefix + flag);
        return -1 !== pos && (-1 === terminatorPos || pos < terminatorPos);
      };
    },
    47011: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var os = __webpack_require__(22037), hasFlag = __webpack_require__(1379), env = process.env, forceColor = void 0;
      function getSupportLevel(stream) {
        var level = function(stream) {
          if (!1 === forceColor) return 0;
          if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) return 3;
          if (hasFlag("color=256")) return 2;
          if (stream && !stream.isTTY && !0 !== forceColor) return 0;
          var min = forceColor ? 1 : 0;
          if ("win32" === process.platform) {
            var osRelease = os.release().split(".");
            return Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586 ? Number(osRelease[2]) >= 14931 ? 3 : 2 : 1;
          }
          if ("CI" in env) return [ "TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI" ].some((function(sign) {
            return sign in env;
          })) || "codeship" === env.CI_NAME ? 1 : min;
          if ("TEAMCITY_VERSION" in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
          if ("TERM_PROGRAM" in env) {
            var version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch (env.TERM_PROGRAM) {
             case "iTerm.app":
              return version >= 3 ? 3 : 2;

             case "Hyper":
              return 3;

             case "Apple_Terminal":
              return 2;
            }
          }
          return /-256(color)?$/i.test(env.TERM) ? 2 : /^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM) || "COLORTERM" in env ? 1 : (env.TERM, 
          min);
        }(stream);
        return function(level) {
          return 0 !== level && {
            level,
            hasBasic: !0,
            has256: level >= 2,
            has16m: level >= 3
          };
        }(level);
      }
      hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") ? forceColor = !1 : (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) && (forceColor = !0), 
      "FORCE_COLOR" in env && (forceColor = 0 === env.FORCE_COLOR.length || 0 !== parseInt(env.FORCE_COLOR, 10)), 
      module.exports = {
        supportsColor: getSupportLevel,
        stdout: getSupportLevel(process.stdout),
        stderr: getSupportLevel(process.stderr)
      };
    },
    67398: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const {promisify} = __webpack_require__(73837), handler = {
        get: function(target, prop, receiver) {
          return "function" != typeof target[prop] ? target[prop] : target[prop][promisify.custom] ? function() {
            return Reflect.get(target, prop, receiver)[promisify.custom].apply(target, arguments);
          } : function() {
            return new Promise(((resolve, reject) => {
              Reflect.get(target, prop, receiver).apply(target, [ ...arguments, function(err, result) {
                if (err) return reject(err);
                resolve(result);
              } ]);
            }));
          };
        }
      };
      module.exports = function(thingToPromisify) {
        if ("function" == typeof thingToPromisify) return promisify(thingToPromisify);
        if ("object" == typeof thingToPromisify) return new Proxy(thingToPromisify, handler);
        throw new TypeError("Can only promisify functions or objects");
      };
    },
    51031: module => {
      const hasIntl = "object" == typeof Intl && !!Intl, Collator = hasIntl && Intl.Collator, cache = new Map, knownOptions = [ "sensitivity", "numeric", "ignorePunctuation", "caseFirst" ], {hasOwnProperty} = Object.prototype;
      module.exports = (locale, options = {}) => {
        if (!locale || "string" != typeof locale) throw new TypeError("locale required");
        const opts = knownOptions.reduce(((opts, k) => (hasOwnProperty.call(options, k) && (opts[k] = options[k]), 
        opts)), {}), key = `${locale}\n${JSON.stringify(opts)}`;
        if (cache.has(key)) return cache.get(key);
        const compare = hasIntl ? ((locale, opts) => {
          const collator = new Collator(locale, opts);
          return (a, b) => collator.compare(a, b);
        })(locale, opts) : ((locale, opts) => (a, b) => a.localeCompare(b, locale, opts))(locale, opts);
        return cache.set(key, compare), compare;
      };
    },
    50089: (module, __unused_webpack_exports, __webpack_require__) => {
      const log = __webpack_require__(46521), localeCompare = __webpack_require__(51031)("en"), saveTypeMap = new Map([ [ "dev", "devDependencies" ], [ "optional", "optionalDependencies" ], [ "prod", "dependencies" ], [ "peerOptional", "peerDependencies" ], [ "peer", "peerDependencies" ] ]), inferSaveType = (pkg, name) => {
        for (const saveType of saveTypeMap.keys()) if (hasSubKey(pkg, saveTypeMap.get(saveType), name)) return "peerOptional" !== saveType || hasSubKey(pkg, "peerDependenciesMeta", name) && pkg.peerDependenciesMeta[name].optional ? saveType : "peer";
        return "prod";
      }, hasSubKey = (pkg, depType, name) => pkg[depType] && Object.prototype.hasOwnProperty.call(pkg[depType], name), deleteSubKey = (pkg, depType, name, replacedBy) => {
        hasSubKey(pkg, depType, name) && (replacedBy && log.warn("idealTree", `Removing ${depType}.${name} in favor of ${replacedBy}.${name}`), 
        delete pkg[depType][name], "peerDependencies" === depType && pkg.peerDependenciesMeta && (delete pkg.peerDependenciesMeta[name], 
        Object.keys(pkg.peerDependenciesMeta).length || delete pkg.peerDependenciesMeta), 
        Object.keys(pkg[depType]).length || delete pkg[depType]);
      };
      module.exports = {
        add: ({pkg, add, saveBundle, saveType}) => {
          for (const {name, rawSpec} of add) {
            let addSaveType = saveType;
            addSaveType || (addSaveType = inferSaveType(pkg, name)), "prod" === addSaveType ? (deleteSubKey(pkg, "devDependencies", name, "dependencies"), 
            deleteSubKey(pkg, "peerDependencies", name, "dependencies")) : "dev" === addSaveType ? deleteSubKey(pkg, "dependencies", name, "devDependencies") : "optional" === addSaveType ? deleteSubKey(pkg, "peerDependencies", name, "optionalDependencies") : (deleteSubKey(pkg, "dependencies", name, "peerDependencies"), 
            deleteSubKey(pkg, "optionalDependencies", name, "peerDependencies"));
            const depType = saveTypeMap.get(addSaveType);
            if (pkg[depType] = pkg[depType] || {}, "" === rawSpec && void 0 !== pkg[depType][name] || (pkg[depType][name] = rawSpec || "*"), 
            "optional" === addSaveType && (pkg.dependencies = pkg.dependencies || {}, pkg.dependencies[name] = pkg.optionalDependencies[name]), 
            "peer" === addSaveType || "peerOptional" === addSaveType) {
              const pdm = pkg.peerDependenciesMeta || {};
              "peer" === addSaveType && pdm[name] && pdm[name].optional ? pdm[name].optional = !1 : "peerOptional" === addSaveType && (pdm[name] = pdm[name] || {}, 
              pdm[name].optional = !0, pkg.peerDependenciesMeta = pdm), pkg.devDependencies && void 0 !== pkg.devDependencies[name] && (pkg.devDependencies[name] = pkg.peerDependencies[name]);
            }
            if (saveBundle && "peer" !== addSaveType && "peerOptional" !== addSaveType) {
              const bd = new Set(pkg.bundleDependencies || []);
              bd.add(name), pkg.bundleDependencies = [ ...bd ].sort(localeCompare);
            }
          }
          return pkg;
        },
        rm: (pkg, rm) => {
          for (const depType of new Set(saveTypeMap.values())) for (const name of rm) deleteSubKey(pkg, depType, name);
          return pkg.bundleDependencies && (pkg.bundleDependencies = pkg.bundleDependencies.filter((name => !rm.includes(name))), 
          pkg.bundleDependencies.length || delete pkg.bundleDependencies), pkg;
        },
        saveTypeMap,
        hasSubKey
      };
    },
    27930: (module, __unused_webpack_exports, __webpack_require__) => {
      const AuditReport = __webpack_require__(88917), _global = Symbol.for("global"), _workspaces = Symbol.for("workspaces"), _includeWorkspaceRoot = Symbol.for("includeWorkspaceRoot");
      module.exports = cls => class extends cls {
        async audit(options = {}) {
          if (this.addTracker("audit"), this[_global]) throw Object.assign(new Error("`npm audit` does not support testing globals"), {
            code: "EAUDITGLOBAL"
          });
          options = {
            ...this.options,
            ...options
          }, process.emit("time", "audit");
          const tree = await this.loadVirtual();
          this[_workspaces] && this[_workspaces].length && (options.filterSet = this.workspaceDependencySet(tree, this[_workspaces], this[_includeWorkspaceRoot])), 
          options.workspacesEnabled || (options.filterSet = this.excludeWorkspacesDependencySet(tree)), 
          this.auditReport = await AuditReport.load(tree, options);
          const ret = options.fix ? this.reify(options) : this.auditReport;
          return process.emit("timeEnd", "audit"), this.finishTracker("audit"), ret;
        }
      };
    },
    14674: (module, __unused_webpack_exports, __webpack_require__) => {
      const localeCompare = __webpack_require__(51031)("en"), rpj = __webpack_require__(1759), npa = __webpack_require__(19932), pacote = __webpack_require__(86585), cacache = __webpack_require__(99269), promiseCallLimit = __webpack_require__(37180), realpath = __webpack_require__(37472), {resolve, dirname} = __webpack_require__(71017), {promisify} = __webpack_require__(73837), treeCheck = __webpack_require__(56912), readdir = promisify(__webpack_require__(51981)), fs = __webpack_require__(57147), lstat = promisify(fs.lstat), readlink = promisify(fs.readlink), {depth} = __webpack_require__(75476), log = __webpack_require__(46521), {OK, REPLACE, CONFLICT} = __webpack_require__(19450), PlaceDep = __webpack_require__(806), debug = __webpack_require__(63120), fromPath = __webpack_require__(25581), calcDepFlags = __webpack_require__(52667), Shrinkwrap = __webpack_require__(33828), {defaultLockfileVersion} = Shrinkwrap, Node = __webpack_require__(41172), Link = __webpack_require__(3112), addRmPkgDeps = __webpack_require__(50089), optionalSet = __webpack_require__(9702), {checkEngine, checkPlatform} = __webpack_require__(91126), relpath = __webpack_require__(52452), _complete = Symbol("complete"), _depsSeen = Symbol("depsSeen"), _depsQueue = Symbol("depsQueue"), _currentDep = Symbol("currentDep"), _updateAll = Symbol.for("updateAll"), _mutateTree = Symbol("mutateTree"), _flagsSuspect = Symbol.for("flagsSuspect"), _workspaces = Symbol.for("workspaces"), _prune = Symbol("prune"), _preferDedupe = Symbol("preferDedupe"), _legacyBundling = Symbol("legacyBundling"), _parseSettings = Symbol("parseSettings"), _initTree = Symbol("initTree"), _applyUserRequests = Symbol("applyUserRequests"), _applyUserRequestsToNode = Symbol("applyUserRequestsToNode"), _inflateAncientLockfile = Symbol("inflateAncientLockfile"), _buildDeps = Symbol("buildDeps"), _buildDepStep = Symbol("buildDepStep"), _nodeFromEdge = Symbol("nodeFromEdge"), _nodeFromSpec = Symbol("nodeFromSpec"), _fetchManifest = Symbol("fetchManifest"), _problemEdges = Symbol("problemEdges"), _manifests = Symbol("manifests"), _loadWorkspaces = Symbol.for("loadWorkspaces"), _linkFromSpec = Symbol("linkFromSpec"), _loadPeerSet = Symbol("loadPeerSet"), _updateNames = Symbol.for("updateNames"), _fixDepFlags = Symbol("fixDepFlags"), _resolveLinks = Symbol("resolveLinks"), _rootNodeFromPackage = Symbol("rootNodeFromPackage"), _add = Symbol("add"), _resolvedAdd = Symbol.for("resolvedAdd"), _queueNamedUpdates = Symbol("queueNamedUpdates"), _queueVulnDependents = Symbol("queueVulnDependents"), _avoidRange = Symbol("avoidRange"), _shouldUpdateNode = Symbol("shouldUpdateNode"), resetDepFlags = __webpack_require__(89783), _loadFailures = Symbol("loadFailures"), _pruneFailedOptional = Symbol("pruneFailedOptional"), _linkNodes = Symbol("linkNodes"), _follow = Symbol("follow"), _globalStyle = Symbol("globalStyle"), _globalRootNode = Symbol("globalRootNode"), _usePackageLock = Symbol.for("usePackageLock"), _rpcache = Symbol.for("realpathCache"), _stcache = Symbol.for("statCache"), _strictPeerDeps = Symbol("strictPeerDeps"), _checkEngineAndPlatform = Symbol("checkEngineAndPlatform"), _virtualRoots = Symbol("virtualRoots"), _virtualRoot = Symbol("virtualRoot"), _includeWorkspaceRoot = Symbol.for("includeWorkspaceRoot"), _failPeerConflict = Symbol("failPeerConflict"), _explainPeerConflict = Symbol("explainPeerConflict"), _edgesOverridden = Symbol("edgesOverridden"), _peerSetSource = Symbol.for("peerSetSource"), _force = Symbol.for("force"), _explicitRequests = Symbol("explicitRequests"), _global = Symbol.for("global"), _idealTreePrune = Symbol.for("idealTreePrune");
      module.exports = cls => class extends cls {
        constructor(options) {
          super(options);
          const registry = options.registry || "https://registry.npmjs.org";
          options.registry = this.registry = registry.replace(/\/+$/, "") + "/";
          const {follow = !1, force = !1, global = !1, globalStyle = !1, idealTree = null, includeWorkspaceRoot = !1, installLinks = !1, legacyPeerDeps = !1, packageLock = !0, strictPeerDeps = !1, workspaces = []} = options;
          if (this[_workspaces] = workspaces || [], this[_force] = !!force, this[_strictPeerDeps] = !!strictPeerDeps, 
          this.idealTree = idealTree, this.installLinks = installLinks, this.legacyPeerDeps = legacyPeerDeps, 
          this[_usePackageLock] = packageLock, this[_global] = !!global, this[_globalStyle] = this[_global] || globalStyle, 
          this[_follow] = !!follow, this[_workspaces].length && this[_global]) throw new Error("Cannot operate on workspaces in global mode");
          this[_explicitRequests] = new Set, this[_preferDedupe] = !1, this[_legacyBundling] = !1, 
          this[_depsSeen] = new Set, this[_depsQueue] = [], this[_currentDep] = null, this[_updateNames] = [], 
          this[_updateAll] = !1, this[_mutateTree] = !1, this[_loadFailures] = new Set, this[_linkNodes] = new Set, 
          this[_manifests] = new Map, this[_edgesOverridden] = new Set, this[_resolvedAdd] = [], 
          this[_peerSetSource] = new WeakMap, this[_virtualRoots] = new Map, this[_includeWorkspaceRoot] = includeWorkspaceRoot;
        }
        get explicitRequests() {
          return new Set(this[_explicitRequests]);
        }
        async buildIdealTree(options = {}) {
          if (this.idealTree) return this.idealTree;
          if ((options = {
            ...this.options,
            ...options
          }).add && 0 !== options.add.length || (options.add = null), options.rm && 0 !== options.rm.length || (options.rm = null), 
          process.emit("time", "idealTree"), !options.add && !options.rm && !options.update && this[_global]) throw new Error("global requires add, rm, or update option");
          this[_parseSettings](options), this.addTracker("idealTree");
          try {
            await this[_initTree](), await this[_inflateAncientLockfile](), await this[_applyUserRequests](options), 
            await this[_buildDeps](), await this[_fixDepFlags](), await this[_pruneFailedOptional](), 
            await this[_checkEngineAndPlatform]();
          } finally {
            process.emit("timeEnd", "idealTree"), this.finishTracker("idealTree");
          }
          return treeCheck(this.idealTree);
        }
        async [_checkEngineAndPlatform]() {
          const {engineStrict, npmVersion, nodeVersion} = this.options;
          for (const node of this.idealTree.inventory.values()) if (!node.optional) {
            try {
              checkEngine(node.package, npmVersion, nodeVersion, this[_force]);
            } catch (err) {
              if (engineStrict) throw err;
              log.warn(err.code, err.message, {
                package: err.pkgid,
                required: err.required,
                current: err.current
              });
            }
            checkPlatform(node.package, this[_force]);
          }
        }
        [_parseSettings](options) {
          const update = !0 === options.update ? {
            all: !0
          } : Array.isArray(options.update) ? {
            names: options.update
          } : options.update || {};
          !update.all && Array.isArray(update.names) || (update.names = []), this[_complete] = !!options.complete, 
          this[_preferDedupe] = !!options.preferDedupe, this[_legacyBundling] = !!options.legacyBundling;
          for (const name of update.names) {
            const spec = npa(name), validationError = new TypeError(`Update arguments must not contain package version specifiers\n\nTry using the package name instead, e.g:\n    npm update ${spec.name}`);
            if (validationError.code = "EUPDATEARGS", "latest" !== spec.fetchSpec) throw validationError;
          }
          this[_updateNames] = update.names, this[_updateAll] = update.all, this[_prune] = !1 !== options.prune, 
          this[_mutateTree] = !!(options.add || options.rm || update.all || update.names.length);
        }
        [_initTree]() {
          return process.emit("time", "idealTree:init"), (this[_global] ? this[_globalRootNode]() : rpj(this.path + "/package.json").then((pkg => this[_rootNodeFromPackage](pkg)), (er => {
            if ("EJSONPARSE" === er.code) throw er;
            return this[_rootNodeFromPackage]({});
          }))).then((root => this[_loadWorkspaces](root))).then((root => this[_global] ? root : !this[_usePackageLock] || this[_updateAll] ? Shrinkwrap.reset({
            path: this.path,
            lockfileVersion: this.options.lockfileVersion,
            resolveOptions: this.options
          }).then((meta => Object.assign(root, {
            meta
          }))) : this.loadVirtual({
            root
          }))).then((async root => {
            if (!this[_updateAll] && !this[_global] && !root.meta.loadedFromDisk || this[_global] && this[_updateNames].length) {
              await new this.constructor(this.options).loadActual({
                root
              });
              root.target.children.size && (root.meta.loadedFromDisk = !0, root.meta.originalLockfileVersion = defaultLockfileVersion, 
              root.meta.lockfileVersion = defaultLockfileVersion);
            }
            return root.meta.inferFormattingOptions(root.package), root;
          })).then((tree => (depth({
            tree,
            getChildren: node => [ ...node.edgesOut.values() ].map((edge => edge.to)),
            filter: node => node,
            visit: node => {
              for (const edge of node.edgesOut.values()) if (!edge.valid) {
                this[_depsQueue].push(node);
                break;
              }
            }
          }), this.idealTree = tree, this.virtualTree = null, process.emit("timeEnd", "idealTree:init"), 
          tree)));
        }
        async [_globalRootNode]() {
          const root = await this[_rootNodeFromPackage]({
            dependencies: {}
          }), meta = new Shrinkwrap({
            path: this.path,
            lockfileVersion: this.options.lockfileVersion,
            resolveOptions: this.options
          });
          return meta.reset(), root.meta = meta, root;
        }
        async [_rootNodeFromPackage](pkg) {
          const real = await realpath(this.path, this[_rpcache], this[_stcache]), root = new (real === this.path ? Node : Link)({
            path: this.path,
            realpath: real,
            pkg,
            extraneous: !1,
            dev: !1,
            devOptional: !1,
            peer: !1,
            optional: !1,
            global: this[_global],
            installLinks: this.installLinks,
            legacyPeerDeps: this.legacyPeerDeps,
            loadOverrides: !0
          });
          return root.isLink && (root.target = new Node({
            path: real,
            realpath: real,
            pkg,
            extraneous: !1,
            dev: !1,
            devOptional: !1,
            peer: !1,
            optional: !1,
            global: this[_global],
            installLinks: this.installLinks,
            legacyPeerDeps: this.legacyPeerDeps,
            root
          })), root;
        }
        async [_applyUserRequests](options) {
          process.emit("time", "idealTree:userRequests");
          const tree = this.idealTree.target;
          if (this[_workspaces].length) {
            const nodes = this.workspaceNodes(tree, this[_workspaces]);
            this[_includeWorkspaceRoot] && nodes.push(tree);
            const appliedRequests = nodes.map((node => this[_applyUserRequestsToNode](node, options)));
            await Promise.all(appliedRequests);
          } else await this[_applyUserRequestsToNode](tree, options);
          process.emit("timeEnd", "idealTree:userRequests");
        }
        async [_applyUserRequestsToNode](tree, options) {
          !this[_global] && this[_updateNames].length && this[_queueNamedUpdates]();
          const globalExplicitUpdateNames = [];
          if (this[_global] && (this[_updateAll] || this[_updateNames].length)) {
            const nm = resolve(this.path, "node_modules");
            for (const name of await readdir(nm).catch((() => []))) {
              tree.package.dependencies = tree.package.dependencies || {};
              const updateName = this[_updateNames].includes(name);
              if (this[_updateAll] || updateName) {
                updateName && globalExplicitUpdateNames.push(name);
                const dir = resolve(nm, name), st = await lstat(dir).catch((er => null));
                if (st && st.isSymbolicLink()) {
                  const target = await readlink(dir), real = resolve(dirname(dir), target).replace(/#/g, "%23");
                  tree.package.dependencies[name] = `file:${real}`;
                } else tree.package.dependencies[name] = "*";
              }
            }
          }
          this.auditReport && this.auditReport.size > 0 && await this[_queueVulnDependents](options);
          const {add, rm} = options;
          if (rm && rm.length) {
            addRmPkgDeps.rm(tree.package, rm);
            for (const name of rm) this[_explicitRequests].add({
              from: tree,
              name,
              action: "DELETE"
            });
          }
          add && add.length && await this[_add](tree, options), (add && add.length || rm && rm.length || this[_global]) && (tree.package = tree.package);
          for (const spec of this[_resolvedAdd]) spec.tree === tree && this[_explicitRequests].add(tree.edgesOut.get(spec.name));
          for (const name of globalExplicitUpdateNames) this[_explicitRequests].add(tree.edgesOut.get(name));
          this[_depsQueue].push(tree);
        }
        async [_add](tree, {add, saveType = null, saveBundle = !1}) {
          const path = tree.target.path;
          await Promise.all(add.map((async rawSpec => {
            let spec = npa(rawSpec);
            const isTag = spec.rawSpec && "tag" === spec.type;
            if (!spec.name || isTag) {
              const mani = await pacote.manifest(spec, {
                ...this.options
              });
              isTag && (spec = npa(`${mani.name}@${mani.version}`)), spec.name = mani.name;
            }
            const {name} = spec;
            if ("file" === spec.type) spec = npa(`file:${relpath(path, spec.fetchSpec).replace(/#/g, "%23")}`, path), 
            spec.name = name; else if ("directory" === spec.type) try {
              const real = await realpath(spec.fetchSpec, this[_rpcache], this[_stcache]);
              spec = npa(`file:${relpath(path, real).replace(/#/g, "%23")}`, path), spec.name = name;
            } catch {}
            spec.tree = tree, this[_resolvedAdd].push(spec);
          }))), addRmPkgDeps.add({
            pkg: tree.package,
            add: this[_resolvedAdd],
            saveBundle,
            saveType
          });
        }
        async [_queueVulnDependents](options) {
          for (const vuln of this.auditReport.values()) for (const node of vuln.nodes) {
            const bundler = node.getBundler();
            if (bundler) log.warn(`audit fix ${node.name}@${node.version}`, `${node.location}\nis a bundled dependency of\n${bundler.name}@${bundler.version} at ${bundler.location}\nIt cannot be fixed automatically.\nCheck for updates to the ${bundler.name} package.`); else for (const edge of node.edgesIn) this.addTracker("idealTree", edge.from.name, edge.from.location), 
            this[_depsQueue].push(edge.from);
          }
          if (this[_force] && this.auditReport && this.auditReport.topVulns.size) {
            options.add = options.add || [], options.rm = options.rm || [];
            const nodesTouched = new Set;
            for (const [name, topVuln] of this.auditReport.topVulns.entries()) {
              const {simpleRange, topNodes, fixAvailable} = topVuln;
              for (const node of topNodes) {
                if (!node.isProjectRoot && !node.isWorkspace) {
                  log.warn("audit", `Manual fix required in linked project at ./${node.location} for ${name}@${simpleRange}.\n'cd ./${node.location}' and run 'npm audit' for details.`);
                  continue;
                }
                if (!fixAvailable) {
                  log.warn("audit", `No fix available for ${name}@${simpleRange}`);
                  continue;
                }
                const {isSemVerMajor, version} = fixAvailable, breakingMessage = isSemVerMajor ? "a SemVer major change" : "outside your stated dependency range";
                log.warn("audit", `Updating ${name} to ${version}, which is ${breakingMessage}.`), 
                await this[_add](node, {
                  add: [ `${name}@${version}` ]
                }), nodesTouched.add(node);
              }
            }
            for (const node of nodesTouched) node.package = node.package;
          }
        }
        [_avoidRange](name) {
          if (!this.auditReport) return null;
          const vuln = this.auditReport.get(name);
          return vuln ? vuln.range : null;
        }
        [_queueNamedUpdates]() {
          const set = this.idealTree.inventory.filter((n => this[_shouldUpdateNode](n)));
          for (const node of set) for (const edge of node.edgesIn) this.addTracker("idealTree", edge.from.name, edge.from.location), 
          this[_depsQueue].push(edge.from);
        }
        [_shouldUpdateNode](node) {
          return this[_updateNames].includes(node.name) && !node.isTop && !node.inDepBundle && !node.inShrinkwrap;
        }
        async [_inflateAncientLockfile]() {
          const {meta, inventory} = this.idealTree, ancient = meta.ancientLockfile, old = meta.loadedFromDisk && !(meta.originalLockfileVersion >= 2);
          if (0 === inventory.size || !ancient && !old) return;
          process.emit("time", "idealTree:inflate");
          const heading = ancient ? "ancient lockfile" : "old lockfile";
          (ancient || !this.options.lockfileVersion || this.options.lockfileVersion >= defaultLockfileVersion) && log.warn(heading, `\nThe ${meta.type} file was created with an old version of npm,\nso supplemental metadata must be fetched from the registry.\n\nThis is a one-time fix-up, please be patient...\n`), 
          this.addTracker("idealTree:inflate");
          const queue = [];
          for (const node of inventory.values()) node.isProjectRoot || node.location.startsWith("node_modules") && queue.push((async () => {
            log.silly("inflate", node.location);
            const {resolved, version, path, name, location, integrity} = node, id = resolved && (!version || resolved.startsWith("file:")) ? resolved : version, spec = npa.resolve(name, id, dirname(path)), t = `idealTree:inflate:${location}`;
            this.addTracker(t);
            try {
              const mani = await pacote.manifest(spec, {
                ...this.options,
                resolved,
                integrity,
                fullMetadata: !1
              });
              node.package = {
                ...mani,
                _id: `${mani.name}@${mani.version}`
              };
            } catch (er) {
              const warning = `Could not fetch metadata for ${name}@${id}`;
              log.warn(heading, warning, er);
            }
            this.finishTracker(t);
          }));
          await promiseCallLimit(queue), calcDepFlags(this.idealTree), meta.originalLockfileVersion = defaultLockfileVersion, 
          this.finishTracker("idealTree:inflate"), process.emit("timeEnd", "idealTree:inflate");
        }
        [_buildDeps]() {
          process.emit("time", "idealTree:buildDeps");
          const tree = this.idealTree.target;
          return tree.assertRootOverrides(), this[_depsQueue].push(tree), log.silly("idealTree", "buildDeps"), 
          this.addTracker("idealTree", tree.name, ""), this[_buildDepStep]().then((() => process.emit("timeEnd", "idealTree:buildDeps")));
        }
        async [_buildDepStep]() {
          if (this[_currentDep]) {
            const {location, name} = this[_currentDep];
            process.emit("timeEnd", `idealTree:${location || "#root"}`), this.finishTracker("idealTree", name, location), 
            this[_currentDep] = null;
          }
          if (!this[_depsQueue].length) return this[_resolveLinks]();
          this[_depsQueue].sort(((a, b) => a.depth - b.depth || localeCompare(a.path, b.path)));
          const node = this[_depsQueue].shift(), bd = node.package.bundleDependencies, hasBundle = bd && Array.isArray(bd) && bd.length, {hasShrinkwrap} = node;
          if (this[_depsSeen].has(node) || node.root !== this.idealTree || hasShrinkwrap && !this[_complete]) return this[_buildDepStep]();
          this[_depsSeen].add(node), this[_currentDep] = node, process.emit("time", `idealTree:${node.location || "#root"}`);
          if (this[_complete] && node !== this.idealTree && node.resolved && (hasBundle || hasShrinkwrap)) {
            const Arborist = this.constructor, opt = {
              ...this.options
            };
            await cacache.tmp.withTmp(this.cache, opt, (async path => {
              await pacote.extract(node.resolved, path, {
                ...opt,
                resolved: node.resolved,
                integrity: node.integrity
              }), hasShrinkwrap && await new Arborist({
                ...this.options,
                path
              }).loadVirtual({
                root: node
              }), hasBundle && await new Arborist({
                ...this.options,
                path
              }).loadActual({
                root: node,
                ignoreMissing: !0
              });
            }));
          }
          const tasks = [], peerSource = this[_peerSetSource].get(node) || node;
          for (const edge of this[_problemEdges](node)) {
            if (edge.peerConflicted) continue;
            const source = edge.peer ? peerSource : node, virtualRoot = this[_virtualRoot](source, !0), vrEdge = virtualRoot && virtualRoot.edgesOut.get(edge.name), vrDep = vrEdge && vrEdge.valid && vrEdge.to, required = new Set([ edge.from ]), parent = edge.peer ? virtualRoot : null, dep = vrDep && vrDep.satisfies(edge) ? vrDep : await this[_nodeFromEdge](edge, parent, null, required);
            debug((() => {
              if (!dep) throw new Error("no dep??");
            })), tasks.push({
              edge,
              dep
            });
          }
          const placeDeps = tasks.sort(((a, b) => localeCompare(a.edge.name, b.edge.name))).map((({edge, dep}) => new PlaceDep({
            edge,
            dep,
            explicitRequest: this[_explicitRequests].has(edge),
            updateNames: this[_updateNames],
            auditReport: this.auditReport,
            force: this[_force],
            preferDedupe: this[_preferDedupe],
            legacyBundling: this[_legacyBundling],
            strictPeerDeps: this[_strictPeerDeps],
            installLinks: this.installLinks,
            legacyPeerDeps: this.legacyPeerDeps,
            globalStyle: this[_globalStyle]
          }))), promises = [];
          for (const pd of placeDeps) depth({
            tree: pd,
            getChildren: pd => pd.children,
            visit: pd => {
              const {placed, edge, canPlace: cpd} = pd;
              if (placed) {
                if (placed.errors.length && this[_loadFailures].add(placed), this[_mutateTree] = !0, 
                cpd.canPlaceSelf === OK) for (const edgeIn of placed.edgesIn) {
                  if (edgeIn === edge) continue;
                  const {from, valid, peerConflicted} = edgeIn;
                  peerConflicted || valid || this[_depsSeen].has(from) || (this.addTracker("idealTree", from.name, from.location), 
                  this[_depsQueue].push(edgeIn.from));
                } else if (cpd.canPlaceSelf === REPLACE) for (const edgeIn of placed.edgesIn) {
                  if (edgeIn === edge) continue;
                  const {valid, peerConflicted} = edgeIn;
                  valid || peerConflicted || (this[_depsSeen].delete(edgeIn.from), this[_depsQueue].push(edgeIn.from));
                }
                if (cpd.canPlaceSelf !== CONFLICT) {
                  this[_depsQueue].push(placed);
                  for (const dep of pd.needEvaluation) this[_depsSeen].delete(dep), this[_depsQueue].push(dep);
                  promises.push(...this[_problemEdges](placed).map((e => this[_fetchManifest](npa.resolve(e.name, e.spec, fromPath(placed, e))).catch((er => null)))));
                } else debug((() => {
                  const er = new Error("placed with canPlaceSelf=CONFLICT");
                  throw Object.assign(er, {
                    placeDep: pd
                  });
                }));
              }
            }
          });
          for (const {to} of node.edgesOut.values()) to && to.isLink && to.target && this[_linkNodes].add(to);
          return await Promise.all(promises), this[_buildDepStep]();
        }
        async [_nodeFromEdge](edge, parent_, secondEdge, required) {
          const parent = parent_ || this[_virtualRoot](edge.from), spec = npa.resolve(edge.name, edge.spec, edge.from.path), first = await this[_nodeFromSpec](edge.name, spec, parent, edge), spec2 = secondEdge && npa.resolve(edge.name, secondEdge.spec, secondEdge.from.path), second = secondEdge && !secondEdge.valid ? await this[_nodeFromSpec](edge.name, spec2, parent, secondEdge) : null, node = second && edge.valid ? second : first;
          node.parent = parent, (required.has(edge.from) && "peerOptional" !== edge.type || secondEdge && required.has(secondEdge.from) && "peerOptional" !== secondEdge.type) && required.add(node);
          const src = parent.sourceReference;
          return this[_peerSetSource].set(node, src), this[_global] && edge.from.isProjectRoot ? node : this[_loadPeerSet](node, required);
        }
        [_virtualRoot](node, reuse = !1) {
          if (reuse && this[_virtualRoots].has(node)) return this[_virtualRoots].get(node);
          const vr = new Node({
            path: node.realpath,
            sourceReference: node,
            installLinks: this.installLinks,
            legacyPeerDeps: this.legacyPeerDeps,
            overrides: node.overrides
          });
          for (const child of node.children.values()) child.isLink && new Node({
            path: child.realpath,
            sourceReference: child.target,
            root: vr
          });
          return this[_virtualRoots].set(node, vr), vr;
        }
        [_problemEdges](node) {
          const bd = node.isProjectRoot || node.isWorkspace ? null : node.package.bundleDependencies, bundled = new Set(bd || []);
          return [ ...node.edgesOut.values() ].filter((edge => !bundled.has(edge.name) && ((!edge.to || !this[_loadFailures].has(edge.to)) && ((!edge.to || !edge.to.inShrinkwrap) && (edge.to ? !edge.valid || !edge.to.isWorkspace && (!!this[_updateNames].includes(edge.name) || (!(!this.auditReport || !this.auditReport.isVulnerable(edge.to)) || !!this[_explicitRequests].has(edge))) : "peerOptional" !== edge.type || this[_explicitRequests].has(edge))))));
        }
        async [_fetchManifest](spec) {
          const options = {
            ...this.options,
            avoid: this[_avoidRange](spec.name)
          };
          if (spec = this.idealTree.meta.checkYarnLock(spec, options), this[_manifests].has(spec.raw)) return this[_manifests].get(spec.raw);
          {
            log.silly("fetch manifest", spec.raw);
            const p = pacote.manifest(spec, options).then((mani => (this[_manifests].set(spec.raw, mani), 
            mani)));
            return this[_manifests].set(spec.raw, p), p;
          }
        }
        [_nodeFromSpec](name, spec, parent, edge) {
          const {installLinks, legacyPeerDeps} = this, isWorkspace = this.idealTree.workspaces && this.idealTree.workspaces.has(spec.name);
          if ("directory" === spec.type && (isWorkspace || !installLinks)) return this[_linkFromSpec](name, spec, parent, edge);
          if (isWorkspace) {
            const existingNode = this.idealTree.edgesOut.get(spec.name).to;
            if (existingNode && existingNode.isWorkspace && existingNode.satisfies(edge)) return edge.to;
          }
          return this[_fetchManifest](spec).then((pkg => new Node({
            name,
            pkg,
            parent,
            installLinks,
            legacyPeerDeps
          })), (error => {
            error.requiredBy = edge.from.location || ".";
            const n = new Node({
              name,
              parent,
              error,
              installLinks,
              legacyPeerDeps
            });
            return this[_loadFailures].add(n), n;
          }));
        }
        [_linkFromSpec](name, spec, parent, edge) {
          const realpath = spec.fetchSpec, {installLinks, legacyPeerDeps} = this;
          return rpj(realpath + "/package.json").catch((() => ({}))).then((pkg => {
            const link = new Link({
              name,
              parent,
              realpath,
              pkg,
              installLinks,
              legacyPeerDeps
            });
            return this[_linkNodes].add(link), link;
          }));
        }
        async [_loadPeerSet](node, required) {
          const peerEdges = [ ...node.edgesOut.values() ].filter((e => e.peer && !(e.valid && e.to))).sort((({name: a}, {name: b}) => localeCompare(a, b)));
          for (const edge of peerEdges) {
            if (edge.valid && edge.to) continue;
            const parentEdge = node.parent.edgesOut.get(edge.name), {isProjectRoot, isWorkspace} = node.parent.sourceReference, isMine = isProjectRoot || isWorkspace, conflictOK = this[_force] || !isMine && !this[_strictPeerDeps];
            if (!edge.to) {
              if (!parentEdge) {
                await this[_nodeFromEdge](edge, node.parent, null, required);
                continue;
              }
              {
                const dep = await this[_nodeFromEdge](parentEdge, node.parent, edge, required);
                if (edge.valid) continue;
                if (conflictOK || !required.has(dep)) {
                  edge.peerConflicted = !0;
                  continue;
                }
                this[_failPeerConflict](edge, parentEdge);
              }
            }
            const current = edge.to;
            (await this[_nodeFromEdge](edge, null, null, required)).canReplace(current) ? await this[_nodeFromEdge](edge, node.parent, null, required) : !conflictOK && required.has(edge.from) && this[_failPeerConflict](edge, parentEdge);
          }
          return node;
        }
        [_failPeerConflict](edge, currentEdge) {
          const expl = this[_explainPeerConflict](edge, currentEdge);
          throw Object.assign(new Error("unable to resolve dependency tree"), expl);
        }
        [_explainPeerConflict](edge, currentEdge) {
          return {
            code: "ERESOLVE",
            current: edge.from.resolve(edge.name).explain(),
            currentEdge: currentEdge ? currentEdge.explain() : null,
            edge: edge.explain(),
            strictPeerDeps: this[_strictPeerDeps],
            force: this[_force]
          };
        }
        [_resolveLinks]() {
          for (const link of this[_linkNodes]) {
            if (this[_linkNodes].delete(link), link.root !== this.idealTree) continue;
            const tree = this.idealTree.target;
            if (!link.target.isDescendantOf(tree) && !this[_follow]) continue;
            const unseenLink = (link.target.parent || link.target.fsParent) && !this[_depsSeen].has(link.target);
            (this[_follow] && !link.target.parent && !link.target.fsParent || unseenLink) && (this.addTracker("idealTree", link.target.name, link.target.location), 
            this[_depsQueue].push(link.target));
          }
          if (this[_depsQueue].length) return this[_buildDepStep]();
        }
        [_fixDepFlags]() {
          process.emit("time", "idealTree:fixDepFlags");
          const metaFromDisk = this.idealTree.meta.loadedFromDisk, flagsSuspect = this[_flagsSuspect], mutateTree = this[_mutateTree];
          metaFromDisk && mutateTree && resetDepFlags(this.idealTree), !metaFromDisk || mutateTree ? calcDepFlags(this.idealTree) : (this.idealTree.extraneous = !1, 
          this.idealTree.dev = !1, this.idealTree.optional = !1, this.idealTree.devOptional = !1, 
          this.idealTree.peer = !1);
          const needPrune = metaFromDisk && (mutateTree || flagsSuspect);
          this[_prune] && needPrune && this[_idealTreePrune](), process.emit("timeEnd", "idealTree:fixDepFlags");
        }
        [_idealTreePrune]() {
          for (const node of this.idealTree.inventory.filter((n => n.extraneous))) node.parent = null;
        }
        [_pruneFailedOptional]() {
          for (const node of this[_loadFailures]) {
            if (!node.optional) throw node.errors[0];
            const set = optionalSet(node);
            for (const node of set) node.parent = null;
          }
        }
      };
    },
    67690: module => {
      module.exports = cls => class extends cls {
        async dedupe(options = {}) {
          options = {
            ...this.options,
            ...options
          };
          const tree = await this.loadVirtual().catch((() => this.loadActual())), names = [];
          for (const name of tree.inventory.query("name")) tree.inventory.query("name", name).size > 1 && names.push(name);
          return this.reify({
            ...options,
            preferDedupe: !0,
            update: {
              names
            }
          });
        }
      };
    },
    10488: (module, __unused_webpack_exports, __webpack_require__) => {
      const {resolve} = __webpack_require__(71017), {homedir} = __webpack_require__(22037), {depth} = __webpack_require__(75476), {saveTypeMap} = __webpack_require__(50089), mixins = [ __webpack_require__(97179), __webpack_require__(97645), __webpack_require__(67690), __webpack_require__(27930), __webpack_require__(14674), __webpack_require__(59003), __webpack_require__(18337), __webpack_require__(24001), __webpack_require__(24717), __webpack_require__(10181) ], _workspacesEnabled = Symbol.for("workspacesEnabled"), Base = mixins.reduce(((a, b) => b(a)), __webpack_require__(82361)), getWorkspaceNodes = __webpack_require__(62349), lockfileVersion = lfv => {
        if (1 === lfv || 2 === lfv || 3 === lfv) return lfv;
        if (null == lfv) return null;
        throw new TypeError("Invalid lockfileVersion config: " + lfv);
      };
      module.exports = class extends Base {
        constructor(options = {}) {
          if (process.emit("time", "arborist:ctor"), super(options), this.options = {
            nodeVersion: process.version,
            ...options,
            path: options.path || ".",
            cache: options.cache || `${homedir()}/.npm/_cacache`,
            packumentCache: options.packumentCache || new Map,
            workspacesEnabled: !1 !== options.workspacesEnabled,
            replaceRegistryHost: options.replaceRegistryHost,
            lockfileVersion: lockfileVersion(options.lockfileVersion)
          }, this.replaceRegistryHost = this.options.replaceRegistryHost = this.options.replaceRegistryHost && "npmjs" !== this.options.replaceRegistryHost ? this.options.replaceRegistryHost : "registry.npmjs.org", 
          this[_workspacesEnabled] = this.options.workspacesEnabled, options.saveType && !saveTypeMap.get(options.saveType)) throw new Error(`Invalid saveType ${options.saveType}`);
          this.cache = resolve(this.options.cache), this.path = resolve(this.options.path), 
          process.emit("timeEnd", "arborist:ctor");
        }
        workspaceNodes(tree, workspaces) {
          return getWorkspaceNodes(tree, workspaces);
        }
        workspaceDependencySet(tree, workspaces, includeWorkspaceRoot) {
          const wsNodes = this.workspaceNodes(tree, workspaces);
          if (includeWorkspaceRoot) for (const edge of tree.edgesOut.values()) "workspace" !== edge.type && edge.to && wsNodes.push(edge.to);
          const wsDepSet = new Set(wsNodes), extraneous = new Set;
          for (const node of wsDepSet) {
            for (const edge of node.edgesOut.values()) {
              const dep = edge.to;
              dep && (wsDepSet.add(dep), dep.isLink && wsDepSet.add(dep.target));
            }
            for (const child of node.children.values()) child.extraneous && extraneous.add(child);
          }
          for (const extra of extraneous) wsDepSet.add(extra);
          return wsDepSet;
        }
        excludeWorkspacesDependencySet(tree) {
          const rootDepSet = new Set;
          return depth({
            tree,
            visit: node => {
              for (const {to} of node.edgesOut.values()) if (to && !to.isWorkspace) for (const edgeIn of to.edgesIn.values()) (edgeIn.from.isRoot || rootDepSet.has(edgeIn.from)) && rootDepSet.add(to);
              return node;
            },
            filter: node => node,
            getChildren: (node, tree) => [ ...tree.edgesOut.values() ].map((edge => edge.to))
          }), rootDepSet;
        }
      };
    },
    18337: (module, __unused_webpack_exports, __webpack_require__) => {
      const {relative, dirname, resolve, join, normalize} = __webpack_require__(71017), rpj = __webpack_require__(1759), {promisify} = __webpack_require__(73837), readdir = promisify(__webpack_require__(51981)), walkUp = __webpack_require__(43967), ancestorPath = __webpack_require__(43090), treeCheck = __webpack_require__(56912), Shrinkwrap = __webpack_require__(33828), calcDepFlags = __webpack_require__(52667), Node = __webpack_require__(41172), Link = __webpack_require__(3112), realpath = __webpack_require__(37472), _loadFSNode = Symbol("loadFSNode"), _newNode = Symbol("newNode"), _newLink = Symbol("newLink"), _loadFSTree = Symbol("loadFSTree"), _loadFSChildren = Symbol("loadFSChildren"), _findMissingEdges = Symbol("findMissingEdges"), _findFSParents = Symbol("findFSParents"), _resetDepFlags = Symbol("resetDepFlags"), _actualTreeLoaded = Symbol("actualTreeLoaded"), _rpcache = Symbol.for("realpathCache"), _stcache = Symbol.for("statCache"), _topNodes = Symbol("linkTargets"), _cache = Symbol("nodeLoadingCache"), _loadActual = Symbol("loadActual"), _loadActualVirtually = Symbol("loadActualVirtually"), _loadActualActually = Symbol("loadActualActually"), _loadWorkspaces = Symbol.for("loadWorkspaces"), _loadWorkspaceTargets = Symbol("loadWorkspaceTargets"), _actualTreePromise = Symbol("actualTreePromise"), _actualTree = Symbol("actualTree"), _transplant = Symbol("transplant"), _transplantFilter = Symbol("transplantFilter"), _filter = Symbol("filter"), _global = Symbol.for("global"), _changePath = Symbol.for("_changePath");
      module.exports = cls => class extends cls {
        constructor(options) {
          super(options), this[_global] = !!options.global, this.actualTree = options.actualTree, 
          this[_actualTreeLoaded] = new Set;
          const cwd = process.cwd();
          this[_rpcache] = new Map([ [ cwd, cwd ] ]), this[_stcache] = new Map, this[_cache] = new Map, 
          this[_topNodes] = new Set;
        }
        [_resetDepFlags](tree, root) {
          if (!root) for (const node of tree.inventory.values()) node.extraneous = !0;
          return calcDepFlags(tree, !root), tree;
        }
        async loadActual(options = {}) {
          return options = {
            ...this.options,
            ...options
          }, this.actualTree ? this.actualTree : this[_actualTreePromise] ? this[_actualTreePromise] : this[_actualTreePromise] = this[_loadActual](options).then((tree => this[_resetDepFlags](tree, options.root))).then((tree => this.actualTree = treeCheck(tree)));
        }
        async [_loadActual](options) {
          const {global = !1, filter = () => !0, root = null, transplantFilter = () => !0, ignoreMissing = !1, forceActual = !1} = options;
          if (this[_filter] = filter, this[_transplantFilter] = transplantFilter, global) {
            const real = await realpath(this.path, this[_rpcache], this[_stcache]), newNodeOrLink = this.path === real ? _newNode : _newLink;
            return this[_actualTree] = await this[newNodeOrLink]({
              path: this.path,
              realpath: real,
              pkg: {},
              global,
              loadOverrides: !0
            }), this[_loadActualActually]({
              root,
              ignoreMissing,
              global
            });
          }
          if (this[_actualTree] = await this[_loadFSNode]({
            path: this.path,
            real: await realpath(this.path, this[_rpcache], this[_stcache]),
            loadOverrides: !0
          }), this[_actualTree].assertRootOverrides(), !forceActual) {
            const meta = await Shrinkwrap.load({
              path: this[_actualTree].path,
              hiddenLockfile: !0,
              resolveOptions: this.options
            });
            if (meta.loadedFromDisk) return this[_actualTree].meta = meta, this[_loadActualVirtually]({
              root
            });
          }
          const meta = await Shrinkwrap.load({
            path: this[_actualTree].path,
            lockfileVersion: this.options.lockfileVersion,
            resolveOptions: this.options
          });
          return this[_actualTree].meta = meta, this[_loadActualActually]({
            root,
            ignoreMissing
          });
        }
        async [_loadActualVirtually]({root}) {
          return await new this.constructor({
            ...this.options
          }).loadVirtual({
            root: this[_actualTree]
          }), await this[_loadWorkspaces](this[_actualTree]), this[_transplant](root), this[_actualTree];
        }
        async [_loadActualActually]({root, ignoreMissing, global}) {
          if (await this[_loadFSTree](this[_actualTree]), await this[_loadWorkspaces](this[_actualTree]), 
          await this[_loadWorkspaceTargets](this[_actualTree]), ignoreMissing || await this[_findMissingEdges](), 
          this[_findFSParents](), this[_transplant](root), global) {
            const tree = this[_actualTree], actualRoot = tree.isLink ? tree.target : tree, {dependencies = {}} = actualRoot.package;
            for (const [name, kid] of actualRoot.children.entries()) {
              const def = kid.isLink ? `file:${kid.realpath.replace(/#/g, "%23")}` : "*";
              dependencies[name] = dependencies[name] || def;
            }
            actualRoot.package = {
              ...actualRoot.package,
              dependencies
            };
          }
          return this[_actualTree];
        }
        async [_loadWorkspaceTargets](tree) {
          if (!tree.workspaces || !tree.workspaces.size) return;
          const promises = [];
          for (const path of tree.workspaces.values()) if (!this[_cache].has(path)) {
            const p = this[_loadFSNode]({
              path,
              root: this[_actualTree],
              useRootOverrides: !0
            }).then((node => this[_loadFSTree](node)));
            promises.push(p);
          }
          await Promise.all(promises);
        }
        [_transplant](root) {
          if (root && root !== this[_actualTree]) {
            this[_actualTree][_changePath](root.path);
            for (const node of this[_actualTree].children.values()) this[_transplantFilter](node) || (node.root = null);
            root.replace(this[_actualTree]);
            for (const node of this[_actualTree].fsChildren) node.root = this[_transplantFilter](node) ? root : null;
            this[_actualTree] = root;
          }
        }
        [_loadFSNode]({path, parent, real, root, loadOverrides, useRootOverrides}) {
          if (!real) return realpath(path, this[_rpcache], this[_stcache]).then((real => this[_loadFSNode]({
            path,
            parent,
            real,
            root,
            loadOverrides,
            useRootOverrides
          })), (error => new Node({
            error,
            path,
            realpath: path,
            parent,
            root,
            loadOverrides
          })));
          const cached = this[_cache].get(path);
          if (cached && !cached.dummy) return Promise.resolve(cached).then((node => (node.parent = parent, 
          node)));
          const p = rpj(join(real, "package.json")).then((pkg => [ pkg, null ]), (error => [ null, error ])).then((([pkg, error]) => this[normalize(path) === real ? _newNode : _newLink]({
            installLinks: this.installLinks,
            legacyPeerDeps: this.legacyPeerDeps,
            path,
            realpath: real,
            pkg,
            error,
            parent,
            root,
            loadOverrides,
            ...useRootOverrides && root.overrides ? {
              overrides: root.overrides.getNodeRule({
                name: pkg.name,
                version: pkg.version
              })
            } : {}
          }))).then((node => (this[_cache].set(path, node), node)));
          return this[_cache].set(path, p), p;
        }
        [_newNode](options) {
          const {parent, realpath} = options;
          return parent || this[_topNodes].add(realpath), "1" === process.env._TEST_ARBORIST_SLOW_LINK_TARGET_ ? new Promise((res => setTimeout((() => res(new Node(options))), 100))) : new Node(options);
        }
        [_newLink](options) {
          const {realpath} = options;
          this[_topNodes].add(realpath);
          const target = this[_cache].get(realpath), link = new Link({
            ...options,
            target
          });
          return target ? (target.then && target.then((node => link.target = node)), link) : (this[_cache].set(realpath, link.target), 
          this[_loadFSTree](link.target).then((() => link)));
        }
        [_loadFSTree](node) {
          const did = this[_actualTreeLoaded];
          return (node = node.target).then ? node.then((node => this[_loadFSTree](node))) : did.has(node.realpath) ? Promise.resolve(node) : (did.add(node.realpath), 
          this[_loadFSChildren](node).then((() => Promise.all([ ...node.children.entries() ].filter((([name, kid]) => !did.has(kid.realpath))).map((([name, kid]) => this[_loadFSTree](kid)))))));
        }
        [_loadFSChildren](node) {
          const nm = resolve(node.realpath, "node_modules");
          return readdir(nm).then((kids => Promise.all(kids.filter((kid => !/^(@[^/]+\/)?\./.test(kid))).filter((kid => this[_filter](node, kid))).map((kid => this[_loadFSNode]({
            parent: node,
            path: resolve(nm, kid)
          }))))), (() => {}));
        }
        async [_findMissingEdges]() {
          const nmContents = new Map, tree = this[_actualTree];
          for (const node of tree.inventory.values()) {
            const ancestor = ancestorPath(node.realpath, this.path), depPromises = [];
            for (const [name, edge] of node.edgesOut.entries()) {
              if (!!(edge.missing || edge.to && (edge.to.dummy || edge.to.parent !== node))) for (const p of walkUp(dirname(node.realpath))) {
                if (ancestor && /^\.\.(?:[\\/]|$)/.test(relative(ancestor, p))) break;
                const entries = nmContents.get(p) || await readdir(p + "/node_modules").catch((() => []));
                if (nmContents.set(p, entries), !entries.includes(name)) continue;
                const d = this[_cache].has(p) ? await this[_cache].get(p) : new Node({
                  path: p,
                  root: node.root,
                  dummy: !0
                });
                if (this[_cache].set(p, d), d.dummy) {
                  const depPath = normalize(`${p}/node_modules/${name}`), cached = this[_cache].get(depPath);
                  cached && !cached.dummy || depPromises.push(this[_loadFSNode]({
                    path: depPath,
                    root: node.root,
                    parent: d
                  }).then((node => this[_loadFSTree](node))));
                }
                break;
              }
            }
            await Promise.all(depPromises);
          }
        }
        [_findFSParents]() {
          for (const path of this[_topNodes]) {
            const node = this[_cache].get(path);
            if (node && !node.parent && !node.fsParent) for (const p of walkUp(dirname(path))) if (this[_cache].has(p)) {
              node.fsParent = this[_cache].get(p);
              break;
            }
          }
        }
      };
    },
    24001: (module, __unused_webpack_exports, __webpack_require__) => {
      const localeCompare = __webpack_require__(51031)("en"), {resolve} = __webpack_require__(71017), nameFromFolder = __webpack_require__(3046), consistentResolve = __webpack_require__(27139), Shrinkwrap = __webpack_require__(33828), Node = __webpack_require__(41172), Link = __webpack_require__(3112), relpath = __webpack_require__(52452), calcDepFlags = __webpack_require__(52667), rpj = __webpack_require__(1759), treeCheck = __webpack_require__(56912), loadFromShrinkwrap = Symbol("loadFromShrinkwrap"), resolveNodes = Symbol("resolveNodes"), resolveLinks = Symbol("resolveLinks"), assignBundles = Symbol("assignBundles"), loadRoot = Symbol("loadRoot"), loadNode = Symbol("loadVirtualNode"), loadLink = Symbol("loadVirtualLink"), loadWorkspaces = Symbol.for("loadWorkspaces"), loadWorkspacesVirtual = Symbol.for("loadWorkspacesVirtual"), flagsSuspect = Symbol.for("flagsSuspect"), reCalcDepFlags = Symbol("reCalcDepFlags"), checkRootEdges = Symbol("checkRootEdges"), rootOptionProvided = Symbol("rootOptionProvided"), depsToEdges = (type, deps) => Object.entries(deps).map((d => [ type, ...d ]));
      module.exports = cls => class extends cls {
        constructor(options) {
          super(options), this.virtualTree = options.virtualTree, this[flagsSuspect] = !1;
        }
        async loadVirtual(options = {}) {
          if (this.virtualTree) return this.virtualTree;
          if ((options = {
            ...this.options,
            ...options
          }).root && options.root.meta) return await this[loadFromShrinkwrap](options.root.meta, options.root), 
          treeCheck(this.virtualTree);
          const s = await Shrinkwrap.load({
            path: this.path,
            lockfileVersion: this.options.lockfileVersion,
            resolveOptions: this.options
          });
          if (!s.loadedFromDisk && !options.root) {
            const er = new Error("loadVirtual requires existing shrinkwrap file");
            throw Object.assign(er, {
              code: "ENOLOCK"
            });
          }
          const {root = await this[loadRoot](s)} = options;
          return this[rootOptionProvided] = options.root, await this[loadFromShrinkwrap](s, root), 
          root.assertRootOverrides(), treeCheck(this.virtualTree);
        }
        async [loadRoot](s) {
          const pj = this.path + "/package.json", pkg = await rpj(pj).catch((() => s.data.packages[""])) || {};
          return this[loadWorkspaces](this[loadNode]("", pkg, !0));
        }
        async [loadFromShrinkwrap](s, root) {
          this[rootOptionProvided] ? this[flagsSuspect] = !0 : (root.extraneous = !1, root.dev = !1, 
          root.optional = !1, root.devOptional = !1, root.peer = !1), this[checkRootEdges](s, root), 
          root.meta = s, this.virtualTree = root;
          const {links, nodes} = this[resolveNodes](s, root);
          return await this[resolveLinks](links, nodes), s.originalLockfileVersion >= 2 || this[assignBundles](nodes), 
          this[flagsSuspect] && this[reCalcDepFlags](nodes.values()), root;
        }
        [reCalcDepFlags](nodes) {
          for (const node of nodes) node.isRoot || node === this[rootOptionProvided] || (node.extraneous = !0, 
          node.dev = !0, node.optional = !0, node.devOptional = !0, node.peer = !0);
          calcDepFlags(this.virtualTree, !this[rootOptionProvided]);
        }
        [checkRootEdges](s, root) {
          if (!s.loadedFromDisk || s.ancientLockfile) return;
          const lock = s.get(""), prod = lock.dependencies || {}, dev = lock.devDependencies || {}, optional = lock.optionalDependencies || {}, peer = lock.peerDependencies || {}, peerOptional = {};
          if (lock.peerDependenciesMeta) for (const [name, meta] of Object.entries(lock.peerDependenciesMeta)) meta.optional && void 0 !== peer[name] && (peerOptional[name] = peer[name], 
          delete peer[name]);
          for (const name of Object.keys(optional)) delete prod[name];
          const lockWS = [], workspaces = this[loadWorkspacesVirtual]({
            cwd: this.path,
            lockfile: s.data
          });
          for (const [name, path] of workspaces.entries()) lockWS.push([ "workspace", name, `file:${path.replace(/#/g, "%23")}` ]);
          const lockEdges = [ ...depsToEdges("prod", prod), ...depsToEdges("dev", dev), ...depsToEdges("optional", optional), ...depsToEdges("peer", peer), ...depsToEdges("peerOptional", peerOptional), ...lockWS ].sort((([atype, aname], [btype, bname]) => localeCompare(atype, btype) || localeCompare(aname, bname))), rootEdges = [ ...root.edgesOut.values() ].map((e => [ e.type, e.name, e.spec ])).sort((([atype, aname], [btype, bname]) => localeCompare(atype, btype) || localeCompare(aname, bname)));
          if (rootEdges.length !== lockEdges.length) return this[flagsSuspect] = !0;
          for (let i = 0; i < lockEdges.length; i++) if (rootEdges[i][0] !== lockEdges[i][0] || rootEdges[i][1] !== lockEdges[i][1] || rootEdges[i][2] !== lockEdges[i][2]) return this[flagsSuspect] = !0;
        }
        [resolveNodes](s, root) {
          const links = new Map, nodes = new Map([ [ "", root ] ]);
          for (const [location, meta] of Object.entries(s.data.packages)) location && (meta.link ? links.set(location, meta) : nodes.set(location, this[loadNode](location, meta)));
          return {
            links,
            nodes
          };
        }
        async [resolveLinks](links, nodes) {
          for (const [location, meta] of links.entries()) {
            const targetPath = resolve(this.path, meta.resolved), targetLoc = relpath(this.path, targetPath), target = nodes.get(targetLoc), link = this[loadLink](location, targetLoc, target, meta);
            if (nodes.set(location, link), nodes.set(targetLoc, link.target), !link.target.parent) {
              const pj = link.realpath + "/package.json", pkg = await rpj(pj).catch((() => null));
              pkg && (link.target.package = pkg);
            }
          }
        }
        [assignBundles](nodes) {
          for (const [location, node] of nodes) {
            if (!location || node.isLink && !node.target.location) continue;
            const {name, parent, package: {inBundle}} = node;
            if (!parent) continue;
            const {package: ppkg} = parent, {inBundle: parentBundled} = ppkg;
            inBundle && !parentBundled && parent.edgesOut.has(node.name) && (ppkg.bundleDependencies ? ppkg.bundleDependencies.push(name) : ppkg.bundleDependencies = [ name ]);
          }
        }
        [loadNode](location, sw, loadOverrides) {
          const p = this.virtualTree ? this.virtualTree.realpath : this.path, path = resolve(p, location);
          sw.name || (sw.name = nameFromFolder(path));
          const dev = sw.dev, optional = sw.optional, devOptional = dev || optional || sw.devOptional, peer = sw.peer, node = new Node({
            installLinks: this.installLinks,
            legacyPeerDeps: this.legacyPeerDeps,
            root: this.virtualTree,
            path,
            realpath: path,
            integrity: sw.integrity,
            resolved: consistentResolve(sw.resolved, this.path, path),
            pkg: sw,
            hasShrinkwrap: sw.hasShrinkwrap,
            dev,
            optional,
            devOptional,
            peer,
            loadOverrides
          });
          return node.extraneous = !!sw.extraneous, node.devOptional = !!(sw.devOptional || sw.dev || sw.optional), 
          node.peer = !!sw.peer, node.optional = !!sw.optional, node.dev = !!sw.dev, node;
        }
        [loadLink](location, targetLoc, target, meta) {
          const path = resolve(this.path, location), link = new Link({
            installLinks: this.installLinks,
            legacyPeerDeps: this.legacyPeerDeps,
            path,
            realpath: resolve(this.path, targetLoc),
            target,
            pkg: target && target.package
          });
          return link.extraneous = target.extraneous, link.devOptional = target.devOptional, 
          link.peer = target.peer, link.optional = target.optional, link.dev = target.dev, 
          link;
        }
      };
    },
    59003: (module, __unused_webpack_exports, __webpack_require__) => {
      const mapWorkspaces = __webpack_require__(69960), _appendWorkspaces = Symbol("appendWorkspaces"), _loadWorkspaces = Symbol.for("loadWorkspaces"), _loadWorkspacesVirtual = Symbol.for("loadWorkspacesVirtual");
      module.exports = cls => class extends cls {
        [_appendWorkspaces](node, workspaces) {
          return node && workspaces.size && (node.workspaces = workspaces), node;
        }
        async [_loadWorkspaces](node) {
          if (node.workspaces) return node;
          const workspaces = await mapWorkspaces({
            cwd: node.path,
            pkg: node.package
          });
          return this[_appendWorkspaces](node, workspaces);
        }
        [_loadWorkspacesVirtual](opts) {
          return mapWorkspaces.virtual(opts);
        }
      };
    },
    97645: module => {
      const _idealTreePrune = Symbol.for("idealTreePrune"), _workspacesEnabled = Symbol.for("workspacesEnabled"), _addNodeToTrashList = Symbol.for("addNodeToTrashList");
      module.exports = cls => class extends cls {
        async prune(options = {}) {
          if (options = {
            ...this.options,
            ...options
          }, await this.buildIdealTree(options), this[_idealTreePrune](), !this[_workspacesEnabled]) {
            const excludeNodes = this.excludeWorkspacesDependencySet(this.idealTree);
            for (const node of this.idealTree.inventory.values()) null === node.parent || node.isProjectRoot || excludeNodes.has(node) || this[_addNodeToTrashList](node);
          }
          return this.reify(options);
        }
      };
    },
    24717: (module, __unused_webpack_exports, __webpack_require__) => {
      const localeCompare = __webpack_require__(51031)("en"), {depth: dfwalk} = __webpack_require__(75476), promiseAllRejectLate = __webpack_require__(40639), rpj = __webpack_require__(1759), binLinks = __webpack_require__(38059), runScript = __webpack_require__(63036), promiseCallLimit = __webpack_require__(37180), {resolve} = __webpack_require__(71017), {isNodeGypPackage, defaultGypInstallScript} = __webpack_require__(66954), log = __webpack_require__(46521), boolEnv = b => b ? "1" : "", sortNodes = (a, b) => a.depth - b.depth || localeCompare(a.path, b.path), _workspaces = Symbol.for("workspaces"), _build = Symbol("build"), _loadDefaultNodes = Symbol("loadDefaultNodes"), _retrieveNodesByType = Symbol("retrieveNodesByType"), _resetQueues = Symbol("resetQueues"), _rebuildBundle = Symbol("rebuildBundle"), _ignoreScripts = Symbol("ignoreScripts"), _binLinks = Symbol("binLinks"), _oldMeta = Symbol("oldMeta"), _createBinLinks = Symbol("createBinLinks"), _doHandleOptionalFailure = Symbol("doHandleOptionalFailure"), _linkAllBins = Symbol("linkAllBins"), _runScripts = Symbol("runScripts"), _buildQueues = Symbol("buildQueues"), _addToBuildSet = Symbol("addToBuildSet"), _checkBins = Symbol.for("checkBins"), _queues = Symbol("queues"), _scriptShell = Symbol("scriptShell"), _includeWorkspaceRoot = Symbol.for("includeWorkspaceRoot"), _workspacesEnabled = Symbol.for("workspacesEnabled"), _force = Symbol.for("force"), _global = Symbol.for("global"), _handleOptionalFailure = Symbol.for("handleOptionalFailure"), _trashList = Symbol.for("trashList");
      module.exports = cls => class extends cls {
        constructor(options) {
          super(options);
          const {ignoreScripts = !1, scriptShell, binLinks = !0, rebuildBundle = !0} = options;
          this.scriptsRun = new Set, this[_binLinks] = binLinks, this[_ignoreScripts] = !!ignoreScripts, 
          this[_scriptShell] = scriptShell, this[_rebuildBundle] = !!rebuildBundle, this[_resetQueues](), 
          this[_oldMeta] = null;
        }
        async rebuild({nodes, handleOptionalFailure = !1} = {}) {
          if (this[_ignoreScripts] && !this[_binLinks]) return;
          this[_doHandleOptionalFailure] = handleOptionalFailure, nodes || (nodes = await this[_loadDefaultNodes]()), 
          process.emit("time", "build");
          const {depNodes, linkNodes} = this[_retrieveNodesByType](nodes);
          await this[_build](depNodes, {}), linkNodes.size && (this[_resetQueues](), await this[_build](linkNodes, {
            type: "links"
          })), process.emit("timeEnd", "build");
        }
        async [_loadDefaultNodes]() {
          let nodes;
          const tree = await this.loadActual();
          let filterSet;
          return this[_workspacesEnabled] ? this[_workspaces] && this[_workspaces].length ? (filterSet = this.workspaceDependencySet(tree, this[_workspaces], this[_includeWorkspaceRoot]), 
          nodes = tree.inventory.filter((node => filterSet.has(node)))) : nodes = tree.inventory.values() : (filterSet = this.excludeWorkspacesDependencySet(tree), 
          nodes = tree.inventory.filter((node => filterSet.has(node) || node.isProjectRoot))), 
          nodes;
        }
        [_retrieveNodesByType](nodes) {
          const depNodes = new Set, linkNodes = new Set;
          for (const node of nodes) node.isLink ? linkNodes.add(node) : depNodes.add(node);
          if (!this[_global]) for (const node of linkNodes) depNodes.delete(node.target);
          return {
            depNodes,
            linkNodes
          };
        }
        [_resetQueues]() {
          this[_queues] = {
            preinstall: [],
            install: [],
            postinstall: [],
            prepare: [],
            bin: []
          };
        }
        async [_build](nodes, {type = "deps"}) {
          process.emit("time", `build:${type}`), await this[_buildQueues](nodes), this[_ignoreScripts] || await this[_runScripts]("preinstall"), 
          "links" === type && await this[_runScripts]("prepare"), this[_binLinks] && await this[_linkAllBins](), 
          this[_ignoreScripts] || (await this[_runScripts]("install"), await this[_runScripts]("postinstall")), 
          process.emit("timeEnd", `build:${type}`);
        }
        async [_buildQueues](nodes) {
          process.emit("time", "build:queue");
          const set = new Set, promises = [];
          for (const node of nodes) if (promises.push(this[_addToBuildSet](node, set)), !1 !== this[_rebuildBundle]) {
            const bd = node.package.bundleDependencies;
            bd && bd.length && dfwalk({
              tree: node,
              leave: node => promises.push(this[_addToBuildSet](node, set)),
              getChildren: node => [ ...node.children.values() ],
              filter: node => node.inBundle
            });
          }
          await promiseAllRejectLate(promises);
          const queue = [ ...set ].sort(sortNodes);
          for (const node of queue) {
            const {package: {bin, scripts = {}}} = node.target, {preinstall, install, postinstall, prepare} = scripts, tests = {
              bin,
              preinstall,
              install,
              postinstall,
              prepare
            };
            for (const [key, has] of Object.entries(tests)) has && this[_queues][key].push(node);
          }
          process.emit("timeEnd", "build:queue");
        }
        async [_checkBins](node) {
          if (!node.globalTop || this[_force]) return;
          const {path, package: pkg} = node;
          await binLinks.checkBins({
            pkg,
            path,
            top: !0,
            global: !0
          });
        }
        async [_addToBuildSet](node, set, refreshed = !1) {
          if (set.has(node)) return;
          if (null === this[_oldMeta]) {
            const {root: {meta}} = node;
            this[_oldMeta] = meta && meta.loadedFromDisk && !(meta.originalLockfileVersion >= 2);
          }
          const {package: pkg, hasInstallScript} = node.target, {gypfile, bin, scripts = {}} = pkg, {preinstall, install, postinstall, prepare} = scripts;
          if (!refreshed && !(preinstall || install || postinstall || prepare) && (hasInstallScript || this[_oldMeta])) {
            set.add(node);
            const pkg = await rpj(node.path + "/package.json").catch((() => ({})));
            set.delete(node);
            const {scripts = {}} = pkg;
            return node.package.scripts = scripts, this[_addToBuildSet](node, set, !0);
          }
          const isGyp = !1 !== gypfile && !install && !preinstall && await isNodeGypPackage(node.path);
          (bin || preinstall || install || postinstall || prepare || isGyp) && (bin && await this[_checkBins](node), 
          isGyp && (scripts.install = defaultGypInstallScript, node.package.scripts = scripts), 
          set.add(node));
        }
        async [_runScripts](event) {
          const queue = this[_queues][event];
          if (!queue.length) return;
          process.emit("time", `build:run:${event}`);
          const stdio = this.options.foregroundScripts ? "inherit" : "pipe", limit = this.options.foregroundScripts ? 1 : void 0;
          await promiseCallLimit(queue.map((node => async () => {
            const {path, integrity, resolved, optional, peer, dev, devOptional, package: pkg, location} = node.target;
            if (this[_trashList].has(path)) return;
            const timer = `build:run:${event}:${location}`;
            process.emit("time", timer), log.info("run", pkg._id, event, location, pkg.scripts[event]);
            const env = {
              npm_package_resolved: resolved,
              npm_package_integrity: integrity,
              npm_package_json: resolve(path, "package.json"),
              npm_package_optional: boolEnv(optional),
              npm_package_dev: boolEnv(dev),
              npm_package_peer: boolEnv(peer),
              npm_package_dev_optional: boolEnv(devOptional && !dev && !optional)
            }, runOpts = {
              event,
              path,
              pkg,
              stdioString: !0,
              stdio,
              env,
              scriptShell: this[_scriptShell]
            }, p = runScript(runOpts).catch((er => {
              const {code, signal} = er;
              throw log.info("run", pkg._id, event, {
                code,
                signal
              }), er;
            })).then((({args, code, signal, stdout, stderr}) => {
              this.scriptsRun.add({
                pkg,
                path,
                event,
                cmd: args && args[args.length - 1],
                env,
                code,
                signal,
                stdout,
                stderr
              }), log.info("run", pkg._id, event, {
                code,
                signal
              });
            }));
            await (this[_doHandleOptionalFailure] ? this[_handleOptionalFailure](node, p) : p), 
            process.emit("timeEnd", timer);
          })), limit), process.emit("timeEnd", `build:run:${event}`);
        }
        async [_linkAllBins]() {
          const queue = this[_queues].bin;
          if (!queue.length) return;
          process.emit("time", "build:link");
          const promises = [];
          for (const node of queue.sort(sortNodes)) promises.push(this[_createBinLinks](node));
          await promiseAllRejectLate(promises), process.emit("timeEnd", "build:link");
        }
        async [_createBinLinks](node) {
          if (this[_trashList].has(node.path)) return;
          process.emit("time", `build:link:${node.location}`);
          const p = binLinks({
            pkg: node.package,
            path: node.path,
            top: !(!node.isTop && !node.globalTop),
            force: this[_force],
            global: !!node.globalTop
          });
          await (this[_doHandleOptionalFailure] ? this[_handleOptionalFailure](node, p) : p), 
          process.emit("timeEnd", `build:link:${node.location}`);
        }
      };
    },
    88917: (module, __unused_webpack_exports, __webpack_require__) => {
      const localeCompare = __webpack_require__(51031)("en"), npa = __webpack_require__(19932), pickManifest = __webpack_require__(65732), Vuln = __webpack_require__(26373), Calculator = __webpack_require__(8327), _getReport = Symbol("getReport"), _fixAvailable = Symbol("fixAvailable"), _checkTopNode = Symbol("checkTopNode"), _init = Symbol("init"), _omit = Symbol("omit"), log = __webpack_require__(46521), fetch = __webpack_require__(92427);
      class AuditReport extends Map {
        static load(tree, opts) {
          return new AuditReport(tree, opts).run();
        }
        get auditReportVersion() {
          return 2;
        }
        toJSON() {
          const obj = {
            auditReportVersion: this.auditReportVersion,
            vulnerabilities: {},
            metadata: {
              vulnerabilities: {
                info: 0,
                low: 0,
                moderate: 0,
                high: 0,
                critical: 0,
                total: this.size
              },
              dependencies: {
                prod: 0,
                dev: 0,
                optional: 0,
                peer: 0,
                peerOptional: 0,
                total: this.tree.inventory.size - 1
              }
            }
          };
          for (const node of this.tree.inventory.values()) {
            const {dependencies} = obj.metadata;
            let prod = !0;
            for (const type of [ "dev", "optional", "peer", "peerOptional" ]) node[type] && (dependencies[type]++, 
            prod = !1);
            prod && dependencies.prod++;
          }
          const vulnerabilities = [];
          for (const [name, vuln] of this.entries()) vulnerabilities.push([ name, vuln.toJSON() ]), 
          obj.metadata.vulnerabilities[vuln.severity]++;
          return obj.vulnerabilities = vulnerabilities.sort((([a], [b]) => localeCompare(a, b))).reduce(((set, [name, vuln]) => (set[name] = vuln, 
          set)), {}), obj;
        }
        constructor(tree, opts = {}) {
          super();
          const {omit} = opts;
          this[_omit] = new Set(omit || []), this.topVulns = new Map, this.calculator = new Calculator(opts), 
          this.error = null, this.options = opts, this.tree = tree, this.filterSet = opts.filterSet;
        }
        async run() {
          return this.report = await this[_getReport](), log.silly("audit report", this.report), 
          this.report && await this[_init](), this;
        }
        isVulnerable(node) {
          const vuln = this.get(node.packageName);
          return !(!vuln || !vuln.isVulnerable(node));
        }
        async [_init]() {
          process.emit("time", "auditReport:init");
          const promises = [];
          for (const [name, advisories] of Object.entries(this.report)) for (const advisory of advisories) promises.push(this.calculator.calculate(name, advisory));
          const advisories = new Set(await Promise.all(promises)), seen = new Set;
          for (const advisory of advisories) {
            const {name, range} = advisory, k = `${name}@${range}`, vuln = this.get(name) || new Vuln({
              name,
              advisory
            });
            if (this.has(name) && vuln.addAdvisory(advisory), super.set(name, vuln), !seen.has(k)) {
              const p = [];
              for (const node of this.tree.inventory.query("packageName", name)) if (shouldAudit(node, this[_omit], this.filterSet) && advisory.testVersion(node.version) && ("metavuln" === advisory.type && vuln.addVia(this.get(advisory.dependency)), 
              !vuln.nodes.has(node))) {
                vuln.nodes.add(node);
                for (const {from: dep, spec} of node.edgesIn) if (dep.isTop && !vuln.topNodes.has(dep)) this[_checkTopNode](dep, vuln, spec); else {
                  const calc = this.calculator.calculate(dep.packageName, advisory);
                  p.push(calc.then((meta => {
                    meta.testVersion(dep.version, spec) && advisories.add(meta);
                  })));
                }
              }
              await Promise.all(p), seen.add(k);
            }
            if (0 !== this.get(name).nodes.size) for (const advisory of vuln.advisories) {
              [ ...vuln.nodes ].some((n => advisory.testVersion(n.version))) || vuln.deleteAdvisory(advisory);
            } else this.delete(name);
          }
          process.emit("timeEnd", "auditReport:init");
        }
        [_checkTopNode](topNode, vuln, spec) {
          vuln.fixAvailable = this[_fixAvailable](topNode, vuln, spec), !0 !== vuln.fixAvailable && (this.topVulns.set(vuln.name, vuln), 
          vuln.topNodes.add(topNode));
        }
        [_fixAvailable](topNode, vuln, spec) {
          const paku = vuln.packument;
          if (!vuln.testSpec(spec)) return !0;
          const specObj = npa(spec);
          if (!specObj.registry) return !1;
          specObj.subSpec && (spec = specObj.subSpec.rawSpec);
          try {
            const {_isSemVerMajor: isSemVerMajor, version, name} = pickManifest(paku, spec, {
              ...this.options,
              before: null,
              avoid: vuln.range,
              avoidStrict: !0
            });
            return {
              name,
              version,
              isSemVerMajor
            };
          } catch (er) {
            return !1;
          }
        }
        set() {
          throw new Error("do not call AuditReport.set() directly");
        }
        static auditToBulk(report) {
          if (!report.advisories) throw Object.assign(new Error("Invalid advisory report"), {
            body: JSON.stringify(report)
          });
          const bulk = {}, {advisories} = report;
          for (const advisory of Object.values(advisories)) {
            const {id, url, title, severity = "high", vulnerable_versions = "*", module_name: name} = advisory;
            bulk[name] = bulk[name] || [], bulk[name].push({
              id,
              url,
              title,
              severity,
              vulnerable_versions
            });
          }
          return bulk;
        }
        async [_getReport]() {
          if (!1 === this.options.audit || !0 === this.options.offline || 1 === this.tree.inventory.size) return null;
          process.emit("time", "auditReport:getReport");
          try {
            try {
              const body = prepareBulkData(this.tree, this[_omit], this.filterSet);
              if (log.silly("audit", "bulk request", body), !Object.keys(body).length) return null;
              const res = await fetch("/-/npm/v1/security/advisories/bulk", {
                ...this.options,
                registry: this.options.auditRegistry || this.options.registry,
                method: "POST",
                gzip: !0,
                body
              });
              return await res.json();
            } catch (er) {
              log.silly("audit", "bulk request failed", String(er.body));
              const body = prepareData(this.tree, this.options), res = await fetch("/-/npm/v1/security/audits/quick", {
                ...this.options,
                registry: this.options.auditRegistry || this.options.registry,
                method: "POST",
                gzip: !0,
                body
              });
              return AuditReport.auditToBulk(await res.json());
            }
          } catch (er) {
            return log.verbose("audit error", er), log.silly("audit error", String(er.body)), 
            this.error = er, null;
          } finally {
            process.emit("timeEnd", "auditReport:getReport");
          }
        }
      }
      const shouldAudit = (node, omit, filterSet) => !!node.version && (!node.isRoot && (!(filterSet && 0 !== filterSet.size && !filterSet.has(node)) && (0 === omit.size || !(node.dev && omit.has("dev") || node.optional && omit.has("optional") || node.devOptional && omit.has("dev") && omit.has("optional") || node.peer && omit.has("peer"))))), prepareBulkData = (tree, omit, filterSet) => {
        const payload = {};
        for (const name of tree.inventory.query("packageName")) {
          const set = new Set;
          for (const node of tree.inventory.query("packageName", name)) shouldAudit(node, omit, filterSet) && set.add(node.version);
          set.size && (payload[name] = [ ...set ]);
        }
        return payload;
      }, prepareData = (tree, opts) => {
        const {npmVersion: npm_version} = opts, node_version = process.version, {platform, arch} = process, {NODE_ENV: node_env} = process.env, data = tree.meta.commit();
        return {
          name: data.name,
          version: data.version,
          requires: {
            ...tree.package.devDependencies || {},
            ...tree.package.peerDependencies || {},
            ...tree.package.optionalDependencies || {},
            ...tree.package.dependencies || {}
          },
          dependencies: data.dependencies,
          metadata: {
            node_version,
            npm_version,
            platform,
            arch,
            node_env
          }
        };
      };
      module.exports = AuditReport;
    },
    52667: (module, __unused_webpack_exports, __webpack_require__) => {
      const {depth} = __webpack_require__(75476), calcDepFlagsStep = node => (node.extraneous = !1, 
      resetParents(node, "extraneous"), resetParents(node, "dev"), resetParents(node, "peer"), 
      resetParents(node, "devOptional"), resetParents(node, "optional"), node.isLink ? (node.target.dev = node.dev, 
      node.target.optional = node.optional, node.target.devOptional = node.devOptional, 
      node.target.peer = node.peer, calcDepFlagsStep(node.target)) : (node.edgesOut.forEach((({peer, optional, dev, to}) => {
        if (!to) return;
        to.extraneous = !1;
        const unsetDevOpt = !(node.devOptional || node.dev || node.optional || dev || optional), unsetDev = unsetDevOpt || !node.dev && !dev, unsetOpt = unsetDevOpt || !node.optional && !optional;
        !node.peer && !peer && unsetFlag(to, "peer"), unsetDevOpt && unsetFlag(to, "devOptional"), 
        unsetDev && unsetFlag(to, "dev"), unsetOpt && unsetFlag(to, "optional");
      })), node)), resetParents = (node, flag) => {
        if (!node[flag]) for (let p = node; p && (p === node || p[flag]); p = p.resolveParent) p[flag] = !1;
      }, unsetFlag = (node, flag) => {
        node[flag] && (node[flag] = !1, depth({
          tree: node,
          visit: node => {
            node.extraneous = node[flag] = !1, node.isLink && (node.target.extraneous = node.target[flag] = !1);
          },
          getChildren: node => [ ...node.target.edgesOut.values() ].filter((edge => edge.to && edge.to[flag] && ("peer" !== flag && "peer" === edge.type || "prod" === edge.type))).map((edge => edge.to))
        }));
      };
      module.exports = (tree, resetRoot = !0) => {
        resetRoot && (tree.dev = !1, tree.optional = !1, tree.devOptional = !1, tree.peer = !1);
        const ret = depth({
          tree,
          visit: node => calcDepFlagsStep(node),
          filter: node => node,
          getChildren: (node, tree) => [ ...tree.edgesOut.values() ].map((edge => edge.to))
        });
        return ret;
      };
    },
    19450: (module, __unused_webpack_exports, __webpack_require__) => {
      const localeCompare = __webpack_require__(51031)("en"), semver = __webpack_require__(5870), debug = __webpack_require__(63120), peerEntrySets = __webpack_require__(67557), deepestNestingTarget = __webpack_require__(36829), CONFLICT = Symbol("CONFLICT"), OK = Symbol("OK"), REPLACE = Symbol("REPLACE"), KEEP = Symbol("KEEP");
      class CanPlaceDep {
        constructor(options) {
          const {dep, target, edge, preferDedupe, parent = null, peerPath = [], explicitRequest = !1} = options;
          debug((() => {
            if (!dep) throw new Error("no dep provided to CanPlaceDep");
            if (!target) throw new Error("no target provided to CanPlaceDep");
            if (!edge) throw new Error("no edge provided to CanPlaceDep");
            this._treeSnapshot = JSON.stringify([ ...target.root.inventory.entries() ].map((([loc, {packageName, version, resolved}]) => [ loc, packageName, version, resolved ])).sort((([a], [b]) => localeCompare(a, b))));
          })), this.canPlace = null, this.canPlaceSelf = null, this.dep = dep, this.target = target, 
          this.edge = edge, this.explicitRequest = explicitRequest, this.peerPath = peerPath, 
          this.preferDedupe = !!preferDedupe || edge.peer, this.parent = parent, this.children = [], 
          this.isSource = target === this.peerSetSource, this.name = edge.name, this.current = target.children.get(this.name), 
          this.targetEdge = target.edgesOut.get(this.name), this.conflicts = new Map, this.edgeOverride = !dep.satisfies(edge), 
          this.canPlace = this.checkCanPlace(), this.canPlaceSelf || (this.canPlaceSelf = this.canPlace), 
          debug((() => {
            const treeSnapshot = JSON.stringify([ ...target.root.inventory.entries() ].map((([loc, {packageName, version, resolved}]) => [ loc, packageName, version, resolved ])).sort((([a], [b]) => localeCompare(a, b))));
            if (this._treeSnapshot !== treeSnapshot) throw Object.assign(new Error("tree changed in CanPlaceDep"), {
              expect: this._treeSnapshot,
              actual: treeSnapshot
            });
          }));
        }
        checkCanPlace() {
          const {target, targetEdge, current, dep} = this;
          return dep.errors.length ? current ? REPLACE : OK : targetEdge && targetEdge.peer && !target.isTop ? CONFLICT : current || !targetEdge || dep.satisfies(targetEdge) || targetEdge === this.edge ? current ? this.checkCanPlaceCurrent() : this.checkCanPlaceNoCurrent() : CONFLICT;
        }
        checkCanPlaceCurrent() {
          const {preferDedupe, explicitRequest, current, target, edge, dep} = this;
          if (dep.matches(current) && (current.satisfies(edge) || this.edgeOverride)) return explicitRequest ? REPLACE : KEEP;
          const {version: curVer} = current, {version: newVer} = dep, tryReplace = curVer && newVer && semver.gte(newVer, curVer);
          if (tryReplace && dep.canReplace(current)) {
            const cpp = this.canPlacePeers(REPLACE);
            if (cpp !== CONFLICT) return cpp;
          }
          if (current.satisfies(edge) && (!explicitRequest || preferDedupe)) return KEEP;
          if (preferDedupe && !tryReplace && dep.canReplace(current)) {
            const cpp = this.canPlacePeers(REPLACE);
            if (cpp !== CONFLICT) return cpp;
          }
          if (target !== this.deepestNestingTarget) return CONFLICT;
          if (!edge.peer && target === edge.from) return this.canPlacePeers(REPLACE);
          if (!this.parent && !edge.peer) return CONFLICT;
          let canReplace = !0;
          for (const [entryEdge, currentPeers] of peerEntrySets(current)) {
            if (entryEdge === this.edge || entryEdge === this.peerEntryEdge) continue;
            const entryNode = entryEdge.to, entryRep = dep.parent.children.get(entryNode.name);
            if (entryRep && entryRep.canReplace(entryNode, dep.parent.children.keys())) continue;
            let canClobber = !entryRep;
            if (!entryRep) {
              const peerReplacementWalk = new Set([ entryNode ]);
              OUTER: for (const currentPeer of peerReplacementWalk) for (const edge of currentPeer.edgesOut.values()) {
                if (!edge.peer || !edge.valid) continue;
                const rep = dep.parent.children.get(edge.name);
                if (rep) {
                  if (!rep.satisfies(edge)) {
                    canClobber = !1;
                    break OUTER;
                  }
                } else edge.to && peerReplacementWalk.add(edge.to);
              }
            }
            if (canClobber) continue;
            let canNestCurrent = !0;
            for (const currentPeer of currentPeers) {
              if (!canNestCurrent) break;
              const curDeep = deepestNestingTarget(entryEdge.from, currentPeer.name);
              (curDeep === target || target.isDescendantOf(curDeep)) && (canNestCurrent = !1, 
              canReplace = !1);
            }
          }
          return canReplace ? this.canPlacePeers(REPLACE) : CONFLICT;
        }
        checkCanPlaceNoCurrent() {
          const {target, peerEntryEdge, dep, name} = this, current = target !== peerEntryEdge.from && target.resolve(name);
          if (current) for (const edge of current.edgesIn.values()) if (edge.from.isDescendantOf(target) && edge.valid && !dep.satisfies(edge)) return CONFLICT;
          return this.canPlacePeers(OK);
        }
        get deepestNestingTarget() {
          const start = this.parent ? this.parent.deepestNestingTarget : this.edge.from;
          return deepestNestingTarget(start, this.name);
        }
        get conflictChildren() {
          return this.allChildren.filter((c => c.canPlace === CONFLICT));
        }
        get allChildren() {
          const set = new Set(this.children);
          for (const child of set) for (const grandchild of child.children) set.add(grandchild);
          return [ ...set ];
        }
        get top() {
          return this.parent ? this.parent.top : this;
        }
        canPlacePeers(state) {
          if (this.canPlaceSelf = state, this._canPlacePeers) return this._canPlacePeers;
          const peerPath = [ ...this.peerPath, this.dep ];
          let sawConflict = !1;
          for (const peerEdge of this.dep.edgesOut.values()) {
            if (!peerEdge.peer || !peerEdge.to || peerPath.includes(peerEdge.to)) continue;
            const peer = peerEdge.to, target = deepestNestingTarget(this.target, peer.name), cpp = new CanPlaceDep({
              dep: peer,
              target,
              parent: this,
              edge: peerEdge,
              peerPath,
              preferDedupe: !0
            });
            debug((() => {
              if (this.children.some((c => c.dep === cpp.dep))) throw new Error("checking same dep repeatedly");
            })), this.children.push(cpp), cpp.canPlace === CONFLICT && (sawConflict = !0);
          }
          return this._canPlacePeers = sawConflict ? CONFLICT : state, this._canPlacePeers;
        }
        get peerSetSource() {
          return this.parent ? this.parent.peerSetSource : this.edge.from;
        }
        get peerEntryEdge() {
          return this.top.edge;
        }
        static get CONFLICT() {
          return CONFLICT;
        }
        static get OK() {
          return OK;
        }
        static get REPLACE() {
          return REPLACE;
        }
        static get KEEP() {
          return KEEP;
        }
        get description() {
          const {canPlace} = this;
          return canPlace && canPlace.description || canPlace;
        }
      }
      module.exports = CanPlaceDep;
    },
    19303: module => {
      const _keys = Symbol("keys"), _normKey = Symbol("normKey"), OGMap = Map;
      module.exports = class extends OGMap {
        constructor(items = []) {
          super(), this[_keys] = new OGMap;
          for (const [key, val] of items) this.set(key, val);
        }
        [_normKey](key) {
          return "string" == typeof key ? key.normalize("NFKD").toLowerCase() : key;
        }
        get(key) {
          const normKey = this[_normKey](key);
          return this[_keys].has(normKey) ? super.get(this[_keys].get(normKey)) : void 0;
        }
        set(key, val) {
          const normKey = this[_normKey](key);
          return this[_keys].has(normKey) && super.delete(this[_keys].get(normKey)), this[_keys].set(normKey, key), 
          super.set(key, val);
        }
        delete(key) {
          const normKey = this[_normKey](key);
          if (this[_keys].has(normKey)) {
            const prevKey = this[_keys].get(normKey);
            return this[_keys].delete(normKey), super.delete(prevKey);
          }
        }
        has(key) {
          const normKey = this[_normKey](key);
          return this[_keys].has(normKey) && super.has(this[_keys].get(normKey));
        }
      };
    },
    27139: (module, __unused_webpack_exports, __webpack_require__) => {
      const npa = __webpack_require__(19932), relpath = __webpack_require__(52452);
      module.exports = (resolved, fromPath, toPath, relPaths = !1) => {
        if (!resolved) return null;
        try {
          const hostedOpt = {
            noCommittish: !1
          }, {fetchSpec, saveSpec, type, hosted, rawSpec, raw} = npa(resolved, fromPath), isPath = "file" === type || "directory" === type;
          return isPath && !relPaths ? `file:${fetchSpec.replace(/#/g, "%23")}` : isPath ? "file:" + (toPath ? relpath(toPath, fetchSpec.replace(/#/g, "%23")) : fetchSpec.replace(/#/g, "%23")) : hosted ? `git+${hosted.auth ? hosted.https(hostedOpt) : hosted.sshurl(hostedOpt)}` : "git" === type ? saveSpec : "" === rawSpec && "@" !== raw.slice(-1) ? raw : rawSpec;
        } catch (_) {
          return resolved;
        }
      };
    },
    63120: (module, __unused_webpack_exports, __webpack_require__) => {
      const debug = "0" !== process.env.ARBORIST_DEBUG && ("1" === process.env.ARBORIST_DEBUG || /\barborist\b/.test(process.env.NODE_DEBUG || "") || "@npmcli/arborist" === process.env.npm_package_name && [ "test", "snap" ].includes(process.env.npm_lifecycle_event) || process.cwd() === __webpack_require__(71017).resolve(__dirname, ".."));
      module.exports = debug ? fn => fn() : () => {};
      const red = process.stderr.isTTY ? msg => `[31m${msg}[39m` : m => m;
      module.exports.log = (...msg) => module.exports((() => {
        const {format} = __webpack_require__(73837), prefix = `\n${process.pid} ${red(format(msg.shift()))} `;
        msg = (prefix + format(...msg).trim().split("\n").join(prefix)).trim(), console.error(msg);
      }));
    },
    36829: module => {
      module.exports = (start, name) => {
        for (const target of start.ancestry()) {
          if (target.isProjectRoot || !target.resolveParent || target.globalTop) return target;
          const targetEdge = target.edgesOut.get(name);
          if (!targetEdge || !targetEdge.peer) return target;
        }
      };
    },
    58999: (module, __unused_webpack_exports, __webpack_require__) => {
      const semver = __webpack_require__(5870), npa = __webpack_require__(19932), {relative} = __webpack_require__(71017), fromPath = __webpack_require__(25581), depValid = (child, requested, requestor) => {
        if ("string" == typeof requested) try {
          requested = npa.resolve(child.name, requested || "*", fromPath(requestor, requestor.edgesOut.get(child.name)));
        } catch (er) {
          return er.dependency = child.name, er.requested = requested, requestor.errors.push(er), 
          !1;
        }
        if (!requested) {
          const er = new Error("Invalid dependency specifier");
          return er.dependency = child.name, er.requested = requested, requestor.errors.push(er), 
          !1;
        }
        switch (requested.type) {
         case "range":
          if ("*" === requested.fetchSpec) return !0;

         case "version":
          return semver.satisfies(child.version, requested.fetchSpec, !0);

         case "directory":
          return linkValid(child, requested, requestor);

         case "file":
          return tarballValid(child, requested, requestor);

         case "alias":
          return depValid(child, requested.subSpec, requestor);

         case "tag":
          return child.resolved && "remote" === npa(child.resolved).type;

         case "remote":
          return child.resolved === requested.fetchSpec;

         case "git":
          {
            const resRepo = npa(child.resolved || ""), resHost = resRepo.hosted, reqHost = requested.hosted, nc = {
              noCommittish: !/^[a-fA-F0-9]{40}$/.test(requested.gitCommittish || "")
            };
            return !!(resHost ? reqHost && reqHost.ssh(nc) === resHost.ssh(nc) : resRepo.fetchSpec === requested.fetchSpec) && (!requested.gitRange || semver.satisfies(child.package.version, requested.gitRange, {
              loose: !0
            }));
          }
        }
        const er = new Error("Unsupported dependency type");
        return er.dependency = child.name, er.requested = requested, requestor.errors.push(er), 
        !1;
      }, linkValid = (child, requested, requestor) => {
        const isLink = !!child.isLink;
        return requestor.installLinks ? !isLink : isLink && "" === relative(child.realpath, requested.fetchSpec);
      }, tarballValid = (child, requested, requestor) => !child.isLink && (child.resolved ? child.resolved.replace(/\\/g, "/") === `file:${requested.fetchSpec.replace(/\\/g, "/")}` : !!child.package._requested && child.package._requested.saveSpec === requested.saveSpec);
      module.exports = (child, requested, accept, requestor) => depValid(child, requested, requestor) || "string" == typeof accept && depValid(child, accept, requestor);
    },
    63636: (module, __unused_webpack_exports, __webpack_require__) => {
      const {depth} = __webpack_require__(75476), {existsSync} = __webpack_require__(57147), ssri = __webpack_require__(60440);
      class Diff {
        constructor({actual, ideal, filterSet, shrinkwrapInflated}) {
          this.filterSet = filterSet, this.shrinkwrapInflated = shrinkwrapInflated, this.children = [], 
          this.actual = actual, this.ideal = ideal, this.ideal && (this.resolved = this.ideal.resolved, 
          this.integrity = this.ideal.integrity), this.action = getAction(this), this.parent = null, 
          this.leaves = [], this.unchanged = [], this.removed = [];
        }
        static calculate({actual, ideal, filterNodes = [], shrinkwrapInflated = new Set}) {
          const filterSet = new Set, extraneous = new Set;
          for (const filterNode of filterNodes) {
            const {root} = filterNode;
            if (root !== ideal && root !== actual) throw new Error("invalid filterNode: outside idealTree/actualTree");
            const rootTarget = root.target, edge = [ ...rootTarget.edgesOut.values() ].filter((e => e.to && (e.to === filterNode || e.to.target === filterNode)))[0];
            filterSet.add(root), filterSet.add(rootTarget), filterSet.add(ideal), filterSet.add(actual), 
            edge && edge.to && (filterSet.add(edge.to), filterSet.add(edge.to.target)), filterSet.add(filterNode), 
            depth({
              tree: filterNode,
              visit: node => filterSet.add(node),
              getChildren: node => {
                const loc = (node = node.target).location, idealNode = ideal.inventory.get(loc), ideals = idealNode ? [ ...idealNode.edgesOut.values() ].filter((e => e.to)).map((e => e.to)) : [], actualNode = actual.inventory.get(loc), actuals = actualNode ? [ ...actualNode.edgesOut.values() ].filter((e => e.to)).map((e => e.to)) : [];
                if (actualNode) for (const child of actualNode.children.values()) child.extraneous && extraneous.add(child);
                return ideals.concat(actuals);
              }
            });
          }
          for (const extra of extraneous) filterSet.add(extra);
          return depth({
            tree: new Diff({
              actual,
              ideal,
              filterSet,
              shrinkwrapInflated
            }),
            getChildren,
            leave
          });
        }
      }
      const getAction = ({actual, ideal}) => {
        if (!ideal) return "REMOVE";
        if (!actual) return ideal.inDepBundle ? null : "ADD";
        if (ideal.isRoot && actual.isRoot) return null;
        if (ideal.version !== actual.version) return "CHANGE";
        const binsExist = ideal.binPaths.every((path => existsSync(path))), noIntegrity = !ideal.integrity && !actual.integrity, noResolved = !ideal.resolved && !actual.resolved, resolvedMatch = ideal.resolved && ideal.resolved === actual.resolved;
        if (noIntegrity && binsExist && (resolvedMatch || noResolved)) return null;
        return !ideal.integrity || !actual.integrity || !ssri.parse(ideal.integrity).match(actual.integrity) || !binsExist ? "CHANGE" : null;
      }, allChildren = node => {
        if (!node) return new Map;
        if (node.isRoot && node.isLink) return allChildren(node.target);
        const kids = new Map;
        for (const n of [ node, ...node.fsChildren ]) for (const kid of n.children.values()) kids.set(kid.path, kid);
        return kids;
      }, getChildren = diff => {
        const children = [], {actual, ideal, unchanged, removed, filterSet, shrinkwrapInflated} = diff, actualKids = allChildren(actual), idealKids = allChildren(ideal);
        if (ideal && ideal.hasShrinkwrap && !shrinkwrapInflated.has(ideal)) return diff.leaves.push(diff), 
        children;
        const paths = new Set([ ...actualKids.keys(), ...idealKids.keys() ]);
        for (const path of paths) {
          const actual = actualKids.get(path), ideal = idealKids.get(path);
          diffNode({
            actual,
            ideal,
            children,
            unchanged,
            removed,
            filterSet,
            shrinkwrapInflated
          });
        }
        return diff.leaves && !children.length && diff.leaves.push(diff), children;
      }, diffNode = ({actual, ideal, children, unchanged, removed, filterSet, shrinkwrapInflated}) => {
        if (filterSet.size && !filterSet.has(ideal) && !filterSet.has(actual)) return;
        const action = getAction({
          actual,
          ideal
        });
        if (action || !shrinkwrapInflated.has(ideal) && ideal.hasShrinkwrap) "REMOVE" === action && removed.push(actual), 
        children.push(new Diff({
          actual,
          ideal,
          filterSet,
          shrinkwrapInflated
        })); else {
          unchanged.push(ideal);
          const bd = ideal.package.bundleDependencies;
          if (actual && bd && bd.length) {
            const bundledChildren = [];
            for (const node of actual.children.values()) node.inBundle && bundledChildren.push(node);
            for (const node of bundledChildren) node.parent = ideal;
          }
          children.push(...getChildren({
            actual,
            ideal,
            unchanged,
            removed,
            filterSet,
            shrinkwrapInflated
          }));
        }
      }, leave = (diff, children) => (children.forEach((kid => {
        kid.parent = diff, diff.leaves.push(...kid.leaves), diff.unchanged.push(...kid.unchanged), 
        diff.removed.push(...kid.removed);
      })), diff.children = children, diff);
      module.exports = Diff;
    },
    23920: (module, __unused_webpack_exports, __webpack_require__) => {
      const util = __webpack_require__(73837), npa = __webpack_require__(19932), depValid = __webpack_require__(58999), _from = Symbol("_from"), _to = Symbol("_to"), _type = Symbol("_type"), _spec = Symbol("_spec"), _accept = Symbol("_accept"), _name = Symbol("_name"), _error = Symbol("_error"), _loadError = Symbol("_loadError"), _setFrom = Symbol("_setFrom"), _explain = Symbol("_explain"), _explanation = Symbol("_explanation"), types = new Set([ "prod", "dev", "optional", "peer", "peerOptional", "workspace" ]);
      class ArboristEdge {}
      class Edge {
        constructor(options) {
          const {type, name, spec, accept, from, overrides} = options;
          if ("string" != typeof spec) throw new TypeError("must provide string spec");
          if ("workspace" === type && "directory" !== npa(spec).type) throw new TypeError("workspace edges must be a symlink");
          if (this[_spec] = spec, void 0 !== overrides && (this.overrides = overrides), void 0 !== accept) {
            if ("string" != typeof accept) throw new TypeError("accept field must be a string if provided");
            this[_accept] = accept || "*";
          }
          if ("string" != typeof name) throw new TypeError("must provide dependency name");
          if (this[_name] = name, !types.has(type)) throw new TypeError(`invalid type: ${type}\n(valid types are: ${Edge.types.join(", ")})`);
          if (this[_type] = type, !from) throw new TypeError('must provide "from" node');
          this[_setFrom](from), this[_error] = this[_loadError](), this.peerConflicted = !1;
        }
        satisfiedBy(node) {
          if (node.name !== this.name) return !1;
          const spec = node.hasShrinkwrap || node.inShrinkwrap || node.inBundle ? this.rawSpec : this.spec;
          return depValid(node, spec, this.accept, this.from);
        }
        explain(seen = []) {
          return this[_explanation] ? this[_explanation] : this[_explanation] = this[_explain](seen);
        }
        [_explain](seen) {
          const {error, from, bundled} = this;
          return {
            type: this.type,
            name: this.name,
            spec: this.spec,
            ...this.rawSpec !== this.spec ? {
              rawSpec: this.rawSpec,
              overridden: !0
            } : {},
            ...bundled ? {
              bundled
            } : {},
            ...error ? {
              error
            } : {},
            ...from ? {
              from: from.explain(null, seen)
            } : {}
          };
        }
        get bundled() {
          if (!this.from) return !1;
          const {package: {bundleDependencies = []}} = this.from;
          return bundleDependencies.includes(this.name);
        }
        get workspace() {
          return "workspace" === this[_type];
        }
        get prod() {
          return "prod" === this[_type];
        }
        get dev() {
          return "dev" === this[_type];
        }
        get optional() {
          return "optional" === this[_type] || "peerOptional" === this[_type];
        }
        get peer() {
          return "peer" === this[_type] || "peerOptional" === this[_type];
        }
        get type() {
          return this[_type];
        }
        get name() {
          return this[_name];
        }
        get rawSpec() {
          return this[_spec];
        }
        get spec() {
          if (this.overrides && this.overrides.value && this.overrides.name === this.name) {
            if (this.overrides.value.startsWith("$")) {
              const ref = this.overrides.value.slice(1), pkg = this.from.sourceReference ? this.from.sourceReference.root.package : this.from.root.package, overrideSpec = pkg.devDependencies && pkg.devDependencies[ref] || pkg.optionalDependencies && pkg.optionalDependencies[ref] || pkg.dependencies && pkg.dependencies[ref] || pkg.peerDependencies && pkg.peerDependencies[ref];
              if (overrideSpec) return overrideSpec;
              throw new Error(`Unable to resolve reference ${this.overrides.value}`);
            }
            return this.overrides.value;
          }
          return this[_spec];
        }
        get accept() {
          return this[_accept];
        }
        get valid() {
          return !this.error;
        }
        get missing() {
          return "MISSING" === this.error;
        }
        get invalid() {
          return "INVALID" === this.error;
        }
        get peerLocal() {
          return "PEER LOCAL" === this.error;
        }
        get error() {
          return this[_error] = this[_error] || this[_loadError](), "OK" === this[_error] ? null : this[_error];
        }
        [_loadError]() {
          return this[_to] ? this.peer && this.from === this.to.parent && !this.from.isTop ? "PEER LOCAL" : this.satisfiedBy(this.to) ? "OK" : "INVALID" : this.optional ? null : "MISSING";
        }
        reload(hard = !1) {
          this[_explanation] = null, this[_from].overrides ? this.overrides = this[_from].overrides.getEdgeRule(this) : delete this.overrides;
          const newTo = this[_from].resolve(this.name);
          newTo !== this[_to] ? (this[_to] && this[_to].edgesIn.delete(this), this[_to] = newTo, 
          this[_error] = this[_loadError](), this[_to] && this[_to].addEdgeIn(this)) : hard && (this[_error] = this[_loadError]());
        }
        detach() {
          this[_explanation] = null, this[_to] && this[_to].edgesIn.delete(this), this[_from].edgesOut.delete(this.name), 
          this[_to] = null, this[_error] = "DETACHED", this[_from] = null;
        }
        [_setFrom](node) {
          this[_explanation] = null, this[_from] = node, node.edgesOut.has(this.name) && node.edgesOut.get(this.name).detach(), 
          node.addEdgeOut(this), this.reload();
        }
        get from() {
          return this[_from];
        }
        get to() {
          return this[_to];
        }
        toJSON() {
          return (edge => {
            const edgeFrom = edge.from && edge.from.location, edgeTo = edge.to && edge.to.location, override = edge.overrides && edge.overrides.value;
            return Object.assign(new ArboristEdge, {
              name: edge.name,
              spec: edge.spec,
              type: edge.type,
              ...null != edgeFrom ? {
                from: edgeFrom
              } : {},
              ...edgeTo ? {
                to: edgeTo
              } : {},
              ...edge.error ? {
                error: edge.error
              } : {},
              ...edge.peerConflicted ? {
                peerConflicted: !0
              } : {},
              ...override ? {
                overridden: override
              } : {}
            });
          })(this);
        }
        [util.inspect.custom]() {
          return this.toJSON();
        }
      }
      Edge.types = [ ...types ], Edge.errors = [ "DETACHED", "MISSING", "PEER LOCAL", "INVALID" ], 
      module.exports = Edge;
    },
    25581: (module, __unused_webpack_exports, __webpack_require__) => {
      const {dirname} = __webpack_require__(71017), npa = __webpack_require__(19932);
      module.exports = (node, edge) => ((node, spec, edge) => edge && edge.overrides && edge.overrides.name === edge.name && edge.overrides.value ? node.sourceReference ? node.sourceReference.root.realpath : node.root.realpath : spec && "file" === spec.type ? dirname(spec.fetchSpec) : node.realpath)(node, node.resolved && npa(node.resolved), edge);
    },
    87280: module => {
      module.exports = (set, edgeFilter) => {
        const deps = new Set(set);
        for (const node of deps) for (const edge of node.edgesOut.values()) edge.to && edgeFilter(edge) && deps.add(edge.to);
        let changed = !0;
        for (;!0 === changed && deps.size > 0; ) {
          changed = !1;
          for (const dep of deps) for (const edge of dep.edgesIn) if (!deps.has(edge.from) && edgeFilter(edge)) {
            changed = !0, deps.delete(dep);
            break;
          }
        }
        return deps;
      };
    },
    62349: (module, __unused_webpack_exports, __webpack_require__) => {
      const log = __webpack_require__(46521), relpath = __webpack_require__(52452);
      module.exports = (tree, workspaces) => {
        const wsMap = tree.workspaces;
        if (!wsMap) return log.warn("workspaces", "filter set, but no workspaces present"), 
        [];
        const nodes = [];
        for (const name of workspaces) {
          const path = wsMap.get(name);
          if (!path) {
            log.warn("workspaces", `${name} in filter set, but not in workspaces`);
            continue;
          }
          const loc = relpath(tree.realpath, path), node = tree.inventory.get(loc);
          node ? nodes.push(node) : log.warn("workspaces", `${name} in filter set, but no workspace folder present`);
        }
        return nodes;
      };
    },
    22290: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = __webpack_require__(10488), module.exports.Arborist = module.exports, 
      module.exports.Node = __webpack_require__(41172), module.exports.Link = __webpack_require__(3112), 
      module.exports.Edge = __webpack_require__(23920), module.exports.Shrinkwrap = __webpack_require__(33828);
    },
    30625: (module, __unused_webpack_exports, __webpack_require__) => {
      const _primaryKey = Symbol("_primaryKey"), _index = Symbol("_index"), defaultKeys = [ "name", "license", "funding", "realpath", "packageName" ], {hasOwnProperty} = Object.prototype, debug = __webpack_require__(63120), getLicense = pkg => {
        if (pkg) {
          const lic = pkg.license || pkg.licence;
          if (lic) return lic;
          const lics = pkg.licenses || pkg.licences;
          if (Array.isArray(lics)) return lics[0];
        }
      };
      class Inventory extends Map {
        constructor(opt = {}) {
          const {primary, keys} = opt;
          super(), this[_primaryKey] = primary || "location", this[_index] = (keys || defaultKeys).reduce(((index, i) => (index.set(i, new Map), 
          index)), new Map);
        }
        get primaryKey() {
          return this[_primaryKey];
        }
        get indexes() {
          return [ ...this[_index].keys() ];
        }
        * filter(fn) {
          for (const node of this.values()) fn(node) && (yield node);
        }
        add(node) {
          const root = super.get("");
          if (root && node.root !== root && node.root !== root.root) return void debug((() => {
            throw Object.assign(new Error("adding external node to inventory"), {
              root: root.path,
              node: node.path,
              nodeRoot: node.root.path
            });
          }));
          const current = super.get(node[this.primaryKey]);
          if (current) {
            if (current === node) return;
            this.delete(current);
          }
          super.set(node[this.primaryKey], node);
          for (const [key, map] of this[_index].entries()) {
            const val_ = hasOwnProperty.call(node, key) ? node[key] : "license" === key ? getLicense(node.package) : node[key] ? node[key] : node.package && node.package[key], val = "string" == typeof val_ ? val_ : val_ && "object" == typeof val_ ? "license" === key ? val_.type : "funding" === key ? val_.url : val_ : val_, set = map.get(val) || new Set;
            set.add(node), map.set(val, set);
          }
        }
        delete(node) {
          if (this.has(node)) {
            super.delete(node[this.primaryKey]);
            for (const [key, map] of this[_index].entries()) {
              const val = void 0 !== node[key] ? node[key] : node[key] || node.package && node.package[key], set = map.get(val);
              set && (set.delete(node), 0 === set.size && map.delete(node[key]));
            }
          }
        }
        query(key, val) {
          const map = this[_index].get(key);
          return map && (2 === arguments.length ? map.get(val) : map.keys()) || new Set;
        }
        has(node) {
          return super.get(node[this.primaryKey]) === node;
        }
        set(k, v) {
          throw new Error("direct set() not supported, use inventory.add(node)");
        }
      }
      module.exports = Inventory;
    },
    3112: (module, __unused_webpack_exports, __webpack_require__) => {
      const debug = __webpack_require__(63120), relpath = __webpack_require__(52452), Node = __webpack_require__(41172), _loadDeps = Symbol.for("Arborist.Node._loadDeps"), _target = Symbol.for("_target"), {dirname} = __webpack_require__(71017), _delistFromMeta = Symbol.for("_delistFromMeta"), _refreshLocation = Symbol.for("_refreshLocation");
      module.exports = class extends Node {
        constructor(options) {
          const {root, realpath, target, parent, fsParent} = options;
          if (!(realpath || target && target.path)) throw new TypeError("must provide realpath for Link node");
          super({
            ...options,
            realpath: realpath || target.path,
            root: root || (parent ? parent.root : fsParent ? fsParent.root : target ? target.root : null)
          }), target ? this.target = target : this.realpath === this.root.path ? this.target = this.root : this.target = new Node({
            ...options,
            path: realpath,
            parent: null,
            fsParent: null,
            root: this.root
          });
        }
        get version() {
          return this.target ? this.target.version : this.package.version || "";
        }
        get target() {
          return this[_target];
        }
        set target(target) {
          const current = this[_target];
          if (target !== current) {
            if (current && current.then && debug((() => {
              throw Object.assign(new Error("cannot set target while awaiting"), {
                path: this.path,
                realpath: this.realpath
              });
            })), target && target.then) return this[_target] = target, void target.then((node => {
              this[_target] = null, this.target = node;
            }));
            if (!target) return current && current.linksIn && current.linksIn.delete(this), 
            void (this.path ? (this[_delistFromMeta](), this[_target] = null, this.package = {}, 
            this[_refreshLocation]()) : this[_target] = null);
            if (!this.path) return target.path ? this.realpath = target.path : target.path = target.realpath = this.realpath, 
            target.root = this.root, this[_target] = target, target.linksIn.add(this), void (this.package = target.package);
            this[_delistFromMeta](), this.package = target.package, this.realpath = target.path, 
            this[_refreshLocation](), target.root = this.root;
          }
        }
        get resolved() {
          return this.path && this.realpath ? `file:${relpath(dirname(this.path), this.realpath).replace(/#/g, "%23")}` : null;
        }
        set resolved(r) {}
        [_loadDeps]() {}
        get children() {
          return new Map;
        }
        set children(c) {}
        get isLink() {
          return !0;
        }
      };
    },
    41172: (module, __unused_webpack_exports, __webpack_require__) => {
      const semver = __webpack_require__(5870), nameFromFolder = __webpack_require__(3046), Edge = __webpack_require__(23920), Inventory = __webpack_require__(30625), OverrideSet = __webpack_require__(74833), {normalize} = __webpack_require__(1759), {getPaths: getBinPaths} = __webpack_require__(38059), npa = __webpack_require__(19932), debug = __webpack_require__(63120), gatherDepSet = __webpack_require__(87280), treeCheck = __webpack_require__(56912), walkUp = __webpack_require__(43967), {resolve, relative, dirname, basename} = __webpack_require__(71017), util = __webpack_require__(73837), _package = Symbol("_package"), _parent = Symbol("_parent"), _target = Symbol.for("_target"), _fsParent = Symbol("_fsParent"), _loadDepType = Symbol("_loadDepType"), _loadWorkspaces = Symbol("_loadWorkspaces"), _reloadNamedEdges = Symbol("_reloadNamedEdges"), _loadDeps = Symbol.for("Arborist.Node._loadDeps"), _root = Symbol("_root"), _refreshLocation = Symbol.for("_refreshLocation"), _changePath = Symbol.for("_changePath"), _delistFromMeta = Symbol.for("_delistFromMeta"), _global = Symbol.for("global"), _workspaces = Symbol("_workspaces"), _explain = Symbol("_explain"), _explanation = Symbol("_explanation"), _meta = Symbol("_meta"), relpath = __webpack_require__(52452), consistentResolve = __webpack_require__(27139), printableTree = __webpack_require__(58986), CaseInsensitiveMap = __webpack_require__(19303), querySelectorAll = __webpack_require__(10704);
      class Node {
        constructor(options) {
          const {root, path, realpath, parent, error, meta, fsParent, resolved, integrity, name, children, fsChildren, installLinks = !1, legacyPeerDeps = !1, linksIn, hasShrinkwrap, overrides, loadOverrides = !1, extraneous = !0, dev = !0, optional = !0, devOptional = !0, peer = !0, global = !1, dummy = !1, sourceReference = null} = options;
          this[_global] = global, this[_workspaces] = null, this.errors = error ? [ error ] : [], 
          this.sourceReference = sourceReference;
          const pkg = sourceReference ? sourceReference.package : normalize(options.pkg || {});
          if (this.name = name || nameFromFolder(path || pkg.name || realpath) || pkg.name || null, 
          this.path = path ? resolve(path) : null, !(this.name || this.path && this.path === dirname(this.path))) throw new TypeError("could not detect node name from path or package");
          if (this.realpath = this.isLink ? resolve(realpath) : this.path, this.resolved = resolved || null, 
          !this.resolved) {
            const resolved = consistentResolve(pkg._resolved);
            !resolved || /^file:/.test(resolved) && pkg._where || (this.resolved = resolved);
          }
          if (this.integrity = integrity || pkg._integrity || null, this.hasShrinkwrap = hasShrinkwrap || pkg._hasShrinkwrap || !1, 
          this.installLinks = installLinks, this.legacyPeerDeps = legacyPeerDeps, this.children = new CaseInsensitiveMap, 
          this.fsChildren = new Set, this.inventory = new Inventory({}), this.tops = new Set, 
          this.linksIn = new Set(linksIn || []), dummy ? (this.dummy = !0, this.dev = !1, 
          this.optional = !1, this.devOptional = !1, this.peer = !1, this.extraneous = !1) : (this.dev = dev, 
          this.optional = optional, this.devOptional = devOptional, this.peer = peer, this.extraneous = extraneous, 
          this.dummy = !1), this.edgesIn = new Set, this.edgesOut = new CaseInsensitiveMap, 
          this[_package] = pkg && "object" == typeof pkg ? pkg : {}, overrides) this.overrides = overrides; else if (loadOverrides) {
            const overrides = this[_package].overrides || {};
            Object.keys(overrides).length > 0 && (this.overrides = new OverrideSet({
              overrides: this[_package].overrides
            }));
          }
          if (this.meta = meta, this[_parent] = null, this.parent = parent || null, this[_fsParent] = null, 
          this.fsParent = fsParent || null, parent || fsParent || (this.root = root || null), 
          children) for (const c of children) new Node({
            ...c,
            parent: this
          });
          if (fsChildren) for (const c of fsChildren) new Node({
            ...c,
            fsParent: this
          });
          this[_loadDeps]();
        }
        get meta() {
          return this[_meta];
        }
        set meta(meta) {
          this[_meta] = meta, meta && meta.add(this);
        }
        get global() {
          return this.root[_global];
        }
        get globalTop() {
          return this.global && this.parent && this.parent.isProjectRoot;
        }
        get workspaces() {
          return this[_workspaces];
        }
        set workspaces(workspaces) {
          if (this[_workspaces]) for (const name of this[_workspaces].keys()) workspaces.has(name) || this.edgesOut.get(name).detach();
          this[_workspaces] = workspaces, this[_loadWorkspaces](), this[_loadDeps]();
        }
        get binPaths() {
          return this.parent ? getBinPaths({
            pkg: this[_package],
            path: this.path,
            global: this.global,
            top: this.globalTop
          }) : [];
        }
        get hasInstallScript() {
          const {hasInstallScript, scripts} = this.package, {install, preinstall, postinstall} = scripts || {};
          return !!(hasInstallScript || install || preinstall || postinstall);
        }
        get version() {
          return this[_package].version || "";
        }
        get packageName() {
          return this[_package].name || null;
        }
        get pkgid() {
          const {name = "", version = ""} = this.package, {isProjectRoot} = this, myname = isProjectRoot && name || this.name;
          return `${myname}@${!isProjectRoot && name && myname !== name ? `npm:${name}@` : ""}${version}`;
        }
        get overridden() {
          return !(!this.overrides || !this.overrides.value || this.overrides.name !== this.name);
        }
        get package() {
          return this[_package];
        }
        set package(pkg) {
          for (const edge of this.edgesOut.values()) edge.detach();
          this[_explanation] = null, pkg && "object" == typeof pkg || (debug((() => {
            throw new Error("setting Node.package to non-object");
          })), pkg = {}), this[_package] = pkg, this[_loadWorkspaces](), this[_loadDeps](), 
          this.edgesIn.forEach((edge => edge.reload(!0)));
        }
        explain(edge = null, seen = []) {
          return this[_explanation] ? this[_explanation] : this[_explanation] = this[_explain](edge, seen);
        }
        [_explain](edge, seen) {
          if (this.isProjectRoot && !this.sourceReference) return {
            location: this.path
          };
          const why = {
            name: this.isProjectRoot || this.isTop ? this.packageName : this.name,
            version: this.package.version
          };
          if (!this.errors.length && this.packageName && this.package.version || (why.errors = this.errors.length ? this.errors : [ new Error("invalid package: lacks name and/or version") ], 
          why.package = this.package), this.root.sourceReference) {
            const {name, version} = this.root.package;
            why.whileInstalling = {
              name,
              version,
              path: this.root.sourceReference.path
            };
          }
          if (this.sourceReference) return this.sourceReference.explain(edge, seen);
          if (seen.includes(this)) return why;
          if (why.location = this.location, why.isWorkspace = this.isWorkspace, seen = seen.concat(this), 
          why.dependents = [], edge) why.dependents.push(edge.explain(seen)); else {
            const edges = [];
            for (const edge of this.edgesIn) (edge.valid || edge.from.isProjectRoot) && edges.push(edge);
            for (const edge of edges) why.dependents.push(edge.explain(seen));
          }
          return this.linksIn.size && (why.linksIn = [ ...this.linksIn ].map((link => link[_explain](edge, seen)))), 
          why;
        }
        isDescendantOf(node) {
          for (let p = this; p; p = p.resolveParent) if (p === node) return !0;
          return !1;
        }
        getBundler(path = []) {
          if (path.includes(this)) return null;
          path.push(this);
          const parent = this[_parent];
          if (!parent) return null;
          const pBundler = parent.getBundler(path);
          if (pBundler) return pBundler;
          const ppkg = parent.package, bd = ppkg && ppkg.bundleDependencies;
          if (Array.isArray(bd) && bd.includes(this.name)) return parent;
          for (const edge of this.edgesIn) {
            const eBundler = edge.from.getBundler(path);
            if (eBundler && eBundler === parent) return eBundler;
          }
          return null;
        }
        get inBundle() {
          return !!this.getBundler();
        }
        get inDepBundle() {
          const bundler = this.getBundler();
          return !!bundler && bundler !== this.root;
        }
        get isWorkspace() {
          if (this.isProjectRoot) return !1;
          const {root} = this, {type, to} = root.edgesOut.get(this.packageName) || {};
          return "workspace" === type && to && (to.target === this || to === this);
        }
        get isRoot() {
          return this === this.root;
        }
        get isProjectRoot() {
          return this === this.root || this === this.root.target;
        }
        get isRegistryDependency() {
          if (0 === this.edgesIn.size) return !1;
          for (const edge of this.edgesIn) if (!npa(edge.spec).registry) return !1;
          return !0;
        }
        * ancestry() {
          for (let anc = this; anc; anc = anc.resolveParent) yield anc;
        }
        set root(root) {
          for (;root && root.root !== root; ) root = root.root;
          if (root = root || this, this[_delistFromMeta](), !this.path || !root.realpath || !root.path) return void (this[_root] = root);
          this[_root] = this;
          for (const link of this.linksIn) link[_target] = null, this.linksIn.delete(link);
          const {target} = this;
          if (this.isLink && (target && (target.linksIn.delete(this), target.root === this && target[_delistFromMeta]()), 
          this[_target] = null), this.parent && this.parent.root !== root && (this.parent.children.delete(this.name), 
          this[_parent] = null), this.fsParent && this.fsParent.root !== root && (this.fsParent.fsChildren.delete(this), 
          this[_fsParent] = null), root === this) this[_refreshLocation](); else {
            const loc = relpath(root.realpath, this.path), current = root.inventory.get(loc);
            current && (current.root = null), this[_root] = root, this[_refreshLocation]();
            for (const p of walkUp(dirname(this.path))) {
              if (p === this.path) continue;
              const ploc = relpath(root.realpath, p), parent = root.inventory.get(ploc);
              if (parent) {
                if (parent.isLink) {
                  debug((() => {
                    throw Object.assign(new Error("assigning parentage to link"), {
                      path: this.path,
                      parent: parent.path,
                      parentReal: parent.realpath
                    });
                  }));
                  continue;
                }
                const childLoc = `${ploc}${ploc ? "/" : ""}node_modules/${this.name}`;
                if (this.location === childLoc) {
                  const oldChild = parent.children.get(this.name);
                  oldChild && oldChild !== this && (oldChild.root = null), this.parent && (this.parent.children.delete(this.name), 
                  this.parent[_reloadNamedEdges](this.name)), parent.children.set(this.name, this), 
                  this[_parent] = parent, this.isLink || parent[_reloadNamedEdges](this.name);
                } else this.fsParent && this.fsParent.fsChildren.delete(this), parent.fsChildren.add(this), 
                this[_fsParent] = parent;
                break;
              }
            }
            this.parent ? root.tops.delete(this) : root.tops.add(this);
            const nmloc = `${this.location}${this.location ? "/" : ""}node_modules/`, isChild = n => n.location === nmloc + n.name, isFsChild = n => dirname(n.path).startsWith(this.path) && n !== this && !n.parent && (!n.fsParent || n.fsParent === this || dirname(this.path).startsWith(n.fsParent.path)), isKid = n => isChild(n) || isFsChild(n);
            for (const child of root.tops) isKid(child) && (this.isLink ? child.root = null : (child.fsParent && child.fsParent.fsChildren.delete(child), 
            child[_fsParent] = null, isChild(child) ? (this.children.set(child.name, child), 
            child[_parent] = this, root.tops.delete(child)) : (this.fsChildren.add(child), child[_fsParent] = this)));
            for (const node of root.inventory.query("realpath", this.realpath)) if (node !== this) {
              if (debug((() => {
                if (node.root !== root) throw new Error("inventory contains node from other root");
              })), this.isLink) {
                const target = node.target;
                this[_target] = target, this[_package] = target.package, target.linksIn.add(this), 
                this.parent && this.parent[_reloadNamedEdges](this.name);
                break;
              }
              node.isLink ? (node[_target] = this, node[_package] = this.package, this.linksIn.add(node), 
              node.parent && node.parent[_reloadNamedEdges](node.name)) : debug((() => {
                throw Object.assign(new Error("duplicate node in root setter"), {
                  path: this.path,
                  realpath: this.realpath,
                  root: root.realpath
                });
              }));
            }
          }
          for (const edge of this.edgesIn) edge.from.root !== root && edge.reload();
          for (const edge of this.edgesOut.values()) edge.to && edge.to.root === root || edge.reload();
          const family = new Set([ ...this.fsChildren, ...this.children.values(), ...this.inventory.values() ].filter((n => n !== this)));
          for (const child of family) if (child.root !== root) {
            child[_delistFromMeta](), child[_parent] = null, this.children.delete(child.name), 
            child[_fsParent] = null, this.fsChildren.delete(child);
            for (const l of child.linksIn) l[_target] = null, child.linksIn.delete(l);
          }
          for (const child of family) child.root !== root && (child.root = root);
          this.isLink && target && !this.target && root !== this && (target.root = root), 
          !this.overrides && this.parent && this.parent.overrides && (this.overrides = this.parent.overrides.getNodeRule(this)), 
          treeCheck(this), treeCheck(root);
        }
        get root() {
          return this[_root] || this;
        }
        [_loadWorkspaces]() {
          if (this[_workspaces]) for (const [name, path] of this[_workspaces].entries()) new Edge({
            from: this,
            name,
            spec: `file:${path.replace(/#/g, "%23")}`,
            type: "workspace"
          });
        }
        [_loadDeps]() {
          const pd = this.package.peerDependencies;
          if (pd && "object" == typeof pd && !this.legacyPeerDeps) {
            const pm = this.package.peerDependenciesMeta || {}, peerDependencies = {}, peerOptional = {};
            for (const [name, dep] of Object.entries(pd)) pm[name] && pm[name].optional ? peerOptional[name] = dep : peerDependencies[name] = dep;
            this[_loadDepType](peerDependencies, "peer"), this[_loadDepType](peerOptional, "peerOptional");
          }
          this[_loadDepType](this.package.dependencies, "prod"), this[_loadDepType](this.package.optionalDependencies, "optional");
          const {globalTop, isTop, path, sourceReference} = this, {globalTop: srcGlobalTop, isTop: srcTop, path: srcPath} = sourceReference || {};
          isTop && !globalTop && path && (!sourceReference || srcTop && !srcGlobalTop && srcPath) && this[_loadDepType](this.package.devDependencies, "dev");
        }
        [_loadDepType](deps, type) {
          const ad = this.package.acceptDependencies || {};
          for (const [name, spec] of Object.entries(deps || {})) {
            const current = this.edgesOut.get(name);
            current && "workspace" === current.type || new Edge({
              from: this,
              name,
              spec,
              accept: ad[name],
              type
            });
          }
        }
        get fsParent() {
          const parent = this[_fsParent];
          return debug((() => {
            if (parent === this) throw new Error("node set to its own fsParent");
          })), parent;
        }
        set fsParent(fsParent) {
          if (!fsParent) return void (this[_fsParent] && (this.root = null));
          if (debug((() => {
            if (fsParent === this) throw new Error("setting node to its own fsParent");
            if (fsParent.realpath === this.realpath) throw new Error("setting fsParent to same path");
            if (!this[_fsParent] && 0 !== this.realpath.indexOf(fsParent.realpath)) throw Object.assign(new Error("setting fsParent improperly"), {
              path: this.path,
              realpath: this.realpath,
              fsParent: {
                path: fsParent.path,
                realpath: fsParent.realpath
              }
            });
          })), fsParent.isLink && (fsParent = fsParent.target), this === fsParent || fsParent.realpath === this.realpath) return;
          if (this[_fsParent] === fsParent) return;
          const oldFsParent = this[_fsParent], newPath = oldFsParent ? resolve(fsParent.path, relative(oldFsParent.path, this.path)) : this.path;
          if (newPath === resolve(fsParent.path, "node_modules", this.name)) return void (this.parent = fsParent);
          const pathChange = newPath !== this.path, oldParent = this.parent, oldName = this.name;
          this.parent && (this.parent.children.delete(this.name), this[_parent] = null), this.fsParent && (this.fsParent.fsChildren.delete(this), 
          this[_fsParent] = null), pathChange && this[_changePath](newPath), oldParent && oldParent[_reloadNamedEdges](oldName), 
          this.root = fsParent.root;
        }
        canReplaceWith(node, ignorePeers = []) {
          if (node.name !== this.name) return !1;
          if (node.packageName !== this.packageName) return !1;
          if (node.overrides !== this.overrides) return !1;
          ignorePeers = new Set(ignorePeers);
          const depSet = gatherDepSet([ this ], (e => e.to !== this && e.valid));
          for (const edge of this.edgesIn) {
            if (!(!this.isTop && edge.from.parent === this.parent && edge.peer && ignorePeers.has(edge.from.name)) && (!depSet.has(edge.from) && !edge.satisfiedBy(node))) return !1;
          }
          return !0;
        }
        canReplace(node, ignorePeers) {
          return node.canReplaceWith(this, ignorePeers);
        }
        canDedupe(preferDedupe = !1) {
          if (this.inDepBundle || this.inShrinkwrap) return !1;
          if (!this.resolveParent || !this.resolveParent.resolveParent) return !1;
          if (0 === this.edgesIn.size) return !0;
          const other = this.resolveParent.resolveParent.resolve(this.name);
          return !!other && (!!other.matches(this) || !!other.canReplace(this) && !(!preferDedupe && !semver.gte(other.version, this.version)));
        }
        satisfies(requested) {
          if (requested instanceof Edge) return this.name === requested.name && requested.satisfiedBy(this);
          const parsed = npa(requested), {name = this.name, rawSpec: spec} = parsed;
          return this.name === name && this.satisfies(new Edge({
            from: new Node({
              path: this.root.realpath
            }),
            type: "prod",
            name,
            spec
          }));
        }
        matches(node) {
          return node === this || node.name === this.name && (this.isLink ? node.isLink && this.target.matches(node.target) : this.isProjectRoot && node.isProjectRoot ? this.path === node.path : this.integrity && node.integrity ? this.integrity === node.integrity : this.resolved && node.resolved ? this.resolved === node.resolved : this.packageName && node.packageName && this.packageName === node.packageName && this.version && node.version && this.version === node.version);
        }
        replaceWith(node) {
          node.replace(this);
        }
        replace(node) {
          this[_delistFromMeta]();
          if (node.parent && node.parent.children.get(this.name) === node ? this.path = resolve(node.parent.path, "node_modules", this.name) : (this.path = node.path, 
          this.name = node.name), this.isLink || (this.realpath = this.path), this[_refreshLocation](), 
          !this.isLink) {
            for (const kid of node.children.values()) kid.parent = this;
            node.isLink && node.target && (node.target.root = null);
          }
          node.isRoot || (this.root = node.root), treeCheck(this);
        }
        get inShrinkwrap() {
          return this.parent && (this.parent.hasShrinkwrap || this.parent.inShrinkwrap);
        }
        get parent() {
          const parent = this[_parent];
          return debug((() => {
            if (parent === this) throw new Error("node set to its own parent");
          })), parent;
        }
        set parent(parent) {
          if (!parent) return void (this[_parent] && (this.root = null));
          if (parent.isLink && (parent = parent.target), this === parent) return;
          const oldParent = this[_parent];
          if (oldParent === parent) return;
          const newPath = resolve(parent.path, "node_modules", this.name), pathChange = newPath !== this.path;
          oldParent && (oldParent.children.delete(this.name), this[_parent] = null), this.fsParent && (this.fsParent.fsChildren.delete(this), 
          this[_fsParent] = null), pathChange && this[_changePath](newPath), parent.overrides && (this.overrides = parent.overrides.getNodeRule(this)), 
          this.root = parent.root;
        }
        [_delistFromMeta]() {
          const root = this.root;
          root.realpath && this.path && (root.inventory.delete(this), root.tops.delete(this), 
          root.meta && root.meta.delete(this.path), debug((() => {
            if ([ ...root.inventory.values() ].includes(this)) throw new Error("failed to delist");
          })));
        }
        [_changePath](newPath) {
          this[_delistFromMeta]();
          const oldPath = this.path;
          this.path = newPath;
          const nameChange = newPath.match(/(?:^|\/|\\)node_modules[\\/](@[^/\\]+[\\/][^\\/]+|[^\\/]+)$/);
          if (nameChange && this.name !== nameChange[1] && (this.name = nameChange[1].replace(/\\/g, "/")), 
          !this.isLink) {
            this.realpath = newPath;
            for (const link of this.linksIn) link[_delistFromMeta](), link.realpath = newPath, 
            link[_refreshLocation]();
          }
          for (const child of this.fsChildren) child[_changePath](resolve(newPath, relative(oldPath, child.path)));
          for (const [name, child] of this.children.entries()) child[_changePath](resolve(newPath, "node_modules", name));
          this[_refreshLocation]();
        }
        [_refreshLocation]() {
          const root = this.root, loc = relpath(root.realpath, this.path);
          this.location = loc, root.inventory.add(this), root.meta && root.meta.add(this);
        }
        assertRootOverrides() {
          if (this.isProjectRoot && this.overrides) for (const edge of this.edgesOut.values()) if (edge.spec !== edge.rawSpec && !edge.spec.startsWith("$")) throw Object.assign(new Error(`Override for ${edge.name}@${edge.rawSpec} conflicts with direct dependency`), {
            code: "EOVERRIDE"
          });
        }
        addEdgeOut(edge) {
          this.overrides && (edge.overrides = this.overrides.getEdgeRule(edge)), this.edgesOut.set(edge.name, edge);
        }
        addEdgeIn(edge) {
          edge.overrides && (this.overrides = edge.overrides), this.edgesIn.add(edge), this.root.meta && this.root.meta.addEdge(edge);
        }
        [_reloadNamedEdges](name, rootLoc = this.location) {
          const edge = this.edgesOut.get(name), rootLocResolved = edge && edge.to && edge.to.location === `${rootLoc}/node_modules/${edge.name}`, sameResolved = edge && this.resolve(name) === edge.to;
          edge && (rootLocResolved || !sameResolved) && edge.reload(!0);
          for (const c of this.children.values()) c[_reloadNamedEdges](name, rootLoc);
          for (const c of this.fsChildren) c[_reloadNamedEdges](name, rootLoc);
        }
        get isLink() {
          return !1;
        }
        get target() {
          return this;
        }
        set target(n) {
          debug((() => {
            throw Object.assign(new Error("cannot set target on non-Link Nodes"), {
              path: this.path
            });
          }));
        }
        get depth() {
          return this.isTop ? 0 : this.parent.depth + 1;
        }
        get isTop() {
          return !this.parent || this.globalTop;
        }
        get top() {
          return this.isTop ? this : this.parent.top;
        }
        get isFsTop() {
          return !this.fsParent;
        }
        get fsTop() {
          return this.isFsTop ? this : this.fsParent.fsTop;
        }
        get resolveParent() {
          return this.parent || this.fsParent;
        }
        resolve(name) {
          debug((() => {
            if ("string" != typeof name || !name) throw new Error("non-string passed to Node.resolve");
          }));
          const mine = this.children.get(name);
          if (mine) return mine;
          const resolveParent = this.resolveParent;
          return resolveParent ? resolveParent.resolve(name) : null;
        }
        inNodeModules() {
          const rp = this.realpath, name = this.name, scoped = "@" === name.charAt(0), d = dirname(rp), nm = scoped ? dirname(d) : d, dir = dirname(nm);
          return (scoped ? `${basename(d)}/${basename(rp)}` : basename(rp)) === name && "node_modules" === basename(nm) && dir;
        }
        querySelectorAll(query) {
          return querySelectorAll(this, query);
        }
        toJSON() {
          return printableTree(this);
        }
        [util.inspect.custom]() {
          return this.toJSON();
        }
      }
      module.exports = Node;
    },
    9702: (module, __unused_webpack_exports, __webpack_require__) => {
      const gatherDepSet = __webpack_require__(87280);
      module.exports = node => {
        if (!node.optional) return new Set;
        const set = new Set([ node ]);
        for (const node of set) for (const edge of node.edgesIn) edge.optional || set.add(edge.from);
        return gatherDepSet(set, (edge => !edge.optional));
      };
    },
    64341: module => {
      module.exports = {
        overrideResolves: function(resolved, opts = {}) {
          const {omitLockfileRegistryResolved = !1} = opts;
          if (!omitLockfileRegistryResolved) return resolved;
        }
      };
    },
    74833: (module, __unused_webpack_exports, __webpack_require__) => {
      const npa = __webpack_require__(19932), semver = __webpack_require__(5870);
      class OverrideSet {
        constructor({overrides, key, parent}) {
          if (this.parent = parent, this.children = new Map, "string" == typeof overrides && (overrides = {
            ".": overrides
          }), "" === overrides["."] && (overrides["."] = "*"), parent) {
            const spec = npa(key);
            if (!spec.name) throw new Error(`Override without name: ${key}`);
            this.name = spec.name, spec.name = "", this.key = key, this.keySpec = "" === spec.rawSpec ? "" : spec.toString(), 
            this.value = overrides["."] || this.keySpec;
          }
          for (const [key, childOverrides] of Object.entries(overrides)) {
            if ("." === key) continue;
            const child = new OverrideSet({
              parent: this,
              key,
              overrides: childOverrides
            });
            this.children.set(child.key, child);
          }
        }
        getEdgeRule(edge) {
          for (const rule of this.ruleset.values()) if (rule.name === edge.name && ("" === rule.keySpec || semver.intersects(edge.spec, rule.keySpec))) return rule;
          return this;
        }
        getNodeRule(node) {
          for (const rule of this.ruleset.values()) if (rule.name === node.name && ("" === rule.keySpec || semver.satisfies(node.version, rule.keySpec) || semver.satisfies(node.version, rule.value))) return rule;
          return this;
        }
        getMatchingRule(node) {
          for (const rule of this.ruleset.values()) if (rule.name === node.name && ("" === rule.keySpec || semver.satisfies(node.version, rule.keySpec) || semver.satisfies(node.version, rule.value))) return rule;
          return null;
        }
        * ancestry() {
          for (let ancestor = this; ancestor; ancestor = ancestor.parent) yield ancestor;
        }
        get isRoot() {
          return !this.parent;
        }
        get ruleset() {
          const ruleset = new Map;
          for (const override of this.ancestry()) {
            for (const kid of override.children.values()) ruleset.has(kid.key) || ruleset.set(kid.key, kid);
            override.isRoot || ruleset.has(override.key) || ruleset.set(override.key, override);
          }
          return ruleset;
        }
      }
      module.exports = OverrideSet;
    },
    67557: module => {
      module.exports = node => {
        const unionSet = new Set([ node ]);
        for (const node of unionSet) {
          for (const edge of node.edgesOut.values()) edge.valid && edge.peer && edge.to && unionSet.add(edge.to);
          for (const edge of node.edgesIn) edge.valid && edge.peer && unionSet.add(edge.from);
        }
        const entrySets = new Map;
        for (const peer of unionSet) for (const edge of peer.edgesIn) if (edge.valid && (!edge.peer || edge.from.isTop)) {
          const sub = new Set([ peer ]);
          for (const peer of sub) for (const edge of peer.edgesOut.values()) edge.valid && edge.peer && edge.to && sub.add(edge.to);
          sub.has(node) && entrySets.set(edge, sub);
        }
        return entrySets;
      };
    },
    806: (module, __unused_webpack_exports, __webpack_require__) => {
      const localeCompare = __webpack_require__(51031)("en"), log = __webpack_require__(46521), deepestNestingTarget = __webpack_require__(36829), CanPlaceDep = __webpack_require__(19450), {KEEP, CONFLICT} = CanPlaceDep, debug = __webpack_require__(63120), Link = __webpack_require__(3112), gatherDepSet = __webpack_require__(87280), peerEntrySets = __webpack_require__(67557);
      class PlaceDep {
        constructor(options) {
          const {dep, edge, parent = null} = options;
          this.name = edge.name, this.dep = dep, this.edge = edge, this.canPlace = null, this.target = null, 
          this.placed = null;
          const {preferDedupe, force, explicitRequest, updateNames, auditReport, legacyBundling, strictPeerDeps, installLinks, legacyPeerDeps, globalStyle} = parent || options;
          Object.assign(this, {
            preferDedupe,
            force,
            explicitRequest,
            updateNames,
            auditReport,
            legacyBundling,
            strictPeerDeps,
            installLinks,
            legacyPeerDeps,
            globalStyle
          }), this.children = [], this.parent = parent, this.peerConflict = null, this.needEvaluation = new Set, 
          this.checks = new Map, this.place();
        }
        place() {
          const {edge, dep, preferDedupe, globalStyle, legacyBundling, explicitRequest, updateNames, checks} = this;
          if (edge.to && !edge.error && !explicitRequest && !updateNames.includes(edge.name) && !this.isVulnerable(edge.to)) return;
          const start = this.getStartNode();
          let canPlace = null, canPlaceSelf = null;
          for (const target of start.ancestry()) {
            const targetEdge = target.edgesOut.get(edge.name);
            if (!target.isTop && targetEdge && targetEdge.peer) continue;
            const cpd = new CanPlaceDep({
              dep,
              edge,
              parent: this.parent && this.parent.canPlace,
              target,
              preferDedupe,
              explicitRequest: this.explicitRequest
            });
            if (checks.set(target, cpd), cpd.canPlaceSelf !== CONFLICT && (canPlaceSelf = cpd), 
            cpd.canPlace === CONFLICT) break;
            if (canPlace = cpd, dep.errors.length) break;
            if (legacyBundling) break;
            if (globalStyle) {
              const rp = target.resolveParent;
              if (rp && rp.isProjectRoot) break;
            }
          }
          if (Object.assign(this, {
            canPlace,
            canPlaceSelf
          }), this.current = edge.to, !canPlace) {
            if (!this.conflictOk) return this.failPeerConflict();
            if (!canPlaceSelf) return void this.warnPeerConflict();
            this.canPlace = canPlaceSelf;
          }
          this.placeInTree();
        }
        placeInTree() {
          const {dep, canPlace, edge} = this;
          if (!canPlace) return void debug((() => {
            throw new Error("canPlace not set, but trying to place in tree");
          }));
          const {target} = canPlace;
          log.silly("placeDep", target.location || "ROOT", `${dep.name}@${dep.version}`, canPlace.description, `for: ${this.edge.from.package._id || this.edge.from.location}`, `want: ${edge.spec || "*"}`);
          if ((canPlace.canPlace === CONFLICT ? canPlace.canPlaceSelf : canPlace.canPlace) === KEEP) return edge.peer && !edge.valid && this.warnPeerConflict(), 
          void this.pruneDedupable(target);
          for (let p = target; p; p = p.resolveParent) if (p.matches(dep) && !p.isTop) return void (this.placed = new Link({
            parent: target,
            target: p
          }));
          const virtualRoot = dep.parent;
          this.placed = new dep.constructor({
            name: dep.name,
            pkg: dep.package,
            resolved: dep.resolved,
            integrity: dep.integrity,
            installLinks: this.installLinks,
            legacyPeerDeps: this.legacyPeerDeps,
            error: dep.errors[0],
            ...dep.overrides ? {
              overrides: dep.overrides
            } : {},
            ...dep.isLink ? {
              target: dep.target,
              realpath: dep.realpath
            } : {}
          }), this.oldDep = target.children.get(this.name), this.oldDep ? this.replaceOldDep() : this.placed.parent = target, 
          edge.peer && !this.placed.satisfies(edge) && this.warnPeerConflict(), edge.valid && edge.to && edge.to !== this.placed && this.pruneDedupable(edge.to, !1);
          for (const node of target.root.inventory.query("name", this.name)) if (node.isDescendantOf(target) && !node.isTop && (this.pruneDedupable(node, !1), 
          node.root === target.root)) for (const kid of node.children.values()) this.pruneDedupable(kid, !1);
          for (const peerEdge of this.placed.edgesOut.values()) {
            if (peerEdge.valid || !peerEdge.peer || peerEdge.peerConflicted) continue;
            const peer = virtualRoot.children.get(peerEdge.name);
            peer && (peer.satisfies(peerEdge) && this.children.push(new PlaceDep({
              parent: this,
              dep: peer,
              node: this.placed,
              edge: peerEdge
            })));
          }
        }
        replaceOldDep() {
          const target = this.oldDep.parent, oldDeps = [];
          for (const [name, edge] of this.oldDep.edgesOut.entries()) !this.placed.edgesOut.has(name) && edge.to && oldDeps.push(...gatherDepSet([ edge.to ], (e => e.to !== edge.to)));
          const prunePeerSets = [];
          for (const edge of this.oldDep.edgesIn) if (!this.placed.satisfies(edge) && edge.peer && edge.from.parent === target && !edge.peerConflicted) for (const entryEdge of peerEntrySets(edge.from).keys()) {
            const entryNode = entryEdge.to;
            deepestNestingTarget(entryNode) === target || entryEdge.from.isProjectRoot || entryEdge.from.isWorkspace ? this.warnPeerConflict(edge, this.dep) : prunePeerSets.push(...gatherDepSet([ entryNode ], (e => e.to !== entryNode && !e.peerConflicted)));
          }
          this.placed.replace(this.oldDep), this.pruneForReplacement(this.placed, oldDeps);
          for (const dep of prunePeerSets) {
            for (const edge of dep.edgesIn) this.needEvaluation.add(edge.from);
            dep.root = null;
          }
        }
        pruneForReplacement(node, oldDeps) {
          const invalidDeps = new Set([ ...node.edgesOut.values() ].filter((e => e.to && !e.valid)).map((e => e.to)));
          for (const dep of oldDeps) {
            const set = gatherDepSet([ dep ], (e => e.to !== dep && e.valid));
            for (const dep of set) invalidDeps.add(dep);
          }
          const deps = gatherDepSet(invalidDeps, (edge => edge.from !== node && edge.to !== node && edge.valid));
          for (const dep of deps) dep.root = null;
        }
        pruneDedupable(node, descend = !0) {
          if (node.canDedupe(this.preferDedupe)) {
            const deps = gatherDepSet([ node ], (e => e.to !== node && e.valid));
            for (const node of deps) node.root = null;
          } else if (descend) {
            const nodeSort = (a, b) => localeCompare(a.location, b.location), children = [ ...node.children.values() ].sort(nodeSort);
            for (const child of children) this.pruneDedupable(child);
            const fsChildren = [ ...node.fsChildren ].sort(nodeSort);
            for (const topNode of fsChildren) {
              const children = [ ...topNode.children.values() ].sort(nodeSort);
              for (const child of children) this.pruneDedupable(child);
            }
          }
        }
        get conflictOk() {
          return this.force || !this.isMine && !this.strictPeerDeps;
        }
        get isMine() {
          const {edge} = this.top, {from: node} = edge;
          if (node.isWorkspace || node.isProjectRoot) return !0;
          if (!edge.peer) return !1;
          let hasPeerEdges = !1;
          for (const edge of node.edgesIn) if (edge.peer) hasPeerEdges = !0; else if (edge.from.isWorkspace || edge.from.isProjectRoot) return !0;
          if (hasPeerEdges) for (const edge of peerEntrySets(node).keys()) if (edge.from.isWorkspace || edge.from.isProjectRoot) return !0;
          return !1;
        }
        warnPeerConflict(edge, dep) {
          edge = edge || this.edge, dep = dep || this.dep, edge.peerConflicted = !0;
          const expl = this.explainPeerConflict(edge, dep);
          log.warn("ERESOLVE", "overriding peer dependency", expl);
        }
        failPeerConflict(edge, dep) {
          edge = edge || this.top.edge, dep = dep || this.top.dep;
          const expl = this.explainPeerConflict(edge, dep);
          throw Object.assign(new Error("could not resolve"), expl);
        }
        explainPeerConflict(edge, dep) {
          const {from: node} = edge, curNode = node.resolve(edge.name), expl = {
            code: "ERESOLVE",
            edge: edge.explain(),
            dep: dep.explain(edge)
          };
          if (this.parent) expl.current = curNode && curNode.explain(edge), expl.peerConflict = this.current && this.current.explain(this.edge); else if (expl.current = curNode && curNode.explain(), 
          this.canPlaceSelf && this.canPlaceSelf.canPlaceSelf !== CONFLICT) {
            const cps = this.canPlaceSelf;
            for (const peer of cps.conflictChildren) if (peer.current) {
              expl.peerConflict = {
                current: peer.current.explain(),
                peer: peer.dep.explain(peer.edge)
              };
              break;
            }
          } else expl.peerConflict = {
            current: this.current && this.current.explain(),
            peer: this.dep.explain(this.edge)
          };
          const {strictPeerDeps, force, isMine} = this;
          return Object.assign(expl, {
            strictPeerDeps,
            force,
            isMine
          }), expl;
        }
        getStartNode() {
          const from = this.parent ? this.parent.getStartNode() : this.edge.from;
          return deepestNestingTarget(from, this.name);
        }
        get top() {
          return this.parent ? this.parent.top : this;
        }
        isVulnerable(node) {
          return this.auditReport && this.auditReport.isVulnerable(node);
        }
        get allChildren() {
          const set = new Set(this.children);
          for (const child of set) for (const grandchild of child.children) set.add(grandchild);
          return [ ...set ];
        }
      }
      module.exports = PlaceDep;
    },
    58986: (module, __unused_webpack_exports, __webpack_require__) => {
      const localeCompare = __webpack_require__(51031)("en"), util = __webpack_require__(73837), relpath = __webpack_require__(52452);
      class ArboristNode {
        constructor(tree, path) {
          this.name = tree.name, tree.packageName && tree.packageName !== this.name && (this.packageName = tree.packageName), 
          tree.version && (this.version = tree.version), this.location = tree.location, this.path = tree.path, 
          tree.realpath !== this.path && (this.realpath = tree.realpath), null !== tree.resolved && (this.resolved = tree.resolved), 
          tree.extraneous && (this.extraneous = !0), tree.dev && (this.dev = !0), tree.optional && (this.optional = !0), 
          !tree.devOptional || tree.dev || tree.optional || (this.devOptional = !0), tree.peer && (this.peer = !0), 
          tree.inBundle && (this.bundled = !0), tree.inDepBundle && (this.bundler = tree.getBundler().location), 
          tree.isProjectRoot && (this.isProjectRoot = !0), tree.isWorkspace && (this.isWorkspace = !0);
          const bd = tree.package && tree.package.bundleDependencies;
          bd && bd.length && (this.bundleDependencies = bd), tree.inShrinkwrap ? this.inShrinkwrap = !0 : tree.hasShrinkwrap && (this.hasShrinkwrap = !0), 
          tree.error && (this.error = treeError(tree.error)), tree.errors && tree.errors.length && (this.errors = tree.errors.map(treeError)), 
          tree.overrides && (this.overrides = new Map([ ...tree.overrides.ruleset.values() ].map((override => [ override.key, override.value ])))), 
          tree.edgesOut.size && (this.edgesOut = new Map([ ...tree.edgesOut.entries() ].sort((([a], [b]) => localeCompare(a, b))).map((([name, edge]) => [ name, new EdgeOut(edge) ])))), 
          tree.edgesIn.size && (this.edgesIn = new Set([ ...tree.edgesIn ].sort(((a, b) => localeCompare(a.from.location, b.from.location))).map((edge => new EdgeIn(edge))))), 
          tree.workspaces && tree.workspaces.size && (this.workspaces = new Map([ ...tree.workspaces.entries() ].map((([name, path]) => [ name, relpath(tree.root.realpath, path) ])))), 
          tree.fsChildren.size && (this.fsChildren = new Set([ ...tree.fsChildren ].sort((({path: a}, {path: b}) => localeCompare(a, b))).map((tree => printableTree(tree, path))))), 
          tree.children.size && (this.children = new Map([ ...tree.children.entries() ].sort((([a], [b]) => localeCompare(a, b))).map((([name, tree]) => [ name, printableTree(tree, path) ]))));
        }
      }
      class ArboristVirtualNode extends ArboristNode {
        constructor(tree, path) {
          super(tree, path), this.sourceReference = printableTree(tree.sourceReference, path);
        }
      }
      class ArboristLink extends ArboristNode {
        constructor(tree, path) {
          super(tree, path), this.target = printableTree(tree.target, path);
        }
      }
      const treeError = ({code, path}) => ({
        code,
        ...path ? {
          path
        } : {}
      });
      class Edge {
        constructor(edge) {
          this.type = edge.type, this.name = edge.name, this.spec = edge.rawSpec || "*", edge.rawSpec !== edge.spec && (this.override = edge.spec), 
          edge.error && (this.error = edge.error), edge.peerConflicted && (this.peerConflicted = edge.peerConflicted);
        }
      }
      class EdgeOut extends Edge {
        constructor(edge) {
          super(edge), this.to = edge.to && edge.to.location;
        }
        [util.inspect.custom]() {
          return `{ ${this.type} ${this.name}@${this.spec}${this.override ? ` overridden:${this.override}` : ""}${this.to ? " -> " + this.to : ""}${this.error ? " " + this.error : ""}${this.peerConflicted ? " peerConflicted" : ""} }`;
        }
      }
      class EdgeIn extends Edge {
        constructor(edge) {
          super(edge), this.from = edge.from && edge.from.location;
        }
        [util.inspect.custom]() {
          return `{ ${this.from || '""'} ${this.type} ${this.name}@${this.spec}${this.error ? " " + this.error : ""}${this.peerConflicted ? " peerConflicted" : ""} }`;
        }
      }
      const printableTree = (tree, path = []) => {
        if (!tree) return tree;
        const Cls = tree.isLink ? ArboristLink : tree.sourceReference ? ArboristVirtualNode : ArboristNode;
        if (path.includes(tree)) {
          const obj = Object.create(Cls.prototype);
          return Object.assign(obj, {
            location: tree.location
          });
        }
        return path.push(tree), new Cls(tree, path);
      };
      module.exports = printableTree;
    },
    10704: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const {resolve} = __webpack_require__(71017), {parser, arrayDelimiter} = __webpack_require__(18006), localeCompare = __webpack_require__(51031)("en"), npa = __webpack_require__(19932), minimatch = __webpack_require__(51191), semver = __webpack_require__(5870);
      class Results {
        #currentAstSelector;
        #initialItems;
        #inventory;
        #pendingCombinator;
        #results=new Map;
        #targetNode;
        constructor(opts) {
          this.#currentAstSelector = opts.rootAstNode.nodes[0], this.#inventory = opts.inventory, 
          this.#initialItems = opts.initialItems, this.#targetNode = opts.targetNode, this.currentResults = this.#initialItems, 
          this.currentAstNode = opts.rootAstNode;
        }
        get currentResults() {
          return this.#results.get(this.#currentAstSelector);
        }
        set currentResults(value) {
          this.#results.set(this.#currentAstSelector, value);
        }
        get initialItems() {
          return this.currentAstNode.parent.nodes[0] === this.currentAstNode && "root" === this.currentAstNode.parent.parent.type ? this.#initialItems : "combinator" === this.currentAstNode.prev().type ? this.#inventory : this.currentResults;
        }
        processPendingCombinator(nextResults) {
          if (this.#pendingCombinator) {
            const res = this.#pendingCombinator(this.currentResults, nextResults);
            this.#pendingCombinator = null, this.currentResults = res;
          } else this.currentResults = nextResults;
        }
        collect(rootAstNode) {
          return new Set(rootAstNode.nodes.flatMap((n => this.#results.get(n))));
        }
        attributeType() {
          const nextResults = this.initialItems.filter((node => attributeMatch(this.currentAstNode, node.package)));
          this.processPendingCombinator(nextResults);
        }
        classType() {
          const depTypeFn = depTypes[String(this.currentAstNode)];
          if (!depTypeFn) throw Object.assign(new Error(`\`${String(this.currentAstNode)}\` is not a supported dependency type.`), {
            code: "EQUERYNODEPTYPE"
          });
          const nextResults = depTypeFn(this.initialItems);
          this.processPendingCombinator(nextResults);
        }
        combinatorType() {
          this.#pendingCombinator = combinators[String(this.currentAstNode)];
        }
        idType() {
          const spec = npa(this.currentAstNode.value), nextResults = this.initialItems.filter((node => (node.name === spec.name || node.package.name === spec.name) && (semver.satisfies(node.version, spec.fetchSpec) || !spec.rawSpec)));
          this.processPendingCombinator(nextResults);
        }
        pseudoType() {
          const pseudoFn = `${this.currentAstNode.value.slice(1)}Pseudo`;
          if (!this[pseudoFn]) throw Object.assign(new Error(`\`${this.currentAstNode.value}\` is not a supported pseudo selector.`), {
            code: "EQUERYNOPSEUDO"
          });
          const nextResults = this[pseudoFn]();
          this.processPendingCombinator(nextResults);
        }
        selectorType() {
          this.#currentAstSelector = this.currentAstNode, this.currentResults || (this.currentResults = []);
        }
        universalType() {
          this.processPendingCombinator(this.initialItems);
        }
        attrPseudo() {
          const {lookupProperties, attributeMatcher} = this.currentAstNode;
          return this.initialItems.filter((node => {
            let objs = [ node.package ];
            for (const prop of lookupProperties) {
              if (prop === arrayDelimiter) {
                objs = objs.flat();
                continue;
              }
              objs = objs.flatMap((obj => obj[prop] || []));
              if (objs.every((obj => !obj))) return !1;
            }
            return objs.some((obj => attributeMatch(attributeMatcher, obj)));
          }));
        }
        emptyPseudo() {
          return this.initialItems.filter((node => 0 === node.edgesOut.size));
        }
        extraneousPseudo() {
          return this.initialItems.filter((node => node.extraneous));
        }
        hasPseudo() {
          const found = [];
          for (const item of this.initialItems) {
            retrieveNodesFromParsedAst({
              initialItems: [ item ],
              inventory: this.#inventory,
              rootAstNode: this.currentAstNode.nestedNode,
              targetNode: item
            }).size > 0 && found.push(item);
          }
          return found;
        }
        invalidPseudo() {
          const found = [];
          for (const node of this.initialItems) for (const edge of node.edgesIn) if (edge.invalid) {
            found.push(node);
            break;
          }
          return found;
        }
        isPseudo() {
          return [ ...retrieveNodesFromParsedAst({
            initialItems: this.initialItems,
            inventory: this.#inventory,
            rootAstNode: this.currentAstNode.nestedNode,
            targetNode: this.currentAstNode
          }) ];
        }
        linkPseudo() {
          return this.initialItems.filter((node => node.isLink || node.isTop && !node.isRoot));
        }
        missingPseudo() {
          return this.#inventory.reduce(((res, node) => {
            for (const edge of node.edgesOut.values()) if (edge.missing) {
              const pkg = {
                name: edge.name,
                version: edge.spec
              };
              res.push(new this.#targetNode.constructor({
                pkg
              }));
            }
            return res;
          }), []);
        }
        notPseudo() {
          const res = retrieveNodesFromParsedAst({
            initialItems: this.initialItems,
            inventory: this.#inventory,
            rootAstNode: this.currentAstNode.nestedNode,
            targetNode: this.currentAstNode
          }), internalSelector = new Set(res);
          return this.initialItems.filter((node => !internalSelector.has(node)));
        }
        overriddenPseudo() {
          return this.initialItems.filter((node => node.overridden));
        }
        pathPseudo() {
          return this.initialItems.filter((node => !this.currentAstNode.pathValue || minimatch(node.realpath.replace(/\\+/g, "/"), resolve(node.root.realpath, this.currentAstNode.pathValue).replace(/\\+/g, "/"))));
        }
        privatePseudo() {
          return this.initialItems.filter((node => node.package.private));
        }
        rootPseudo() {
          return this.initialItems.filter((node => node === this.#targetNode.root));
        }
        scopePseudo() {
          return this.initialItems.filter((node => node === this.#targetNode));
        }
        semverPseudo() {
          return this.currentAstNode.semverValue ? this.initialItems.filter((node => semver.satisfies(node.version, this.currentAstNode.semverValue))) : this.initialItems;
        }
        typePseudo() {
          return this.currentAstNode.typeValue ? this.initialItems.flatMap((node => {
            const found = [];
            for (const edge of node.edgesIn) npa(`${edge.name}@${edge.spec}`).type === this.currentAstNode.typeValue && found.push(edge.to);
            return found;
          })) : this.initialItems;
        }
        dedupedPseudo() {
          return this.initialItems.filter((node => node.target.edgesIn.size > 1));
        }
      }
      const attributeOperators = {
        "=": ({attr, value, insensitive}) => attr === value,
        "~=": ({attr, value, insensitive}) => (attr.match(/\w+/g) || []).includes(value),
        "*=": ({attr, value, insensitive}) => attr.includes(value),
        "|=": ({attr, value, insensitive}) => attr.startsWith(`${value}-`),
        "^=": ({attr, value, insensitive}) => attr.startsWith(value),
        "$=": ({attr, value, insensitive}) => attr.endsWith(value)
      }, attributeOperator = ({attr, value, insensitive, operator}) => ("number" == typeof attr && (attr = String(attr)), 
      "string" == typeof attr && (insensitive && (attr = attr.toLowerCase()), attributeOperators[operator]({
        attr,
        insensitive,
        value
      }))), attributeMatch = (matcher, obj) => {
        const insensitive = !!matcher.insensitive, operator = matcher.operator || "", attribute = matcher.qualifiedAttribute;
        let value = matcher.value || "";
        if ("" === operator) return Boolean(obj[attribute]);
        if (insensitive && (value = value.toLowerCase()), Array.isArray(obj[attribute])) return obj[attribute].find(((i, index) => {
          const attr = obj[attribute][index] || "";
          return attributeOperator({
            attr,
            value,
            insensitive,
            operator
          });
        }));
        {
          const attr = obj[attribute] || "";
          return attributeOperator({
            attr,
            value,
            insensitive,
            operator
          });
        }
      }, edgeIsType = (node, type, seen = new Set) => {
        for (const edgeIn of node.edgesIn) if (!seen.has(edgeIn) && (seen.add(edgeIn), edgeIn.type === type || edgeIn.from[type] || edgeIsType(edgeIn.from, type, seen))) return !0;
        return !1;
      }, filterByType = (nodes, type) => {
        const found = [];
        for (const node of nodes) (node[type] || edgeIsType(node, type)) && found.push(node);
        return found;
      }, depTypes = {
        ".prod"(prevResults) {
          const found = [];
          for (const node of prevResults) node.dev || found.push(node);
          return found;
        },
        ".dev": prevResults => filterByType(prevResults, "dev"),
        ".optional": prevResults => filterByType(prevResults, "optional"),
        ".peer": prevResults => filterByType(prevResults, "peer"),
        ".workspace": prevResults => prevResults.filter((node => node.isWorkspace)),
        ".bundled": prevResults => prevResults.filter((node => node.inBundle))
      }, hasParent = (node, compareNodes) => {
        for (const compareNode of compareNodes) {
          if (node.isTop && node.resolveParent === compareNode) return !0;
          for (const edge of node.edgesIn) if (edge && edge.from === compareNode) return !0;
        }
        return !1;
      }, hasAscendant = (node, compareNodes, seen = new Set) => {
        if (hasParent(node, compareNodes)) return !0;
        if (node.isTop && node.resolveParent) return hasAscendant(node.resolveParent, compareNodes);
        for (const edge of node.edgesIn) if (!seen.has(edge) && (seen.add(edge), edge && edge.from && hasAscendant(edge.from, compareNodes, seen))) return !0;
        return !1;
      }, combinators = {
        ">": (prevResults, nextResults) => nextResults.filter((node => hasParent(node, prevResults))),
        " ": (prevResults, nextResults) => nextResults.filter((node => hasAscendant(node, prevResults))),
        "~"(prevResults, nextResults) {
          const parentNodes = new Set;
          for (const node of prevResults) for (const edge of node.edgesIn) parentNodes.add(edge.from);
          return nextResults.filter((node => !prevResults.includes(node) && hasParent(node, [ ...parentNodes ])));
        }
      }, retrieveNodesFromParsedAst = opts => {
        const rootAstNode = opts.rootAstNode;
        if (!rootAstNode.nodes) return new Set;
        const results = new Results(opts);
        return rootAstNode.walk((nextAstNode => {
          results.currentAstNode = nextAstNode;
          const updateFn = `${results.currentAstNode.type}Type`;
          if ("function" != typeof results[updateFn]) throw Object.assign(new Error(`\`${results.currentAstNode.type}\` is not a supported selector.`), {
            code: "EQUERYNOSELECTOR"
          });
          results[updateFn]();
        })), results.collect(rootAstNode);
      };
      module.exports = async (targetNode, query) => {
        const inventory = [ ...targetNode.root.inventory.values() ];
        return [ ...retrieveNodesFromParsedAst({
          initialItems: inventory,
          inventory,
          rootAstNode: parser(query),
          targetNode
        }) ].sort(((a, b) => localeCompare(a.location, b.location)));
      };
    },
    37472: (module, __unused_webpack_exports, __webpack_require__) => {
      const fs = __webpack_require__(57147), promisify = __webpack_require__(73837).promisify, readlink = promisify(fs.readlink), lstat = promisify(fs.lstat), {resolve, basename, dirname} = __webpack_require__(71017), realpathCached = (path, rpcache, stcache, depth) => {
        if (depth > 2e3) throw eloop(path);
        if (path = resolve(path), rpcache.has(path)) return Promise.resolve(rpcache.get(path));
        const dir = dirname(path), base = basename(path);
        return base && rpcache.has(dir) ? realpathChild(dir, base, rpcache, stcache, depth) : base ? realpathCached(dir, rpcache, stcache, depth + 1).then((() => realpathCached(path, rpcache, stcache, depth + 1))) : (rpcache.set(dir, dir), 
        Promise.resolve(dir));
      }, eloop = path => Object.assign(new Error(`ELOOP: too many symbolic links encountered, stat '${path}'`), {
        errno: -62,
        syscall: "stat",
        code: "ELOOP",
        path
      }), realpathChild = (dir, base, rpcache, stcache, depth) => {
        const realdir = rpcache.get(dir);
        if (void 0 === realdir) throw new Error("in realpathChild without parent being in realpath cache");
        const realish = resolve(realdir, base);
        return ((path, stcache) => {
          if (stcache.has(path)) return Promise.resolve(stcache.get(path));
          const p = lstat(path).then((st => (stcache.set(path, st), st)));
          return stcache.set(path, p), p;
        })(realish, stcache).then((st => st.isSymbolicLink() ? readlink(realish).then((target => {
          const resolved = resolve(realdir, target);
          if (realish === resolved) throw eloop(realish);
          return realpathCached(resolved, rpcache, stcache, depth + 1);
        })).then((real => (rpcache.set(resolve(dir, base), real), real))) : (rpcache.set(resolve(dir, base), realish), 
        realish)));
      };
      module.exports = realpathCached;
    },
    52452: (module, __unused_webpack_exports, __webpack_require__) => {
      const {relative} = __webpack_require__(71017);
      module.exports = (from, to) => relative(from, to).replace(/\\/g, "/");
    },
    89783: module => {
      module.exports = tree => {
        for (const node of tree.inventory.values()) node.extraneous = !0, node.dev = !0, 
        node.devOptional = !0, node.peer = !0, node.optional = !0;
      };
    },
    46826: (module, __unused_webpack_exports, __webpack_require__) => {
      const crypto = __webpack_require__(6113), {dirname, basename, resolve} = __webpack_require__(71017);
      module.exports = from => {
        const d = dirname(from), b = basename(from), hash = (s = from, crypto.createHash("sha1").update(s).digest("base64").replace(/[^a-zA-Z0-9]+/g, "").slice(0, 8));
        var s;
        return resolve(d, `.${b}-${hash}`);
      };
    },
    33828: (module, __unused_webpack_exports, __webpack_require__) => {
      const localeCompare = __webpack_require__(51031)("en"), mismatch = (a, b) => a && b && a !== b, log = __webpack_require__(46521), YarnLock = __webpack_require__(41545), {promisify} = __webpack_require__(73837), rimraf = promisify(__webpack_require__(11567)), fs = __webpack_require__(57147), readFile = promisify(fs.readFile), writeFile = promisify(fs.writeFile), stat = promisify(fs.stat), readdir_ = promisify(fs.readdir), readlink = promisify(fs.readlink), lstat = promisify(fs.lstat), {resolve, basename} = __webpack_require__(71017), specFromLock = __webpack_require__(57177), versionFromTgz = __webpack_require__(20913), npa = __webpack_require__(19932), rpj = __webpack_require__(1759), parseJSON = __webpack_require__(67697), stringify = __webpack_require__(99091), swKeyOrder = [ "name", "version", "lockfileVersion", "resolved", "integrity", "requires", "packages", "dependencies" ], yarnRegRe = /^https?:\/\/registry\.yarnpkg\.com\//, npmRegRe = /^https?:\/\/registry\.npmjs\.org\//, relpath = __webpack_require__(52452), consistentResolve = __webpack_require__(27139), {overrideResolves} = __webpack_require__(64341), maybeReadFile = file => readFile(file, "utf8").then((d => d), (er => {
        if ("ENOENT" === er.code) return "";
        throw er;
      })), pkgMetaKeys = [ "version", "dependencies", "peerDependencies", "peerDependenciesMeta", "optionalDependencies", "bundleDependencies", "acceptDependencies", "funding", "engines", "os", "cpu", "_integrity", "license", "_hasShrinkwrap", "hasInstallScript", "bin", "deprecated", "workspaces" ], nodeMetaKeys = [ "integrity", "inBundle", "hasShrinkwrap", "hasInstallScript" ], metaFieldFromPkg = (pkg, key) => {
        const val = pkg[key];
        return "license" === key && val && "object" == typeof val && val.type ? val.type : val && ("object" != typeof val || Object.keys(val).length) ? val : null;
      }, assertNoNewer = async (path, data, lockTime, dir = path, seen = null) => {
        const base = basename(dir), isNM = dir !== path && "node_modules" === base, isScope = dir !== path && !isNM && "@" === base.charAt(0), isParent = dir === path || isNM || isScope, rel = relpath(path, dir);
        if (dir !== path) {
          if ((await stat(dir)).mtime > lockTime) throw "out of date, updated: " + rel;
          if (!isScope && !isNM && !data.packages[rel]) throw "missing from lockfile: " + rel;
          seen.add(rel);
        } else seen = new Set([ rel ]);
        const parent = isParent ? dir : resolve(dir, "node_modules"), children = dir === path ? Promise.resolve([ {
          name: "node_modules",
          isDirectory: () => !0
        } ]) : (async (path, opt) => {
          if (!opt || !opt.withFileTypes) return readdir_(path, opt);
          const ents = await readdir_(path, opt);
          return "string" == typeof ents[0] ? Promise.all(ents.map((async ent => Object.assign(await lstat(path + "/" + ent), {
            name: ent
          })))) : ents;
        })(parent, {
          withFileTypes: !0
        }), ents = await children.catch((() => []));
        if (await Promise.all(ents.map((async ent => {
          const child = resolve(parent, ent.name);
          if (ent.isDirectory() && !/^\./.test(ent.name)) await assertNoNewer(path, data, lockTime, child, seen); else if (ent.isSymbolicLink()) {
            const target = resolve(parent, await readlink(child)), tstat = await stat(target).catch((() => null));
            seen.add(relpath(path, child)), tstat && tstat.isDirectory() && !seen.has(relpath(path, target)) && await assertNoNewer(path, data, lockTime, target, seen);
          }
        }))), dir === path) for (const loc of new Set(Object.keys(data.packages))) if (!seen.has(loc)) throw "missing from node_modules: " + loc;
      }, _awaitingUpdate = Symbol("_awaitingUpdate"), _updateWaitingNode = Symbol("_updateWaitingNode"), _lockFromLoc = Symbol("_lockFromLoc"), _pathToLoc = Symbol("_pathToLoc"), _loadAll = Symbol("_loadAll"), _metaFromLock = Symbol("_metaFromLock"), _resolveMetaNode = Symbol("_resolveMetaNode"), _fixDependencies = Symbol("_fixDependencies"), _buildLegacyLockfile = Symbol("_buildLegacyLockfile"), _filenameSet = Symbol("_filenameSet"), _maybeRead = Symbol("_maybeRead"), _maybeStat = Symbol("_maybeStat");
      class Shrinkwrap {
        static get defaultLockfileVersion() {
          return 2;
        }
        static load(options) {
          return new Shrinkwrap(options).load();
        }
        static get keyOrder() {
          return swKeyOrder;
        }
        static async reset(options) {
          const s = new Shrinkwrap(options);
          s.reset();
          const [sw, lock] = await s[_maybeStat]();
          s.filename = resolve(s.path, (s.hiddenLockfile ? "node_modules/.package-lock" : s.shrinkwrapOnly || sw ? "npm-shrinkwrap" : "package-lock") + ".json"), 
          s.loadedFromDisk = !(!sw && !lock), s.type = basename(s.filename);
          try {
            if (s.loadedFromDisk && !s.lockfileVersion) {
              const json = parseJSON(await maybeReadFile(s.filename));
              json.lockfileVersion > 2 && (s.lockfileVersion = json.lockfileVersion);
            }
          } catch {}
          return s;
        }
        static metaFromNode(node, path, options = {}) {
          if (node.isLink) return {
            resolved: relpath(path, node.realpath),
            link: !0
          };
          const meta = {};
          pkgMetaKeys.forEach((key => {
            const val = metaFieldFromPkg(node.package, key);
            val && (meta[key.replace(/^_/, "")] = val);
          }));
          const pname = node.packageName;
          !pname || node !== node.root && pname === node.name || (meta.name = pname), node.isTop && node.package.devDependencies && (meta.devDependencies = node.package.devDependencies), 
          nodeMetaKeys.forEach((key => {
            node[key] && (meta[key] = node[key]);
          }));
          const resolved = consistentResolve(node.resolved, node.path, path, !0);
          return resolved && (node.isRegistryDependency ? meta.resolved = overrideResolves(resolved, options) : meta.resolved = resolved), 
          node.extraneous ? meta.extraneous = !0 : (node.peer && (meta.peer = !0), node.dev && (meta.dev = !0), 
          node.optional && (meta.optional = !0), !node.devOptional || node.dev || node.optional || (meta.devOptional = !0)), 
          meta;
        }
        constructor(options = {}) {
          const {path, indent = 2, newline = "\n", shrinkwrapOnly = !1, hiddenLockfile = !1, lockfileVersion, resolveOptions = {}} = options;
          this.lockfileVersion = hiddenLockfile ? 3 : lockfileVersion ? parseInt(lockfileVersion, 10) : null, 
          this[_awaitingUpdate] = new Map, this.tree = null, this.path = resolve(path || "."), 
          this.filename = null, this.data = null, this.indent = indent, this.newline = newline, 
          this.loadedFromDisk = !1, this.type = null, this.yarnLock = null, this.hiddenLockfile = hiddenLockfile, 
          this.loadingError = null, this.resolveOptions = resolveOptions, this.shrinkwrapOnly = shrinkwrapOnly;
        }
        checkYarnLock(spec, options = {}) {
          spec = npa(spec);
          const {yarnLock, loadedFromDisk} = this, fromYarn = yarnLock && !loadedFromDisk && yarnLock.entries.get(spec.raw);
          if (fromYarn && fromYarn.version) {
            const {resolved, version, integrity} = fromYarn, isYarnReg = spec.registry && yarnRegRe.test(resolved), isReg = spec.registry && !isYarnReg && npmRegRe.test(resolved) || isYarnReg, tgz = isReg && versionFromTgz(spec.name, resolved) || {}, yspec = tgz.name === spec.name && tgz.version === version ? version : isReg && tgz.name && tgz.version ? `npm:${tgz.name}@${tgz.version}` : resolved;
            if (yspec) return options.resolved = resolved.replace(yarnRegRe, "https://registry.npmjs.org/"), 
            options.integrity = integrity, npa(`${spec.name}@${yspec}`);
          }
          return spec;
        }
        reset() {
          this.tree = null, this[_awaitingUpdate] = new Map;
          const lockfileVersion = this.lockfileVersion || 2;
          this.originalLockfileVersion = lockfileVersion, this.data = {
            lockfileVersion,
            requires: !0,
            packages: {},
            dependencies: {}
          };
        }
        [_filenameSet]() {
          return this.shrinkwrapOnly ? [ this.path + "/npm-shrinkwrap.json" ] : this.hiddenLockfile ? [ null, this.path + "/node_modules/.package-lock.json" ] : [ this.path + "/npm-shrinkwrap.json", this.path + "/package-lock.json", this.path + "/yarn.lock" ];
        }
        [_maybeRead]() {
          return Promise.all(this[_filenameSet]().map((fn => fn && maybeReadFile(fn))));
        }
        [_maybeStat]() {
          return Promise.all(this[_filenameSet]().slice(0, 2).map((fn => fn && stat(fn).then((st => st.isFile()), (er => {
            if ("ENOENT" === er.code) return null;
            throw er;
          })))));
        }
        inferFormattingOptions(packageJSONData) {
          const {[Symbol.for("indent")]: indent, [Symbol.for("newline")]: newline} = packageJSONData;
          this.indent = void 0 !== indent ? indent : this.indent, this.newline = void 0 !== newline ? newline : this.newline;
        }
        async load() {
          return this[_maybeRead]().then((([sw, lock, yarn]) => {
            const data = sw || lock || "";
            if (this.filename = resolve(this.path, (this.hiddenLockfile ? "node_modules/.package-lock" : this.shrinkwrapOnly || sw ? "npm-shrinkwrap" : "package-lock") + ".json"), 
            this.type = basename(this.filename), this.loadedFromDisk = !!data, yarn) {
              this.yarnLock = new YarnLock;
              try {
                this.yarnLock.parse(yarn);
              } catch {}
            }
            return data ? parseJSON(data) : {};
          })).then((async data => {
            if (this.inferFormattingOptions(data), !this.hiddenLockfile || !data.packages) return data;
            const lockTime = +(await stat(this.filename)).mtime + 10;
            return await assertNoNewer(this.path, data, lockTime), data;
          })).catch((er => {
            if ("string" == typeof this.filename) {
              const rel = relpath(this.path, this.filename);
              log.verbose("shrinkwrap", `failed to load ${rel}`, er);
            } else log.verbose("shrinkwrap", `failed to load ${this.path}`, er);
            return this.loadingError = er, this.loadedFromDisk = !1, this.ancientLockfile = !1, 
            {};
          })).then((lock => {
            const lockfileVersion = this.lockfileVersion ? this.lockfileVersion : Math.max(lock.lockfileVersion || 0, 2);
            if (this.data = {
              ...lock,
              lockfileVersion,
              requires: !0,
              packages: lock.packages || {},
              dependencies: lock.dependencies || {}
            }, this.originalLockfileVersion = lock.lockfileVersion, this.lockfileVersion || (this.lockfileVersion = this.data.lockfileVersion = lockfileVersion), 
            this.ancientLockfile = this.loadedFromDisk && !(lock.lockfileVersion >= 2) && !lock.requires, 
            lock.dependencies && !lock.packages) return rpj(this.path + "/package.json").then((pkg => pkg), (er => ({}))).then((pkg => {
              this[_loadAll]("", null, this.data), this[_fixDependencies](pkg);
            }));
          })).then((() => this));
        }
        [_loadAll](location, name, lock) {
          const meta = this[_metaFromLock](location, name, lock);
          if (meta.link && (location = meta.resolved), lock.dependencies) for (const [name, dep] of Object.entries(lock.dependencies)) {
            const loc = location + (location ? "/" : "") + "node_modules/" + name;
            this[_loadAll](loc, name, dep);
          }
        }
        [_fixDependencies](pkg) {
          const root = this.data.packages[""];
          pkgMetaKeys.forEach((key => {
            const val = metaFieldFromPkg(pkg, key), k = key.replace(/^_/, "");
            val && (root[k] = val);
          }));
          for (const [loc, meta] of Object.entries(this.data.packages)) if (meta.requires && loc) {
            for (const [name, spec] of Object.entries(meta.requires)) {
              const dep = this[_resolveMetaNode](loc, name), depType = dep && dep.optional && !meta.optional ? "optionalDependencies" : dep && dep.dev && !meta.dev ? "devDependencies" : "dependencies";
              meta[depType] = meta[depType] || {}, meta[depType][name] = spec;
            }
            delete meta.requires;
          }
        }
        [_resolveMetaNode](loc, name) {
          for (let path = loc; ;path = path.replace(/(^|\/)[^/]*$/, "")) {
            const check = `${path}${path ? "/" : ""}node_modules/${name}`;
            if (this.data.packages[check]) return this.data.packages[check];
            if (!path) break;
          }
          return null;
        }
        [_lockFromLoc](lock, path, i = 0) {
          return lock ? ("" === path[i] && i++, i >= path.length ? lock : lock.dependencies ? this[_lockFromLoc](lock.dependencies[path[i]], path, i + 1) : null) : null;
        }
        [_pathToLoc](path) {
          return relpath(this.path, resolve(this.path, path));
        }
        delete(nodePath) {
          if (!this.data) throw new Error("run load() before getting or setting data");
          const location = this[_pathToLoc](nodePath);
          this[_awaitingUpdate].delete(location), delete this.data.packages[location];
          const path = location.split(/(?:^|\/)node_modules\//), name = path.pop(), pLock = this[_lockFromLoc](this.data, path);
          pLock && pLock.dependencies && delete pLock.dependencies[name];
        }
        get(nodePath) {
          if (!this.data) throw new Error("run load() before getting or setting data");
          const location = this[_pathToLoc](nodePath);
          if (this[_awaitingUpdate].has(location) && this[_updateWaitingNode](location), this.data.packages[location]) return this.data.packages[location];
          const path = location.split(/(?:^|\/)node_modules\//), name = path[path.length - 1], lock = this[_lockFromLoc](this.data, path);
          return this[_metaFromLock](location, name, lock);
        }
        [_metaFromLock](location, name, lock) {
          if (!lock) return {};
          const spec = specFromLock(name, lock, this.path);
          if ("directory" === spec.type) {
            const target = relpath(this.path, spec.fetchSpec);
            return this.data.packages[location] = {
              link: !0,
              resolved: target
            }, this.data.packages[target] || this[_metaFromLock](target, name, {
              ...lock,
              version: null
            }), this.data.packages[location];
          }
          const meta = {};
          if (lock.requires && "object" == typeof lock.requires && (meta.requires = lock.requires), 
          lock.optional && (meta.optional = !0), lock.dev && (meta.dev = !0), "" === location && (meta.name = lock.name), 
          lock.integrity && (meta.integrity = lock.integrity), lock.version && !lock.integrity) {
            if ("git" === spec.type) return meta.resolved = consistentResolve(spec, this.path, this.path), 
            this.data.packages[location] = meta;
            spec.registry && (meta.version = lock.version);
          }
          if ((lock.resolved || spec.type && !spec.registry) && (spec.registry ? meta.resolved = lock.resolved : "file" === spec.type ? meta.resolved = consistentResolve(spec, this.path, this.path, !0) : spec.fetchSpec && (meta.resolved = spec.fetchSpec)), 
          !meta.version) if ("file" === spec.type || "remote" === spec.type) {
            const fromTgz = versionFromTgz(spec.name, spec.fetchSpec) || versionFromTgz(spec.name, meta.resolved);
            fromTgz && (meta.version = fromTgz.version, fromTgz.name !== name && (meta.name = fromTgz.name));
          } else "alias" === spec.type ? (meta.name = spec.subSpec.name, meta.version = spec.subSpec.fetchSpec) : "version" === spec.type && (meta.version = spec.fetchSpec);
          return lock.bundled && (meta.inBundle = !0), this.data.packages[location] = meta;
        }
        add(node) {
          if (!this.data) throw new Error("run load() before getting or setting data");
          const loc = relpath(this.path, node.path);
          if (node.path === this.path && (this.tree = node), null === node.resolved || null === node.integrity) {
            const {resolved, integrity, hasShrinkwrap, version} = this.get(node.path), pathFixed = resolved ? /^file:/.test(resolved) ? `file:${resolve(this.path, resolved.slice(5)).replace(/#/g, "%23")}` : resolved : null, resolvedOk = !resolved || !node.resolved || node.resolved === pathFixed, integrityOk = !integrity || !node.integrity || node.integrity === integrity, versionOk = !version || !node.version || version === node.version;
            if ((resolved || integrity || version) && resolvedOk && integrityOk && versionOk) node.resolved = node.resolved || pathFixed || null, 
            node.integrity = node.integrity || integrity || null, node.hasShrinkwrap = node.hasShrinkwrap || hasShrinkwrap || !1; else {
              const {resolved, integrity, hasShrinkwrap} = Shrinkwrap.metaFromNode(node, this.path, this.resolveOptions);
              node.resolved = node.resolved || resolved || null, node.integrity = node.integrity || integrity || null, 
              node.hasShrinkwrap = node.hasShrinkwrap || hasShrinkwrap || !1;
            }
          }
          this[_awaitingUpdate].set(loc, node);
        }
        addEdge(edge) {
          if (!this.yarnLock || !edge.valid) return;
          const {to: node} = edge;
          if (null !== node.resolved && null !== node.integrity) return;
          if (!this.yarnLock.entries || !this.yarnLock.entries.size) return;
          const pathFixed = node.resolved ? /file:/.test(node.resolved) ? consistentResolve(node.resolved, node.path, this.path, !0) : node.resolved : null, spec = npa(`${node.name}@${edge.spec}`), entry = this.yarnLock.entries.get(`${node.name}@${edge.spec}`);
          !entry || mismatch(node.version, entry.version) || mismatch(node.integrity, entry.integrity) || mismatch(pathFixed, entry.resolved) || (entry.resolved && yarnRegRe.test(entry.resolved) && spec.registry && (entry.resolved = entry.resolved.replace(yarnRegRe, "https://registry.npmjs.org/")), 
          node.integrity = node.integrity || entry.integrity || null, node.resolved = node.resolved || consistentResolve(entry.resolved, this.path, node.path) || null, 
          this[_awaitingUpdate].set(relpath(this.path, node.path), node));
        }
        [_updateWaitingNode](loc) {
          const node = this[_awaitingUpdate].get(loc);
          this[_awaitingUpdate].delete(loc), this.data.packages[loc] = Shrinkwrap.metaFromNode(node, this.path, this.resolveOptions);
        }
        commit() {
          if (this.tree) {
            this.yarnLock && this.yarnLock.fromTree(this.tree);
            const root = Shrinkwrap.metaFromNode(this.tree.target, this.path, this.resolveOptions);
            this.data.packages = {}, Object.keys(root).length && (this.data.packages[""] = root);
            for (const node of this.tree.root.inventory.values()) {
              if (node === this.tree || node.isRoot || "" === node.location) continue;
              const loc = relpath(this.path, node.path);
              this.data.packages[loc] = Shrinkwrap.metaFromNode(node, this.path, this.resolveOptions);
            }
          } else if (this[_awaitingUpdate].size > 0) for (const loc of this[_awaitingUpdate].keys()) this[_updateWaitingNode](loc);
          if (this.lockfileVersion || (this.lockfileVersion = 2), this.data.lockfileVersion = this.lockfileVersion, 
          this.hiddenLockfile ? (delete this.data.packages[""], delete this.data.dependencies) : this.tree && this.lockfileVersion <= 3 && this[_buildLegacyLockfile](this.tree, this.data), 
          this.lockfileVersion >= 3) {
            const {dependencies, ...data} = this.data;
            return data;
          }
          if (this.lockfileVersion < 2) {
            const {packages, ...data} = this.data;
            return data;
          }
          return {
            ...this.data
          };
        }
        [_buildLegacyLockfile](node, lock, path = []) {
          node === this.tree && (lock.name = node.packageName || node.name, node.version && (lock.version = node.version));
          const edge = [ ...node.edgesIn ].filter((e => e.valid)).sort(((a, b) => {
            const aloc = a.from.location.split("node_modules"), bloc = b.from.location.split("node_modules");
            return aloc.length > bloc.length ? 1 : bloc.length > aloc.length ? -1 : localeCompare(aloc[aloc.length - 1], bloc[bloc.length - 1]);
          }))[0], rSpec = (resolved => {
            try {
              return npa(resolved);
            } catch (er) {
              return {};
            }
          })(consistentResolve(node.resolved, this.path, this.path, !0)), spec = edge ? npa.resolve(node.name, edge.spec, edge.from.realpath) : rSpec;
          node.isLink ? lock.version = `file:${relpath(this.path, node.realpath).replace(/#/g, "%23")}` : !spec || "file" !== spec.type && "remote" !== spec.type ? spec && "git" === spec.type || "git" === rSpec.type ? (lock.version = node.resolved, 
          spec.raw && (lock.from = spec.raw)) : !node.isRoot && node.package && node.packageName && node.packageName !== node.name ? lock.version = `npm:${node.packageName}@${node.version}` : node.package && node.version && (lock.version = node.version) : lock.version = spec.saveSpec, 
          node.inDepBundle && (lock.bundled = !0), node.resolved && !node.isLink && "git" !== rSpec.type && "file" !== rSpec.type && "directory" !== rSpec.type && "directory" !== spec.type && "git" !== spec.type && "file" !== spec.type && "remote" !== spec.type && (lock.resolved = overrideResolves(node.resolved, this.resolveOptions)), 
          node.integrity && (lock.integrity = node.integrity), node.extraneous ? lock.extraneous = !0 : node.isLink || (node.peer && (lock.peer = !0), 
          !node.devOptional || node.dev || node.optional || (lock.devOptional = !0), node.dev && (lock.dev = !0), 
          node.optional && (lock.optional = !0));
          const depender = node.target;
          if (depender.edgesOut.size > 0) if (node !== this.tree) {
            const entries = [ ...depender.edgesOut.entries() ];
            lock.requires = entries.reduce(((set, [k, v]) => {
              const {spec, peer} = v;
              if (peer) return set;
              if (spec.startsWith("file:")) {
                const p = resolve(node.realpath, spec.slice("file:".length));
                set[k] = `file:${relpath(node.realpath, p).replace(/#/g, "%23")}`;
              } else set[k] = spec;
              return set;
            }), {});
          } else lock.requires = !0;
          const {children} = node.target;
          if (children.size) {
            const kidPath = [ ...path, node.realpath ], dependencies = {};
            let found = !1;
            for (const [name, kid] of children.entries()) path.includes(kid.realpath) || (dependencies[name] = this[_buildLegacyLockfile](kid, {}, kidPath), 
            found = !0);
            found && (lock.dependencies = dependencies);
          } else delete lock.dependencies;
          return lock;
        }
        toJSON() {
          if (!this.data) throw new Error("run load() before getting or setting data");
          return this.commit();
        }
        toString(options = {}) {
          const data = this.toJSON(), {format = !0} = options, defaultIndent = this.indent || 2, indent = !0 === format ? defaultIndent : format || 0, eol = format ? this.newline || "\n" : "";
          return stringify(data, swKeyOrder, indent).replace(/\n/g, eol);
        }
        save(options = {}) {
          if (!this.data) throw new Error("run load() before saving data");
          const json = this.toString(options);
          return Promise.all([ writeFile(this.filename, json).catch((er => {
            if (this.hiddenLockfile) return rimraf(this.filename);
            throw er;
          })), this.yarnLock && this.yarnLock.entries.size && writeFile(this.path + "/yarn.lock", this.yarnLock.toString()) ]);
        }
      }
      module.exports = Shrinkwrap;
    },
    52478: (module, __unused_webpack_exports, __webpack_require__) => {
      const signals = __webpack_require__(57248);
      module.exports = Object.assign((fn => setup(fn)), {
        process
      });
      const setup = fn => {
        const {process} = module.exports, sigListeners = {
          loaded: !1
        }, unload = () => {
          if (sigListeners.loaded) {
            for (const sig of signals) try {
              process.removeListener(sig, sigListeners[sig]);
            } catch {}
            process.removeListener("beforeExit", onBeforeExit), sigListeners.loaded = !1;
          }
        }, onBeforeExit = () => {
          unload(), process.kill(process.pid, signalReceived), setTimeout((() => {}), 500);
        };
        let signalReceived = null;
        const listener = (sig, fn) => () => {
          signalReceived = sig, unload(), process.listeners(sig).length < 1 && process.once("beforeExit", onBeforeExit), 
          fn({
            signal: sig
          });
        };
        for (const sig of signals) {
          sigListeners[sig] = listener(sig, fn);
          const max = process.getMaxListeners();
          try {
            const {length} = process.listeners(sig);
            length >= max && process.setMaxListeners(length + 1), process.on(sig, sigListeners[sig]);
          } catch {}
        }
        return sigListeners.loaded = !0, unload;
      };
    },
    57248: module => {
      const platform = global.__ARBORIST_FAKE_PLATFORM__ || process.platform;
      module.exports = [ "SIGABRT", "SIGALRM", "SIGHUP", "SIGINT", "SIGTERM" ], "win32" !== platform && module.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT"), 
      "linux" === platform && module.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
    },
    57177: (module, __unused_webpack_exports, __webpack_require__) => {
      const npa = __webpack_require__(19932);
      module.exports = (name, lock, where) => {
        try {
          if (lock.version) {
            const spec = npa.resolve(name, lock.version, where);
            if (lock.integrity || "git" === spec.type) return spec;
          }
          if (lock.from) {
            const spec = npa.resolve(name, lock.from, where);
            if (spec.registry && lock.version) return npa.resolve(name, lock.version, where);
            if (!lock.resolved) return spec;
          }
          if (lock.resolved) return npa.resolve(name, lock.resolved, where);
        } catch {}
        try {
          return npa.resolve(name, lock.version, where);
        } catch {
          return {};
        }
      };
    },
    97179: (module, __unused_webpack_exports, __webpack_require__) => {
      const _progress = Symbol("_progress"), _onError = Symbol("_onError"), _setProgress = Symbol("_setProgess"), npmlog = __webpack_require__(19334);
      module.exports = cls => class extends cls {
        constructor(options = {}) {
          super(options), this[_setProgress] = !!options.progress, this[_progress] = new Map;
        }
        addTracker(section, subsection = null, key = null) {
          null == section && this[_onError]("Tracker can't be null or undefined"), null === key && (key = subsection);
          const hasTracker = this[_progress].has(section), hasSubtracker = this[_progress].has(`${section}:${key}`);
          hasTracker && null === subsection ? this[_onError](`Tracker "${section}" already exists`) : hasTracker || null !== subsection ? hasTracker || null === subsection ? hasTracker && hasSubtracker || this[_progress].set(`${section}:${key}`, this[_progress].get(section).newGroup(`${section}:${subsection}`)) : this[_onError](`Parent tracker "${section}" does not exist`) : (this[_setProgress] && 0 === this[_progress].size && npmlog.enableProgress(), 
          this[_progress].set(section, npmlog.newGroup(section)));
        }
        finishTracker(section, subsection = null, key = null) {
          null == section && this[_onError]("Tracker can't be null or undefined"), null === key && (key = subsection);
          const hasTracker = this[_progress].has(section), hasSubtracker = this[_progress].has(`${section}:${key}`);
          if (hasTracker && null === subsection) {
            const keys = this[_progress].keys();
            for (const key of keys) key.match(new RegExp(section + ":")) && this.finishTracker(section, key);
            this[_progress].get(section).finish(), this[_progress].delete(section), this[_setProgress] && 0 === this[_progress].size && npmlog.disableProgress();
          } else hasTracker || null !== subsection ? hasTracker && !hasSubtracker || (this[_progress].get(`${section}:${key}`).finish(), 
          this[_progress].delete(`${section}:${key}`)) : this[_onError](`Tracker "${section}" does not exist`);
        }
        [_onError](msg) {
          throw this[_setProgress] && npmlog.disableProgress(), new Error(msg);
        }
      };
    },
    56912: (module, __unused_webpack_exports, __webpack_require__) => {
      const debug = __webpack_require__(63120), checkTree = (tree, checkUnreachable = !0) => {
        const log = [ [ "START TREE CHECK", tree.path ] ];
        if (!tree.root || !tree.root.inventory) return tree;
        const {inventory} = tree.root, seen = new Set, check = (node, via = tree, viaType = "self") => {
          if (log.push([ "CHECK", node && node.location, via && via.location, viaType, "seen=" + seen.has(node), "promise=" + !(!node || !node.then), "root=" + !(!node || !node.isRoot) ]), 
          !node || seen.has(node) || node.then) return;
          if (seen.add(node), node.isRoot && node !== tree.root) throw Object.assign(new Error("double root"), {
            node: node.path,
            realpath: node.realpath,
            tree: tree.path,
            root: tree.root.path,
            via: via.path,
            viaType,
            log
          });
          if (node.root !== tree.root) throw Object.assign(new Error("node from other root in tree"), {
            node: node.path,
            realpath: node.realpath,
            tree: tree.path,
            root: tree.root.path,
            via: via.path,
            viaType,
            otherRoot: node.root && node.root.path,
            log
          });
          if (!node.isRoot && 0 !== node.inventory.size) throw Object.assign(new Error("non-root has non-zero inventory"), {
            node: node.path,
            tree: tree.path,
            root: tree.root.path,
            via: via.path,
            viaType,
            inventory: [ ...node.inventory.values() ].map((node => [ node.path, node.location ])),
            log
          });
          if (!node.isRoot && !inventory.has(node) && !node.dummy) throw Object.assign(new Error("not in inventory"), {
            node: node.path,
            tree: tree.path,
            root: tree.root.path,
            via: via.path,
            viaType,
            log
          });
          const devEdges = [ ...node.edgesOut.values() ].filter((e => e.dev));
          if (!node.isTop && devEdges.length) throw Object.assign(new Error("dev edges on non-top node"), {
            node: node.path,
            tree: tree.path,
            root: tree.root.path,
            via: via.path,
            viaType,
            devEdges: devEdges.map((e => [ e.type, e.name, e.spec, e.error ])),
            log
          });
          if (node.path === tree.root.path && node !== tree.root) throw Object.assign(new Error("node with same path as root"), {
            node: node.path,
            tree: tree.path,
            root: tree.root.path,
            via: via.path,
            viaType,
            log
          });
          if (!node.isLink && node.path !== node.realpath) throw Object.assign(new Error("non-link with mismatched path/realpath"), {
            node: node.path,
            tree: tree.path,
            realpath: node.realpath,
            root: tree.root.path,
            via: via.path,
            viaType,
            log
          });
          const {parent, fsParent, target} = node;
          check(parent, node, "parent"), check(fsParent, node, "fsParent"), check(target, node, "target"), 
          log.push([ "CHILDREN", node.location, ...node.children.keys() ]);
          for (const kid of node.children.values()) check(kid, node, "children");
          for (const kid of node.fsChildren) check(kid, node, "fsChildren");
          for (const link of node.linksIn) check(link, node, "linksIn");
          for (const top of node.tops) check(top, node, "tops");
          log.push([ "DONE", node.location ]);
        };
        if (check(tree), checkUnreachable) for (const node of inventory.values()) if (!seen.has(node) && node !== tree.root) throw Object.assign(new Error("unreachable in inventory"), {
          node: node.path,
          realpath: node.realpath,
          location: node.location,
          root: tree.root.path,
          tree: tree.path,
          log
        });
        return tree;
      };
      module.exports = tree => tree, debug((() => module.exports = checkTree));
    },
    20913: (module, __unused_webpack_exports, __webpack_require__) => {
      const semver = __webpack_require__(5870), {basename} = __webpack_require__(71017), {parse} = __webpack_require__(57310);
      module.exports = (name, tgz) => {
        const base = basename(tgz);
        if (!base.endsWith(".tgz")) return null;
        const u = parse(tgz);
        if (/^https?:/.test(u.protocol)) {
          const tfsplit = u.path.slice(1).split("/-/");
          if (tfsplit.length > 1) {
            if (tfsplit.pop() === base) {
              const preSplit = tfsplit.pop().split(/\/|%2f/i), project = preSplit.pop(), scope = preSplit.pop();
              return versionFromBaseScopeName(base, scope, project);
            }
          }
        }
        const split = name.split(/\/|%2f/i), project = split.pop(), scope = split.pop();
        return versionFromBaseScopeName(base, scope, project);
      };
      const versionFromBaseScopeName = (base, scope, name) => {
        if (!base.startsWith(name + "-")) return null;
        const parsed = semver.parse(base.substring(name.length + 1, base.length - 4));
        return parsed ? {
          name: scope && "@" === scope.charAt(0) ? `${scope}/${name}` : name,
          version: parsed.version
        } : null;
      };
    },
    26373: (module, __unused_webpack_exports, __webpack_require__) => {
      const {satisfies, simplifyRange} = __webpack_require__(5870), semverOpt = {
        loose: !0,
        includePrerelease: !0
      }, localeCompare = __webpack_require__(51031)("en"), npa = __webpack_require__(19932), _range = Symbol("_range"), _simpleRange = Symbol("_simpleRange"), _fixAvailable = Symbol("_fixAvailable"), severities = new Map([ [ "info", 0 ], [ "low", 1 ], [ "moderate", 2 ], [ "high", 3 ], [ "critical", 4 ], [ null, -1 ] ]);
      for (const [name, val] of severities.entries()) severities.set(val, name);
      module.exports = class {
        constructor({name, advisory}) {
          this.name = name, this.via = new Set, this.advisories = new Set, this.severity = null, 
          this.effects = new Set, this.topNodes = new Set, this[_range] = null, this[_simpleRange] = null, 
          this.nodes = new Set, this[_fixAvailable] = !0, this.addAdvisory(advisory), this.packument = advisory.packument, 
          this.versions = advisory.versions;
        }
        get fixAvailable() {
          return this[_fixAvailable];
        }
        set fixAvailable(f) {
          this[_fixAvailable] = f;
          for (const v of this.via) v.fixAvailable !== f && (!1 === f || !0 === v.fixAvailable ? v.fixAvailable = f : "object" != typeof f || "object" == typeof v.fixAvailable && v.fixAvailable.isSemVerMajor || (v.fixAvailable = f));
        }
        get isDirect() {
          for (const node of this.nodes.values()) for (const edge of node.edgesIn) if (edge.from.isProjectRoot || edge.from.isWorkspace) return !0;
          return !1;
        }
        testSpec(spec) {
          const specObj = npa(spec);
          if (!specObj.registry) return !0;
          specObj.subSpec && (spec = specObj.subSpec.rawSpec);
          for (const v of this.versions) if (satisfies(v, spec) && !satisfies(v, this.range, semverOpt)) return !1;
          return !0;
        }
        toJSON() {
          return {
            name: this.name,
            severity: this.severity,
            isDirect: this.isDirect,
            via: [ ...this.advisories ].map((v => "metavuln" === v.type ? v.dependency : {
              ...v,
              versions: void 0,
              vulnerableVersions: void 0,
              id: void 0
            })).sort(((a, b) => localeCompare(String(a.source || a), String(b.source || b)))),
            effects: [ ...this.effects ].map((v => v.name)).sort(localeCompare),
            range: this.simpleRange,
            nodes: [ ...this.nodes ].map((n => n.location)).sort(localeCompare),
            fixAvailable: this[_fixAvailable]
          };
        }
        addVia(v) {
          this.via.add(v), v.effects.add(this), this.fixAvailable = this.fixAvailable;
        }
        deleteVia(v) {
          this.via.delete(v), v.effects.delete(this);
        }
        deleteAdvisory(advisory) {
          this.advisories.delete(advisory), this.severity = null, this[_range] = null, this[_simpleRange] = null;
          for (const advisory of this.advisories) this.addAdvisory(advisory);
          const vias = new Set([ ...this.advisories ].map((a => a.dependency)));
          for (const via of this.via) vias.has(via.name) || this.deleteVia(via);
        }
        addAdvisory(advisory) {
          this.advisories.add(advisory);
          const sev = severities.get(advisory.severity);
          this[_range] = null, this[_simpleRange] = null, sev > severities.get(this.severity) && (this.severity = advisory.severity);
        }
        get range() {
          return this[_range] || (this[_range] = [ ...this.advisories ].map((v => v.range)).join(" || "));
        }
        get simpleRange() {
          if (this[_simpleRange] && this[_simpleRange] === this[_range]) return this[_simpleRange];
          const versions = [ ...this.advisories ][0].versions, range = this.range, simple = simplifyRange(versions, range, semverOpt);
          return this[_simpleRange] = this[_range] = simple;
        }
        isVulnerable(node) {
          if (this.nodes.has(node)) return !0;
          const {version} = node.package;
          if (!version) return !1;
          for (const v of this.advisories) if (v.testVersion(version)) return this.nodes.add(node), 
          !0;
          return !1;
        }
      };
    },
    41545: (module, __unused_webpack_exports, __webpack_require__) => {
      const localeCompare = __webpack_require__(51031)("en"), consistentResolve = __webpack_require__(27139), {dirname} = __webpack_require__(71017), {breadth} = __webpack_require__(75476), match = (p, n) => p.integrity && n.integrity ? p.integrity === n.integrity : p.resolved && n.resolved ? p.resolved === n.resolved : !p.version || !n.version || p.version === n.version, nullSymbol = Symbol("null");
      class YarnLock {
        static parse(data) {
          return (new YarnLock).parse(data);
        }
        static fromTree(tree) {
          return (new YarnLock).fromTree(tree);
        }
        constructor() {
          this.entries = null, this.endCurrent();
        }
        endCurrent() {
          this.current = null, this.subkey = nullSymbol;
        }
        parse(data) {
          const ENTRY_START = /^[^\s].*:$/, SUBKEY = /^ {2}[^\s]+:$/, SUBVAL = /^ {4}[^\s]+ .+$/, METADATA = /^ {2}[^\s]+ .+$/;
          this.entries = new Map, this.current = null;
          const linere = /([^\r\n]*)\r?\n/gm;
          let match, lineNum = 0;
          for (/\n$/.test(data) || (data += "\n"); match = linere.exec(data); ) {
            const line = match[1];
            if (lineNum++, "#" !== line.charAt(0)) if ("" !== line) if (ENTRY_START.test(line)) {
              this.endCurrent();
              const specs = this.splitQuoted(line.slice(0, -1), /, */);
              this.current = new YarnLockEntry(specs), specs.forEach((spec => this.entries.set(spec, this.current)));
            } else {
              if (!SUBKEY.test(line)) {
                if (SUBVAL.test(line) && this.current && this.current[this.subkey]) {
                  const subval = this.splitQuoted(line.trimLeft(), " ");
                  if (2 === subval.length) {
                    this.current[this.subkey][subval[0]] = subval[1];
                    continue;
                  }
                }
                if (METADATA.test(line) && this.current) {
                  const metadata = this.splitQuoted(line.trimLeft(), " ");
                  if (2 === metadata.length) {
                    "resolved" === metadata[0] && (metadata[1] = metadata[1].replace(/#.*/, "")), this.current[metadata[0]] = metadata[1];
                    continue;
                  }
                }
                throw Object.assign(new Error("invalid or corrupted yarn.lock file"), {
                  position: match.index,
                  content: match[0],
                  line: lineNum
                });
              }
              this.subkey = line.slice(2, -1), this.current[this.subkey] = {};
            } else this.endCurrent();
          }
          return this.endCurrent(), this;
        }
        splitQuoted(str, delim) {
          const split = str.split(delim), out = [];
          let o = 0;
          for (let i = 0; i < split.length; i++) {
            const chunk = split[i];
            if (/^".*"$/.test(chunk)) out[o++] = chunk.trim().slice(1, -1); else if (/^"/.test(chunk)) {
              let collect = chunk.trimLeft().slice(1);
              for (;++i < split.length; ) {
                const n = split[i];
                if (/[^\\](\\\\)*"$/.test(n)) {
                  collect += n.trimRight().slice(0, -1);
                  break;
                }
                collect += n;
              }
              out[o++] = collect;
            } else out[o++] = chunk.trim();
          }
          return out;
        }
        toString() {
          return "# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n# yarn lockfile v1\n\n\n" + [ ...new Set([ ...this.entries.values() ]) ].map((e => e.toString())).sort(localeCompare).join("\n\n") + "\n";
        }
        fromTree(tree) {
          return this.entries = new Map, breadth({
            tree,
            visit: node => this.addEntryFromNode(node),
            getChildren: node => [ ...node.children.values(), ...node.fsChildren ].sort(((a, b) => a.depth - b.depth || localeCompare(a.name, b.name)))
          }), this;
        }
        addEntryFromNode(node) {
          const specs = [ ...node.edgesIn ].map((e => `${node.name}@${e.spec}`)).sort(localeCompare), n = this.entryDataFromNode(node);
          let priorEntry = null;
          const newSpecs = [];
          for (const s of specs) {
            const prev = this.entries.get(s);
            if (!prev) {
              priorEntry ? priorEntry.addSpec(s) : newSpecs.push(s);
              continue;
            }
            if (match(prev, n)) if (priorEntry) priorEntry.addSpec(s), this.entries.set(s, priorEntry); else {
              priorEntry = prev;
              for (const s of newSpecs) priorEntry.addSpec(s), this.entries.set(s, priorEntry);
              newSpecs.length = 0;
            }
          }
          if (priorEntry) Object.assign(priorEntry, n); else {
            const entry = Object.assign(new YarnLockEntry(newSpecs), n);
            for (const s of newSpecs) this.entries.set(s, entry);
          }
        }
        entryDataFromNode(node) {
          const n = {};
          return node.package.dependencies && (n.dependencies = node.package.dependencies), 
          node.package.optionalDependencies && (n.optionalDependencies = node.package.optionalDependencies), 
          node.version && (n.version = node.version), node.resolved && (n.resolved = consistentResolve(node.resolved, node.isLink ? dirname(node.path) : node.path, node.root.path, !0)), 
          node.integrity && (n.integrity = node.integrity), n;
        }
        static get Entry() {
          return YarnLockEntry;
        }
      }
      const _specs = Symbol("_specs");
      class YarnLockEntry {
        constructor(specs) {
          this[_specs] = new Set(specs), this.resolved = null, this.version = null, this.integrity = null, 
          this.dependencies = null, this.optionalDependencies = null;
        }
        toString() {
          return ([ ...this[_specs] ].sort(localeCompare).map(JSON.stringify).join(", ") + ":\n" + Object.getOwnPropertyNames(this).filter((prop => null !== this[prop])).sort(((a, b) => "object" == typeof this[a] == ("object" == typeof this[b]) ? localeCompare(a, b) : "object" == typeof this[a] ? 1 : -1)).map((prop => {
            return "object" != typeof this[prop] ? `  ${JSON.stringify(prop)} ${JSON.stringify(this[prop])}\n` : 0 === Object.keys(this[prop]).length ? "" : `  ${prop}:\n` + (obj = this[prop], 
            Object.keys(obj).sort(localeCompare).map((k => `    ${JSON.stringify(k)} ${JSON.stringify(obj[k])}`)).join("\n") + "\n");
            var obj;
          })).join("")).trim();
        }
        addSpec(spec) {
          this[_specs].add(spec);
        }
      }
      module.exports = YarnLock;
    },
    21811: module => {
      module.exports = () => process.env.GERRIT_PROJECT ? "gerrit" : process.env.SYSTEM_TEAMFOUNDATIONCOLLECTIONURI ? "azure-pipelines" : process.env.BITRISE_IO ? "bitrise" : process.env.BUDDY_WORKSPACE_ID ? "buddy" : process.env.BUILDKITE ? "buildkite" : process.env.CIRRUS_CI ? "cirrus" : process.env.GITLAB_CI ? "gitlab" : process.env.APPVEYOR ? "appveyor" : process.env.CIRCLECI ? "circle-ci" : process.env.SEMAPHORE ? "semaphore" : process.env.DRONE ? "drone" : process.env.DSARI ? "dsari" : process.env.GITHUB_ACTION ? "github-actions" : process.env.TDDIUM ? "tddium" : process.env.SCREWDRIVER ? "screwdriver" : process.env.STRIDER ? "strider" : process.env.TASKCLUSTER_ROOT_URL ? "taskcluster" : process.env.JENKINS_URL ? "jenkins" : process.env["bamboo.buildKey"] ? "bamboo" : process.env.GO_PIPELINE_NAME ? "gocd" : process.env.HUDSON_URL ? "hudson" : process.env.WERCKER ? "wercker" : process.env.NETLIFY ? "netlify" : process.env.NOW_GITHUB_DEPLOYMENT ? "now-github" : process.env.GITLAB_DEPLOYMENT ? "now-gitlab" : process.env.BITBUCKET_DEPLOYMENT ? "now-bitbucket" : process.env.BITBUCKET_BUILD_NUMBER ? "bitbucket-pipelines" : process.env.NOW_BUILDER ? "now" : process.env.VERCEL_GITHUB_DEPLOYMENT ? "vercel-github" : process.env.VERCEL_GITLAB_DEPLOYMENT ? "vercel-gitlab" : process.env.VERCEL_BITBUCKET_DEPLOYMENT ? "vercel-bitbucket" : process.env.VERCEL_URL ? "vercel" : process.env.MAGNUM ? "magnum" : process.env.NEVERCODE ? "nevercode" : process.env.RENDER ? "render" : process.env.SAIL_CI ? "sail" : process.env.SHIPPABLE ? "shippable" : process.env.TEAMCITY_VERSION ? "teamcity" : process.env.CI_NAME ? process.env.CI_NAME : /\/\.heroku\/node\/bin\/node$/.test(process.env.NODE || "") ? "heroku" : process.env.TRAVIS ? "travis-ci" : process.env.CODEBUILD_SRC_DIR ? "aws-codebuild" : "true" === process.env.CI || "1" === process.env.CI ? "custom" : !!process.env.BUILDER_OUTPUT && "builder";
    },
    84847: module => {
      const envExpr = /(?<!\\)(\\*)\$\{([^${}]+)\}/g;
      module.exports = (f, env) => f.replace(envExpr, ((orig, esc, name) => {
        const val = void 0 !== env[name] ? env[name] : `\${${name}}`;
        return esc.length % 2 ? orig.slice((esc.length + 1) / 2) : esc.slice(esc.length / 2) + val;
      }));
    },
    18919: (module, __unused_webpack_exports, __webpack_require__) => {
      const walkUp = __webpack_require__(43967), ini = __webpack_require__(92869), nopt = __webpack_require__(69892), mkdirp = __webpack_require__(87700), mapWorkspaces = __webpack_require__(69960), rpj = __webpack_require__(1759), log = __webpack_require__(46521), myUid = process.getuid && process.getuid(), myGid = process.getgid && process.getgid(), {resolve, dirname, join} = __webpack_require__(71017), {homedir} = __webpack_require__(22037), {promisify} = __webpack_require__(73837), fs = __webpack_require__(57147), readFile = promisify(fs.readFile), writeFile = promisify(fs.writeFile), chmod = promisify(fs.chmod), chown = promisify(fs.chown), unlink = promisify(fs.unlink), stat = promisify(fs.stat), hasOwnProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key), settableGetter = (obj, key, get) => {
        Object.defineProperty(obj, key, {
          get,
          set(value) {
            Object.defineProperty(obj, key, {
              value,
              configurable: !0,
              writable: !0,
              enumerable: !0
            });
          },
          configurable: !0,
          enumerable: !0
        });
      }, typeDefs = __webpack_require__(81233), nerfDart = __webpack_require__(30621), envReplace = __webpack_require__(84847), parseField = __webpack_require__(86854), typeDescription = __webpack_require__(8711), setEnvs = __webpack_require__(54120), confFileTypes = new Set([ "global", "user", "project" ]), confTypes = new Set([ "default", "builtin", ...confFileTypes, "env", "cli" ]), _loaded = Symbol("loaded"), _get = Symbol("get"), _find = Symbol("find"), _loadObject = Symbol("loadObject"), _loadFile = Symbol("loadFile"), _checkDeprecated = Symbol("checkDeprecated"), _flatten = Symbol("flatten"), _flatOptions = Symbol("flatOptions");
      const _data = Symbol("data"), _raw = Symbol("raw"), _loadError = Symbol("loadError"), _source = Symbol("source"), _valid = Symbol("valid");
      class ConfigData {
        constructor(parent) {
          this[_data] = Object.create(parent && parent.data), this[_source] = null, this[_loadError] = null, 
          this[_raw] = null, this[_valid] = !0;
        }
        get data() {
          return this[_data];
        }
        get valid() {
          return this[_valid];
        }
        set source(s) {
          if (this[_source]) throw new Error("cannot set ConfigData source more than once");
          this[_source] = s;
        }
        get source() {
          return this[_source];
        }
        set loadError(e) {
          if (this[_loadError] || this[_raw]) throw new Error("cannot set ConfigData loadError after load");
          this[_loadError] = e;
        }
        get loadError() {
          return this[_loadError];
        }
        set raw(r) {
          if (this[_raw] || this[_loadError]) throw new Error("cannot set ConfigData raw after load");
          this[_raw] = r;
        }
        get raw() {
          return this[_raw];
        }
      }
      module.exports = class {
        static get typeDefs() {
          return typeDefs;
        }
        constructor({definitions, shorthands, flatten, npmPath, env = process.env, argv = process.argv, platform = process.platform, execPath = process.execPath, cwd = process.cwd()}) {
          this.definitions = definitions;
          const types = {}, defaults = {};
          this.deprecated = {};
          for (const [key, def] of Object.entries(definitions)) defaults[key] = def.default, 
          types[key] = def.type, def.deprecated && (this.deprecated[key] = def.deprecated.trim().replace(/\n +/, "\n"));
          this[_flatOptions] = null, this[_flatten] = flatten, this.types = types, this.shorthands = shorthands, 
          this.defaults = defaults, this.npmPath = npmPath, this.argv = argv, this.env = env, 
          this.execPath = execPath, this.platform = platform, this.cwd = cwd, this.globalPrefix = null, 
          this.localPrefix = null, this.home = null;
          const wheres = [ ...confTypes ];
          this.data = new Map;
          let parent = null;
          for (const where of wheres) this.data.set(where, parent = new ConfigData(parent));
          this.data.set = () => {
            throw new Error("cannot change internal config data structure");
          }, this.data.delete = () => {
            throw new Error("cannot change internal config data structure");
          }, this.sources = new Map([]), this.list = [];
          for (const {data} of this.data.values()) this.list.unshift(data);
          Object.freeze(this.list), this[_loaded] = !1;
        }
        get loaded() {
          return this[_loaded];
        }
        get prefix() {
          return this[_get]("global") ? this.globalPrefix : this.localPrefix;
        }
        find(key) {
          if (!this.loaded) throw new Error("call config.load() before reading values");
          return this[_find](key);
        }
        [_find](key) {
          const entries = [ ...this.data.entries() ];
          for (let i = entries.length - 1; i > -1; i--) {
            const [where, {data}] = entries[i];
            if (hasOwnProperty(data, key)) return where;
          }
          return null;
        }
        get(key, where) {
          if (!this.loaded) throw new Error("call config.load() before reading values");
          return this[_get](key, where);
        }
        [_get](key, where = null) {
          if (null !== where && !confTypes.has(where)) throw new Error("invalid config location param: " + where);
          const {data} = this.data.get(where || "cli");
          return null === where || hasOwnProperty(data, key) ? data[key] : void 0;
        }
        set(key, val, where = "cli") {
          if (!this.loaded) throw new Error("call config.load() before setting values");
          if (!confTypes.has(where)) throw new Error("invalid config location param: " + where);
          this[_checkDeprecated](key);
          const {data} = this.data.get(where);
          data[key] = val, this.data.get(where)[_valid] = null, this[_flatOptions] = null;
        }
        get flat() {
          if (this[_flatOptions]) return this[_flatOptions];
          process.emit("time", "config:load:flatten"), this[_flatOptions] = {};
          for (const {data} of this.data.values()) this[_flatten](data, this[_flatOptions]);
          return process.emit("timeEnd", "config:load:flatten"), this[_flatOptions];
        }
        delete(key, where = "cli") {
          if (!this.loaded) throw new Error("call config.load() before deleting values");
          if (!confTypes.has(where)) throw new Error("invalid config location param: " + where);
          delete this.data.get(where).data[key];
        }
        async load() {
          if (this.loaded) throw new Error("attempting to load npm config multiple times");
          process.emit("time", "config:load"), process.emit("time", "config:load:defaults"), 
          this.loadDefaults(), process.emit("timeEnd", "config:load:defaults"), process.emit("time", "config:load:builtin"), 
          await this.loadBuiltinConfig(), process.emit("timeEnd", "config:load:builtin"), 
          process.emit("time", "config:load:cli"), this.loadCLI(), process.emit("timeEnd", "config:load:cli"), 
          process.emit("time", "config:load:env"), this.loadEnv(), process.emit("timeEnd", "config:load:env"), 
          process.emit("time", "config:load:project"), await this.loadProjectConfig(), process.emit("timeEnd", "config:load:project"), 
          process.emit("time", "config:load:user"), await this.loadUserConfig(), process.emit("timeEnd", "config:load:user"), 
          process.emit("time", "config:load:global"), await this.loadGlobalConfig(), process.emit("timeEnd", "config:load:global"), 
          process.emit("time", "config:load:validate"), this.validate(), process.emit("timeEnd", "config:load:validate"), 
          this[_loaded] = !0, process.emit("time", "config:load:credentials");
          const reg = this.get("registry"), creds = this.getCredentialsByURI(reg);
          try {
            this.setCredentialsByURI(reg, creds);
          } catch (_) {}
          process.emit("timeEnd", "config:load:credentials"), this.globalPrefix = this.get("prefix"), 
          process.emit("time", "config:load:setEnvs"), this.setEnvs(), process.emit("timeEnd", "config:load:setEnvs"), 
          process.emit("timeEnd", "config:load");
        }
        loadDefaults() {
          this.loadGlobalPrefix(), this.loadHome(), this[_loadObject]({
            ...this.defaults,
            prefix: this.globalPrefix
          }, "default", "default values");
          const {data} = this.data.get("default");
          settableGetter(data, "metrics-registry", (() => this[_get]("registry"))), settableGetter(data, "globalconfig", (() => resolve(this[_get]("prefix"), "etc/npmrc")));
        }
        loadHome() {
          if (this.env.HOME) return this.home = this.env.HOME;
          this.home = homedir();
        }
        loadGlobalPrefix() {
          if (this.globalPrefix) throw new Error("cannot load default global prefix more than once");
          this.env.PREFIX ? this.globalPrefix = this.env.PREFIX : "win32" === this.platform ? this.globalPrefix = dirname(this.execPath) : (this.globalPrefix = dirname(dirname(this.execPath)), 
          this.env.DESTDIR && (this.globalPrefix = join(this.env.DESTDIR, this.globalPrefix)));
        }
        loadEnv() {
          const conf = Object.create(null);
          for (const [envKey, envVal] of Object.entries(this.env)) {
            if (!/^npm_config_/i.test(envKey) || "" === envVal) continue;
            let key = envKey.slice("npm_config_".length);
            key.startsWith("//") || (key = key.replace(/(?!^)_/g, "-").toLowerCase()), conf[key] = envVal;
          }
          this[_loadObject](conf, "env", "environment");
        }
        loadCLI() {
          nopt.invalidHandler = (k, val, type) => this.invalidHandler(k, val, type, "command line options", "cli");
          const conf = nopt(this.types, this.shorthands, this.argv);
          nopt.invalidHandler = null, this.parsedArgv = conf.argv, delete conf.argv, this[_loadObject](conf, "cli", "command line options");
        }
        get valid() {
          for (const [where, {valid}] of this.data.entries()) if (!1 === valid || null === valid && !this.validate(where)) return !1;
          return !0;
        }
        validate(where) {
          if (where) {
            const obj = this.data.get(where);
            return obj[_valid] = !0, nopt.invalidHandler = (k, val, type) => this.invalidHandler(k, val, type, obj.source, where), 
            nopt.clean(obj.data, this.types, this.typeDefs), nopt.invalidHandler = null, obj[_valid];
          }
          {
            let valid = !0;
            for (const [entryWhere] of this.data.entries()) {
              if ("default" === entryWhere || "builtin" === entryWhere || "cli" === entryWhere) continue;
              const ret = this.validate(entryWhere);
              valid = valid && ret;
            }
            return valid;
          }
        }
        isDefault(key) {
          const [defaultType, ...types] = [ ...confTypes ], defaultData = this.data.get(defaultType).data;
          return hasOwnProperty(defaultData, key) && types.every((type => {
            const typeData = this.data.get(type).data;
            return !hasOwnProperty(typeData, key);
          }));
        }
        invalidHandler(k, val, type, source, where) {
          log.warn("invalid config", k + "=" + JSON.stringify(val), `set in ${source}`), this.data.get(where)[_valid] = !1, 
          Array.isArray(type) && (type.includes(typeDefs.url.type) ? type = typeDefs.url.type : type.includes(typeDefs.path.type) && (type = typeDefs.path.type));
          const typeDesc = typeDescription(type), oneOrMore = -1 !== typeDesc.indexOf(Array), mustBe = typeDesc.filter((m => void 0 !== m && m !== Array)), msg = "Must be" + (1 === mustBe.length && oneOrMore ? " one or more" : mustBe.length > 1 && oneOrMore ? " one or more of:" : mustBe.length > 1 ? " one of:" : ""), desc = 1 === mustBe.length ? mustBe[0] : mustBe.filter((m => m !== Array)).map((n => "string" == typeof n ? n : JSON.stringify(n))).join(", ");
          log.warn("invalid config", msg, desc);
        }
        [_loadObject](obj, where, source, er = null) {
          const conf = this.data.get(where);
          if (conf.source) {
            const m = `double-loading "${where}" configs from ${source}, previously loaded from ${conf.source}`;
            throw new Error(m);
          }
          if (this.sources.has(source)) {
            const m = `double-loading config "${source}" as "${where}", previously loaded as "${this.sources.get(source)}"`;
            throw new Error(m);
          }
          if (conf.source = source, this.sources.set(source, where), er) conf.loadError = er, 
          "ENOENT" !== er.code && log.verbose("config", `error loading ${where} config`, er); else {
            conf.raw = obj;
            for (const [key, value] of Object.entries(obj)) {
              const k = envReplace(key, this.env), v = this.parseField(value, k);
              "default" !== where && this[_checkDeprecated](k, where, obj, [ key, value ]), conf.data[k] = v;
            }
          }
        }
        [_checkDeprecated](key, where, obj, kv) {
          this.deprecated[key] && log.warn("config", key, this.deprecated[key]);
        }
        parseField(f, key, listElement = !1) {
          return parseField(f, key, this, listElement);
        }
        async [_loadFile](file, type) {
          process.emit("time", "config:load:file:" + file), await readFile(file, "utf8").then((data => this[_loadObject](ini.parse(data), type, file)), (er => this[_loadObject](null, type, file, er))), 
          process.emit("timeEnd", "config:load:file:" + file);
        }
        loadBuiltinConfig() {
          return this[_loadFile](resolve(this.npmPath, "npmrc"), "builtin");
        }
        async loadProjectConfig() {
          if (await this.loadLocalPrefix(), !0 === this[_get]("global") || "global" === this[_get]("location")) return this.data.get("project").source = "(global mode enabled, ignored)", 
          void this.sources.set(this.data.get("project").source, "project");
          const projectFile = resolve(this.localPrefix, ".npmrc");
          if (projectFile !== this[_get]("userconfig")) return this[_loadFile](projectFile, "project");
          this.data.get("project").source = '(same as "user" config, ignored)', this.sources.set(this.data.get("project").source, "project");
        }
        async loadLocalPrefix() {
          const cliPrefix = this[_get]("prefix", "cli");
          if (cliPrefix) return void (this.localPrefix = cliPrefix);
          const cliWorkspaces = this[_get]("workspaces", "cli"), isGlobal = this[_get]("global") || "global" === this[_get]("location");
          for (const p of walkUp(this.cwd)) {
            const hasNodeModules = await stat(resolve(p, "node_modules")).then((st => st.isDirectory())).catch((() => !1)), hasPackageJson = await stat(resolve(p, "package.json")).then((st => st.isFile())).catch((() => !1));
            if (this.localPrefix || !hasNodeModules && !hasPackageJson) {
              if (this.localPrefix && hasPackageJson) {
                const pkg = await rpj(resolve(p, "package.json")).catch((() => !1));
                if (!pkg) continue;
                const workspaces = await mapWorkspaces({
                  cwd: p,
                  pkg
                });
                for (const w of workspaces.values()) if (w === this.localPrefix) {
                  await stat(resolve(this.localPrefix, ".npmrc")).then((st => st.isFile())).catch((() => !1)) && log.warn(`ignoring workspace config at ${this.localPrefix}/.npmrc`);
                  const {data} = this.data.get("default");
                  return data.workspace = [ this.localPrefix ], this.localPrefix = p, void log.info(`found workspace root at ${this.localPrefix}`);
                }
              }
            } else if (this.localPrefix = p, !1 === cliWorkspaces || isGlobal) return;
          }
          this.localPrefix || (this.localPrefix = this.cwd);
        }
        loadUserConfig() {
          return this[_loadFile](this[_get]("userconfig"), "user");
        }
        loadGlobalConfig() {
          return this[_loadFile](this[_get]("globalconfig"), "global");
        }
        async save(where) {
          if (!this.loaded) throw new Error("call config.load() before saving");
          if (!confFileTypes.has(where)) throw new Error("invalid config location param: " + where);
          const conf = this.data.get(where);
          if (conf[_raw] = {
            ...conf.data
          }, conf[_loadError] = null, "user" === where) {
            const reg = this.get("registry"), creds = this.getCredentialsByURI(reg);
            try {
              this.setCredentialsByURI(reg, creds);
            } catch (_) {}
          }
          const iniData = ini.stringify(conf.data).trim() + "\n";
          if (!iniData.trim()) return void await unlink(conf.source).catch((er => {}));
          const dir = dirname(conf.source);
          if (await mkdirp(dir), await writeFile(conf.source, iniData, "utf8"), 0 === myUid) {
            const st = await stat(dir).catch((() => null));
            !st || st.uid === myUid && st.gid === myGid || await chown(conf.source, st.uid, st.gid).catch((() => {}));
          }
          const mode = "user" === where ? 384 : 438;
          await chmod(conf.source, mode);
        }
        clearCredentialsByURI(uri) {
          const nerfed = nerfDart(uri);
          nerfDart(this.get("registry")) === nerfed && (this.delete("-authtoken", "user"), 
          this.delete("_authToken", "user"), this.delete("_authtoken", "user"), this.delete("_auth", "user"), 
          this.delete("_password", "user"), this.delete("username", "user")), this.delete(`${nerfed}:_authToken`, "user"), 
          this.delete(`${nerfed}:_auth`, "user"), this.delete(`${nerfed}:_password`, "user"), 
          this.delete(`${nerfed}:username`, "user"), this.delete(`${nerfed}:email`, "user"), 
          this.delete(`${nerfed}:certfile`, "user"), this.delete(`${nerfed}:keyfile`, "user");
        }
        setCredentialsByURI(uri, {token, username, password, email, certfile, keyfile}) {
          const nerfed = nerfDart(uri), def = nerfDart(this.get("registry"));
          if (def === nerfed && (this.delete("_password", "user"), this.delete("username", "user"), 
          this.delete("_auth", "user"), this.delete("_authtoken", "user"), this.delete("-authtoken", "user"), 
          this.delete("_authToken", "user")), nerfed === def && (email = email || this.get("email", "user") || this.get(`${nerfed}:email`, "user")) && this.set("email", email, "user"), 
          this.delete(`${nerfed}:always-auth`, "user"), this.delete(`${nerfed}:email`, "user"), 
          certfile && keyfile && (this.set(`${nerfed}:certfile`, certfile, "user"), this.set(`${nerfed}:keyfile`, keyfile, "user")), 
          token) this.set(`${nerfed}:_authToken`, token, "user"), this.delete(`${nerfed}:_password`, "user"), 
          this.delete(`${nerfed}:username`, "user"); else if (username || password) {
            if (!username) throw new Error("must include username");
            if (!password) throw new Error("must include password");
            this.delete(`${nerfed}:_authToken`, "user"), this.set(`${nerfed}:username`, username, "user");
            const encoded = Buffer.from(password, "utf8").toString("base64");
            this.set(`${nerfed}:_password`, encoded, "user");
          } else if (!certfile || !keyfile) throw new Error("No credentials to set.");
        }
        getCredentialsByURI(uri) {
          const nerfed = nerfDart(uri), creds = {}, deprecatedAuthWarning = [ "`_auth`, `_authToken`, `username` and `_password` must be scoped to a registry.", "see `npm help npmrc` for more information." ].join(" "), email = this.get(`${nerfed}:email`) || this.get("email");
          email && (creds.email = email);
          const certfileReg = this.get(`${nerfed}:certfile`), keyfileReg = this.get(`${nerfed}:keyfile`);
          certfileReg && keyfileReg && (creds.certfile = certfileReg, creds.keyfile = keyfileReg);
          const defaultToken = nerfDart(this.get("registry")) && this.get("_authToken"), tokenReg = this.get(`${nerfed}:_authToken`) || defaultToken;
          if (tokenReg) return tokenReg === defaultToken && log.warn("config", deprecatedAuthWarning), 
          creds.token = tokenReg, creds;
          const userReg = this.get(`${nerfed}:username`), passReg = this.get(`${nerfed}:_password`);
          if (userReg && passReg) {
            creds.username = userReg, creds.password = Buffer.from(passReg, "base64").toString("utf8");
            const auth = `${creds.username}:${creds.password}`;
            return creds.auth = Buffer.from(auth, "utf8").toString("base64"), creds;
          }
          const authReg = this.get(`${nerfed}:_auth`);
          if (authReg) {
            const authSplit = Buffer.from(authReg, "base64").toString("utf8").split(":");
            return creds.username = authSplit.shift(), creds.password = authSplit.join(":"), 
            creds.auth = authReg, creds;
          }
          if (nerfed !== nerfDart(this.get("registry"))) return creds;
          const userDef = this.get("username"), passDef = this.get("_password");
          if (userDef && passDef) {
            log.warn("config", deprecatedAuthWarning), creds.username = userDef, creds.password = Buffer.from(passDef, "base64").toString("utf8");
            const auth = `${creds.username}:${creds.password}`;
            return creds.auth = Buffer.from(auth, "utf8").toString("base64"), creds;
          }
          const auth = this.get("_auth");
          if (!auth) return creds;
          log.warn("config", deprecatedAuthWarning);
          const authSplit = Buffer.from(auth, "base64").toString("utf8").split(":");
          return creds.username = authSplit.shift(), creds.password = authSplit.join(":"), 
          creds.auth = auth, creds;
        }
        setEnvs() {
          setEnvs(this);
        }
      };
    },
    30621: (module, __unused_webpack_exports, __webpack_require__) => {
      const {URL} = __webpack_require__(57310);
      module.exports = url => {
        const parsed = new URL(url), from = `${parsed.protocol}//${parsed.host}${parsed.pathname}`, rel = new URL(".", from);
        return `//${rel.host}${rel.pathname}`;
      };
    },
    86854: (module, __unused_webpack_exports, __webpack_require__) => {
      const typeDefs = __webpack_require__(81233), envReplace = __webpack_require__(84847), {resolve} = __webpack_require__(71017), {parse: umaskParse} = __webpack_require__(86827), parseField = (f, key, opts, listElement = !1) => {
        if ("string" != typeof f && !Array.isArray(f)) return f;
        const {platform, types, home, env} = opts, typeList = new Set([].concat(types[key])), isPath = typeList.has(typeDefs.path.type), isBool = typeList.has(typeDefs.Boolean.type), isString = isPath || typeList.has(typeDefs.String.type), isUmask = typeList.has(typeDefs.Umask.type), isNumber = typeList.has(typeDefs.Number.type), isList = !listElement && typeList.has(Array);
        if (Array.isArray(f)) return isList ? f.map((field => parseField(field, key, opts, !0))) : f;
        if (f = f.trim(), isList) return parseField(f.split("\n\n"), key, opts);
        if (isBool && !isString && "" === f) return !0;
        if (!isString && !isPath && !isNumber) switch (f) {
         case "true":
          return !0;

         case "false":
          return !1;

         case "null":
          return null;

         case "undefined":
          return;
        }
        if (f = envReplace(f, env), isPath) {
          f = ("win32" === platform ? /^~(\/|\\)/ : /^~\//).test(f) && home ? resolve(home, f.slice(2)) : resolve(f);
        }
        if (isUmask) try {
          return umaskParse(f);
        } catch (er) {
          return f;
        }
        return isNumber && !isNaN(f) && (f = +f), f;
      };
      module.exports = parseField;
    },
    54120: (module, __unused_webpack_exports, __webpack_require__) => {
      const envVal = val => Array.isArray(val) ? val.map((v => envVal(v))).join("\n\n") : null == val || !1 === val ? "" : "object" == typeof val ? null : String(val), sameConfigValue = (def, val) => Array.isArray(val) && Array.isArray(def) ? sameArrayValue(def, val) : def === val, sameArrayValue = (def, val) => {
        if (def.length !== val.length) return !1;
        for (let i = 0; i < def.length; i++) if (def[i] !== val[i]) return !1;
        return !0;
      }, setEnv = (env, rawKey, rawVal) => {
        const val = envVal(rawVal), key = ((key, val) => !/^[/@_]/.test(key) && "string" == typeof envVal(val) && `npm_config_${key.replace(/-/g, "_").toLowerCase()}`)(rawKey, val);
        key && null !== val && (env[key] = val);
      };
      module.exports = config => {
        const {env, defaults, definitions, list: [cliConf, envConf]} = config;
        env.INIT_CWD = process.cwd();
        const cliSet = new Set(Object.keys(cliConf)), envSet = new Set(Object.keys(envConf));
        for (const key in cliConf) {
          const {deprecated, envExport = !0} = definitions[key] || {};
          deprecated || !1 === envExport || (sameConfigValue(defaults[key], cliConf[key]) ? sameConfigValue(envConf[key], cliConf[key]) || setEnv(env, key, cliConf[key]) : envSet.has(key) && !cliSet.has(key) || setEnv(env, key, cliConf[key]));
        }
        env.HOME = config.home, env.npm_config_global_prefix = config.globalPrefix, env.npm_config_local_prefix = config.localPrefix, 
        cliConf.editor && (env.EDITOR = cliConf.editor), cliConf["node-options"] && (env.NODE_OPTIONS = cliConf["node-options"]), 
        __webpack_require__.c[__webpack_require__.s] && __webpack_require__.c[__webpack_require__.s].filename && (env.npm_execpath = __webpack_require__.c[__webpack_require__.s].filename), 
        env.NODE = env.npm_node_execpath = config.execPath;
      };
    },
    81233: (module, __unused_webpack_exports, __webpack_require__) => {
      const nopt = __webpack_require__(69892), {Umask, validate: validateUmask} = __webpack_require__(86827), semver = __webpack_require__(5870), noptValidatePath = nopt.typeDefs.path.validate;
      module.exports = {
        ...nopt.typeDefs,
        semver: {
          type: semver,
          validate: (data, k, val) => {
            const valid = semver.valid(val);
            if (!valid) return !1;
            data[k] = valid;
          },
          description: "full valid SemVer string"
        },
        Umask: {
          type: Umask,
          validate: validateUmask,
          description: "octal number in range 0o000..0o777 (0..511)"
        },
        url: {
          ...nopt.typeDefs.url,
          description: 'full url with "http://"'
        },
        path: {
          ...nopt.typeDefs.path,
          validate: (data, k, val) => "string" == typeof val && noptValidatePath(data, k, val),
          description: "valid filesystem path"
        },
        Number: {
          ...nopt.typeDefs.Number,
          description: "numeric value"
        },
        Boolean: {
          ...nopt.typeDefs.Boolean,
          description: "boolean value (true or false)"
        },
        Date: {
          ...nopt.typeDefs.Date,
          description: "valid Date string"
        }
      }, nopt.typeDefs = module.exports;
    },
    8711: (module, __unused_webpack_exports, __webpack_require__) => {
      const typeDefs = __webpack_require__(81233), typeDescription = t => {
        if (!t || "function" != typeof t && "object" != typeof t) return t;
        if (Array.isArray(t)) return t.map((t => typeDescription(t)));
        for (const {type, description} of Object.values(typeDefs)) if (type === t) return description || type;
        return t;
      };
      module.exports = t => [].concat(typeDescription(t)).filter((t => void 0 !== t));
    },
    86827: module => {
      const parse = val => {
        if ("string" == typeof val) {
          if (/^0o?[0-7]+$/.test(val)) return parseInt(val.replace(/^0o?/, ""), 8);
          if (/^[1-9][0-9]*$/.test(val)) return parseInt(val, 10);
          throw new Error(`invalid umask value: ${val}`);
        }
        if ("number" != typeof val) throw new Error(`invalid umask value: ${val}`);
        if ((val = Math.floor(val)) < 0 || val > 511) throw new Error(`invalid umask value: ${val}`);
        return val;
      };
      module.exports = {
        Umask: class {},
        parse,
        validate: (data, k, val) => {
          try {
            return data[k] = parse(val), !0;
          } catch (er) {
            return !1;
          }
        }
      };
    },
    71657: (module, __unused_webpack_exports, __webpack_require__) => {
      const ansi = __webpack_require__(53694), colors = {
        removed: ansi.red,
        added: ansi.green,
        header: ansi.yellow,
        section: ansi.magenta
      };
      module.exports = function(str, opts) {
        let headerLength = (opts || {}).headerLength;
        ("number" != typeof headerLength || Number.isNaN(headerLength)) && (headerLength = 2);
        const color = (colorStr, colorId) => {
          const {open, close} = colors[colorId];
          return colorStr.replace(/[^\n\r]+/g, open + "$&" + close);
        }, lines = ("string" == typeof str && str || "").split(/^/m);
        return color(lines.slice(0, headerLength).join(""), "header") + lines.slice(headerLength).join("").replace(/^-.*/gm, color("$&", "removed")).replace(/^\+.*/gm, color("$&", "added")).replace(/^@@.+@@/gm, color("$&", "section"));
      };
    },
    55784: module => {
      module.exports = (input, {copy, wrap}) => {
        const result = {};
        if (input && "object" == typeof input) for (const prop of copy) void 0 !== input[prop] && (result[prop] = input[prop]); else result[wrap] = input;
        return result;
      };
    },
    43913: (module, __unused_webpack_exports, __webpack_require__) => {
      const semver = __webpack_require__(5870);
      module.exports = {
        satisfies: range => semver.satisfies(process.version, range, {
          includePrerelease: !0
        })
      };
    },
    47573: (module, __unused_webpack_exports, __webpack_require__) => {
      const {dirname, resolve} = __webpack_require__(71017), url = __webpack_require__(57310), fs = __webpack_require__(54421), find = path => {
        if (!process.getuid) return {};
        const resolved = null != path && path.href && path.origin ? resolve(url.fileURLToPath(path)) : resolve(path);
        let stat;
        try {
          stat = fs.lstatSync(resolved);
        } finally {
          return stat ? {
            uid: stat.uid,
            gid: stat.gid
          } : resolved !== dirname(resolved) ? find(dirname(resolved)) : {};
        }
      };
      module.exports = {
        find,
        update: (path, uid, gid) => {
          if (void 0 !== uid || void 0 !== gid) {
            try {
              const stat = fs.statSync(path);
              if (uid === stat.uid && gid === stat.gid) return;
            } catch {}
            try {
              fs.chownSync(path, uid, gid);
            } catch {}
          }
        },
        validate: (path, input) => {
          let uid, gid;
          if ("string" == typeof input || "number" == typeof input ? (uid = input, gid = input) : input && "object" == typeof input && (uid = input.uid, 
          gid = input.gid), "inherit" === uid || "inherit" === gid) {
            const owner = find(path);
            "inherit" === uid && (uid = owner.uid), "inherit" === gid && (gid = owner.gid);
          }
          return {
            uid,
            gid
          };
        }
      };
    },
    45127: (module, __unused_webpack_exports, __webpack_require__) => {
      const {dirname, resolve} = __webpack_require__(71017), url = __webpack_require__(57310), fs = __webpack_require__(54421), find = async path => {
        if (!process.getuid) return {};
        const resolved = null != path && path.href && path.origin ? resolve(url.fileURLToPath(path)) : resolve(path);
        let stat;
        try {
          stat = await fs.lstat(resolved);
        } finally {
          return stat ? {
            uid: stat.uid,
            gid: stat.gid
          } : resolved !== dirname(resolved) ? find(dirname(resolved)) : {};
        }
      };
      module.exports = {
        find,
        update: async (path, uid, gid) => {
          if (void 0 !== uid || void 0 !== gid) {
            try {
              const stat = await fs.stat(path);
              if (uid === stat.uid && gid === stat.gid) return;
            } catch {}
            try {
              await fs.chown(path, uid, gid);
            } catch {}
          }
        },
        validate: async (path, input) => {
          let uid, gid;
          if ("string" == typeof input || "number" == typeof input ? (uid = input, gid = input) : input && "object" == typeof input && (uid = input.uid, 
          gid = input.gid), "inherit" === uid || "inherit" === gid) {
            const owner = await find(path);
            "inherit" === uid && (uid = owner.uid), "inherit" === gid && (gid = owner.gid);
          }
          return {
            uid,
            gid
          };
        }
      };
    },
    82940: (module, __unused_webpack_exports, __webpack_require__) => {
      const fs = __webpack_require__(54421), getOptions = __webpack_require__(55784), withOwner = __webpack_require__(5383);
      module.exports = async (src, dest, opts) => {
        const options = getOptions(opts, {
          copy: [ "mode" ],
          wrap: "mode"
        });
        return withOwner(dest, (() => fs.copyFile(src, dest, options.mode)), opts);
      };
    },
    34947: (module, __unused_webpack_exports, __webpack_require__) => {
      const fs = __webpack_require__(54421), getOptions = __webpack_require__(55784), node = __webpack_require__(43913), polyfill = __webpack_require__(65987), useNative = node.satisfies(">=16.7.0");
      module.exports = async (src, dest, opts) => {
        const options = getOptions(opts, {
          copy: [ "dereference", "errorOnExist", "filter", "force", "preserveTimestamps", "recursive" ]
        });
        return useNative ? fs.cp(src, dest, options) : polyfill(src, dest, options);
      };
    },
    65987: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const {ERR_FS_CP_DIR_TO_NON_DIR, ERR_FS_CP_EEXIST, ERR_FS_CP_EINVAL, ERR_FS_CP_FIFO_PIPE, ERR_FS_CP_NON_DIR_TO_DIR, ERR_FS_CP_SOCKET, ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY, ERR_FS_CP_UNKNOWN, ERR_FS_EISDIR, ERR_INVALID_ARG_TYPE} = __webpack_require__(55371), {constants: {errno: {EEXIST, EISDIR, EINVAL, ENOTDIR}}} = __webpack_require__(22037), {chmod, copyFile, lstat, mkdir, readdir, readlink, stat, symlink, unlink, utimes} = __webpack_require__(54421), {dirname, isAbsolute, join, parse, resolve, sep, toNamespacedPath} = __webpack_require__(71017), {fileURLToPath} = __webpack_require__(57310), defaultOptions = {
        dereference: !1,
        errorOnExist: !1,
        filter: void 0,
        force: !0,
        preserveTimestamps: !1,
        recursive: !1
      };
      function getValidatedPath(fileURLOrPath) {
        return null != fileURLOrPath && fileURLOrPath.href && fileURLOrPath.origin ? fileURLToPath(fileURLOrPath) : fileURLOrPath;
      }
      async function checkPaths(src, dest, opts) {
        const {0: srcStat, 1: destStat} = await function(src, dest, opts) {
          const statFunc = opts.dereference ? file => stat(file, {
            bigint: !0
          }) : file => lstat(file, {
            bigint: !0
          });
          return Promise.all([ statFunc(src), statFunc(dest).catch((err => {
            if ("ENOENT" === err.code) return null;
            throw err;
          })) ]);
        }(src, dest, opts);
        if (destStat) {
          if (areIdentical(srcStat, destStat)) throw new ERR_FS_CP_EINVAL({
            message: "src and dest cannot be the same",
            path: dest,
            syscall: "cp",
            errno: EINVAL
          });
          if (srcStat.isDirectory() && !destStat.isDirectory()) throw new ERR_FS_CP_DIR_TO_NON_DIR({
            message: `cannot overwrite directory ${src} with non-directory ${dest}`,
            path: dest,
            syscall: "cp",
            errno: EISDIR
          });
          if (!srcStat.isDirectory() && destStat.isDirectory()) throw new ERR_FS_CP_NON_DIR_TO_DIR({
            message: `cannot overwrite non-directory ${src} with directory ${dest}`,
            path: dest,
            syscall: "cp",
            errno: ENOTDIR
          });
        }
        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) throw new ERR_FS_CP_EINVAL({
          message: `cannot copy ${src} to a subdirectory of self ${dest}`,
          path: dest,
          syscall: "cp",
          errno: EINVAL
        });
        return {
          srcStat,
          destStat
        };
      }
      function areIdentical(srcStat, destStat) {
        return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
      }
      async function checkParentDir(destStat, src, dest, opts) {
        const destParent = dirname(dest), dirExists = await function(dest) {
          return stat(dest).then((() => !0), (err => "ENOENT" !== err.code && Promise.reject(err)));
        }(destParent);
        return dirExists || await mkdir(destParent, {
          recursive: !0
        }), getStatsForCopy(destStat, src, dest, opts);
      }
      async function checkParentPaths(src, srcStat, dest) {
        const srcParent = resolve(dirname(src)), destParent = resolve(dirname(dest));
        if (destParent === srcParent || destParent === parse(destParent).root) return;
        let destStat;
        try {
          destStat = await stat(destParent, {
            bigint: !0
          });
        } catch (err) {
          if ("ENOENT" === err.code) return;
          throw err;
        }
        if (areIdentical(srcStat, destStat)) throw new ERR_FS_CP_EINVAL({
          message: `cannot copy ${src} to a subdirectory of self ${dest}`,
          path: dest,
          syscall: "cp",
          errno: EINVAL
        });
        return checkParentPaths(src, srcStat, destParent);
      }
      const normalizePathToArray = path => resolve(path).split(sep).filter(Boolean);
      function isSrcSubdir(src, dest) {
        const srcArr = normalizePathToArray(src), destArr = normalizePathToArray(dest);
        return srcArr.every(((cur, i) => destArr[i] === cur));
      }
      async function handleFilter(onInclude, destStat, src, dest, opts, cb) {
        if (await opts.filter(src, dest)) return onInclude(destStat, src, dest, opts, cb);
      }
      function startCopy(destStat, src, dest, opts) {
        return opts.filter ? handleFilter(getStatsForCopy, destStat, src, dest, opts) : getStatsForCopy(destStat, src, dest, opts);
      }
      async function getStatsForCopy(destStat, src, dest, opts) {
        const statFn = opts.dereference ? stat : lstat, srcStat = await statFn(src);
        if (srcStat.isDirectory() && opts.recursive) return function(srcStat, destStat, src, dest, opts) {
          if (!destStat) return async function(srcMode, src, dest, opts) {
            return await mkdir(dest), await copyDir(src, dest, opts), setDestMode(dest, srcMode);
          }(srcStat.mode, src, dest, opts);
          return copyDir(src, dest, opts);
        }(srcStat, destStat, src, dest, opts);
        if (srcStat.isDirectory()) throw new ERR_FS_EISDIR({
          message: `${src} is a directory (not copied)`,
          path: src,
          syscall: "cp",
          errno: EINVAL
        });
        if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return function(srcStat, destStat, src, dest, opts) {
          if (!destStat) return _copyFile(srcStat, src, dest, opts);
          return async function(srcStat, src, dest, opts) {
            if (opts.force) return await unlink(dest), _copyFile(srcStat, src, dest, opts);
            if (opts.errorOnExist) throw new ERR_FS_CP_EEXIST({
              message: `${dest} already exists`,
              path: dest,
              syscall: "cp",
              errno: EEXIST
            });
          }(srcStat, src, dest, opts);
        }(srcStat, destStat, src, dest, opts);
        if (srcStat.isSymbolicLink()) return async function(destStat, src, dest) {
          let resolvedDest, resolvedSrc = await readlink(src);
          isAbsolute(resolvedSrc) || (resolvedSrc = resolve(dirname(src), resolvedSrc));
          if (!destStat) return symlink(resolvedSrc, dest);
          try {
            resolvedDest = await readlink(dest);
          } catch (err) {
            if ("EINVAL" === err.code || "UNKNOWN" === err.code) return symlink(resolvedSrc, dest);
            throw err;
          }
          isAbsolute(resolvedDest) || (resolvedDest = resolve(dirname(dest), resolvedDest));
          if (isSrcSubdir(resolvedSrc, resolvedDest)) throw new ERR_FS_CP_EINVAL({
            message: `cannot copy ${resolvedSrc} to a subdirectory of self ${resolvedDest}`,
            path: dest,
            syscall: "cp",
            errno: EINVAL
          });
          if ((await stat(src)).isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) throw new ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY({
            message: `cannot overwrite ${resolvedDest} with ${resolvedSrc}`,
            path: dest,
            syscall: "cp",
            errno: EINVAL
          });
          return async function(resolvedSrc, dest) {
            return await unlink(dest), symlink(resolvedSrc, dest);
          }(resolvedSrc, dest);
        }(destStat, src, dest);
        if (srcStat.isSocket()) throw new ERR_FS_CP_SOCKET({
          message: `cannot copy a socket file: ${dest}`,
          path: dest,
          syscall: "cp",
          errno: EINVAL
        });
        if (srcStat.isFIFO()) throw new ERR_FS_CP_FIFO_PIPE({
          message: `cannot copy a FIFO pipe: ${dest}`,
          path: dest,
          syscall: "cp",
          errno: EINVAL
        });
        throw new ERR_FS_CP_UNKNOWN({
          message: `cannot copy an unknown file type: ${dest}`,
          path: dest,
          syscall: "cp",
          errno: EINVAL
        });
      }
      async function _copyFile(srcStat, src, dest, opts) {
        return await copyFile(src, dest), opts.preserveTimestamps ? async function(srcMode, src, dest) {
          if (function(srcMode) {
            return 0 == (128 & srcMode);
          }(srcMode)) return await function(dest, srcMode) {
            return setDestMode(dest, 128 | srcMode);
          }(dest, srcMode), setDestTimestampsAndMode(srcMode, src, dest);
          return setDestTimestampsAndMode(srcMode, src, dest);
        }(srcStat.mode, src, dest) : setDestMode(dest, srcStat.mode);
      }
      async function setDestTimestampsAndMode(srcMode, src, dest) {
        return await async function(src, dest) {
          const updatedSrcStat = await stat(src);
          return utimes(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
        }(src, dest), setDestMode(dest, srcMode);
      }
      function setDestMode(dest, srcMode) {
        return chmod(dest, srcMode);
      }
      async function copyDir(src, dest, opts) {
        const dir = await readdir(src);
        for (let i = 0; i < dir.length; i++) {
          const item = dir[i], srcItem = join(src, item), destItem = join(dest, item), {destStat} = await checkPaths(srcItem, destItem, opts);
          await startCopy(destStat, srcItem, destItem, opts);
        }
      }
      module.exports = async function(src, dest, opts) {
        if (null != opts && "object" != typeof opts) throw new ERR_INVALID_ARG_TYPE("options", [ "Object" ], opts);
        return async function(src, dest, opts) {
          if (opts.preserveTimestamps && "ia32" === process.arch) {
            const warning = "Using the preserveTimestamps option in 32-bit node is not recommended";
            process.emitWarning(warning, "TimestampPrecisionWarning");
          }
          const stats = await checkPaths(src, dest, opts), {srcStat, destStat} = stats;
          if (await checkParentPaths(src, srcStat, dest), opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts);
          return checkParentDir(destStat, src, dest, opts);
        }(toNamespacedPath(getValidatedPath(src)), toNamespacedPath(getValidatedPath(dest)), {
          ...defaultOptions,
          ...opts
        });
      };
    },
    55371: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const {inspect} = __webpack_require__(73837);
      class SystemError {
        constructor(code, prefix, context) {
          let message = `${prefix}: ${context.syscall} returned ${context.code} (${context.message})`;
          void 0 !== context.path && (message += ` ${context.path}`), void 0 !== context.dest && (message += ` => ${context.dest}`), 
          this.code = code, Object.defineProperties(this, {
            name: {
              value: "SystemError",
              enumerable: !1,
              writable: !0,
              configurable: !0
            },
            message: {
              value: message,
              enumerable: !1,
              writable: !0,
              configurable: !0
            },
            info: {
              value: context,
              enumerable: !0,
              configurable: !0,
              writable: !1
            },
            errno: {
              get: () => context.errno,
              set(value) {
                context.errno = value;
              },
              enumerable: !0,
              configurable: !0
            },
            syscall: {
              get: () => context.syscall,
              set(value) {
                context.syscall = value;
              },
              enumerable: !0,
              configurable: !0
            }
          }), void 0 !== context.path && Object.defineProperty(this, "path", {
            get: () => context.path,
            set(value) {
              context.path = value;
            },
            enumerable: !0,
            configurable: !0
          }), void 0 !== context.dest && Object.defineProperty(this, "dest", {
            get: () => context.dest,
            set(value) {
              context.dest = value;
            },
            enumerable: !0,
            configurable: !0
          });
        }
        toString() {
          return `${this.name} [${this.code}]: ${this.message}`;
        }
        [Symbol.for("nodejs.util.inspect.custom")](_recurseTimes, ctx) {
          return inspect(this, {
            ...ctx,
            getters: !0,
            customInspect: !1
          });
        }
      }
      function E(code, message) {
        module.exports[code] = class extends SystemError {
          constructor(ctx) {
            super(code, message, ctx);
          }
        };
      }
      E("ERR_FS_CP_DIR_TO_NON_DIR", "Cannot overwrite directory with non-directory"), 
      E("ERR_FS_CP_EEXIST", "Target already exists"), E("ERR_FS_CP_EINVAL", "Invalid src or dest"), 
      E("ERR_FS_CP_FIFO_PIPE", "Cannot copy a FIFO pipe"), E("ERR_FS_CP_NON_DIR_TO_DIR", "Cannot overwrite non-directory with directory"), 
      E("ERR_FS_CP_SOCKET", "Cannot copy a socket file"), E("ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY", "Cannot overwrite symlink in subdirectory of self"), 
      E("ERR_FS_CP_UNKNOWN", "Cannot copy an unknown file type"), E("ERR_FS_EISDIR", "Path is a directory"), 
      module.exports.ERR_INVALID_ARG_TYPE = class extends Error {
        constructor(name, expected, actual) {
          super(), this.code = "ERR_INVALID_ARG_TYPE", this.message = `The ${name} argument must be ${expected}. Received ${typeof actual}`;
        }
      };
    },
    54421: (module, __unused_webpack_exports, __webpack_require__) => {
      const fs = __webpack_require__(57147), promisify = __webpack_require__(67398), fsSync = Object.fromEntries(Object.entries(fs).filter((([k, v]) => {
        return "function" == typeof v && (k.endsWith("Sync") || !((s = k[0]) === s.toLowerCase() && s !== s.toUpperCase()));
        var s;
      })));
      module.exports = {
        ...promisify(fs),
        ...fsSync
      };
    },
    45264: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = {
        ...__webpack_require__(54421),
        copyFile: __webpack_require__(82940),
        cp: __webpack_require__(34947),
        mkdir: __webpack_require__(81026),
        mkdtemp: __webpack_require__(71593),
        rm: __webpack_require__(39605),
        withTempDir: __webpack_require__(91762),
        withOwner: __webpack_require__(5383),
        withOwnerSync: __webpack_require__(16435),
        writeFile: __webpack_require__(23851)
      };
    },
    81026: (module, __unused_webpack_exports, __webpack_require__) => {
      const fs = __webpack_require__(54421), getOptions = __webpack_require__(55784), withOwner = __webpack_require__(5383);
      module.exports = async (path, opts) => {
        const options = getOptions(opts, {
          copy: [ "mode", "recursive" ],
          wrap: "mode"
        });
        return withOwner(path, (() => fs.mkdir(path, options)), opts);
      };
    },
    71593: (module, __unused_webpack_exports, __webpack_require__) => {
      const {dirname, sep} = __webpack_require__(71017), fs = __webpack_require__(54421), getOptions = __webpack_require__(55784), withOwner = __webpack_require__(5383);
      module.exports = async (prefix, opts) => {
        const options = getOptions(opts, {
          copy: [ "encoding" ],
          wrap: "encoding"
        }), root = prefix.endsWith(sep) ? prefix : dirname(prefix);
        return withOwner(root, (() => fs.mkdtemp(prefix, options)), opts);
      };
    },
    39605: (module, __unused_webpack_exports, __webpack_require__) => {
      const fs = __webpack_require__(54421), getOptions = __webpack_require__(55784), node = __webpack_require__(43913), polyfill = __webpack_require__(54733), useNative = node.satisfies(">=14.14.0");
      module.exports = async (path, opts) => {
        const options = getOptions(opts, {
          copy: [ "retryDelay", "maxRetries", "recursive", "force" ]
        });
        return useNative ? fs.rm(path, options) : polyfill(path, options);
      };
    },
    54733: (module, __unused_webpack_exports, __webpack_require__) => {
      const errnos = __webpack_require__(22037).constants.errno, {join} = __webpack_require__(71017), fs = __webpack_require__(54421), notEmptyCodes = new Set([ "ENOTEMPTY", "EEXIST", "EPERM" ]), retryCodes = new Set([ "EBUSY", "EMFILE", "ENFILE", "ENOTEMPTY", "EPERM" ]), isWindows = "win32" === process.platform, defaultOptions = {
        retryDelay: 100,
        maxRetries: 0,
        recursive: !1,
        force: !1
      };
      class ERR_FS_EISDIR extends Error {
        constructor(path) {
          super(), this.info = {
            code: "EISDIR",
            message: "is a directory",
            path,
            syscall: "rm",
            errno: errnos.EISDIR
          }, this.name = "SystemError", this.code = "ERR_FS_EISDIR", this.errno = errnos.EISDIR, 
          this.syscall = "rm", this.path = path, this.message = `Path is a directory: ${this.syscall} returned ${this.info.code} (is a directory) ${path}`;
        }
        toString() {
          return `${this.name} [${this.code}]: ${this.message}`;
        }
      }
      class ENOTDIR extends Error {
        constructor(path) {
          super(), this.name = "Error", this.code = "ENOTDIR", this.errno = errnos.ENOTDIR, 
          this.syscall = "rmdir", this.path = path, this.message = `not a directory, ${this.syscall} '${this.path}'`;
        }
        toString() {
          return `${this.name}: ${this.code}: ${this.message}`;
        }
      }
      const rimraf = async (path, options, isTop = !1) => {
        const force = !isTop || options.force, stat = await fs.lstat(path).catch((err => {
          if ("ENOENT" !== err.code || !force) {
            if (isWindows && "EPERM" === err.code) return fixEPERM(path, options, err, isTop);
            throw err;
          }
        }));
        if (stat) return stat.isDirectory() ? rmdir(path, options, null, isTop) : fs.unlink(path).catch((err => {
          if ("ENOENT" !== err.code || !force) {
            if ("EISDIR" === err.code) return rmdir(path, options, err, isTop);
            if ("EPERM" === err.code) return isWindows ? fixEPERM(path, options, err, isTop) : rmdir(path, options, err, isTop);
            throw err;
          }
        }));
      }, fixEPERM = async (path, options, originalErr, isTop) => {
        const force = !isTop || options.force;
        if (await fs.chmod(path, 438).catch((err => {
          if ("ENOENT" === err.code && force) return !0;
          throw originalErr;
        }))) return;
        const stat = await fs.lstat(path).catch((err => {
          if ("ENOENT" !== err.code || !force) throw originalErr;
        }));
        return stat ? stat.isDirectory() ? rmdir(path, options, originalErr, isTop) : fs.unlink(path) : void 0;
      }, rmdir = async (path, options, originalErr, isTop) => {
        if (!options.recursive && isTop) throw originalErr || new ERR_FS_EISDIR(path);
        const force = !isTop || options.force;
        return fs.rmdir(path).catch((async err => {
          if (isWindows && "ENOENT" === err.code) {
            await fs.lstat(path).then((() => !0), (() => !1)) && (err = new ENOTDIR(path));
          }
          if ("ENOENT" !== err.code || !force) {
            if (originalErr && "ENOTDIR" === err.code) throw originalErr;
            if (notEmptyCodes.has(err.code)) {
              const files = await fs.readdir(path);
              return await Promise.all(files.map((file => {
                const target = join(path, file);
                return rimraf(target, options);
              }))), fs.rmdir(path);
            }
            throw err;
          }
        }));
      }, promiseTimeout = ms => new Promise((r => setTimeout(r, ms)));
      module.exports = async (path, opts) => {
        const options = {
          ...defaultOptions,
          ...opts
        };
        let retries = 0;
        const errHandler = async err => {
          if (retryCodes.has(err.code) && ++retries < options.maxRetries) {
            const delay = retries * options.retryDelay;
            return await promiseTimeout(delay), rimraf(path, options, !0).catch(errHandler);
          }
          throw err;
        };
        return rimraf(path, options, !0).catch(errHandler);
      };
    },
    16435: (module, __unused_webpack_exports, __webpack_require__) => {
      const getOptions = __webpack_require__(55784), owner = __webpack_require__(47573);
      module.exports = (path, fn, opts) => {
        const options = getOptions(opts, {
          copy: [ "owner" ]
        }), {uid, gid} = owner.validate(path, options.owner), result = fn({
          uid,
          gid
        });
        return owner.update(path, uid, gid), "string" == typeof result && owner.update(result, uid, gid), 
        result;
      };
    },
    5383: (module, __unused_webpack_exports, __webpack_require__) => {
      const getOptions = __webpack_require__(55784), owner = __webpack_require__(45127);
      module.exports = async (path, fn, opts) => {
        const options = getOptions(opts, {
          copy: [ "owner" ]
        }), {uid, gid} = await owner.validate(path, options.owner), result = await fn({
          uid,
          gid
        });
        return await Promise.all([ owner.update(path, uid, gid), "string" == typeof result ? owner.update(result, uid, gid) : null ]), 
        result;
      };
    },
    91762: (module, __unused_webpack_exports, __webpack_require__) => {
      const {join, sep} = __webpack_require__(71017), getOptions = __webpack_require__(55784), mkdir = __webpack_require__(81026), mkdtemp = __webpack_require__(71593), rm = __webpack_require__(39605);
      module.exports = async (root, fn, opts) => {
        const options = getOptions(opts, {
          copy: [ "tmpPrefix" ]
        });
        await mkdir(root, {
          recursive: !0,
          owner: "inherit"
        });
        const target = await mkdtemp(join(`${root}${sep}`, options.tmpPrefix || ""), {
          owner: "inherit"
        });
        let err, result;
        try {
          result = await fn(target);
        } catch (_err) {
          err = _err;
        }
        try {
          await rm(target, {
            force: !0,
            recursive: !0
          });
        } catch {}
        if (err) throw err;
        return result;
      };
    },
    23851: (module, __unused_webpack_exports, __webpack_require__) => {
      const fs = __webpack_require__(54421), getOptions = __webpack_require__(55784), withOwner = __webpack_require__(5383);
      module.exports = async (file, data, opts) => {
        const options = getOptions(opts, {
          copy: [ "encoding", "mode", "flag", "signal" ],
          wrap: "encoding"
        });
        return withOwner(file, (() => fs.writeFile(file, data, options)), opts);
      };
    },
    86696: (module, __unused_webpack_exports, __webpack_require__) => {
      const shallowHosts = new Set([ "github.com", "gist.github.com", "gitlab.com", "bitbucket.com", "bitbucket.org" ]), {parse} = __webpack_require__(57310), path = __webpack_require__(71017), getRevs = __webpack_require__(56883), spawn = __webpack_require__(95966), {isWindows} = __webpack_require__(72266), pickManifest = __webpack_require__(65732), fs = __webpack_require__(57147), mkdirp = __webpack_require__(41718);
      module.exports = (repo, ref = "HEAD", target = null, opts = {}) => getRevs(repo, opts).then((revs => clone(repo, revs, ref, resolveRef(revs, ref, opts), target || defaultTarget(repo, opts.cwd), opts)));
      const maybeShallow = (repo, opts) => !1 === opts.gitShallow || opts.gitShallow ? opts.gitShallow : shallowHosts.has(parse(repo).host), defaultTarget = (repo, cwd = process.cwd()) => path.resolve(cwd, path.basename(repo.replace(/[/\\]?\.git$/, ""))), clone = (repo, revs, ref, revDoc, target, opts) => revDoc ? revDoc.sha === revs.refs.HEAD.sha ? plain(repo, revDoc, target, opts) : "tag" === revDoc.type || "branch" === revDoc.type ? branch(repo, revDoc, target, opts) : other(repo, revDoc, target, opts) : unresolved(repo, ref, target, opts), resolveRef = (revs, ref, opts) => {
        const {spec = {}} = opts;
        return ref = spec.gitCommittish || ref, revs ? spec.gitRange ? pickManifest(revs, spec.gitRange, opts) : ref ? revs.refs[ref] ? revs.refs[ref] : revs.shas[ref] ? revs.refs[revs.shas[ref][0]] : null : revs.refs.HEAD : null;
      }, other = (repo, revDoc, target, opts) => {
        const shallow = maybeShallow(repo, opts), fetchOrigin = [ "fetch", "origin", revDoc.rawRef ].concat(shallow ? [ "--depth=1" ] : []), git = args => spawn(args, {
          ...opts,
          cwd: target
        });
        return mkdirp(target).then((() => git([ "init" ]))).then((() => isWindows(opts) ? git([ "config", "--local", "--add", "core.longpaths", "true" ]) : null)).then((() => git([ "remote", "add", "origin", repo ]))).then((() => git(fetchOrigin))).then((() => git([ "checkout", revDoc.sha ]))).then((() => updateSubmodules(target, opts))).then((() => revDoc.sha));
      }, branch = (repo, revDoc, target, opts) => {
        const args = [ "clone", "-b", revDoc.ref, repo, target, "--recurse-submodules" ];
        return maybeShallow(repo, opts) && args.push("--depth=1"), isWindows(opts) && args.push("--config", "core.longpaths=true"), 
        spawn(args, opts).then((() => revDoc.sha));
      }, plain = (repo, revDoc, target, opts) => {
        const args = [ "clone", repo, target, "--recurse-submodules" ];
        return maybeShallow(repo, opts) && args.push("--depth=1"), isWindows(opts) && args.push("--config", "core.longpaths=true"), 
        spawn(args, opts).then((() => revDoc.sha));
      }, updateSubmodules = (target, opts) => new Promise((resolve => fs.stat(target + "/.gitmodules", (er => resolve(er ? null : spawn([ "submodule", "update", "-q", "--init", "--recursive" ], {
        ...opts,
        cwd: target
      })))))), unresolved = (repo, ref, target, opts) => {
        const lp = isWindows(opts) ? [ "--config", "core.longpaths=true" ] : [], cloneArgs = [ "clone", "--mirror", "-q", repo, target + "/.git" ], git = args => spawn(args, {
          ...opts,
          cwd: target
        });
        return mkdirp(target).then((() => git(cloneArgs.concat(lp)))).then((() => git([ "init" ]))).then((() => git([ "checkout", ref ]))).then((() => updateSubmodules(target, opts))).then((() => git([ "rev-parse", "--revs-only", "HEAD" ]))).then((({stdout}) => stdout.trim()));
      };
    },
    30839: module => {
      class GitError extends Error {
        shouldRetry() {
          return !1;
        }
      }
      module.exports = {
        GitConnectionError: class extends GitError {
          constructor(message) {
            super("A git connection error occurred");
          }
          shouldRetry(number) {
            return number < 3;
          }
        },
        GitPathspecError: class extends GitError {
          constructor(message) {
            super("The git reference could not be found");
          }
        },
        GitUnknownError: class extends GitError {
          constructor(message) {
            super("An unknown git error occurred");
          }
        }
      };
    },
    88824: (module, __unused_webpack_exports, __webpack_require__) => {
      const is = __webpack_require__(75554), {dirname} = __webpack_require__(71017);
      module.exports = async ({cwd = process.cwd()} = {}) => {
        if (await is({
          cwd
        })) return cwd;
        for (;cwd !== dirname(cwd); ) if (cwd = dirname(cwd), await is({
          cwd
        })) return cwd;
        return null;
      };
    },
    1626: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = {
        clone: __webpack_require__(86696),
        revs: __webpack_require__(56883),
        spawn: __webpack_require__(95966),
        is: __webpack_require__(75554),
        find: __webpack_require__(88824),
        isClean: __webpack_require__(10801),
        errors: __webpack_require__(30839)
      };
    },
    10801: (module, __unused_webpack_exports, __webpack_require__) => {
      const spawn = __webpack_require__(95966);
      module.exports = (opts = {}) => spawn([ "status", "--porcelain=v1", "-uno" ], opts).then((res => !res.stdout.trim().split(/\r?\n+/).map((l => l.trim())).filter((l => l)).length));
    },
    75554: (module, __unused_webpack_exports, __webpack_require__) => {
      const {promisify} = __webpack_require__(73837), stat = promisify(__webpack_require__(57147).stat);
      module.exports = ({cwd = process.cwd()} = {}) => stat(cwd + "/.git").then((() => !0), (() => !1));
    },
    96549: (module, __unused_webpack_exports, __webpack_require__) => {
      const semver = __webpack_require__(5870);
      module.exports = lines => finish(lines.reduce(linesToRevsReducer, {
        versions: {},
        "dist-tags": {},
        refs: {},
        shas: {}
      }));
      const finish = revs => distTags(shaList(peelTags(revs))), shaList = revs => (Object.keys(revs.refs).forEach((ref => {
        const doc = revs.refs[ref];
        revs.shas[doc.sha] ? revs.shas[doc.sha].push(ref) : revs.shas[doc.sha] = [ ref ];
      })), revs), peelTags = revs => (Object.keys(revs.refs).filter((ref => ref.endsWith("^{}"))).forEach((ref => {
        const peeled = revs.refs[ref], unpeeled = revs.refs[ref.replace(/\^\{\}$/, "")];
        unpeeled && (unpeeled.sha = peeled.sha, delete revs.refs[ref]);
      })), revs), distTags = revs => {
        const HEAD = revs.refs.HEAD || {};
        return Object.keys(revs.versions).forEach((v => {
          const ver = revs.versions[v];
          revs.refs.latest && ver.sha === revs.refs.latest.sha ? revs["dist-tags"].latest = v : ver.sha === HEAD.sha && (revs["dist-tags"].HEAD = v, 
          revs.refs.latest || (revs["dist-tags"].latest = v));
        })), revs;
      }, linesToRevsReducer = (revs, line) => {
        const doc = (line => {
          const split = line.trim().split(/\s+/, 2);
          if (split.length < 2) return null;
          const sha = split[0].trim(), rawRef = split[1].trim(), type = (ref = rawRef).startsWith("refs/tags/") ? "tag" : ref.startsWith("refs/heads/") ? "branch" : ref.startsWith("refs/pull/") ? "pull" : "HEAD" === ref ? "head" : "other";
          var ref;
          if ("tag" === type) return {
            sha,
            ref: rawRef.slice("refs/tags/".length),
            rawRef,
            type
          };
          if ("branch" === type) return {
            sha,
            ref: rawRef.slice("refs/heads/".length),
            rawRef,
            type
          };
          if ("pull" === type) return {
            sha,
            ref: rawRef.slice("refs/".length).replace(/\/head$/, ""),
            rawRef,
            type
          };
          if ("head" === type) return {
            sha,
            ref: "HEAD",
            rawRef,
            type
          };
          return {
            sha,
            ref: rawRef,
            rawRef,
            type
          };
        })(line);
        if (!doc) return revs;
        if (revs.refs[doc.ref] = doc, revs.refs[doc.rawRef] = doc, "tag" === doc.type) {
          const match = !doc.ref.endsWith("^{}") && doc.ref.match(/v?(\d+\.\d+\.\d+(?:[-+].+)?)$/);
          match && semver.valid(match[1], !0) && (revs.versions[semver.clean(match[1], !0)] = doc);
        }
        return revs;
      };
    },
    77832: (module, __unused_webpack_exports, __webpack_require__) => {
      const {GitConnectionError, GitPathspecError, GitUnknownError} = __webpack_require__(30839), connectionErrorRe = new RegExp([ "remote error: Internal Server Error", "The remote end hung up unexpectedly", "Connection timed out", "Operation timed out", "Failed to connect to .* Timed out", "Connection reset by peer", "SSL_ERROR_SYSCALL", "The requested URL returned error: 503" ].join("|")), missingPathspecRe = /pathspec .* did not match any file\(s\) known to git/;
      module.exports = function(er) {
        const message = er.stderr;
        let gitEr;
        return gitEr = connectionErrorRe.test(message) ? new GitConnectionError(message) : missingPathspecRe.test(message) ? new GitPathspecError(message) : new GitUnknownError(message), 
        Object.assign(gitEr, er);
      };
    },
    38332: module => {
      const gitEnv = {
        GIT_ASKPASS: "echo",
        GIT_SSH_COMMAND: "ssh -oStrictHostKeyChecking=accept-new"
      };
      module.exports = (opts = {}) => ({
        stdioString: !0,
        ...opts,
        shell: !1,
        env: opts.env || {
          ...gitEnv,
          ...process.env
        }
      });
    },
    56883: (module, __unused_webpack_exports, __webpack_require__) => {
      const pinflight = __webpack_require__(10978), spawn = __webpack_require__(95966), revsCache = new (__webpack_require__(71752))({
        max: 100,
        ttl: 3e5
      }), linesToRevs = __webpack_require__(96549);
      module.exports = async (repo, opts = {}) => {
        if (!opts.noGitRevCache) {
          const cached = revsCache.get(repo);
          if (cached) return cached;
        }
        return pinflight(`ls-remote:${repo}`, (() => spawn([ "ls-remote", repo ], opts).then((({stdout}) => linesToRevs(stdout.trim().split("\n")))).then((revs => (revsCache.set(repo, revs), 
        revs)))));
      };
    },
    95966: (module, __unused_webpack_exports, __webpack_require__) => {
      const spawn = __webpack_require__(26035), promiseRetry = __webpack_require__(49776), log = __webpack_require__(46521), makeError = __webpack_require__(77832), whichGit = __webpack_require__(54201), makeOpts = __webpack_require__(38332);
      module.exports = (gitArgs, opts = {}) => {
        const gitPath = whichGit(opts);
        if (gitPath instanceof Error) return Promise.reject(gitPath);
        const args = opts.allowReplace || "--no-replace-objects" === gitArgs[0] ? gitArgs : [ "--no-replace-objects", ...gitArgs ];
        let retryOpts = opts.retry;
        return null == retryOpts && (retryOpts = {
          retries: opts.fetchRetries || 2,
          factor: opts.fetchRetryFactor || 10,
          maxTimeout: opts.fetchRetryMaxtimeout || 6e4,
          minTimeout: opts.fetchRetryMintimeout || 1e3
        }), promiseRetry(((retryFn, number) => (1 !== number && log.silly("git", `Retrying git command: ${args.join(" ")} attempt # ${number}`), 
        spawn(gitPath, args, makeOpts(opts)).catch((er => {
          const gitError = makeError(er);
          if (!gitError.shouldRetry(number)) throw gitError;
          retryFn(gitError);
        })))), retryOpts);
      };
    },
    72266: (__unused_webpack_module, exports) => {
      exports.isWindows = opts => "win32" === (opts.fakePlatform || process.platform);
    },
    54201: (module, __unused_webpack_exports, __webpack_require__) => {
      const which = __webpack_require__(7017);
      let gitPath;
      try {
        gitPath = which.sync("git");
      } catch {}
      module.exports = (opts = {}) => opts.git ? opts.git : gitPath && !1 !== opts.git ? gitPath : Object.assign(new Error("No git binary found in $PATH"), {
        code: "ENOGIT"
      });
    },
    20590: (module, __unused_webpack_exports, __webpack_require__) => {
      module = __webpack_require__.nmd(module);
      const bundled = __webpack_require__(24492), {promisify} = __webpack_require__(73837), fs = __webpack_require__(57147), readFile = promisify(fs.readFile), readdir = promisify(fs.readdir), stat = promisify(fs.stat), lstat = promisify(fs.lstat), {relative, resolve, basename, dirname} = __webpack_require__(71017), normalizePackageBin = __webpack_require__(63697), normalized = Symbol("package data has been normalized"), rpj = ({path, packageJsonCache}) => (({path, packageJsonCache}) => packageJsonCache.has(path) ? Promise.resolve(packageJsonCache.get(path)) : readFile(path).then((json => {
        const pkg = normalizePackageBin(JSON.parse(json));
        return packageJsonCache.set(path, pkg), pkg;
      })).catch((er => null)))({
        path,
        packageJsonCache
      }).then((pkg => {
        if (!pkg || pkg[normalized]) return pkg;
        pkg.bundledDependencies && !pkg.bundleDependencies && (pkg.bundleDependencies = pkg.bundledDependencies, 
        delete pkg.bundledDependencies);
        const bd = pkg.bundleDependencies;
        return !0 === bd && (pkg.bundleDependencies = [ ...Object.keys(pkg.dependencies || {}), ...Object.keys(pkg.optionalDependencies || {}) ]), 
        "object" != typeof bd || Array.isArray(bd) || (pkg.bundleDependencies = Object.keys(bd)), 
        pkg[normalized] = !0, pkg;
      })), pkgContents = async ({path, depth, currentDepth = 0, pkg = null, result = null, packageJsonCache = null}) => {
        if (result || (result = new Set), packageJsonCache || (packageJsonCache = new Map), 
        !0 === pkg) return rpj({
          path: path + "/package.json",
          packageJsonCache
        }).then((pkg => pkgContents({
          path,
          depth,
          currentDepth,
          pkg,
          result,
          packageJsonCache
        })));
        if (pkg && pkg.bin) {
          const dir = dirname(path), scope = (basename(path), basename(dir)), nm = /^@.+/.test(scope) ? dirname(dir) : dir, binFiles = [];
          Object.keys(pkg.bin).forEach((b => {
            const base = resolve(nm, ".bin", b);
            binFiles.push(base, base + ".cmd", base + ".ps1");
          }));
          (await Promise.all(binFiles.map((b => stat(b).then((() => b)).catch((er => null)))))).filter((b => b)).forEach((b => result.add(b)));
        }
        if (currentDepth >= depth) return result.add(path), result;
        const [dirEntries, bundleDeps] = await Promise.all([ readdir(path, {
          withFileTypes: !0
        }), 0 === currentDepth && pkg && pkg.bundleDependencies ? bundled({
          path,
          packageJsonCache
        }) : null ]).catch((() => []));
        if (!dirEntries) return result;
        if (!dirEntries.length && !bundleDeps && 0 !== currentDepth) return result.add(path), 
        result;
        const recursePromises = [];
        "string" == typeof dirEntries[0] && await Promise.all(dirEntries.map((async (name, index) => {
          const p = resolve(path, name), st = await lstat(p);
          dirEntries[index] = Object.assign(st, {
            name
          });
        })));
        for (const entry of dirEntries) {
          const p = resolve(path, entry.name);
          !1 !== entry.isDirectory() ? 0 === currentDepth && "node_modules" === entry.name || (currentDepth < depth - 1 ? recursePromises.push(pkgContents({
            path: p,
            packageJsonCache,
            depth,
            currentDepth: currentDepth + 1,
            result
          })) : result.add(p)) : result.add(p);
        }
        return bundleDeps && recursePromises.push(...bundleDeps.map((dep => {
          const p = resolve(path, "node_modules", dep);
          return pkgContents({
            path: p,
            packageJsonCache,
            pkg: !0,
            depth,
            currentDepth: currentDepth + 1,
            result
          });
        }))), recursePromises.length && await Promise.all(recursePromises), result;
      };
      if (module.exports = ({path, depth = 1, packageJsonCache}) => pkgContents({
        path: resolve(path),
        depth,
        pkg: !0,
        packageJsonCache
      }).then((results => [ ...results ])), __webpack_require__.c[__webpack_require__.s] === module) {
        const options = {
          path: null,
          depth: 1
        }, usage = 'Usage:\n  installed-package-contents <path> [-d<n> --depth=<n>]\n\nLists the files installed for a package specified by <path>.\n\nOptions:\n  -d<n> --depth=<n>   Provide a numeric value ("Infinity" is allowed)\n                      to specify how deep in the file tree to traverse.\n                      Default=1\n  -h --help           Show this usage information';
        process.argv.slice(2).forEach((arg => {
          let match;
          (match = arg.match(/^--depth=([0-9]+|Infinity)/)) || (match = arg.match(/^-d([0-9]+|Infinity)/)) ? options.depth = +match[1] : "-h" === arg || "--help" === arg ? (console.log(usage), 
          process.exit(0)) : options.path = arg;
        })), options.path || (console.error("ERROR: no path provided"), console.error(usage), 
        process.exit(1));
        const cwd = process.cwd();
        module.exports(options).then((list => list.sort().forEach((p => console.log(relative(cwd, p)))))).catch((er => {
          console.error(er), process.exit(1);
        }));
      }
    },
    24492: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const fs = __webpack_require__(57147), path = __webpack_require__(71017), EE = __webpack_require__(82361).EventEmitter, normalizePackageBin = __webpack_require__(63697);
      class BundleWalker extends EE {
        constructor(opt) {
          if (super(opt = opt || {}), this.path = path.resolve(opt.path || process.cwd()), 
          this.parent = opt.parent || null, this.parent) {
            if (this.result = this.parent.result, !this.parent.parent) {
              const base = path.basename(this.path), scope = path.basename(path.dirname(this.path));
              this.result.add(/^@/.test(scope) ? scope + "/" + base : base);
            }
            this.root = this.parent.root, this.packageJsonCache = this.parent.packageJsonCache;
          } else this.result = new Set, this.root = this.path, this.packageJsonCache = opt.packageJsonCache || new Map;
          this.seen = new Set, this.didDone = !1, this.children = 0, this.node_modules = [], 
          this.package = null, this.bundle = null;
        }
        addListener(ev, fn) {
          return this.on(ev, fn);
        }
        on(ev, fn) {
          const ret = super.on(ev, fn);
          return "done" === ev && this.didDone && this.emit("done", this.result), ret;
        }
        done() {
          if (!this.didDone) if (this.didDone = !0, this.parent) this.emit("done"); else {
            const res = Array.from(this.result);
            this.result = res, this.emit("done", res);
          }
        }
        start() {
          const pj = path.resolve(this.path, "package.json");
          return this.packageJsonCache.has(pj) ? this.onPackage(this.packageJsonCache.get(pj)) : this.readPackageJson(pj), 
          this;
        }
        readPackageJson(pj) {
          fs.readFile(pj, ((er, data) => er ? this.done() : this.onPackageJson(pj, data)));
        }
        onPackageJson(pj, data) {
          try {
            this.package = normalizePackageBin(JSON.parse(data + ""));
          } catch (er) {
            return this.done();
          }
          this.packageJsonCache.set(pj, this.package), this.onPackage(this.package);
        }
        allDepsBundled(pkg) {
          return Object.keys(pkg.dependencies || {}).concat(Object.keys(pkg.optionalDependencies || {}));
        }
        onPackage(pkg) {
          const bdRaw = this.parent ? this.allDepsBundled(pkg) : pkg.bundleDependencies || pkg.bundledDependencies || [], bd = Array.from(new Set(Array.isArray(bdRaw) ? bdRaw : !0 === bdRaw ? this.allDepsBundled(pkg) : Object.keys(bdRaw)));
          if (!bd.length) return this.done();
          this.bundle = bd;
          this.path;
          this.readModules();
        }
        readModules() {
          readdirNodeModules(this.path + "/node_modules", ((er, nm) => er ? this.onReaddir([]) : this.onReaddir(nm)));
        }
        onReaddir(nm) {
          this.node_modules = nm, this.bundle.forEach((dep => this.childDep(dep))), 0 === this.children && this.done();
        }
        childDep(dep) {
          -1 !== this.node_modules.indexOf(dep) ? this.seen.has(dep) || (this.seen.add(dep), 
          this.child(dep)) : this.parent && this.parent.childDep(dep);
        }
        child(dep) {
          const p = this.path + "/node_modules/" + dep;
          this.children += 1;
          const child = new BundleWalker({
            path: p,
            parent: this
          });
          child.on("done", (_ => {
            0 == --this.children && this.done();
          })), child.start();
        }
      }
      class BundleWalkerSync extends BundleWalker {
        constructor(opt) {
          super(opt);
        }
        start() {
          return super.start(), this.done(), this;
        }
        readPackageJson(pj) {
          try {
            this.onPackageJson(pj, fs.readFileSync(pj));
          } catch (er) {}
          return this;
        }
        readModules() {
          try {
            this.onReaddir(readdirNodeModulesSync(this.path + "/node_modules"));
          } catch (er) {
            this.onReaddir([]);
          }
        }
        child(dep) {
          new BundleWalkerSync({
            path: this.path + "/node_modules/" + dep,
            parent: this
          }).start();
        }
      }
      const readdirNodeModules = (nm, cb) => {
        fs.readdir(nm, ((er, set) => {
          if (er) cb(er); else {
            const scopes = set.filter((f => /^@/.test(f)));
            if (scopes.length) {
              const unscoped = set.filter((f => !/^@/.test(f)));
              let count = scopes.length;
              scopes.forEach((scope => {
                fs.readdir(nm + "/" + scope, ((er, pkgs) => {
                  er || !pkgs.length ? unscoped.push(scope) : unscoped.push.apply(unscoped, pkgs.map((p => scope + "/" + p))), 
                  0 == --count && cb(null, unscoped);
                }));
              }));
            } else cb(null, set);
          }
        }));
      }, readdirNodeModulesSync = nm => {
        const set = fs.readdirSync(nm), unscoped = set.filter((f => !/^@/.test(f))), scopes = set.filter((f => /^@/.test(f))).map((scope => {
          try {
            const pkgs = fs.readdirSync(nm + "/" + scope);
            return pkgs.length ? pkgs.map((p => scope + "/" + p)) : [ scope ];
          } catch (er) {
            return [ scope ];
          }
        })).reduce(((a, b) => a.concat(b)), []);
        return unscoped.concat(scopes);
      }, walk = (options, callback) => {
        const p = new Promise(((resolve, reject) => {
          new BundleWalker(options).on("done", resolve).on("error", reject).start();
        }));
        return callback ? p.then((res => callback(null, res)), callback) : p;
      };
      module.exports = walk, walk.sync = options => new BundleWalkerSync(options).start().result, 
      walk.BundleWalker = BundleWalker, walk.BundleWalkerSync = BundleWalkerSync;
    },
    63697: (module, __unused_webpack_exports, __webpack_require__) => {
      const {join, basename} = __webpack_require__(71017), normalizeString = pkg => pkg.name ? (pkg.bin = {
        [pkg.name]: pkg.bin
      }, normalizeObject(pkg)) : removeBin(pkg), normalizeArray = pkg => (pkg.bin = pkg.bin.reduce(((acc, k) => (acc[basename(k)] = k, 
      acc)), {}), normalizeObject(pkg)), removeBin = pkg => (delete pkg.bin, pkg), normalizeObject = pkg => {
        const orig = pkg.bin, clean = {};
        let hasBins = !1;
        return Object.keys(orig).forEach((binKey => {
          const base = join("/", basename(binKey.replace(/\\|:/g, "/"))).substr(1);
          if ("string" != typeof orig[binKey] || !base) return;
          const binTarget = join("/", orig[binKey]).replace(/\\/g, "/").substr(1);
          binTarget && (clean[base] = binTarget, hasBins = !0);
        })), hasBins ? pkg.bin = clean : delete pkg.bin, pkg;
      };
      module.exports = pkg => pkg.bin ? "string" == typeof pkg.bin ? normalizeString(pkg) : Array.isArray(pkg.bin) ? normalizeArray(pkg) : "object" == typeof pkg.bin ? normalizeObject(pkg) : removeBin(pkg) : removeBin(pkg);
    },
    69960: (module, __unused_webpack_exports, __webpack_require__) => {
      const {promisify} = __webpack_require__(73837), path = __webpack_require__(71017), getName = __webpack_require__(3046), minimatch = __webpack_require__(51191), rpj = __webpack_require__(1759), pGlob = promisify(__webpack_require__(34436));
      function getPatterns(workspaces) {
        const workspacesDeclaration = Array.isArray(workspaces.packages) ? workspaces.packages : workspaces;
        if (!Array.isArray(workspacesDeclaration)) throw getError({
          message: "workspaces config expects an Array",
          code: "EWORKSPACESCONFIG"
        });
        return function(patterns) {
          const results = [];
          for (let pattern of patterns) {
            const excl = pattern.match(/^!+/);
            excl && (pattern = pattern.slice(excl[0].length)), pattern = pattern.replace(/^\/+/, "");
            const negate = excl && excl[0].length % 2 == 1;
            results.push({
              pattern,
              negate
            });
          }
          return results;
        }(workspacesDeclaration);
      }
      function getPackageName(pkg, pathname) {
        const {name} = pkg;
        return name || getName(pathname);
      }
      function pkgPathmame(opts) {
        return (...args) => {
          const cwd = opts.cwd ? opts.cwd : process.cwd();
          return path.join.apply(null, [ cwd, ...args ]);
        };
      }
      function getError({Type = TypeError, message, code}) {
        return Object.assign(new Type(message), {
          code
        });
      }
      async function mapWorkspaces(opts = {}) {
        if (!opts || !opts.pkg) throw getError({
          message: "mapWorkspaces missing pkg info",
          code: "EMAPWORKSPACESPKG"
        });
        const {workspaces = []} = opts.pkg, patterns = getPatterns(workspaces), results = new Map, seen = new Map;
        if (!patterns.length) return results;
        const getPackagePathname = pkgPathmame(opts);
        for (const item of patterns) {
          const matches = await pGlob((pattern = item.pattern, (pattern = pattern.replace(/\\/g, "/")).endsWith("/") ? pattern : `${pattern}/`), {
            ...opts,
            ignore: [ ...opts.ignore || [], "**/node_modules/**" ]
          });
          for (const match of matches) {
            let pkg;
            const packageJsonPathname = getPackagePathname(match, "package.json"), packagePathname = path.dirname(packageJsonPathname);
            try {
              pkg = await rpj(packageJsonPathname);
            } catch (err) {
              if ("ENOENT" === err.code) continue;
              throw err;
            }
            const name = getPackageName(pkg, packagePathname);
            let seenPackagePathnames = seen.get(name);
            seenPackagePathnames || (seenPackagePathnames = new Set, seen.set(name, seenPackagePathnames)), 
            item.negate ? seenPackagePathnames.delete(packagePathname) : seenPackagePathnames.add(packagePathname);
          }
        }
        var pattern;
        const errorMessageArray = [ "must not have multiple workspaces with the same name" ];
        for (const [packageName, seenPackagePathnames] of seen) 0 !== seenPackagePathnames.size && (seenPackagePathnames.size > 1 ? addDuplicateErrorMessages(errorMessageArray, packageName, seenPackagePathnames) : results.set(packageName, seenPackagePathnames.values().next().value));
        if (errorMessageArray.length > 1) throw getError({
          Type: Error,
          message: errorMessageArray.join("\n"),
          code: "EDUPLICATEWORKSPACE"
        });
        return results;
      }
      function addDuplicateErrorMessages(messageArray, packageName, packagePathnames) {
        messageArray.push(`package '${packageName}' has conflicts in the following paths:`);
        for (const packagePathname of packagePathnames) messageArray.push("    " + packagePathname);
      }
      mapWorkspaces.virtual = function(opts = {}) {
        if (!opts || !opts.lockfile) throw getError({
          message: "mapWorkspaces.virtual missing lockfile info",
          code: "EMAPWORKSPACESLOCKFILE"
        });
        const {packages = {}} = opts.lockfile, {workspaces = []} = packages[""] || {}, results = new Map, patterns = getPatterns(workspaces);
        if (!patterns.length) return results;
        patterns.push({
          pattern: "**/node_modules/**",
          negate: !0
        });
        const getPackagePathname = pkgPathmame(opts);
        for (const packageKey of Object.keys(packages)) if ("" !== packageKey) for (const item of patterns) if (minimatch(packageKey, item.pattern)) {
          const packagePathname = getPackagePathname(packageKey), name = getPackageName(packages[packageKey], packagePathname);
          item.negate ? results.delete(packagePathname) : results.set(packagePathname, name);
        }
        return map = results, new Map(Array.from(map, (item => item.reverse())));
        var map;
      }, module.exports = mapWorkspaces;
    },
    76755: (module, __unused_webpack_exports, __webpack_require__) => {
      const hash = __webpack_require__(11978), semver = __webpack_require__(5870), semverOpt = {
        includePrerelease: !0,
        loose: !0
      }, getDepSpec = __webpack_require__(40594), _source = Symbol("source"), _packument = Symbol("packument"), _versionVulnMemo = Symbol("versionVulnMemo"), _updated = Symbol("updated"), _options = Symbol("options"), _specVulnMemo = Symbol("specVulnMemo"), _testVersion = Symbol("testVersion"), _testVersions = Symbol("testVersions"), _calculateRange = Symbol("calculateRange"), _markVulnerable = Symbol("markVulnerable"), _testSpec = Symbol("testSpec");
      module.exports = class {
        constructor(name, source, options = {}) {
          this.source = source.id, this[_source] = source, this[_options] = options, this.name = name, 
          source.name || (source.name = name), this.dependency = source.name, "advisory" === this.type ? (this.title = source.title, 
          this.url = source.url) : (this.title = `Depends on vulnerable versions of ${source.name}`, 
          this.url = null), this.severity = source.severity || "high", this.versions = [], 
          this.vulnerableVersions = [], this.cwe = source.cwe, this.cvss = source.cvss, this.range = "advisory" === this.type ? source.vulnerable_versions || "*" : null, 
          this.id = hash(this), this[_packument] = null, this[_versionVulnMemo] = new Map, 
          this[_specVulnMemo] = new Map, this[_updated] = !1;
        }
        get updated() {
          return this[_updated];
        }
        get type() {
          return this.dependency === this.name ? "advisory" : "metavuln";
        }
        get packument() {
          return this[_packument];
        }
        load(cached, packument) {
          if (!cached || "object" != typeof cached) throw new TypeError("invalid cached data, expected object");
          if (!packument || "object" != typeof packument) throw new TypeError("invalid packument data, expected object");
          if (cached.id && cached.id !== this.id) throw Object.assign(new Error("loading from incorrect cache entry"), {
            expected: this.id,
            actual: cached.id
          });
          if (packument.name !== this.name) throw Object.assign(new Error("loading from incorrect packument"), {
            expected: this.name,
            actual: packument.name
          });
          if (this[_packument]) throw new Error("advisory object already loaded");
          (!this.range || cached.range && cached.range === this.range) && Object.assign(this, cached), 
          this[_packument] = packument;
          const pakuVersions = Object.keys(packument.versions), allVersions = new Set([ ...pakuVersions, ...this.versions ]), versionsAdded = [], versionsRemoved = [];
          for (const v of allVersions) this.versions.includes(v) ? pakuVersions.includes(v) || versionsRemoved.push(v) : (versionsAdded.push(v), 
          this.versions.push(v));
          this.versions = semver.sort(this.versions.filter((v => !versionsRemoved.includes(v))), semverOpt);
          const unchanged = "advisory" === this.type ? this.range && this.range === cached.range : !this[_source].updated;
          return this.vulnerableVersions = unchanged ? semver.sort(this.vulnerableVersions.filter((v => !versionsRemoved.includes(v))), semverOpt) : [], 
          !unchanged || versionsAdded.length || versionsRemoved.length ? (this[_updated] = !0, 
          unchanged && !versionsAdded.length || this[_testVersions](unchanged ? versionsAdded : this.versions), 
          this.vulnerableVersions = semver.sort(this.vulnerableVersions, semverOpt), "metavuln" === this.type && this[_calculateRange](), 
          this) : this;
        }
        [_calculateRange]() {
          const ranges = [];
          this.versions = semver.sort(this.versions, semverOpt), this.vulnerableVersions = semver.sort(this.vulnerableVersions, semverOpt);
          for (let v = 0, vulnVer = 0; v < this.versions.length; v++) {
            const vr = [ this.versions[v] ];
            for (;v < this.versions.length; ) {
              if (this.versions[v] !== this.vulnerableVersions[vulnVer]) {
                if (/-/.test(this.versions[v])) {
                  v++;
                  continue;
                }
                break;
              }
              vr.length > 1 ? vr[1] = this.versions[v] : vr.push(this.versions[v]), v++, vulnVer++;
            }
            if (vr.length > 1) {
              const tail = this.versions[this.versions.length - 1];
              ranges.push(vr[1] === tail ? `>=${vr[0]}` : vr[0] === vr[1] ? vr[0] : vr.join(" - "));
            }
          }
          const metavuln = ranges.join(" || ").trim();
          this.range = metavuln ? semver.simplifyRange(this.versions, metavuln, semverOpt) : "<0.0.0-0";
        }
        testVersion(version, spec = null) {
          const sv = String(version);
          if (this[_versionVulnMemo].has(sv)) return this[_versionVulnMemo].get(sv);
          const result = this[_testVersion](version, spec);
          return result && this[_markVulnerable](version), this[_versionVulnMemo].set(sv, !!result), 
          result;
        }
        [_markVulnerable](version) {
          const sv = String(version);
          this.vulnerableVersions.includes(sv) || this.vulnerableVersions.push(sv);
        }
        [_testVersion](version, spec) {
          const sv = String(version);
          if (this.vulnerableVersions.includes(sv)) return !0;
          if ("advisory" === this.type) return semver.satisfies(version, this.range, semverOpt);
          const mani = this[_packument].versions[version] || {
            dependencies: {
              [this.dependency]: spec
            }
          };
          if (spec || (spec = getDepSpec(mani, this.dependency)), null === spec) return !1;
          if (!semver.validRange(spec, semverOpt)) return !0;
          const bd = mani.bundleDependencies, bundled = bd && bd.includes(this[_source].name), avoid = this[_source].range;
          return bundled ? semver.intersects(spec, avoid, semverOpt) : this[_source].testSpec(spec);
        }
        testSpec(spec) {
          const memo = this[_specVulnMemo];
          if (memo.has(spec)) return memo.get(spec);
          const res = this[_testSpec](spec);
          return memo.set(spec, res), res;
        }
        [_testSpec](spec) {
          for (const v of this.versions) {
            if (semver.satisfies(v, spec) && !this.testVersion(v)) return !1;
          }
          return !0;
        }
        [_testVersions](versions) {
          if (!versions.length) return;
          const versionSets = new Set;
          let last = (versions = semver.sort(versions.map((v => semver.parse(v, semverOpt)))))[0].major + "." + versions[0].minor, list = [];
          versionSets.add(list);
          for (const v of versions) {
            const k = v.major + "." + v.minor;
            k !== last && (last = k, list = [], versionSets.add(list)), list.push(v);
          }
          for (const set of versionSets) {
            let h = 0;
            const origHeadVuln = this.testVersion(set[h]);
            for (;h < set.length && /-/.test(String(set[h])); ) h++;
            if (h === set.length) h = 0; else if (origHeadVuln) for (let hh = 0; hh < h; hh++) this[_markVulnerable](set[hh]);
            let t = set.length - 1;
            const origTailVuln = this.testVersion(set[t]);
            for (;t > h && /-/.test(String(set[t])); ) t--;
            if (t === h) t = set.length - 1; else if (origTailVuln) for (let tt = set.length - 1; tt > t; tt--) this[_markVulnerable](set[tt]);
            const headVuln = 0 === h ? origHeadVuln : this.testVersion(set[h]), tailVuln = t === set.length - 1 ? origTailVuln : this.testVersion(set[t]);
            if (headVuln && tailVuln) {
              for (let v = h; v < t; v++) this[_markVulnerable](set[v]);
              continue;
            }
            if (t < h + 2) continue;
            const mid = Math.floor(set.length / 2), pre = set.slice(0, mid), post = set.slice(mid);
            if (!/-/.test(String(pre[0]))) {
              const midVuln = this.testVersion(pre[pre.length - 1]);
              for (;/-/.test(String(pre[pre.length - 1])); ) {
                const v = pre.pop();
                midVuln && this[_markVulnerable](v);
              }
            }
            if (!/-/.test(String(post[post.length - 1]))) {
              const midVuln = this.testVersion(post[0]);
              for (;/-/.test(String(post[0])); ) {
                const v = post.shift();
                midVuln && this[_markVulnerable](v);
              }
            }
            versionSets.add(pre), versionSets.add(post);
          }
        }
      };
    },
    40594: module => {
      module.exports = (mani, name) => {
        const {dependencies: deps = {}, optionalDependencies: optDeps = {}, peerDependencies: peerDeps = {}} = mani;
        return deps && "string" == typeof deps[name] ? deps[name] : optDeps && "string" == typeof optDeps[name] ? optDeps[name] : peerDeps && "string" == typeof peerDeps[name] ? peerDeps[name] : null;
      };
    },
    11978: (module, __unused_webpack_exports, __webpack_require__) => {
      const {createHash} = __webpack_require__(6113);
      module.exports = ({name, source}) => createHash("sha512").update(JSON.stringify([ name, source ])).digest("base64");
    },
    8327: (module, __unused_webpack_exports, __webpack_require__) => {
      const pacote = __webpack_require__(86585), cacache = __webpack_require__(99269), Advisory = __webpack_require__(76755), {homedir} = __webpack_require__(22037), jsonParse = __webpack_require__(40295), _packument = Symbol("packument"), _cachePut = Symbol("cachePut"), _cacheGet = Symbol("cacheGet"), _cacheData = Symbol("cacheData"), _packuments = Symbol("packuments"), _cache = Symbol("cache"), _options = Symbol("options"), _advisories = Symbol("advisories"), _calculate = Symbol("calculate");
      module.exports = class {
        constructor(options = {}) {
          this[_options] = {
            ...options
          }, this[_cache] = this[_options].cache || homedir() + "/.npm/_cacache", this[_options].cache = this[_cache], 
          this[_packuments] = new Map, this[_cacheData] = new Map, this[_advisories] = new Map;
        }
        get cache() {
          return this[_cache];
        }
        get options() {
          return {
            ...this[_options]
          };
        }
        async calculate(name, source) {
          const k = `security-advisory:${name}:${source.id}`;
          if (this[_advisories].has(k)) return this[_advisories].get(k);
          const p = this[_calculate](name, source);
          return this[_advisories].set(k, p), p;
        }
        async [_calculate](name, source) {
          const k = `security-advisory:${name}:${source.id}`, t = `metavuln:calculate:${k}`;
          process.emit("time", t);
          const advisory = new Advisory(name, source, this[_options]), [cached, packument] = await Promise.all([ this[_cacheGet](advisory), this[_packument](name) ]);
          return process.emit("time", `metavuln:load:${k}`), advisory.load(cached, packument), 
          process.emit("timeEnd", `metavuln:load:${k}`), advisory.updated && await this[_cachePut](advisory), 
          this[_advisories].set(k, advisory), process.emit("timeEnd", t), advisory;
        }
        async [_cachePut](advisory) {
          const {name, id} = advisory, key = `security-advisory:${name}:${id}`;
          process.emit("time", `metavuln:cache:put:${key}`);
          const data = JSON.stringify(advisory), options = {
            ...this[_options]
          };
          this[_cacheData].set(key, jsonParse(data)), await cacache.put(this[_cache], key, data, options).catch((() => {})), 
          process.emit("timeEnd", `metavuln:cache:put:${key}`);
        }
        async [_cacheGet](advisory) {
          const {name, id} = advisory, key = `security-advisory:${name}:${id}`;
          if (this[_cacheData].has(key)) return this[_cacheData].get(key);
          process.emit("time", `metavuln:cache:get:${key}`);
          const p = cacache.get(this[_cache], key, {
            ...this[_options]
          }).catch((() => ({
            data: "{}"
          }))).then((({data}) => (data = jsonParse(data), process.emit("timeEnd", `metavuln:cache:get:${key}`), 
          this[_cacheData].set(key, data), data)));
          return this[_cacheData].set(key, p), p;
        }
        async [_packument](name) {
          if (this[_packuments].has(name)) return this[_packuments].get(name);
          process.emit("time", `metavuln:packument:${name}`);
          const p = pacote.packument(name, {
            ...this[_options]
          }).catch((er => ({
            name,
            versions: {}
          }))).then((paku => (process.emit("timeEnd", `metavuln:packument:${name}`), this[_packuments].set(name, paku), 
          paku)));
          return this[_packuments].set(name, p), p;
        }
      };
    },
    24052: (module, __unused_webpack_exports, __webpack_require__) => {
      const {dirname, join, resolve, relative, isAbsolute} = __webpack_require__(71017), rimraf_ = __webpack_require__(11567), {promisify} = __webpack_require__(73837), {access: access_, accessSync, copyFile: copyFile_, copyFileSync, readdir: readdir_, readdirSync, rename: rename_, renameSync, stat: stat_, statSync, lstat: lstat_, lstatSync, symlink: symlink_, symlinkSync, readlink: readlink_, readlinkSync} = __webpack_require__(57147), access = promisify(access_), copyFile = promisify(copyFile_), readdir = promisify(readdir_), rename = promisify(rename_), stat = promisify(stat_), lstat = promisify(lstat_), symlink = promisify(symlink_), readlink = promisify(readlink_), rimraf = promisify(rimraf_), rimrafSync = rimraf_.sync, mkdirp = __webpack_require__(41718), moveFile = async (source, destination, options = {}, root = !0, symlinks = []) => {
        if (!source || !destination) throw new TypeError("`source` and `destination` file required");
        if (!(options = {
          overwrite: !0,
          ...options
        }).overwrite && await (async path => {
          try {
            return await access(path), !0;
          } catch (er) {
            return "ENOENT" !== er.code;
          }
        })(destination)) throw new Error(`The destination file exists: ${destination}`);
        await mkdirp(dirname(destination));
        try {
          await rename(source, destination);
        } catch (error) {
          if ("EXDEV" !== error.code && "EPERM" !== error.code) throw error;
          {
            const sourceStat = await lstat(source);
            if (sourceStat.isDirectory()) {
              const files = await readdir(source);
              await Promise.all(files.map((file => moveFile(join(source, file), join(destination, file), options, !1, symlinks))));
            } else sourceStat.isSymbolicLink() ? symlinks.push({
              source,
              destination
            }) : await copyFile(source, destination);
          }
        }
        root && (await Promise.all(symlinks.map((async ({source: symSource, destination: symDestination}) => {
          let target = await readlink(symSource);
          isAbsolute(target) && (target = resolve(symDestination, relative(symSource, target)));
          let targetStat = "file";
          try {
            targetStat = await stat(resolve(dirname(symSource), target)), targetStat.isDirectory() && (targetStat = "junction");
          } catch {}
          await symlink(target, symDestination, targetStat);
        }))), await rimraf(source));
      }, moveFileSync = (source, destination, options = {}, root = !0, symlinks = []) => {
        if (!source || !destination) throw new TypeError("`source` and `destination` file required");
        if (!(options = {
          overwrite: !0,
          ...options
        }).overwrite && (path => {
          try {
            return accessSync(path), !0;
          } catch (er) {
            return "ENOENT" !== er.code;
          }
        })(destination)) throw new Error(`The destination file exists: ${destination}`);
        mkdirp.sync(dirname(destination));
        try {
          renameSync(source, destination);
        } catch (error) {
          if ("EXDEV" !== error.code && "EPERM" !== error.code) throw error;
          {
            const sourceStat = lstatSync(source);
            if (sourceStat.isDirectory()) {
              const files = readdirSync(source);
              for (const file of files) moveFileSync(join(source, file), join(destination, file), options, !1, symlinks);
            } else sourceStat.isSymbolicLink() ? symlinks.push({
              source,
              destination
            }) : copyFileSync(source, destination);
          }
        }
        if (root) {
          for (const {source: symSource, destination: symDestination} of symlinks) {
            let target = readlinkSync(symSource);
            isAbsolute(target) && (target = resolve(symDestination, relative(symSource, target)));
            let targetStat = "file";
            try {
              targetStat = statSync(resolve(dirname(symSource), target)), targetStat.isDirectory() && (targetStat = "junction");
            } catch {}
            symlinkSync(target, symDestination, targetStat);
          }
          rimrafSync(source);
        }
      };
      module.exports = moveFile, module.exports.sync = moveFileSync;
    },
    3046: (module, __unused_webpack_exports, __webpack_require__) => {
      const {basename, dirname} = __webpack_require__(71017);
      module.exports = dir => {
        return !!dir && (parent = basename(dirname(dir)), base = basename(dir), "@" === parent.charAt(0) ? `${parent}/${base}` : base);
        var parent, base;
      };
    },
    66954: (module, __unused_webpack_exports, __webpack_require__) => {
      const util = __webpack_require__(73837), fs = __webpack_require__(57147), {stat} = fs.promises || {
        stat: util.promisify(fs.stat)
      };
      module.exports = {
        isNodeGypPackage: async function(path) {
          return await stat(`${path}/binding.gyp`).then((st => st.isFile())).catch((() => !1));
        },
        defaultGypInstallScript: "node-gyp rebuild"
      };
    },
    66096: (module, __unused_webpack_exports, __webpack_require__) => {
      const fs = __webpack_require__(57147), promisify = __webpack_require__(73837).promisify, readFile = promisify(fs.readFile), writeFile = promisify(fs.writeFile), {resolve} = __webpack_require__(71017), updateDeps = __webpack_require__(22538), updateScripts = __webpack_require__(6197), updateWorkspaces = __webpack_require__(27311), parseJSON = __webpack_require__(40295), _filename = Symbol("filename"), _manifest = Symbol("manifest"), _readFileContent = Symbol("readFileContent"), knownSteps = new Set([ updateDeps, updateScripts, updateWorkspaces ]), knownKeys = new Set([ ...updateDeps.knownKeys, "scripts", "workspaces" ]);
      class PackageJson {
        static async load(path) {
          return await new PackageJson(path).load();
        }
        constructor(path) {
          this[_filename] = resolve(path, "package.json"), this[_manifest] = {}, this[_readFileContent] = "";
        }
        async load() {
          try {
            this[_readFileContent] = await readFile(this[_filename], "utf8");
          } catch (err) {
            throw new Error("package.json not found");
          }
          try {
            this[_manifest] = parseJSON(this[_readFileContent]);
          } catch (err) {
            throw new Error(`Invalid package.json: ${err}`);
          }
          return this;
        }
        get content() {
          return this[_manifest];
        }
        update(content) {
          if ("object" != typeof this[_manifest] || "object" != typeof content) throw Object.assign(new Error("Can't update invalid package.json data"), {
            code: "EPACKAGEJSONUPDATE"
          });
          for (const step of knownSteps) this[_manifest] = step({
            content,
            originalContent: this[_manifest]
          });
          for (const [key, value] of Object.entries(content)) knownKeys.has(key) || (this[_manifest][key] = value);
          return this;
        }
        async save() {
          const {[Symbol.for("indent")]: indent, [Symbol.for("newline")]: newline} = this[_manifest], format = void 0 === indent ? "  " : indent, eol = void 0 === newline ? "\n" : newline, fileContent = `${JSON.stringify(this[_manifest], null, format)}\n`.replace(/\n/g, eol);
          if (fileContent.trim() !== this[_readFileContent].trim()) return await writeFile(this[_filename], fileContent);
        }
      }
      module.exports = PackageJson;
    },
    22538: module => {
      const depTypes = new Set([ "dependencies", "optionalDependencies", "devDependencies", "peerDependencies" ]), updateDependencies = ({content, originalContent}) => {
        const pkg = (content => {
          for (const type of depTypes) content && content[type] && (content[type] = Object.keys(content[type]).sort(((a, b) => a.localeCompare(b, "en"))).reduce(((res, key) => (res[key] = content[type][key], 
          res)), {}));
          return content;
        })({
          ...content
        });
        if (pkg.dependencies && pkg.optionalDependencies) for (const name of Object.keys(pkg.optionalDependencies)) delete pkg.dependencies[name];
        const result = {
          ...originalContent
        };
        for (const type of depTypes) {
          pkg[type] && (result[type] = pkg[type]);
          pkg[type] && "object" == typeof pkg && 0 === Object.keys(pkg[type]).length && delete result[type];
        }
        const {dependencies: origProd, peerDependencies: origPeer} = originalContent || {}, {peerDependencies: newPeer} = result;
        if (origProd && origPeer && newPeer) for (const name of Object.keys(origPeer)) void 0 !== origProd[name] && void 0 !== newPeer[name] && (result.dependencies = result.dependencies || {}, 
        result.dependencies[name] = newPeer[name]);
        return result;
      };
      updateDependencies.knownKeys = depTypes, module.exports = updateDependencies;
    },
    6197: module => {
      module.exports = ({content, originalContent = {}}) => {
        const newScripts = content.scripts;
        if (!newScripts) return originalContent;
        if (Object.entries(newScripts).some((([key, value]) => "string" != typeof key || "string" != typeof value))) throw Object.assign(new TypeError("package.json scripts should be a key-value pair of strings."), {
          code: "ESCRIPTSINVALID"
        });
        return {
          ...originalContent,
          scripts: {
            ...newScripts
          }
        };
      };
    },
    27311: module => {
      module.exports = ({content, originalContent = {}}) => {
        const newWorkspaces = content.workspaces;
        if (!newWorkspaces) return originalContent;
        if (!newWorkspaces.length || newWorkspaces.some((w => !("string" == typeof w)))) throw Object.assign(new TypeError("workspaces should be an array of strings."), {
          code: "EWORKSPACESINVALID"
        });
        return {
          ...originalContent,
          workspaces: [ ...newWorkspaces ]
        };
      };
    },
    26035: (module, __unused_webpack_exports, __webpack_require__) => {
      const {spawn} = __webpack_require__(32081), inferOwner = __webpack_require__(84876), isPipe = (stdio = "pipe", fd) => "pipe" === stdio || null === stdio || !!Array.isArray(stdio) && isPipe(stdio[fd], fd), stdioResult = (stdout, stderr, {stdioString, stdio}) => stdioString ? {
        stdout: isPipe(stdio, 1) ? Buffer.concat(stdout).toString() : null,
        stderr: isPipe(stdio, 2) ? Buffer.concat(stderr).toString() : null
      } : {
        stdout: isPipe(stdio, 1) ? Buffer.concat(stdout) : null,
        stderr: isPipe(stdio, 2) ? Buffer.concat(stderr) : null
      }, promiseSpawnUid = (cmd, args, opts, extra) => {
        let proc;
        const p = new Promise(((res, rej) => {
          proc = spawn(cmd, args, opts);
          const stdout = [], stderr = [], reject = er => rej(Object.assign(er, {
            cmd,
            args,
            ...stdioResult(stdout, stderr, opts),
            ...extra
          }));
          proc.on("error", reject), proc.stdout && (proc.stdout.on("data", (c => stdout.push(c))).on("error", reject), 
          proc.stdout.on("error", (er => reject(er)))), proc.stderr && (proc.stderr.on("data", (c => stderr.push(c))).on("error", reject), 
          proc.stderr.on("error", (er => reject(er)))), proc.on("close", ((code, signal) => {
            const result = {
              cmd,
              args,
              code,
              signal,
              ...stdioResult(stdout, stderr, opts),
              ...extra
            };
            code || signal ? rej(Object.assign(new Error("command failed"), result)) : res(result);
          }));
        }));
        return p.stdin = proc.stdin, p.process = proc, p;
      };
      module.exports = (cmd, args, opts = {}, extra = {}) => {
        const cwd = opts.cwd || process.cwd(), isRoot = process.getuid && 0 === process.getuid(), {uid, gid} = isRoot ? inferOwner.sync(cwd) : {};
        return promiseSpawnUid(cmd, args, {
          ...opts,
          cwd,
          uid,
          gid
        }, extra);
      };
    },
    18006: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const npa = __webpack_require__(19932), parser = __webpack_require__(2513), semver = __webpack_require__(5870), arrayDelimiter = Symbol("arrayDelimiter"), unescapeSlashes = str => str.replace(/\\\//g, "/"), fixupAttr = astNode => {
        const properties = [], matcher = {};
        for (const selectorAstNode of astNode.nodes) {
          const [firstAstNode] = selectorAstNode.nodes;
          "tag" === firstAstNode.type && properties.push(firstAstNode.value);
        }
        const lastSelectorAstNode = astNode.nodes.pop(), [attributeAstNode] = lastSelectorAstNode.nodes;
        if (":attr" === attributeAstNode.value) {
          const appendParts = fixupAttr(attributeAstNode);
          properties.push(arrayDelimiter, ...appendParts.lookupProperties), matcher.qualifiedAttribute = appendParts.attributeMatcher.qualifiedAttribute, 
          matcher.operator = appendParts.attributeMatcher.operator, matcher.value = appendParts.attributeMatcher.value, 
          matcher.attribute = appendParts.attributeMatcher.attribute, appendParts.attributeMatcher.insensitive && (matcher.insensitive = !0);
        } else {
          if ("attribute" !== attributeAstNode.type) throw Object.assign(new Error("`:attr` pseudo-class expects an attribute matcher as the last value"), {
            code: "EQUERYATTR"
          });
          matcher.qualifiedAttribute = unescapeSlashes(attributeAstNode.qualifiedAttribute), 
          matcher.operator = attributeAstNode.operator, matcher.value = attributeAstNode.value, 
          matcher.attribute = matcher.qualifiedAttribute, attributeAstNode.insensitive && (matcher.insensitive = !0);
        }
        return astNode.lookupProperties = properties, astNode.attributeMatcher = matcher, 
        astNode.nodes.length = 0, astNode;
      }, transformAst = selector => {
        selector.walk((nextAstNode => {
          switch ("id" === nextAstNode.type && (astNode => {
            const {name, rawSpec: part} = npa(astNode.value), versionParts = [ {
              astNode,
              part
            } ];
            let version, currentAstNode = astNode.next();
            if (!part) return;
            for (;currentAstNode; ) versionParts.push({
              astNode: currentAstNode,
              part: String(currentAstNode)
            }), currentAstNode = currentAstNode.next();
            let length = versionParts.length;
            for (;!version && length; ) version = semver.valid(versionParts.slice(0, length).reduce(((res, i) => `${res}${i.part}`), "")), 
            length--;
            astNode.value = `${name}@${version}`;
            for (let i = 1; i <= length; i++) versionParts[i].astNode.remove();
          })(nextAstNode), nextAstNode.value) {
           case ":attr":
            return fixupAttr(nextAstNode);

           case ":is":
           case ":has":
           case ":not":
            return (astNode => {
              const newRootNode = parser.root();
              astNode.nestedNode = newRootNode, newRootNode.nodes = [ ...astNode.nodes ], astNode.nodes.length = 0;
              for (const currAstNode of newRootNode.nodes) currAstNode.parent = newRootNode;
              transformAst(newRootNode);
            })(nextAstNode);

           case ":path":
            return (astNode = nextAstNode).pathValue = unescapeSlashes(String(astNode.nodes[0])), 
            void (astNode.nodes.length = 0);

           case ":semver":
            return (astNode => {
              const value = astNode.nodes.shift().nodes.reduce(((res, i) => `${res}${String(i)}`), "");
              let semverFunc;
              if (2 === astNode.nodes.length) {
                const funcNode = astNode.nodes.pop().nodes[0];
                "tag" === funcNode.type && (semverFunc = funcNode.value);
              }
              1 === astNode.nodes.length ? fixupAttr(astNode) : (astNode.attributeMatcher = {
                insensitive: !1,
                attribute: "version",
                qualifiedAttribute: "version"
              }, astNode.lookupProperties = []), astNode.semverFunc = semverFunc, astNode.semverValue = value, 
              astNode.nodes.length = 0;
            })(nextAstNode);

           case ":type":
            return (astNode => {
              const [valueAstNode] = astNode.nodes[0].nodes, {value} = valueAstNode || {};
              astNode.typeValue = value, astNode.nodes.length = 0;
            })(nextAstNode);
          }
          var astNode;
        }));
      };
      module.exports = {
        parser: query => query ? parser(transformAst).astSync(query.replace(/\//g, "\\/"), {
          lossless: !1
        }) : [],
        arrayDelimiter
      };
    },
    86527: module => {
      "use strict";
      module.exports = {
        cmd: (input, doubleEscape) => {
          if (!input.length) return '""';
          let result;
          if (/[ \t\n\v"]/.test(input)) {
            result = '"';
            for (let i = 0; i <= input.length; ++i) {
              let slashCount = 0;
              for (;"\\" === input[i]; ) ++i, ++slashCount;
              if (i === input.length) {
                result += "\\".repeat(2 * slashCount);
                break;
              }
              '"' === input[i] ? (result += "\\".repeat(2 * slashCount + 1), result += input[i]) : (result += "\\".repeat(slashCount), 
              result += input[i]);
            }
            result += '"';
          } else result = input;
          return result = result.replace(/[ !%^&()<>|"]/g, "^$&"), doubleEscape && (result = result.replace(/[ !%^&()<>|"]/g, "^$&")), 
          result;
        },
        sh: input => {
          if (!input.length) return "''";
          if (!/[\t\n\r "#$&'()*;<>?\\`|~]/.test(input)) return input;
          return `'${input.replace(/'/g, "'\\''")}'`.replace(/^(?:'')+(?!$)/, "").replace(/\\'''/g, "\\'");
        }
      };
    },
    2929: (module, __unused_webpack_exports, __webpack_require__) => {
      const util = __webpack_require__(73837), fs = __webpack_require__(57147), {stat} = fs.promises || {
        stat: util.promisify(fs.stat)
      }, {resolve} = __webpack_require__(71017);
      module.exports = async path => {
        try {
          return (await stat(resolve(path, "server.js"))).isFile();
        } catch (er) {
          return !1;
        }
      };
    },
    6669: module => {
      const platform = process.env.__FAKE_TESTING_PLATFORM__ || process.platform;
      module.exports = "win32" === platform;
    },
    84552: module => {
      const envVal = val => Array.isArray(val) ? val.map((v => envVal(v))).join("\n\n") : null === val || !1 === val ? "" : String(val), packageEnvs = (env, vals, prefix) => {
        for (const [key, val] of Object.entries(vals)) void 0 !== val && (val && !Array.isArray(val) && "object" == typeof val ? packageEnvs(env, val, `${prefix}${key}_`) : env[`${prefix}${key}`] = envVal(val));
        return env;
      };
      module.exports = (env, pkg) => packageEnvs({
        ...env
      }, {
        name: pkg.name,
        version: pkg.version,
        config: pkg.config,
        engines: pkg.engines,
        bin: pkg.bin
      }, "npm_package_");
    },
    53367: (module, __unused_webpack_exports, __webpack_require__) => {
      const makeSpawnArgs = __webpack_require__(84173), promiseSpawn = __webpack_require__(26035), packageEnvs = __webpack_require__(84552), {isNodeGypPackage, defaultGypInstallScript} = __webpack_require__(66954), signalManager = __webpack_require__(8446), isServerPackage = __webpack_require__(2929);
      module.exports = async options => {
        const {event, path, scriptShell, binPaths = !1, env = {}, stdio = "pipe", pkg, args = [], stdioString = !1, banner = !0, signalTimeout = 500} = options, {scripts = {}, gypfile} = pkg;
        let cmd = null;
        if (options.cmd ? cmd = options.cmd : pkg.scripts && pkg.scripts[event] ? cmd = pkg.scripts[event] : "install" !== event || scripts.install || scripts.preinstall || !1 === gypfile || !await isNodeGypPackage(path) ? "start" === event && await isServerPackage(path) && (cmd = "node server.js") : cmd = defaultGypInstallScript, 
        !cmd) return {
          code: 0,
          signal: null
        };
        "inherit" === stdio && !1 !== banner && console.log(((id, event, cmd, args) => {
          let banner = id ? `\n> ${id} ${event}\n` : `\n> ${event}\n`;
          return banner += `> ${cmd.trim().replace(/\n/g, "\n> ")}`, args.length && (banner += ` ${args.join(" ")}`), 
          banner += "\n", banner;
        })(pkg._id, event, cmd, args));
        const [spawnShell, spawnArgs, spawnOpts] = makeSpawnArgs({
          event,
          path,
          scriptShell,
          binPaths,
          env: packageEnvs(env, pkg),
          stdio,
          cmd,
          args,
          stdioString
        }), p = promiseSpawn(spawnShell, spawnArgs, spawnOpts, {
          event,
          script: cmd,
          pkgid: pkg._id,
          path
        });
        return "inherit" === stdio && signalManager.add(p.process), p.stdin && p.stdin.end(), 
        p.catch((er => {
          const {signal} = er;
          if ("inherit" === stdio && signal) return process.kill(process.pid, signal), new Promise(((res, rej) => setTimeout((() => rej(er)), signalTimeout)));
          throw er;
        }));
      };
    },
    63036: (module, __unused_webpack_exports, __webpack_require__) => {
      const rpj = __webpack_require__(1759), runScriptPkg = __webpack_require__(53367), validateOptions = __webpack_require__(33359), isServerPackage = __webpack_require__(2929);
      module.exports = Object.assign((options => {
        validateOptions(options);
        const {pkg, path} = options;
        return pkg ? runScriptPkg(options) : rpj(path + "/package.json").then((readPackage => runScriptPkg({
          ...options,
          pkg: readPackage
        })));
      }), {
        isServerPackage
      });
    },
    8446: module => {
      const runningProcs = new Set;
      let handlersInstalled = !1;
      const forwardedSignals = [ "SIGINT", "SIGTERM" ], handleSignal = signal => {
        for (const proc of runningProcs) proc.kill(signal);
      };
      module.exports = {
        add: proc => {
          runningProcs.add(proc), handlersInstalled || (() => {
            for (const signal of forwardedSignals) process.on(signal, handleSignal);
            handlersInstalled = !0;
          })(), proc.once("exit", (() => {
            runningProcs.delete(proc), (() => {
              if (0 === runningProcs.size) {
                for (const signal of forwardedSignals) process.removeListener(signal, handleSignal);
                handlersInstalled = !1;
              }
            })();
          }));
        },
        handleSignal,
        forwardedSignals
      };
    },
    33359: module => {
      module.exports = options => {
        if ("object" != typeof options || !options) throw new TypeError("invalid options object provided to runScript");
        const {event, path, scriptShell, env = {}, stdio = "pipe", args = [], cmd} = options;
        if (!event || "string" != typeof event) throw new TypeError("valid event not provided to runScript");
        if (!path || "string" != typeof path) throw new TypeError("valid path not provided to runScript");
        if (void 0 !== scriptShell && "string" != typeof scriptShell) throw new TypeError("invalid scriptShell option provided to runScript");
        if ("object" != typeof env || !env) throw new TypeError("invalid env option provided to runScript");
        if ("string" != typeof stdio && !Array.isArray(stdio)) throw new TypeError("invalid stdio option provided to runScript");
        if (!Array.isArray(args) || args.some((a => "string" != typeof a))) throw new TypeError("invalid args option provided to runScript");
        if (void 0 !== cmd && "string" != typeof cmd) throw new TypeError("invalid cmd option provided to runScript");
      };
    },
    70143: (module, exports) => {
      function abbrev(list) {
        1 === arguments.length && Array.isArray(list) || (list = Array.prototype.slice.call(arguments, 0));
        for (var i = 0, l = list.length, args = []; i < l; i++) args[i] = "string" == typeof list[i] ? list[i] : String(list[i]);
        var abbrevs = {}, prev = "";
        for (i = 0, l = (args = args.sort(lexSort)).length; i < l; i++) {
          var current = args[i], next = args[i + 1] || "", nextMatches = !0, prevMatches = !0;
          if (current !== next) {
            for (var j = 0, cl = current.length; j < cl; j++) {
              var curChar = current.charAt(j);
              if (nextMatches = nextMatches && curChar === next.charAt(j), prevMatches = prevMatches && curChar === prev.charAt(j), 
              !nextMatches && !prevMatches) {
                j++;
                break;
              }
            }
            if (prev = current, j !== cl) for (var a = current.substr(0, j); j <= cl; j++) abbrevs[a] = current, 
            a += current.charAt(j); else abbrevs[current] = current;
          }
        }
        return abbrevs;
      }
      function lexSort(a, b) {
        return a === b ? 0 : a > b ? 1 : -1;
      }
      module.exports = abbrev.abbrev = abbrev, abbrev.monkeyPatch = function() {
        Object.defineProperty(Array.prototype, "abbrev", {
          value: function() {
            return abbrev(this);
          },
          enumerable: !1,
          configurable: !0,
          writable: !0
        }), Object.defineProperty(Object.prototype, "abbrev", {
          value: function() {
            return abbrev(Object.keys(this));
          },
          enumerable: !1,
          configurable: !0,
          writable: !0
        });
      };
    },
    64708: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const indentString = __webpack_require__(9057), cleanStack = __webpack_require__(17569);
      class AggregateError extends Error {
        constructor(errors) {
          if (!Array.isArray(errors)) throw new TypeError("Expected input to be an Array, got " + typeof errors);
          let message = (errors = [ ...errors ].map((error => error instanceof Error ? error : null !== error && "object" == typeof error ? Object.assign(new Error(error.message), error) : new Error(error)))).map((error => "string" == typeof error.stack ? cleanStack(error.stack).replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, "") : String(error))).join("\n");
          message = "\n" + indentString(message, 4), super(message), this.name = "AggregateError", 
          Object.defineProperty(this, "_errors", {
            value: errors
          });
        }
        * [Symbol.iterator]() {
          for (const error of this._errors) yield error;
        }
      }
      module.exports = AggregateError;
    },
    71882: module => {
      "use strict";
      module.exports = ({onlyFirst = !1} = {}) => {
        const pattern = [ "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))" ].join("|");
        return new RegExp(pattern, onlyFirst ? void 0 : "g");
      };
    },
    53694: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module = __webpack_require__.nmd(module);
      const wrapAnsi16 = (fn, offset) => (...args) => `[${fn(...args) + offset}m`, wrapAnsi256 = (fn, offset) => (...args) => {
        const code = fn(...args);
        return `[${38 + offset};5;${code}m`;
      }, wrapAnsi16m = (fn, offset) => (...args) => {
        const rgb = fn(...args);
        return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
      }, ansi2ansi = n => n, rgb2rgb = (r, g, b) => [ r, g, b ], setLazyProperty = (object, property, get) => {
        Object.defineProperty(object, property, {
          get: () => {
            const value = get();
            return Object.defineProperty(object, property, {
              value,
              enumerable: !0,
              configurable: !0
            }), value;
          },
          enumerable: !0,
          configurable: !0
        });
      };
      let colorConvert;
      const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
        void 0 === colorConvert && (colorConvert = __webpack_require__(70319));
        const offset = isBackground ? 10 : 0, styles = {};
        for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
          const name = "ansi16" === sourceSpace ? "ansi" : sourceSpace;
          sourceSpace === targetSpace ? styles[name] = wrap(identity, offset) : "object" == typeof suite && (styles[name] = wrap(suite[targetSpace], offset));
        }
        return styles;
      };
      Object.defineProperty(module, "exports", {
        enumerable: !0,
        get: function() {
          const codes = new Map, styles = {
            modifier: {
              reset: [ 0, 0 ],
              bold: [ 1, 22 ],
              dim: [ 2, 22 ],
              italic: [ 3, 23 ],
              underline: [ 4, 24 ],
              inverse: [ 7, 27 ],
              hidden: [ 8, 28 ],
              strikethrough: [ 9, 29 ]
            },
            color: {
              black: [ 30, 39 ],
              red: [ 31, 39 ],
              green: [ 32, 39 ],
              yellow: [ 33, 39 ],
              blue: [ 34, 39 ],
              magenta: [ 35, 39 ],
              cyan: [ 36, 39 ],
              white: [ 37, 39 ],
              blackBright: [ 90, 39 ],
              redBright: [ 91, 39 ],
              greenBright: [ 92, 39 ],
              yellowBright: [ 93, 39 ],
              blueBright: [ 94, 39 ],
              magentaBright: [ 95, 39 ],
              cyanBright: [ 96, 39 ],
              whiteBright: [ 97, 39 ]
            },
            bgColor: {
              bgBlack: [ 40, 49 ],
              bgRed: [ 41, 49 ],
              bgGreen: [ 42, 49 ],
              bgYellow: [ 43, 49 ],
              bgBlue: [ 44, 49 ],
              bgMagenta: [ 45, 49 ],
              bgCyan: [ 46, 49 ],
              bgWhite: [ 47, 49 ],
              bgBlackBright: [ 100, 49 ],
              bgRedBright: [ 101, 49 ],
              bgGreenBright: [ 102, 49 ],
              bgYellowBright: [ 103, 49 ],
              bgBlueBright: [ 104, 49 ],
              bgMagentaBright: [ 105, 49 ],
              bgCyanBright: [ 106, 49 ],
              bgWhiteBright: [ 107, 49 ]
            }
          };
          styles.color.gray = styles.color.blackBright, styles.bgColor.bgGray = styles.bgColor.bgBlackBright, 
          styles.color.grey = styles.color.blackBright, styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
          for (const [groupName, group] of Object.entries(styles)) {
            for (const [styleName, style] of Object.entries(group)) styles[styleName] = {
              open: `[${style[0]}m`,
              close: `[${style[1]}m`
            }, group[styleName] = styles[styleName], codes.set(style[0], style[1]);
            Object.defineProperty(styles, groupName, {
              value: group,
              enumerable: !1
            });
          }
          return Object.defineProperty(styles, "codes", {
            value: codes,
            enumerable: !1
          }), styles.color.close = "[39m", styles.bgColor.close = "[49m", setLazyProperty(styles.color, "ansi", (() => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, !1))), 
          setLazyProperty(styles.color, "ansi256", (() => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, !1))), 
          setLazyProperty(styles.color, "ansi16m", (() => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, !1))), 
          setLazyProperty(styles.bgColor, "ansi", (() => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, !0))), 
          setLazyProperty(styles.bgColor, "ansi256", (() => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, !0))), 
          setLazyProperty(styles.bgColor, "ansi16m", (() => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, !0))), 
          styles;
        }
      });
    },
    95073: module => {
      "use strict";
      module.exports = validate;
      const types = {
        "*": {
          label: "any",
          check: () => !0
        },
        A: {
          label: "array",
          check: _ => {
            return Array.isArray(_) || null != (thingy = _) && "object" == typeof thingy && thingy.hasOwnProperty("callee");
            var thingy;
          }
        },
        S: {
          label: "string",
          check: _ => "string" == typeof _
        },
        N: {
          label: "number",
          check: _ => "number" == typeof _
        },
        F: {
          label: "function",
          check: _ => "function" == typeof _
        },
        O: {
          label: "object",
          check: _ => "object" == typeof _ && null != _ && !types.A.check(_) && !types.E.check(_)
        },
        B: {
          label: "boolean",
          check: _ => "boolean" == typeof _
        },
        E: {
          label: "error",
          check: _ => _ instanceof Error
        },
        Z: {
          label: "null",
          check: _ => null == _
        }
      };
      function addSchema(schema, arity) {
        const group = arity[schema.length] = arity[schema.length] || [];
        -1 === group.indexOf(schema) && group.push(schema);
      }
      function validate(rawSchemas, args) {
        if (2 !== arguments.length) throw wrongNumberOfArgs([ "SA" ], arguments.length);
        if (!rawSchemas) throw missingRequiredArg(0);
        if (!args) throw missingRequiredArg(1);
        if (!types.S.check(rawSchemas)) throw invalidType(0, [ "string" ], rawSchemas);
        if (!types.A.check(args)) throw invalidType(1, [ "array" ], args);
        const schemas = rawSchemas.split("|"), arity = {};
        schemas.forEach((schema => {
          for (let ii = 0; ii < schema.length; ++ii) {
            const type = schema[ii];
            if (!types[type]) throw unknownType(ii, type);
          }
          if (/E.*E/.test(schema)) throw moreThanOneError(schema);
          addSchema(schema, arity), /E/.test(schema) && (addSchema(schema.replace(/E.*$/, "E"), arity), 
          addSchema(schema.replace(/E/, "Z"), arity), 1 === schema.length && addSchema("", arity));
        }));
        let matching = arity[args.length];
        if (!matching) throw wrongNumberOfArgs(Object.keys(arity), args.length);
        for (let ii = 0; ii < args.length; ++ii) {
          let newMatching = matching.filter((schema => {
            const type = schema[ii];
            return (0, types[type].check)(args[ii]);
          }));
          if (!newMatching.length) {
            const labels = matching.map((_ => types[_[ii]].label)).filter((_ => null != _));
            throw invalidType(ii, labels, args[ii]);
          }
          matching = newMatching;
        }
      }
      function missingRequiredArg(num) {
        return newException("EMISSINGARG", "Missing required argument #" + (num + 1));
      }
      function unknownType(num, type) {
        return newException("EUNKNOWNTYPE", "Unknown type " + type + " in argument #" + (num + 1));
      }
      function invalidType(num, expectedTypes, value) {
        let valueType;
        return Object.keys(types).forEach((typeCode => {
          types[typeCode].check(value) && (valueType = types[typeCode].label);
        })), newException("EINVALIDTYPE", "Argument #" + (num + 1) + ": Expected " + englishList(expectedTypes) + " but got " + valueType);
      }
      function englishList(list) {
        return list.join(", ").replace(/, ([^,]+)$/, " or $1");
      }
      function wrongNumberOfArgs(expected, got) {
        return newException("EWRONGARGCOUNT", "Expected " + englishList(expected) + " " + (expected.every((ex => 1 === ex.length)) ? "argument" : "arguments") + " but got " + got);
      }
      function moreThanOneError(schema) {
        return newException("ETOOMANYERRORTYPES", 'Only one error type per argument signature is allowed, more than one found in "' + schema + '"');
      }
      function newException(code, msg) {
        const err = new Error(msg);
        return err.code = code, Error.captureStackTrace && Error.captureStackTrace(err, validate), 
        err;
      }
    },
    84032: module => {
      module.exports = function archy(obj, prefix, opts) {
        void 0 === prefix && (prefix = ""), opts || (opts = {});
        var chr = function(s) {
          return !1 === opts.unicode ? {
            "": "|",
            "": "`",
            "": "+",
            "": "-",
            "": "-"
          }[s] : s;
        };
        "string" == typeof obj && (obj = {
          label: obj
        });
        var nodes = obj.nodes || [], lines = (obj.label || "").split("\n"), splitter = "\n" + prefix + (nodes.length ? chr("") : " ") + " ";
        return prefix + lines.join(splitter) + "\n" + nodes.map((function(node, ix) {
          var last = ix === nodes.length - 1, more = node.nodes && node.nodes.length, prefix_ = prefix + (last ? " " : chr("")) + " ";
          return prefix + chr(last ? "" : "") + chr("") + chr(more ? "" : "") + " " + archy(node, prefix_, opts).slice(prefix.length + 2);
        })).join("");
      };
    },
    40574: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var rawAsap = __webpack_require__(62327), freeTasks = [];
      function RawTask() {
        this.task = null, this.domain = null;
      }
      module.exports = function(task) {
        var rawTask;
        rawTask = freeTasks.length ? freeTasks.pop() : new RawTask;
        rawTask.task = task, rawTask.domain = process.domain, rawAsap(rawTask);
      }, RawTask.prototype.call = function() {
        this.domain && this.domain.enter();
        var threw = !0;
        try {
          this.task.call(), threw = !1, this.domain && this.domain.exit();
        } finally {
          threw && rawAsap.requestFlush(), this.task = null, this.domain = null, freeTasks.push(this);
        }
      };
    },
    62327: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var domain, hasSetImmediate = "function" == typeof setImmediate;
      function rawAsap(task) {
        queue.length || (requestFlush(), flushing = !0), queue[queue.length] = task;
      }
      module.exports = rawAsap;
      var queue = [], flushing = !1, index = 0;
      function flush() {
        for (;index < queue.length; ) {
          var currentIndex = index;
          if (index += 1, queue[currentIndex].call(), index > 1024) {
            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) queue[scan] = queue[scan + index];
            queue.length -= index, index = 0;
          }
        }
        queue.length = 0, index = 0, flushing = !1;
      }
      function requestFlush() {
        var parentDomain = process.domain;
        parentDomain && (domain || (domain = __webpack_require__(13639)), domain.active = process.domain = null), 
        flushing && hasSetImmediate ? setImmediate(flush) : process.nextTick(flush), parentDomain && (domain.active = process.domain = parentDomain);
      }
      rawAsap.requestFlush = requestFlush;
    },
    74263: (module, __unused_webpack_exports, __webpack_require__) => {
      const isWindows = __webpack_require__(94569), getPrefix = __webpack_require__(19867), getNodeModules = __webpack_require__(3968), {dirname} = __webpack_require__(71017);
      module.exports = ({top, path}) => top ? isWindows ? getPrefix(path) : dirname(getPrefix(path)) + "/bin" : getNodeModules(path) + "/.bin";
    },
    12595: (module, __unused_webpack_exports, __webpack_require__) => {
      const isWindows = __webpack_require__(94569), binTarget = __webpack_require__(74263), {resolve, dirname} = __webpack_require__(71017), readCmdShim = __webpack_require__(84554), fs = __webpack_require__(57147), {promisify} = __webpack_require__(73837), readlink = promisify(fs.readlink), checkLink = async ({target, path}) => {
        const current = await readlink(target).catch((er => (async ({er, target}) => "ENOENT" === er.code ? null : failEEXIST({
          target
        }))({
          er,
          target
        })));
        if (!current) return;
        return 0 !== resolve(dirname(target), current).toLowerCase().indexOf(path.toLowerCase()) ? failEEXIST({
          target
        }) : void 0;
      }, failEEXIST = ({target}) => Promise.reject(Object.assign(new Error("EEXIST: file already exists"), {
        path: target,
        code: "EEXIST"
      })), checkShim = async ({target, path}) => {
        const shims = [ target, target + ".cmd", target + ".ps1" ];
        await Promise.all(shims.map((async shim => {
          const current = await readCmdShim(shim).catch((er => (({er, target}) => "ENOENT" === er.code ? null : failEEXIST({
            target
          }))({
            er,
            target: shim
          })));
          if (!current) return;
          return 0 !== resolve(dirname(shim), current.replace(/\\/g, "/")).toLowerCase().indexOf(path.toLowerCase()) ? failEEXIST({
            target: shim
          }) : void 0;
        })));
      };
      module.exports = async ({bin, path, top, global, force}) => {
        if (force || !global || !top) return;
        const target = resolve(binTarget({
          path,
          top
        }), bin);
        return path = resolve(path), isWindows ? checkShim({
          target,
          path
        }) : checkLink({
          target,
          path
        });
      };
    },
    66555: (module, __unused_webpack_exports, __webpack_require__) => {
      const checkBin = __webpack_require__(12595), normalize = __webpack_require__(51234);
      module.exports = async ({pkg, path, top, global, force}) => {
        !force && global && top && (pkg = normalize(pkg)).bin && await Promise.all(Object.keys(pkg.bin).map((bin => checkBin({
          bin,
          path,
          top,
          global,
          force
        }))));
      };
    },
    37101: (module, __unused_webpack_exports, __webpack_require__) => {
      const fs = __webpack_require__(57147), {promisify} = __webpack_require__(73837), execMode = 511 & ~process.umask(), writeFileAtomic = __webpack_require__(27610), open = promisify(fs.open), close = promisify(fs.close), read = promisify(fs.read), chmod = promisify(fs.chmod), readFile = promisify(fs.readFile);
      module.exports = (file, mode = execMode) => chmod(file, mode).then((() => (file => {
        const FALSE = () => !1;
        return open(file, "r").then((fd => {
          const buf = Buffer.alloc(2048);
          return read(fd, buf, 0, 2048, 0).then((() => {
            const isWHB = (buf => buf[0] === "#".charCodeAt(0) && buf[1] === "!".charCodeAt(0) && /^#![^\n]+\r\n/.test(buf.toString()))(buf);
            return close(fd).then((() => isWHB), (() => isWHB));
          }), (() => close(fd).then(FALSE, FALSE)));
        }), FALSE);
      })(file))).then((isWHB => isWHB ? (file => readFile(file, "utf8").then((content => writeFileAtomic(file, content.replace(/^(#![^\n]+)\r\n/, "$1\n")))))(file) : null));
    },
    3968: (module, __unused_webpack_exports, __webpack_require__) => {
      const {dirname, basename} = __webpack_require__(71017), memo = new Map;
      module.exports = path => {
        if (memo.has(path)) return memo.get(path);
        const scopeOrNm = dirname(path), nm = "node_modules" === basename(scopeOrNm) ? scopeOrNm : dirname(scopeOrNm);
        return memo.set(path, nm), nm;
      };
    },
    96376: (module, __unused_webpack_exports, __webpack_require__) => {
      const binTarget = __webpack_require__(74263), manTarget = __webpack_require__(72084), {resolve, basename, extname} = __webpack_require__(71017), isWindows = __webpack_require__(94569);
      module.exports = ({path, pkg, global, top}) => {
        if (top && !global) return [];
        const binSet = [], binTarg = binTarget({
          path,
          top
        });
        if (pkg.bin) for (const bin of Object.keys(pkg.bin)) {
          const b = resolve(binTarg, bin);
          binSet.push(b), isWindows && (binSet.push(b + ".cmd"), binSet.push(b + ".ps1"));
        }
        const manTarg = manTarget({
          path,
          top
        }), manSet = [];
        if (manTarg && pkg.man && Array.isArray(pkg.man) && pkg.man.length) for (const man of pkg.man) {
          if (!/.\.[0-9]+(\.gz)?$/.test(man)) return binSet;
          const section = extname(basename(man, ".gz")).slice(1), base = basename(man);
          manSet.push(resolve(manTarg, "man" + section, base));
        }
        return manSet.length ? [ ...binSet, ...manSet ] : binSet;
      };
    },
    19867: (module, __unused_webpack_exports, __webpack_require__) => {
      const {dirname} = __webpack_require__(71017), getNodeModules = __webpack_require__(3968);
      module.exports = path => dirname(getNodeModules(path));
    },
    38059: (module, __unused_webpack_exports, __webpack_require__) => {
      const linkBins = __webpack_require__(81044), linkMans = __webpack_require__(20981), shimBin = __webpack_require__(98398), linkGently = __webpack_require__(18934), checkBins = __webpack_require__(66555), getPaths = __webpack_require__(96376);
      module.exports = Object.assign((opts => {
        const {path, pkg, force, global, top} = opts;
        return top && !global ? Promise.resolve() : Promise.all([ linkBins({
          path,
          pkg,
          top,
          force: force || !top
        }), linkMans({
          path,
          pkg,
          top,
          force
        }) ]);
      }), {
        checkBins,
        resetSeen: () => {
          shimBin.resetSeen(), linkGently.resetSeen();
        },
        getPaths
      });
    },
    94569: module => {
      const platform = process.env.__TESTING_BIN_LINKS_PLATFORM__ || process.platform;
      module.exports = "win32" === platform;
    },
    91892: (module, __unused_webpack_exports, __webpack_require__) => {
      const linkGently = __webpack_require__(18934), fixBin = __webpack_require__(37101);
      module.exports = ({path, to, from, absFrom, force}) => linkGently({
        path,
        to,
        from,
        absFrom,
        force
      }).then((linked => linked && fixBin(absFrom)));
    },
    81044: (module, __unused_webpack_exports, __webpack_require__) => {
      const isWindows = __webpack_require__(94569), binTarget = __webpack_require__(74263), {dirname, resolve, relative} = __webpack_require__(71017), linkBin = __webpack_require__(isWindows ? 98398 : 91892), normalize = __webpack_require__(51234);
      module.exports = ({path, pkg, top, force}) => {
        if (!(pkg = normalize(pkg)).bin) return Promise.resolve([]);
        const promises = [], target = binTarget({
          path,
          top
        });
        for (const [key, val] of Object.entries(pkg.bin)) {
          const to = resolve(target, key), absFrom = resolve(path, val), from = relative(dirname(to), absFrom);
          promises.push(linkBin({
            path,
            from,
            to,
            absFrom,
            force
          }));
        }
        return Promise.all(promises);
      };
    },
    18934: (module, __unused_webpack_exports, __webpack_require__) => {
      const {promisify} = __webpack_require__(73837), {resolve, dirname} = __webpack_require__(71017), mkdirp = __webpack_require__(87700), fs = __webpack_require__(57147), symlink = promisify(fs.symlink), readlink = promisify(fs.readlink), lstat = promisify(fs.lstat), throwNonEnoent = er => {
        if ("ENOENT" !== er.code) throw er;
      }, seen = new Set, rimraf = promisify(__webpack_require__(11567)), rm = path => rimraf(path, {
        glob: !1
      }), SKIP = Symbol("skip - missing or already installed"), CLOBBER = Symbol("clobber - ours or in forceful mode");
      module.exports = Object.assign((async ({path, to, from, absFrom, force}) => !!seen.has(to) || (seen.add(to), 
      Promise.all([ lstat(absFrom).catch(throwNonEnoent), lstat(to).catch(throwNonEnoent) ]).then((([stFrom, stTo]) => stFrom ? stTo ? stTo.isSymbolicLink() ? readlink(to).then((target => target === from ? SKIP : !(0 !== (target = resolve(dirname(to), target)).indexOf(path) && !force) && rm(to).then((() => CLOBBER)))) : force && rm(to).then((() => CLOBBER)) : mkdirp(dirname(to)) : SKIP)).then((skipOrClobber => skipOrClobber !== SKIP && symlink(from, to, "file").catch((er => {
        if (skipOrClobber === CLOBBER || force) return rm(to).then((() => symlink(from, to, "file")));
        throw er;
      })).then((() => !0)))))), {
        resetSeen: () => {
          for (const p of seen) seen.delete(p);
        }
      });
    },
    20981: (module, __unused_webpack_exports, __webpack_require__) => {
      const {dirname, relative, join, resolve, basename} = __webpack_require__(71017), linkGently = __webpack_require__(18934), manTarget = __webpack_require__(72084);
      module.exports = ({path, pkg, top, force}) => {
        const target = manTarget({
          path,
          top
        });
        if (!(target && pkg.man && Array.isArray(pkg.man) && pkg.man.length)) return Promise.resolve([]);
        const set = [ ...new Set(pkg.man.map((man => man ? join("/", man).replace(/\\|:/g, "/").slice(1) : null)).filter((man => "string" == typeof man))) ];
        return Promise.all(set.map((man => {
          const parseMan = man.match(/(.*\.([0-9]+)(\.gz)?)$/);
          if (!parseMan) return Promise.reject(Object.assign(new Error("invalid man entry name\nMan files must end with a number, and optionally a .gz suffix if they are compressed."), {
            code: "EBADMAN",
            path,
            pkgid: pkg._id,
            man
          }));
          const stem = parseMan[1], sxn = parseMan[2], base = basename(stem), absFrom = resolve(path, man);
          if (0 !== absFrom.indexOf(path)) return Promise.reject(Object.assign(new Error("invalid man entry"), {
            code: "EBADMAN",
            path,
            pkgid: pkg._id,
            man
          }));
          const to = resolve(target, "man" + sxn, base), from = relative(dirname(to), absFrom);
          return linkGently({
            from,
            to,
            path,
            absFrom,
            force
          });
        })));
      };
    },
    72084: (module, __unused_webpack_exports, __webpack_require__) => {
      const isWindows = __webpack_require__(94569), getPrefix = __webpack_require__(19867), {dirname} = __webpack_require__(71017);
      module.exports = ({top, path}) => !top || isWindows ? null : dirname(getPrefix(path)) + "/share/man";
    },
    98398: (module, __unused_webpack_exports, __webpack_require__) => {
      const {promisify} = __webpack_require__(73837), {resolve, dirname} = __webpack_require__(71017), lstat = promisify(__webpack_require__(57147).lstat), throwNonEnoent = er => {
        if ("ENOENT" !== er.code) throw er;
      }, cmdShim = __webpack_require__(93865), readCmdShim = __webpack_require__(84554), fixBin = __webpack_require__(37101), seen = new Set, failEEXIST = ({path, to, from}) => Promise.reject(Object.assign(new Error("EEXIST: file already exists"), {
        path: to,
        dest: from,
        code: "EEXIST"
      })), SKIP = Symbol("skip - missing or already installed"), doShim = (absFrom, to) => cmdShim(absFrom, to).then((() => fixBin(absFrom)));
      module.exports = Object.assign((({path, to, from, absFrom, force}) => {
        const shims = [ to, to + ".cmd", to + ".ps1" ];
        for (const shim of shims) {
          if (seen.has(shim)) return !0;
          seen.add(shim);
        }
        return Promise.all([ ...shims, absFrom ].map((f => lstat(f).catch(throwNonEnoent)))).then((stats => {
          const [, , , stFrom] = stats;
          return stFrom ? !force && Promise.all(shims.map(((s, i) => [ s, stats[i] ])).map((([s, st]) => !!st && readCmdShim(s).then((target => 0 !== (target = resolve(dirname(to), target)).indexOf(resolve(path)) && failEEXIST({
            from,
            to,
            path
          })), (er => (({er, from, to}) => "ENOENT" === er.code ? null : "ENOTASHIM" === er.code ? failEEXIST({
            from,
            to
          }) : Promise.reject(er))({
            er,
            from,
            to
          })))))) : SKIP;
        })).then((skip => skip !== SKIP && doShim(absFrom, to)));
      }), {
        resetSeen: () => {
          for (const p of seen) seen.delete(p);
        }
      });
    },
    78874: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const semver = __webpack_require__(5870), permanentModules = [ "assert", "buffer", "child_process", "cluster", "console", "constants", "crypto", "dgram", "dns", "domain", "events", "fs", "http", "https", "module", "net", "os", "path", "punycode", "querystring", "readline", "repl", "stream", "string_decoder", "sys", "timers", "tls", "tty", "url", "util", "vm", "zlib" ], versionLockedModules = {
        freelist: "<6.0.0",
        v8: ">=1.0.0",
        process: ">=1.1.0",
        inspector: ">=8.0.0",
        async_hooks: ">=8.1.0",
        http2: ">=8.4.0",
        perf_hooks: ">=8.5.0",
        trace_events: ">=10.0.0",
        worker_threads: ">=12.0.0",
        "node:test": ">=18.0.0"
      }, experimentalModules = {
        worker_threads: ">=10.5.0",
        wasi: ">=12.16.0",
        diagnostics_channel: "^14.17.0 || >=15.1.0"
      };
      module.exports = ({version = process.version, experimental = !1} = {}) => {
        const builtins = [ ...permanentModules ];
        for (const [name, semverRange] of Object.entries(versionLockedModules)) ("*" === version || semver.satisfies(version, semverRange)) && builtins.push(name);
        if (experimental) for (const [name, semverRange] of Object.entries(experimentalModules)) builtins.includes(name) || "*" !== version && !semver.satisfies(version, semverRange) || builtins.push(name);
        return builtins;
      };
    },
    25433: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const ansiStyles = __webpack_require__(53694), {stdout: stdoutColor, stderr: stderrColor} = __webpack_require__(90760), {stringReplaceAll, stringEncaseCRLFWithFirstIndex} = __webpack_require__(19071), {isArray} = Array, levelMapping = [ "ansi", "ansi", "ansi256", "ansi16m" ], styles = Object.create(null);
      class ChalkClass {
        constructor(options) {
          return chalkFactory(options);
        }
      }
      const chalkFactory = options => {
        const chalk = {};
        return ((object, options = {}) => {
          if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) throw new Error("The `level` option should be an integer from 0 to 3");
          const colorLevel = stdoutColor ? stdoutColor.level : 0;
          object.level = void 0 === options.level ? colorLevel : options.level;
        })(chalk, options), chalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_), 
        Object.setPrototypeOf(chalk, Chalk.prototype), Object.setPrototypeOf(chalk.template, chalk), 
        chalk.template.constructor = () => {
          throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
        }, chalk.template.Instance = ChalkClass, chalk.template;
      };
      function Chalk(options) {
        return chalkFactory(options);
      }
      for (const [styleName, style] of Object.entries(ansiStyles)) styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          return Object.defineProperty(this, styleName, {
            value: builder
          }), builder;
        }
      };
      styles.visible = {
        get() {
          const builder = createBuilder(this, this._styler, !0);
          return Object.defineProperty(this, "visible", {
            value: builder
          }), builder;
        }
      };
      const usedModels = [ "rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256" ];
      for (const model of usedModels) styles[model] = {
        get() {
          const {level} = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
      for (const model of usedModels) {
        styles["bg" + model[0].toUpperCase() + model.slice(1)] = {
          get() {
            const {level} = this;
            return function(...arguments_) {
              const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
              return createBuilder(this, styler, this._isEmpty);
            };
          }
        };
      }
      const proto = Object.defineProperties((() => {}), {
        ...styles,
        level: {
          enumerable: !0,
          get() {
            return this._generator.level;
          },
          set(level) {
            this._generator.level = level;
          }
        }
      }), createStyler = (open, close, parent) => {
        let openAll, closeAll;
        return void 0 === parent ? (openAll = open, closeAll = close) : (openAll = parent.openAll + open, 
        closeAll = close + parent.closeAll), {
          open,
          close,
          openAll,
          closeAll,
          parent
        };
      }, createBuilder = (self, _styler, _isEmpty) => {
        const builder = (...arguments_) => isArray(arguments_[0]) && isArray(arguments_[0].raw) ? applyStyle(builder, chalkTag(builder, ...arguments_)) : applyStyle(builder, 1 === arguments_.length ? "" + arguments_[0] : arguments_.join(" "));
        return Object.setPrototypeOf(builder, proto), builder._generator = self, builder._styler = _styler, 
        builder._isEmpty = _isEmpty, builder;
      }, applyStyle = (self, string) => {
        if (self.level <= 0 || !string) return self._isEmpty ? "" : string;
        let styler = self._styler;
        if (void 0 === styler) return string;
        const {openAll, closeAll} = styler;
        if (-1 !== string.indexOf("")) for (;void 0 !== styler; ) string = stringReplaceAll(string, styler.close, styler.open), 
        styler = styler.parent;
        const lfIndex = string.indexOf("\n");
        return -1 !== lfIndex && (string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex)), 
        openAll + string + closeAll;
      };
      let template;
      const chalkTag = (chalk, ...strings) => {
        const [firstString] = strings;
        if (!isArray(firstString) || !isArray(firstString.raw)) return strings.join(" ");
        const arguments_ = strings.slice(1), parts = [ firstString.raw[0] ];
        for (let i = 1; i < firstString.length; i++) parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
        return void 0 === template && (template = __webpack_require__(88911)), template(chalk, parts.join(""));
      };
      Object.defineProperties(Chalk.prototype, styles);
      const chalk = Chalk();
      chalk.supportsColor = stdoutColor, chalk.stderr = Chalk({
        level: stderrColor ? stderrColor.level : 0
      }), chalk.stderr.supportsColor = stderrColor, module.exports = chalk;
    },
    88911: module => {
      "use strict";
      const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi, ESCAPES = new Map([ [ "n", "\n" ], [ "r", "\r" ], [ "t", "\t" ], [ "b", "\b" ], [ "f", "\f" ], [ "v", "\v" ], [ "0", "\0" ], [ "\\", "\\" ], [ "e", "" ], [ "a", "" ] ]);
      function unescape(c) {
        const u = "u" === c[0], bracket = "{" === c[1];
        return u && !bracket && 5 === c.length || "x" === c[0] && 3 === c.length ? String.fromCharCode(parseInt(c.slice(1), 16)) : u && bracket ? String.fromCodePoint(parseInt(c.slice(2, -1), 16)) : ESCAPES.get(c) || c;
      }
      function parseArguments(name, arguments_) {
        const results = [], chunks = arguments_.trim().split(/\s*,\s*/g);
        let matches;
        for (const chunk of chunks) {
          const number = Number(chunk);
          if (Number.isNaN(number)) {
            if (!(matches = chunk.match(STRING_REGEX))) throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
            results.push(matches[2].replace(ESCAPE_REGEX, ((m, escape, character) => escape ? unescape(escape) : character)));
          } else results.push(number);
        }
        return results;
      }
      function parseStyle(style) {
        STYLE_REGEX.lastIndex = 0;
        const results = [];
        let matches;
        for (;null !== (matches = STYLE_REGEX.exec(style)); ) {
          const name = matches[1];
          if (matches[2]) {
            const args = parseArguments(name, matches[2]);
            results.push([ name ].concat(args));
          } else results.push([ name ]);
        }
        return results;
      }
      function buildStyle(chalk, styles) {
        const enabled = {};
        for (const layer of styles) for (const style of layer.styles) enabled[style[0]] = layer.inverse ? null : style.slice(1);
        let current = chalk;
        for (const [styleName, styles] of Object.entries(enabled)) if (Array.isArray(styles)) {
          if (!(styleName in current)) throw new Error(`Unknown Chalk style: ${styleName}`);
          current = styles.length > 0 ? current[styleName](...styles) : current[styleName];
        }
        return current;
      }
      module.exports = (chalk, temporary) => {
        const styles = [], chunks = [];
        let chunk = [];
        if (temporary.replace(TEMPLATE_REGEX, ((m, escapeCharacter, inverse, style, close, character) => {
          if (escapeCharacter) chunk.push(unescape(escapeCharacter)); else if (style) {
            const string = chunk.join("");
            chunk = [], chunks.push(0 === styles.length ? string : buildStyle(chalk, styles)(string)), 
            styles.push({
              inverse,
              styles: parseStyle(style)
            });
          } else if (close) {
            if (0 === styles.length) throw new Error("Found extraneous } in Chalk template literal");
            chunks.push(buildStyle(chalk, styles)(chunk.join(""))), chunk = [], styles.pop();
          } else chunk.push(character);
        })), chunks.push(chunk.join("")), styles.length > 0) {
          const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${1 === styles.length ? "" : "s"} (\`}\`)`;
          throw new Error(errMessage);
        }
        return chunks.join("");
      };
    },
    19071: module => {
      "use strict";
      module.exports = {
        stringReplaceAll: (string, substring, replacer) => {
          let index = string.indexOf(substring);
          if (-1 === index) return string;
          const substringLength = substring.length;
          let endIndex = 0, returnValue = "";
          do {
            returnValue += string.substr(endIndex, index - endIndex) + substring + replacer, 
            endIndex = index + substringLength, index = string.indexOf(substring, endIndex);
          } while (-1 !== index);
          return returnValue += string.substr(endIndex), returnValue;
        },
        stringEncaseCRLFWithFirstIndex: (string, prefix, postfix, index) => {
          let endIndex = 0, returnValue = "";
          do {
            const gotCR = "\r" === string[index - 1];
            returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix, 
            endIndex = index + 1, index = string.indexOf("\n", endIndex);
          } while (-1 !== index);
          return returnValue += string.substr(endIndex), returnValue;
        }
      };
    },
    13159: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const fs = __webpack_require__(57147), path = __webpack_require__(71017), LCHOWN = fs.lchown ? "lchown" : "chown", LCHOWNSYNC = fs.lchownSync ? "lchownSync" : "chownSync", needEISDIRHandled = fs.lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/), lchownSync = (path, uid, gid) => {
        try {
          return fs[LCHOWNSYNC](path, uid, gid);
        } catch (er) {
          if ("ENOENT" !== er.code) throw er;
        }
      }, handleEISDIR = needEISDIRHandled ? (path, uid, gid, cb) => er => {
        er && "EISDIR" === er.code ? fs.chown(path, uid, gid, cb) : cb(er);
      } : (_, __, ___, cb) => cb, handleEISDirSync = needEISDIRHandled ? (path, uid, gid) => {
        try {
          return lchownSync(path, uid, gid);
        } catch (er) {
          if ("EISDIR" !== er.code) throw er;
          ((path, uid, gid) => {
            try {
              fs.chownSync(path, uid, gid);
            } catch (er) {
              if ("ENOENT" !== er.code) throw er;
            }
          })(path, uid, gid);
        }
      } : (path, uid, gid) => lchownSync(path, uid, gid), nodeVersion = process.version;
      let readdir = (path, options, cb) => fs.readdir(path, options, cb);
      /^v4\./.test(nodeVersion) && (readdir = (path, options, cb) => fs.readdir(path, cb));
      const chown = (cpath, uid, gid, cb) => {
        fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, (er => {
          cb(er && "ENOENT" !== er.code ? er : null);
        })));
      }, chownrKid = (p, child, uid, gid, cb) => {
        if ("string" == typeof child) return fs.lstat(path.resolve(p, child), ((er, stats) => {
          if (er) return cb("ENOENT" !== er.code ? er : null);
          stats.name = child, chownrKid(p, stats, uid, gid, cb);
        }));
        if (child.isDirectory()) chownr(path.resolve(p, child.name), uid, gid, (er => {
          if (er) return cb(er);
          const cpath = path.resolve(p, child.name);
          chown(cpath, uid, gid, cb);
        })); else {
          const cpath = path.resolve(p, child.name);
          chown(cpath, uid, gid, cb);
        }
      }, chownr = (p, uid, gid, cb) => {
        readdir(p, {
          withFileTypes: !0
        }, ((er, children) => {
          if (er) {
            if ("ENOENT" === er.code) return cb();
            if ("ENOTDIR" !== er.code && "ENOTSUP" !== er.code) return cb(er);
          }
          if (er || !children.length) return chown(p, uid, gid, cb);
          let len = children.length, errState = null;
          const then = er => {
            if (!errState) return er ? cb(errState = er) : 0 == --len ? chown(p, uid, gid, cb) : void 0;
          };
          children.forEach((child => chownrKid(p, child, uid, gid, then)));
        }));
      }, chownrSync = (p, uid, gid) => {
        let children;
        try {
          children = ((path, options) => fs.readdirSync(path, options))(p, {
            withFileTypes: !0
          });
        } catch (er) {
          if ("ENOENT" === er.code) return;
          if ("ENOTDIR" === er.code || "ENOTSUP" === er.code) return handleEISDirSync(p, uid, gid);
          throw er;
        }
        return children && children.length && children.forEach((child => ((p, child, uid, gid) => {
          if ("string" == typeof child) try {
            const stats = fs.lstatSync(path.resolve(p, child));
            stats.name = child, child = stats;
          } catch (er) {
            if ("ENOENT" === er.code) return;
            throw er;
          }
          child.isDirectory() && chownrSync(path.resolve(p, child.name), uid, gid), handleEISDirSync(path.resolve(p, child.name), uid, gid);
        })(p, child, uid, gid))), handleEISDirSync(p, uid, gid);
      };
      module.exports = chownr, chownr.sync = chownrSync;
    },
    47535: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const ipRegex = __webpack_require__(33573), defaultOpts = {
        exact: !1
      }, v4str = `${ipRegex.v4().source}\\/(3[0-2]|[12]?[0-9])`, v6str = `${ipRegex.v6().source}\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])`, v4exact = new RegExp(`^${v4str}$`), v6exact = new RegExp(`^${v6str}$`), v46exact = new RegExp(`(?:^${v4str}$)|(?:^${v6str}$)`);
      module.exports = ({exact} = defaultOpts) => exact ? v46exact : new RegExp(`(?:${v4str})|(?:${v6str})`, "g"), 
      module.exports.v4 = ({exact} = defaultOpts) => exact ? v4exact : new RegExp(v4str, "g"), 
      module.exports.v6 = ({exact} = defaultOpts) => exact ? v6exact : new RegExp(v6str, "g");
    },
    17569: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const os = __webpack_require__(22037), extractPathRegex = /\s+at.*(?:\(|\s)(.*)\)?/, pathRegex = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/, homeDir = void 0 === os.homedir ? "" : os.homedir();
      module.exports = (stack, options) => (options = Object.assign({
        pretty: !1
      }, options), stack.replace(/\\/g, "/").split("\n").filter((line => {
        const pathMatches = line.match(extractPathRegex);
        if (null === pathMatches || !pathMatches[1]) return !0;
        const match = pathMatches[1];
        return !match.includes(".app/Contents/Resources/electron.asar") && !match.includes(".app/Contents/Resources/default_app.asar") && !pathRegex.test(match);
      })).filter((line => "" !== line.trim())).map((line => options.pretty ? line.replace(extractPathRegex, ((m, p1) => m.replace(p1, p1.replace(homeDir, "~")))) : line)).join("\n"));
    },
    33998: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const stringWidth = __webpack_require__(41055), stripAnsi = __webpack_require__(42935), concat = Array.prototype.concat, defaults = {
        character: " ",
        newline: "\n",
        padding: 2,
        sort: !0,
        width: 0
      };
      function byPlainText(a, b) {
        const plainA = stripAnsi(a), plainB = stripAnsi(b);
        return plainA === plainB ? 0 : plainA > plainB ? 1 : -1;
      }
      function makeArray() {
        return [];
      }
      function makeList(count) {
        return Array.apply(null, Array(count));
      }
      function padCell(fullWidth, character, value) {
        return value + makeList(fullWidth - stringWidth(value) + 1).join(character);
      }
      function toRows(rows, cell, i) {
        return rows[i % rows.length].push(cell), rows;
      }
      function toString(arr) {
        return arr.join("");
      }
      module.exports = function(values, options) {
        values = concat.apply([], values), options = Object.assign({}, defaults, options);
        let cells = values.filter(Boolean).map(String);
        !1 !== options.sort && (cells = cells.sort(byPlainText));
        const termWidth = options.width || process.stdout.columns, cellWidth = Math.max.apply(null, cells.map(stringWidth)) + options.padding, columnCount = Math.floor(termWidth / cellWidth) || 1, rowCount = Math.ceil(cells.length / columnCount) || 1;
        return 1 === columnCount ? cells.join(options.newline) : cells.map(padCell.bind(null, cellWidth, options.character)).reduce(toRows, makeList(rowCount).map(makeArray)).map(toString).join(options.newline);
      };
    },
    96213: (module, __unused_webpack_exports, __webpack_require__) => {
      const {info, debug} = __webpack_require__(60865), utils = __webpack_require__(95741);
      class Cell {
        constructor(options) {
          this.setOptions(options), this.x = null, this.y = null;
        }
        setOptions(options) {
          -1 !== [ "boolean", "number", "string" ].indexOf(typeof options) && (options = {
            content: "" + options
          }), options = options || {}, this.options = options;
          let content = options.content;
          if (-1 !== [ "boolean", "number", "string" ].indexOf(typeof content)) this.content = String(content); else {
            if (content) throw new Error("Content needs to be a primitive, got: " + typeof content);
            this.content = this.options.href || "";
          }
          this.colSpan = options.colSpan || 1, this.rowSpan = options.rowSpan || 1, this.options.href && Object.defineProperty(this, "href", {
            get() {
              return this.options.href;
            }
          });
        }
        mergeTableOptions(tableOptions, cells) {
          this.cells = cells;
          let optionsChars = this.options.chars || {}, tableChars = tableOptions.chars, chars = this.chars = {};
          CHAR_NAMES.forEach((function(name) {
            setOption(optionsChars, tableChars, name, chars);
          })), this.truncate = this.options.truncate || tableOptions.truncate;
          let style = this.options.style = this.options.style || {}, tableStyle = tableOptions.style;
          setOption(style, tableStyle, "padding-left", this), setOption(style, tableStyle, "padding-right", this), 
          this.head = style.head || tableStyle.head, this.border = style.border || tableStyle.border, 
          this.fixedWidth = tableOptions.colWidths[this.x], this.lines = this.computeLines(tableOptions), 
          this.desiredWidth = utils.strlen(this.content) + this.paddingLeft + this.paddingRight, 
          this.desiredHeight = this.lines.length;
        }
        computeLines(tableOptions) {
          if (this.fixedWidth && (tableOptions.wordWrap || tableOptions.textWrap)) {
            if (this.fixedWidth -= this.paddingLeft + this.paddingRight, this.colSpan) {
              let i = 1;
              for (;i < this.colSpan; ) this.fixedWidth += tableOptions.colWidths[this.x + i], 
              i++;
            }
            const {wrapOnWordBoundary = !0} = tableOptions;
            return this.wrapLines(utils.wordWrap(this.fixedWidth, this.content, wrapOnWordBoundary));
          }
          return this.wrapLines(this.content.split("\n"));
        }
        wrapLines(computedLines) {
          const lines = utils.colorizeLines(computedLines);
          return this.href ? lines.map((line => utils.hyperlink(this.href, line))) : lines;
        }
        init(tableOptions) {
          let x = this.x, y = this.y;
          this.widths = tableOptions.colWidths.slice(x, x + this.colSpan), this.heights = tableOptions.rowHeights.slice(y, y + this.rowSpan), 
          this.width = this.widths.reduce(sumPlusOne, -1), this.height = this.heights.reduce(sumPlusOne, -1), 
          this.hAlign = this.options.hAlign || tableOptions.colAligns[x], this.vAlign = this.options.vAlign || tableOptions.rowAligns[y], 
          this.drawRight = x + this.colSpan == tableOptions.colWidths.length;
        }
        draw(lineNum, spanningCell) {
          if ("top" == lineNum) return this.drawTop(this.drawRight);
          if ("bottom" == lineNum) return this.drawBottom(this.drawRight);
          let content = utils.truncate(this.content, 10, this.truncate);
          lineNum || info(`${this.y}-${this.x}: ${this.rowSpan - lineNum}x${this.colSpan} Cell ${content}`);
          let padTop, padLen = Math.max(this.height - this.lines.length, 0);
          switch (this.vAlign) {
           case "center":
            padTop = Math.ceil(padLen / 2);
            break;

           case "bottom":
            padTop = padLen;
            break;

           default:
            padTop = 0;
          }
          if (lineNum < padTop || lineNum >= padTop + this.lines.length) return this.drawEmpty(this.drawRight, spanningCell);
          let forceTruncation = this.lines.length > this.height && lineNum + 1 >= this.height;
          return this.drawLine(lineNum - padTop, this.drawRight, forceTruncation, spanningCell);
        }
        drawTop(drawRight) {
          let content = [];
          return this.cells ? this.widths.forEach((function(width, index) {
            content.push(this._topLeftChar(index)), content.push(utils.repeat(this.chars[0 == this.y ? "top" : "mid"], width));
          }), this) : (content.push(this._topLeftChar(0)), content.push(utils.repeat(this.chars[0 == this.y ? "top" : "mid"], this.width))), 
          drawRight && content.push(this.chars[0 == this.y ? "topRight" : "rightMid"]), this.wrapWithStyleColors("border", content.join(""));
        }
        _topLeftChar(offset) {
          let leftChar, x = this.x + offset;
          if (0 == this.y) leftChar = 0 == x ? "topLeft" : 0 == offset ? "topMid" : "top"; else if (0 == x) leftChar = "leftMid"; else if (leftChar = 0 == offset ? "midMid" : "bottomMid", 
          this.cells) {
            if (this.cells[this.y - 1][x] instanceof Cell.ColSpanCell && (leftChar = 0 == offset ? "topMid" : "mid"), 
            0 == offset) {
              let i = 1;
              for (;this.cells[this.y][x - i] instanceof Cell.ColSpanCell; ) i++;
              this.cells[this.y][x - i] instanceof Cell.RowSpanCell && (leftChar = "leftMid");
            }
          }
          return this.chars[leftChar];
        }
        wrapWithStyleColors(styleProperty, content) {
          if (!this[styleProperty] || !this[styleProperty].length) return content;
          try {
            let colors = __webpack_require__(21845);
            for (let i = this[styleProperty].length - 1; i >= 0; i--) colors = colors[this[styleProperty][i]];
            return colors(content);
          } catch (e) {
            return content;
          }
        }
        drawLine(lineNum, drawRight, forceTruncationSymbol, spanningCell) {
          let left = this.chars[0 == this.x ? "left" : "middle"];
          if (this.x && spanningCell && this.cells) {
            let cellLeft = this.cells[this.y + spanningCell][this.x - 1];
            for (;cellLeft instanceof ColSpanCell; ) cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];
            cellLeft instanceof RowSpanCell || (left = this.chars.rightMid);
          }
          let leftPadding = utils.repeat(" ", this.paddingLeft), right = drawRight ? this.chars.right : "", rightPadding = utils.repeat(" ", this.paddingRight), line = this.lines[lineNum], len = this.width - (this.paddingLeft + this.paddingRight);
          forceTruncationSymbol && (line += this.truncate || "");
          let content = utils.truncate(line, len, this.truncate);
          return content = utils.pad(content, len, " ", this.hAlign), content = leftPadding + content + rightPadding, 
          this.stylizeLine(left, content, right);
        }
        stylizeLine(left, content, right) {
          return left = this.wrapWithStyleColors("border", left), right = this.wrapWithStyleColors("border", right), 
          0 === this.y && (content = this.wrapWithStyleColors("head", content)), left + content + right;
        }
        drawBottom(drawRight) {
          let left = this.chars[0 == this.x ? "bottomLeft" : "bottomMid"], content = utils.repeat(this.chars.bottom, this.width), right = drawRight ? this.chars.bottomRight : "";
          return this.wrapWithStyleColors("border", left + content + right);
        }
        drawEmpty(drawRight, spanningCell) {
          let left = this.chars[0 == this.x ? "left" : "middle"];
          if (this.x && spanningCell && this.cells) {
            let cellLeft = this.cells[this.y + spanningCell][this.x - 1];
            for (;cellLeft instanceof ColSpanCell; ) cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];
            cellLeft instanceof RowSpanCell || (left = this.chars.rightMid);
          }
          let right = drawRight ? this.chars.right : "", content = utils.repeat(" ", this.width);
          return this.stylizeLine(left, content, right);
        }
      }
      class ColSpanCell {
        constructor() {}
        draw(lineNum) {
          return "number" == typeof lineNum && debug(`${this.y}-${this.x}: 1x1 ColSpanCell`), 
          "";
        }
        init() {}
        mergeTableOptions() {}
      }
      class RowSpanCell {
        constructor(originalCell) {
          this.originalCell = originalCell;
        }
        init(tableOptions) {
          let y = this.y, originalY = this.originalCell.y;
          this.cellOffset = y - originalY, this.offset = function(dimensionTable, startingIndex, span) {
            let ret = dimensionTable[startingIndex];
            for (let i = 1; i < span; i++) ret += 1 + dimensionTable[startingIndex + i];
            return ret;
          }(tableOptions.rowHeights, originalY, this.cellOffset);
        }
        draw(lineNum) {
          return "top" == lineNum ? this.originalCell.draw(this.offset, this.cellOffset) : "bottom" == lineNum ? this.originalCell.draw("bottom") : (debug(`${this.y}-${this.x}: 1x${this.colSpan} RowSpanCell for ${this.originalCell.content}`), 
          this.originalCell.draw(this.offset + 1 + lineNum));
        }
        mergeTableOptions() {}
      }
      function firstDefined(...args) {
        return args.filter((v => null != v)).shift();
      }
      function setOption(objA, objB, nameB, targetObj) {
        let nameA = nameB.split("-");
        nameA.length > 1 ? (nameA[1] = nameA[1].charAt(0).toUpperCase() + nameA[1].substr(1), 
        nameA = nameA.join(""), targetObj[nameA] = firstDefined(objA[nameA], objA[nameB], objB[nameA], objB[nameB])) : targetObj[nameB] = firstDefined(objA[nameB], objB[nameB]);
      }
      function sumPlusOne(a, b) {
        return a + b + 1;
      }
      let CHAR_NAMES = [ "top", "top-mid", "top-left", "top-right", "bottom", "bottom-mid", "bottom-left", "bottom-right", "left", "left-mid", "mid", "mid-mid", "right", "right-mid", "middle" ];
      module.exports = Cell, module.exports.ColSpanCell = ColSpanCell, module.exports.RowSpanCell = RowSpanCell;
    },
    60865: module => {
      let messages = [], level = 0;
      const debug = (msg, min) => {
        level >= min && messages.push(msg);
      };
      debug.WARN = 1, debug.INFO = 2, debug.DEBUG = 3, debug.reset = () => {
        messages = [];
      }, debug.setDebugLevel = v => {
        level = v;
      }, debug.warn = msg => debug(msg, debug.WARN), debug.info = msg => debug(msg, debug.INFO), 
      debug.debug = msg => debug(msg, debug.DEBUG), debug.debugMessages = () => messages, 
      module.exports = debug;
    },
    65229: (module, __unused_webpack_exports, __webpack_require__) => {
      const {warn, debug} = __webpack_require__(60865), Cell = __webpack_require__(96213), {ColSpanCell, RowSpanCell} = Cell;
      function makeComputeWidths(colSpan, desiredWidth, x, forcedMin) {
        return function(vals, table) {
          let result = [], spanners = [], auto = {};
          table.forEach((function(row) {
            row.forEach((function(cell) {
              (cell[colSpan] || 1) > 1 ? spanners.push(cell) : result[cell[x]] = Math.max(result[cell[x]] || 0, cell[desiredWidth] || 0, forcedMin);
            }));
          })), vals.forEach((function(val, index) {
            "number" == typeof val && (result[index] = val);
          }));
          for (let k = spanners.length - 1; k >= 0; k--) {
            let cell = spanners[k], span = cell[colSpan], col = cell[x], existingWidth = result[col], editableCols = "number" == typeof vals[col] ? 0 : 1;
            if ("number" == typeof existingWidth) for (let i = 1; i < span; i++) existingWidth += 1 + result[col + i], 
            "number" != typeof vals[col + i] && editableCols++; else existingWidth = "desiredWidth" === desiredWidth ? cell.desiredWidth - 1 : 1, 
            (!auto[col] || auto[col] < existingWidth) && (auto[col] = existingWidth);
            if (cell[desiredWidth] > existingWidth) {
              let i = 0;
              for (;editableCols > 0 && cell[desiredWidth] > existingWidth; ) {
                if ("number" != typeof vals[col + i]) {
                  let dif = Math.round((cell[desiredWidth] - existingWidth) / editableCols);
                  existingWidth += dif, result[col + i] += dif, editableCols--;
                }
                i++;
              }
            }
          }
          Object.assign(vals, result, auto);
          for (let j = 0; j < vals.length; j++) vals[j] = Math.max(forcedMin, vals[j] || 0);
        };
      }
      !function() {
        function next(alloc, col) {
          return alloc[col] > 0 ? next(alloc, col + 1) : col;
        }
        function layoutTable(table) {
          let alloc = {};
          table.forEach((function(row, rowIndex) {
            let col = 0;
            row.forEach((function(cell) {
              cell.y = rowIndex, cell.x = rowIndex ? next(alloc, col) : col;
              const rowSpan = cell.rowSpan || 1, colSpan = cell.colSpan || 1;
              if (rowSpan > 1) for (let cs = 0; cs < colSpan; cs++) alloc[cell.x + cs] = rowSpan;
              col = cell.x + colSpan;
            })), Object.keys(alloc).forEach((idx => {
              alloc[idx]--, alloc[idx] < 1 && delete alloc[idx];
            }));
          }));
        }
        function maxWidth(table) {
          let mw = 0;
          return table.forEach((function(row) {
            row.forEach((function(cell) {
              mw = Math.max(mw, cell.x + (cell.colSpan || 1));
            }));
          })), mw;
        }
        function cellsConflict(cell1, cell2) {
          let yMin1 = cell1.y, yMax1 = cell1.y - 1 + (cell1.rowSpan || 1), yMin2 = cell2.y, yConflict = !(yMin1 > cell2.y - 1 + (cell2.rowSpan || 1) || yMin2 > yMax1), xMin1 = cell1.x, xMax1 = cell1.x - 1 + (cell1.colSpan || 1), xMin2 = cell2.x, xMax2 = cell2.x - 1 + (cell2.colSpan || 1);
          return yConflict && !(xMin1 > xMax2 || xMin2 > xMax1);
        }
        function conflictExists(rows, x, y) {
          let i_max = Math.min(rows.length - 1, y), cell = {
            x,
            y
          };
          for (let i = 0; i <= i_max; i++) {
            let row = rows[i];
            for (let j = 0; j < row.length; j++) if (cellsConflict(cell, row[j])) return !0;
          }
          return !1;
        }
        function allBlank(rows, y, xMin, xMax) {
          for (let x = xMin; x < xMax; x++) if (conflictExists(rows, x, y)) return !1;
          return !0;
        }
        function addRowSpanCells(table) {
          table.forEach((function(row, rowIndex) {
            row.forEach((function(cell) {
              for (let i = 1; i < cell.rowSpan; i++) {
                let rowSpanCell = new RowSpanCell(cell);
                rowSpanCell.x = cell.x, rowSpanCell.y = cell.y + i, rowSpanCell.colSpan = cell.colSpan, 
                insertCell(rowSpanCell, table[rowIndex + i]);
              }
            }));
          }));
        }
        function insertCell(cell, row) {
          let x = 0;
          for (;x < row.length && row[x].x < cell.x; ) x++;
          row.splice(x, 0, cell);
        }
        function fillInTable(table) {
          let h_max = function(table) {
            return table.length;
          }(table), w_max = maxWidth(table);
          debug(`Max rows: ${h_max}; Max cols: ${w_max}`);
          for (let y = 0; y < h_max; y++) for (let x = 0; x < w_max; x++) if (!conflictExists(table, x, y)) {
            let opts = {
              x,
              y,
              colSpan: 1,
              rowSpan: 1
            };
            for (x++; x < w_max && !conflictExists(table, x, y); ) opts.colSpan++, x++;
            let y2 = y + 1;
            for (;y2 < h_max && allBlank(table, y2, opts.x, opts.x + opts.colSpan); ) opts.rowSpan++, 
            y2++;
            let cell = new Cell(opts);
            cell.x = opts.x, cell.y = opts.y, warn(`Missing cell at ${cell.y}-${cell.x}.`), 
            insertCell(cell, table[y]);
          }
        }
        module.exports = {
          makeTableLayout: function(rows) {
            let cellRows = function(rows) {
              return rows.map((function(row) {
                if (!Array.isArray(row)) {
                  let key = Object.keys(row)[0];
                  row = row[key], Array.isArray(row) ? (row = row.slice()).unshift(key) : row = [ key, row ];
                }
                return row.map((function(cell) {
                  return new Cell(cell);
                }));
              }));
            }(rows);
            return layoutTable(cellRows), fillInTable(cellRows), addRowSpanCells(cellRows), 
            function(cellRows) {
              for (let rowIndex = cellRows.length - 1; rowIndex >= 0; rowIndex--) {
                let cellColumns = cellRows[rowIndex];
                for (let columnIndex = 0; columnIndex < cellColumns.length; columnIndex++) {
                  let cell = cellColumns[columnIndex];
                  for (let k = 1; k < cell.colSpan; k++) {
                    let colSpanCell = new ColSpanCell;
                    colSpanCell.x = cell.x + k, colSpanCell.y = cell.y, cellColumns.splice(columnIndex + 1, 0, colSpanCell);
                  }
                }
              }
            }(cellRows), cellRows;
          },
          layoutTable,
          addRowSpanCells,
          maxWidth,
          fillInTable,
          computeWidths: makeComputeWidths("colSpan", "desiredWidth", "x", 1),
          computeHeights: makeComputeWidths("rowSpan", "desiredHeight", "y", 1)
        };
      }();
    },
    27275: (module, __unused_webpack_exports, __webpack_require__) => {
      const debug = __webpack_require__(60865), utils = __webpack_require__(95741), tableLayout = __webpack_require__(65229);
      class Table extends Array {
        constructor(opts) {
          super();
          const options = utils.mergeOptions(opts);
          if (Object.defineProperty(this, "options", {
            value: options,
            enumerable: options.debug
          }), options.debug) {
            switch (typeof options.debug) {
             case "boolean":
              debug.setDebugLevel(debug.WARN);
              break;

             case "number":
              debug.setDebugLevel(options.debug);
              break;

             case "string":
              debug.setDebugLevel(parseInt(options.debug, 10));
              break;

             default:
              debug.setDebugLevel(debug.WARN), debug.warn("Debug option is expected to be boolean, number, or string. Received a " + typeof options.debug);
            }
            Object.defineProperty(this, "messages", {
              get: () => debug.debugMessages()
            });
          }
        }
        toString() {
          let array = this, headersPresent = this.options.head && this.options.head.length;
          headersPresent ? (array = [ this.options.head ], this.length && array.push.apply(array, this)) : this.options.style.head = [];
          let cells = tableLayout.makeTableLayout(array);
          cells.forEach((function(row) {
            row.forEach((function(cell) {
              cell.mergeTableOptions(this.options, cells);
            }), this);
          }), this), tableLayout.computeWidths(this.options.colWidths, cells), tableLayout.computeHeights(this.options.rowHeights, cells), 
          cells.forEach((function(row) {
            row.forEach((function(cell) {
              cell.init(this.options);
            }), this);
          }), this);
          let result = [];
          for (let rowIndex = 0; rowIndex < cells.length; rowIndex++) {
            let row = cells[rowIndex], heightOfRow = this.options.rowHeights[rowIndex];
            (0 === rowIndex || !this.options.style.compact || 1 == rowIndex && headersPresent) && doDraw(row, "top", result);
            for (let lineNum = 0; lineNum < heightOfRow; lineNum++) doDraw(row, lineNum, result);
            rowIndex + 1 == cells.length && doDraw(row, "bottom", result);
          }
          return result.join("\n");
        }
        get width() {
          return this.toString().split("\n")[0].length;
        }
      }
      function doDraw(row, lineNum, result) {
        let line = [];
        row.forEach((function(cell) {
          line.push(cell.draw(lineNum));
        }));
        let str = line.join("");
        str.length && result.push(str);
      }
      Table.reset = () => debug.reset(), module.exports = Table;
    },
    95741: (module, __unused_webpack_exports, __webpack_require__) => {
      const stringWidth = __webpack_require__(41055);
      function codeRegex(capture) {
        return capture ? /\u001b\[((?:\d*;){0,5}\d*)m/g : /\u001b\[(?:\d*;){0,5}\d*m/g;
      }
      function strlen(str) {
        let code = codeRegex();
        return ("" + str).replace(code, "").split("\n").reduce((function(memo, s) {
          return stringWidth(s) > memo ? stringWidth(s) : memo;
        }), 0);
      }
      function repeat(str, times) {
        return Array(times + 1).join(str);
      }
      let codeCache = {};
      function addToCodeCache(name, on, off) {
        off = "[" + off + "m", codeCache[on = "[" + on + "m"] = {
          set: name,
          to: !0
        }, codeCache[off] = {
          set: name,
          to: !1
        }, codeCache[name] = {
          on,
          off
        };
      }
      function updateState(state, controlChars) {
        let controlCode = controlChars[1] ? parseInt(controlChars[1].split(";")[0]) : 0;
        if (controlCode >= 30 && controlCode <= 39 || controlCode >= 90 && controlCode <= 97) return void (state.lastForegroundAdded = controlChars[0]);
        if (controlCode >= 40 && controlCode <= 49 || controlCode >= 100 && controlCode <= 107) return void (state.lastBackgroundAdded = controlChars[0]);
        if (0 === controlCode) {
          for (let i in state) Object.prototype.hasOwnProperty.call(state, i) && delete state[i];
          return;
        }
        let info = codeCache[controlChars[0]];
        info && (state[info.set] = info.to);
      }
      function readState(line) {
        let code = codeRegex(!0), controlChars = code.exec(line), state = {};
        for (;null !== controlChars; ) updateState(state, controlChars), controlChars = code.exec(line);
        return state;
      }
      function unwindState(state, ret) {
        let lastBackgroundAdded = state.lastBackgroundAdded, lastForegroundAdded = state.lastForegroundAdded;
        return delete state.lastBackgroundAdded, delete state.lastForegroundAdded, Object.keys(state).forEach((function(key) {
          state[key] && (ret += codeCache[key].off);
        })), lastBackgroundAdded && "[49m" != lastBackgroundAdded && (ret += "[49m"), 
        lastForegroundAdded && "[39m" != lastForegroundAdded && (ret += "[39m"), ret;
      }
      function rewindState(state, ret) {
        let lastBackgroundAdded = state.lastBackgroundAdded, lastForegroundAdded = state.lastForegroundAdded;
        return delete state.lastBackgroundAdded, delete state.lastForegroundAdded, Object.keys(state).forEach((function(key) {
          state[key] && (ret = codeCache[key].on + ret);
        })), lastBackgroundAdded && "[49m" != lastBackgroundAdded && (ret = lastBackgroundAdded + ret), 
        lastForegroundAdded && "[39m" != lastForegroundAdded && (ret = lastForegroundAdded + ret), 
        ret;
      }
      function truncateWidth(str, desiredLength) {
        if (str.length === strlen(str)) return str.substr(0, desiredLength);
        for (;strlen(str) > desiredLength; ) str = str.slice(0, -1);
        return str;
      }
      function wordWrap(maxLength, input) {
        let whitespace, lines = [], split = input.split(/(\s+)/g), line = [], lineLength = 0;
        for (let i = 0; i < split.length; i += 2) {
          let word = split[i], newLength = lineLength + strlen(word);
          lineLength > 0 && whitespace && (newLength += whitespace.length), newLength > maxLength ? (0 !== lineLength && lines.push(line.join("")), 
          line = [ word ], lineLength = strlen(word)) : (line.push(whitespace || "", word), 
          lineLength = newLength), whitespace = split[i + 1];
        }
        return lineLength && lines.push(line.join("")), lines;
      }
      function textWrap(maxLength, input) {
        let lines = [], line = "";
        function pushLine(str, ws) {
          for (line.length && ws && (line += ws), line += str; line.length > maxLength; ) lines.push(line.slice(0, maxLength)), 
          line = line.slice(maxLength);
        }
        let split = input.split(/(\s+)/g);
        for (let i = 0; i < split.length; i += 2) pushLine(split[i], i && split[i - 1]);
        return line.length && lines.push(line), lines;
      }
      addToCodeCache("bold", 1, 22), addToCodeCache("italics", 3, 23), addToCodeCache("underline", 4, 24), 
      addToCodeCache("inverse", 7, 27), addToCodeCache("strikethrough", 9, 29), module.exports = {
        strlen,
        repeat,
        pad: function(str, len, pad, dir) {
          let length = strlen(str);
          if (len + 1 >= length) {
            let padlen = len - length;
            switch (dir) {
             case "right":
              str = repeat(pad, padlen) + str;
              break;

             case "center":
              {
                let right = Math.ceil(padlen / 2);
                str = repeat(pad, padlen - right) + str + repeat(pad, right);
                break;
              }

             default:
              str += repeat(pad, padlen);
            }
          }
          return str;
        },
        truncate: function(str, desiredLength, truncateChar) {
          if (truncateChar = truncateChar || "", strlen(str) <= desiredLength) return str;
          let ret = function(str, desiredLength) {
            let myArray, code = codeRegex(!0), split = str.split(codeRegex()), splitIndex = 0, retLen = 0, ret = "", state = {};
            for (;retLen < desiredLength; ) {
              myArray = code.exec(str);
              let toAdd = split[splitIndex];
              if (splitIndex++, retLen + strlen(toAdd) > desiredLength && (toAdd = truncateWidth(toAdd, desiredLength - retLen)), 
              ret += toAdd, retLen += strlen(toAdd), retLen < desiredLength) {
                if (!myArray) break;
                ret += myArray[0], updateState(state, myArray);
              }
            }
            return unwindState(state, ret);
          }(str, desiredLength -= strlen(truncateChar));
          return ret + truncateChar;
        },
        mergeOptions: function(options, defaults) {
          options = options || {}, defaults = defaults || {
            chars: {
              top: "",
              "top-mid": "",
              "top-left": "",
              "top-right": "",
              bottom: "",
              "bottom-mid": "",
              "bottom-left": "",
              "bottom-right": "",
              left: "",
              "left-mid": "",
              mid: "",
              "mid-mid": "",
              right: "",
              "right-mid": "",
              middle: ""
            },
            truncate: "",
            colWidths: [],
            rowHeights: [],
            colAligns: [],
            rowAligns: [],
            style: {
              "padding-left": 1,
              "padding-right": 1,
              head: [ "red" ],
              border: [ "grey" ],
              compact: !1
            },
            head: []
          };
          let ret = Object.assign({}, defaults, options);
          return ret.chars = Object.assign({}, defaults.chars, options.chars), ret.style = Object.assign({}, defaults.style, options.style), 
          ret;
        },
        wordWrap: function(maxLength, input, wrapOnWordBoundary = !0) {
          let output = [];
          input = input.split("\n");
          const handler = wrapOnWordBoundary ? wordWrap : textWrap;
          for (let i = 0; i < input.length; i++) output.push.apply(output, handler(maxLength, input[i]));
          return output;
        },
        colorizeLines: function(input) {
          let state = {}, output = [];
          for (let i = 0; i < input.length; i++) {
            let line = rewindState(state, input[i]);
            state = readState(line);
            let temp = Object.assign({}, state);
            output.push(unwindState(temp, line));
          }
          return output;
        },
        hyperlink: function(url, text) {
          const OSC = "]", BEL = "", SEP = ";";
          return [ OSC, "8", SEP, SEP, url || text, BEL, text, OSC, "8", SEP, SEP, BEL ].join("");
        }
      };
    },
    6120: module => {
      var clone = function() {
        "use strict";
        function clone(parent, circular, depth, prototype) {
          "object" == typeof circular && (depth = circular.depth, prototype = circular.prototype, 
          circular.filter, circular = circular.circular);
          var allParents = [], allChildren = [], useBuffer = "undefined" != typeof Buffer;
          return void 0 === circular && (circular = !0), void 0 === depth && (depth = 1 / 0), 
          function _clone(parent, depth) {
            if (null === parent) return null;
            if (0 == depth) return parent;
            var child, proto;
            if ("object" != typeof parent) return parent;
            if (clone.__isArray(parent)) child = []; else if (clone.__isRegExp(parent)) child = new RegExp(parent.source, __getRegExpFlags(parent)), 
            parent.lastIndex && (child.lastIndex = parent.lastIndex); else if (clone.__isDate(parent)) child = new Date(parent.getTime()); else {
              if (useBuffer && Buffer.isBuffer(parent)) return child = Buffer.allocUnsafe ? Buffer.allocUnsafe(parent.length) : new Buffer(parent.length), 
              parent.copy(child), child;
              void 0 === prototype ? (proto = Object.getPrototypeOf(parent), child = Object.create(proto)) : (child = Object.create(prototype), 
              proto = prototype);
            }
            if (circular) {
              var index = allParents.indexOf(parent);
              if (-1 != index) return allChildren[index];
              allParents.push(parent), allChildren.push(child);
            }
            for (var i in parent) {
              var attrs;
              proto && (attrs = Object.getOwnPropertyDescriptor(proto, i)), attrs && null == attrs.set || (child[i] = _clone(parent[i], depth - 1));
            }
            return child;
          }(parent, depth);
        }
        function __objToStr(o) {
          return Object.prototype.toString.call(o);
        }
        function __getRegExpFlags(re) {
          var flags = "";
          return re.global && (flags += "g"), re.ignoreCase && (flags += "i"), re.multiline && (flags += "m"), 
          flags;
        }
        return clone.clonePrototype = function(parent) {
          if (null === parent) return null;
          var c = function() {};
          return c.prototype = parent, new c;
        }, clone.__objToStr = __objToStr, clone.__isDate = function(o) {
          return "object" == typeof o && "[object Date]" === __objToStr(o);
        }, clone.__isArray = function(o) {
          return "object" == typeof o && "[object Array]" === __objToStr(o);
        }, clone.__isRegExp = function(o) {
          return "object" == typeof o && "[object RegExp]" === __objToStr(o);
        }, clone.__getRegExpFlags = __getRegExpFlags, clone;
      }();
      module.exports && (module.exports = clone);
    },
    93865: (module, __unused_webpack_exports, __webpack_require__) => {
      const {promisify} = __webpack_require__(73837), fs = __webpack_require__(57147), writeFile = promisify(fs.writeFile), readFile = promisify(fs.readFile), chmod = promisify(fs.chmod), stat = promisify(fs.stat), unlink = promisify(fs.unlink), {dirname, relative} = __webpack_require__(71017), mkdir = __webpack_require__(87700), toBatchSyntax = __webpack_require__(64244), shebangExpr = /^#!\s*(?:\/usr\/bin\/env\s*((?:[^ \t=]+=[^ \t=]+\s+)*))?([^ \t]+)(.*)$/, rm = path => unlink(path).catch((() => {})), cmdShim = (from, to) => stat(from).then((() => cmdShim_(from, to))), cmdShim_ = (from, to) => Promise.all([ rm(to), rm(to + ".cmd"), rm(to + ".ps1") ]).then((() => writeShim(from, to))), writeShim = (from, to) => mkdir(dirname(to)).then((() => readFile(from, "utf8"))).then((data => {
        const shebang = data.trim().split(/\r*\n/)[0].match(shebangExpr);
        if (!shebang) return writeShim_(from, to);
        const vars = shebang[1] || "", prog = shebang[2], args = shebang[3] || "";
        return writeShim_(from, to, prog, args, vars);
      }), (er => writeShim_(from, to))), writeShim_ = (from, to, prog, args, variables) => {
        let longProg, shLongProg, pwshLongProg, shTarget = relative(dirname(to), from), target = shTarget.split("/").join("\\"), shProg = prog && prog.split("\\").join("/"), pwshProg = shProg && `"${shProg}$exe"`;
        shTarget = shTarget.split("\\").join("/"), args = args || "", variables = variables || "", 
        prog ? (longProg = `"%dp0%\\${prog}.exe"`, shLongProg = `"$basedir/${prog}"`, pwshLongProg = `"$basedir/${prog}$exe"`, 
        target = `"%dp0%\\${target}"`, shTarget = `"$basedir/${shTarget}"`) : (prog = `"%dp0%\\${target}"`, 
        shProg = `"$basedir/${shTarget}"`, pwshProg = shProg, args = "", target = "", shTarget = "");
        const head = '@ECHO off\r\nGOTO start\r\n:find_dp0\r\nSET "dp0=%~dp0"\r\nEXIT /b\r\n:start\r\nSETLOCAL\r\nCALL :find_dp0\r\n';
        let cmd;
        if (longProg) {
          shLongProg = shLongProg.trim(), args = args.trim();
          cmd = head + toBatchSyntax.convertToSetCommands(variables) + "\r\n" + `IF EXIST ${longProg} (\r\n` + `  SET "_prog=${longProg.replace(/(^")|("$)/g, "")}"\r\n) ELSE (\r\n` + `  SET "_prog=${prog.replace(/(^")|("$)/g, "")}"\r\n  SET "PATHEXT=%PATHEXT:;.JS;=;%"\r\n)\r\n\r\nendLocal & goto #_undefined_# 2>NUL || title %COMSPEC% & ` + `"%_prog%" ${args} ${target} %*\r\n`;
        } else cmd = `${head}${prog} ${args} ${target} %*\r\n`;
        let sh = "#!/bin/sh\n";
        sh += 'basedir=$(dirname "$(echo "$0" | sed -e \'s,\\\\,/,g\')")\n\ncase `uname` in\n  *CYGWIN*|*MINGW*|*MSYS*) basedir=`cygpath -w "$basedir"`;;\nesac\n\n', 
        shLongProg ? sh = sh + `_prog=${shLongProg}\nif [ ! -x "$_prog" ]; then\n` + `  _prog=${shProg}\nfi\n` + `exec ${variables}"$_prog" ${args} ${shTarget} "$@"\n` : sh += `exec ${shProg} ${args} ${shTarget} "$@"\n`;
        let pwsh = '#!/usr/bin/env pwsh\n$basedir=Split-Path $MyInvocation.MyCommand.Definition -Parent\n\n$exe=""\nif ($PSVersionTable.PSVersion -lt "6.0" -or $IsWindows) {\n  # Fix case when both the Windows and Linux builds of Node\n  # are installed in the same directory\n  $exe=".exe"\n}\n';
        return pwsh = shLongProg ? pwsh + `$_prog=${pwshLongProg}\nif (!(Test-Path "$_prog")) {\n` + `  $_prog=${pwshProg}\n}\n# Support pipeline input\nif ($MyInvocation.ExpectingInput) {\n` + `  $input | & "$_prog" ${args} ${shTarget} $args\n} else {\n` + `  & "$_prog" ${args} ${shTarget} $args\n}\nexit $LASTEXITCODE\n` : pwsh + "# Support pipeline input\nif ($MyInvocation.ExpectingInput) {\n" + `  $input | & ${pwshProg} ${args} ${shTarget} $args\n} else {\n` + `  & ${pwshProg} ${args} ${shTarget} $args\n}\nexit $LASTEXITCODE\n`, 
        Promise.all([ writeFile(to + ".ps1", pwsh, "utf8"), writeFile(to + ".cmd", cmd, "utf8"), writeFile(to, sh, "utf8") ]).then((() => chmodShim(to)));
      }, chmodShim = to => Promise.all([ chmod(to, 493), chmod(to + ".cmd", 493), chmod(to + ".ps1", 493) ]);
      module.exports = cmdShim, cmdShim.ifExists = (from, to) => stat(from).then((() => cmdShim(from, to)), (() => {}));
    },
    64244: (__unused_webpack_module, exports) => {
      function convertToSetCommand(key, value) {
        var line = "";
        return key = (key = key || "").trim(), value = (value = value || "").trim(), key && value && value.length > 0 && (line = "@SET " + key + "=" + replaceDollarWithPercentPair(value) + "\r\n"), 
        line;
      }
      function replaceDollarWithPercentPair(value) {
        var dollarExpressions = /\$\{?([^$@#?\- \t{}:]+)\}?/g, result = "", startIndex = 0;
        do {
          var match = dollarExpressions.exec(value);
          if (match) result += (value.substring(startIndex, match.index) || "") + "%" + match[1] + "%", 
          startIndex = dollarExpressions.lastIndex;
        } while (dollarExpressions.lastIndex > 0);
        return result += value.slice(startIndex);
      }
      exports.replaceDollarWithPercentPair = replaceDollarWithPercentPair, exports.convertToSetCommand = convertToSetCommand, 
      exports.convertToSetCommands = function(variableString) {
        var variableValuePairs = (declarations = variableString.split(" "), pairs = {}, 
        declarations.map((function(declaration) {
          var split = declaration.split("=");
          pairs[split[0]] = split[1];
        })), pairs), variableDeclarationsAsBatch = "";
        var declarations, pairs;
        return Object.keys(variableValuePairs).forEach((function(key) {
          variableDeclarationsAsBatch += convertToSetCommand(key, variableValuePairs[key]);
        })), variableDeclarationsAsBatch;
      };
    },
    47072: (module, __unused_webpack_exports, __webpack_require__) => {
      const cssKeywords = __webpack_require__(23435), reverseKeywords = {};
      for (const key of Object.keys(cssKeywords)) reverseKeywords[cssKeywords[key]] = key;
      const convert = {
        rgb: {
          channels: 3,
          labels: "rgb"
        },
        hsl: {
          channels: 3,
          labels: "hsl"
        },
        hsv: {
          channels: 3,
          labels: "hsv"
        },
        hwb: {
          channels: 3,
          labels: "hwb"
        },
        cmyk: {
          channels: 4,
          labels: "cmyk"
        },
        xyz: {
          channels: 3,
          labels: "xyz"
        },
        lab: {
          channels: 3,
          labels: "lab"
        },
        lch: {
          channels: 3,
          labels: "lch"
        },
        hex: {
          channels: 1,
          labels: [ "hex" ]
        },
        keyword: {
          channels: 1,
          labels: [ "keyword" ]
        },
        ansi16: {
          channels: 1,
          labels: [ "ansi16" ]
        },
        ansi256: {
          channels: 1,
          labels: [ "ansi256" ]
        },
        hcg: {
          channels: 3,
          labels: [ "h", "c", "g" ]
        },
        apple: {
          channels: 3,
          labels: [ "r16", "g16", "b16" ]
        },
        gray: {
          channels: 1,
          labels: [ "gray" ]
        }
      };
      module.exports = convert;
      for (const model of Object.keys(convert)) {
        if (!("channels" in convert[model])) throw new Error("missing channels property: " + model);
        if (!("labels" in convert[model])) throw new Error("missing channel labels property: " + model);
        if (convert[model].labels.length !== convert[model].channels) throw new Error("channel and label counts mismatch: " + model);
        const {channels, labels} = convert[model];
        delete convert[model].channels, delete convert[model].labels, Object.defineProperty(convert[model], "channels", {
          value: channels
        }), Object.defineProperty(convert[model], "labels", {
          value: labels
        });
      }
      convert.rgb.hsl = function(rgb) {
        const r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), delta = max - min;
        let h, s;
        max === min ? h = 0 : r === max ? h = (g - b) / delta : g === max ? h = 2 + (b - r) / delta : b === max && (h = 4 + (r - g) / delta), 
        h = Math.min(60 * h, 360), h < 0 && (h += 360);
        const l = (min + max) / 2;
        return s = max === min ? 0 : l <= .5 ? delta / (max + min) : delta / (2 - max - min), 
        [ h, 100 * s, 100 * l ];
      }, convert.rgb.hsv = function(rgb) {
        let rdif, gdif, bdif, h, s;
        const r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, v = Math.max(r, g, b), diff = v - Math.min(r, g, b), diffc = function(c) {
          return (v - c) / 6 / diff + .5;
        };
        return 0 === diff ? (h = 0, s = 0) : (s = diff / v, rdif = diffc(r), gdif = diffc(g), 
        bdif = diffc(b), r === v ? h = bdif - gdif : g === v ? h = 1 / 3 + rdif - bdif : b === v && (h = 2 / 3 + gdif - rdif), 
        h < 0 ? h += 1 : h > 1 && (h -= 1)), [ 360 * h, 100 * s, 100 * v ];
      }, convert.rgb.hwb = function(rgb) {
        const r = rgb[0], g = rgb[1];
        let b = rgb[2];
        const h = convert.rgb.hsl(rgb)[0], w = 1 / 255 * Math.min(r, Math.min(g, b));
        return b = 1 - 1 / 255 * Math.max(r, Math.max(g, b)), [ h, 100 * w, 100 * b ];
      }, convert.rgb.cmyk = function(rgb) {
        const r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, k = Math.min(1 - r, 1 - g, 1 - b);
        return [ 100 * ((1 - r - k) / (1 - k) || 0), 100 * ((1 - g - k) / (1 - k) || 0), 100 * ((1 - b - k) / (1 - k) || 0), 100 * k ];
      }, convert.rgb.keyword = function(rgb) {
        const reversed = reverseKeywords[rgb];
        if (reversed) return reversed;
        let currentClosestKeyword, currentClosestDistance = 1 / 0;
        for (const keyword of Object.keys(cssKeywords)) {
          const value = cssKeywords[keyword], distance = (y = value, ((x = rgb)[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2);
          distance < currentClosestDistance && (currentClosestDistance = distance, currentClosestKeyword = keyword);
        }
        var x, y;
        return currentClosestKeyword;
      }, convert.keyword.rgb = function(keyword) {
        return cssKeywords[keyword];
      }, convert.rgb.xyz = function(rgb) {
        let r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255;
        r = r > .04045 ? ((r + .055) / 1.055) ** 2.4 : r / 12.92, g = g > .04045 ? ((g + .055) / 1.055) ** 2.4 : g / 12.92, 
        b = b > .04045 ? ((b + .055) / 1.055) ** 2.4 : b / 12.92;
        return [ 100 * (.4124 * r + .3576 * g + .1805 * b), 100 * (.2126 * r + .7152 * g + .0722 * b), 100 * (.0193 * r + .1192 * g + .9505 * b) ];
      }, convert.rgb.lab = function(rgb) {
        const xyz = convert.rgb.xyz(rgb);
        let x = xyz[0], y = xyz[1], z = xyz[2];
        x /= 95.047, y /= 100, z /= 108.883, x = x > .008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116, 
        y = y > .008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116, z = z > .008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
        return [ 116 * y - 16, 500 * (x - y), 200 * (y - z) ];
      }, convert.hsl.rgb = function(hsl) {
        const h = hsl[0] / 360, s = hsl[1] / 100, l = hsl[2] / 100;
        let t2, t3, val;
        if (0 === s) return val = 255 * l, [ val, val, val ];
        t2 = l < .5 ? l * (1 + s) : l + s - l * s;
        const t1 = 2 * l - t2, rgb = [ 0, 0, 0 ];
        for (let i = 0; i < 3; i++) t3 = h + 1 / 3 * -(i - 1), t3 < 0 && t3++, t3 > 1 && t3--, 
        val = 6 * t3 < 1 ? t1 + 6 * (t2 - t1) * t3 : 2 * t3 < 1 ? t2 : 3 * t3 < 2 ? t1 + (t2 - t1) * (2 / 3 - t3) * 6 : t1, 
        rgb[i] = 255 * val;
        return rgb;
      }, convert.hsl.hsv = function(hsl) {
        const h = hsl[0];
        let s = hsl[1] / 100, l = hsl[2] / 100, smin = s;
        const lmin = Math.max(l, .01);
        l *= 2, s *= l <= 1 ? l : 2 - l, smin *= lmin <= 1 ? lmin : 2 - lmin;
        return [ h, 100 * (0 === l ? 2 * smin / (lmin + smin) : 2 * s / (l + s)), 100 * ((l + s) / 2) ];
      }, convert.hsv.rgb = function(hsv) {
        const h = hsv[0] / 60, s = hsv[1] / 100;
        let v = hsv[2] / 100;
        const hi = Math.floor(h) % 6, f = h - Math.floor(h), p = 255 * v * (1 - s), q = 255 * v * (1 - s * f), t = 255 * v * (1 - s * (1 - f));
        switch (v *= 255, hi) {
         case 0:
          return [ v, t, p ];

         case 1:
          return [ q, v, p ];

         case 2:
          return [ p, v, t ];

         case 3:
          return [ p, q, v ];

         case 4:
          return [ t, p, v ];

         case 5:
          return [ v, p, q ];
        }
      }, convert.hsv.hsl = function(hsv) {
        const h = hsv[0], s = hsv[1] / 100, v = hsv[2] / 100, vmin = Math.max(v, .01);
        let sl, l;
        l = (2 - s) * v;
        const lmin = (2 - s) * vmin;
        return sl = s * vmin, sl /= lmin <= 1 ? lmin : 2 - lmin, sl = sl || 0, l /= 2, [ h, 100 * sl, 100 * l ];
      }, convert.hwb.rgb = function(hwb) {
        const h = hwb[0] / 360;
        let wh = hwb[1] / 100, bl = hwb[2] / 100;
        const ratio = wh + bl;
        let f;
        ratio > 1 && (wh /= ratio, bl /= ratio);
        const i = Math.floor(6 * h), v = 1 - bl;
        f = 6 * h - i, 0 != (1 & i) && (f = 1 - f);
        const n = wh + f * (v - wh);
        let r, g, b;
        switch (i) {
         default:
         case 6:
         case 0:
          r = v, g = n, b = wh;
          break;

         case 1:
          r = n, g = v, b = wh;
          break;

         case 2:
          r = wh, g = v, b = n;
          break;

         case 3:
          r = wh, g = n, b = v;
          break;

         case 4:
          r = n, g = wh, b = v;
          break;

         case 5:
          r = v, g = wh, b = n;
        }
        return [ 255 * r, 255 * g, 255 * b ];
      }, convert.cmyk.rgb = function(cmyk) {
        const c = cmyk[0] / 100, m = cmyk[1] / 100, y = cmyk[2] / 100, k = cmyk[3] / 100;
        return [ 255 * (1 - Math.min(1, c * (1 - k) + k)), 255 * (1 - Math.min(1, m * (1 - k) + k)), 255 * (1 - Math.min(1, y * (1 - k) + k)) ];
      }, convert.xyz.rgb = function(xyz) {
        const x = xyz[0] / 100, y = xyz[1] / 100, z = xyz[2] / 100;
        let r, g, b;
        return r = 3.2406 * x + -1.5372 * y + -.4986 * z, g = -.9689 * x + 1.8758 * y + .0415 * z, 
        b = .0557 * x + -.204 * y + 1.057 * z, r = r > .0031308 ? 1.055 * r ** (1 / 2.4) - .055 : 12.92 * r, 
        g = g > .0031308 ? 1.055 * g ** (1 / 2.4) - .055 : 12.92 * g, b = b > .0031308 ? 1.055 * b ** (1 / 2.4) - .055 : 12.92 * b, 
        r = Math.min(Math.max(0, r), 1), g = Math.min(Math.max(0, g), 1), b = Math.min(Math.max(0, b), 1), 
        [ 255 * r, 255 * g, 255 * b ];
      }, convert.xyz.lab = function(xyz) {
        let x = xyz[0], y = xyz[1], z = xyz[2];
        x /= 95.047, y /= 100, z /= 108.883, x = x > .008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116, 
        y = y > .008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116, z = z > .008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
        return [ 116 * y - 16, 500 * (x - y), 200 * (y - z) ];
      }, convert.lab.xyz = function(lab) {
        let x, y, z;
        y = (lab[0] + 16) / 116, x = lab[1] / 500 + y, z = y - lab[2] / 200;
        const y2 = y ** 3, x2 = x ** 3, z2 = z ** 3;
        return y = y2 > .008856 ? y2 : (y - 16 / 116) / 7.787, x = x2 > .008856 ? x2 : (x - 16 / 116) / 7.787, 
        z = z2 > .008856 ? z2 : (z - 16 / 116) / 7.787, x *= 95.047, y *= 100, z *= 108.883, 
        [ x, y, z ];
      }, convert.lab.lch = function(lab) {
        const l = lab[0], a = lab[1], b = lab[2];
        let h;
        h = 360 * Math.atan2(b, a) / 2 / Math.PI, h < 0 && (h += 360);
        return [ l, Math.sqrt(a * a + b * b), h ];
      }, convert.lch.lab = function(lch) {
        const l = lch[0], c = lch[1], hr = lch[2] / 360 * 2 * Math.PI;
        return [ l, c * Math.cos(hr), c * Math.sin(hr) ];
      }, convert.rgb.ansi16 = function(args, saturation = null) {
        const [r, g, b] = args;
        let value = null === saturation ? convert.rgb.hsv(args)[2] : saturation;
        if (value = Math.round(value / 50), 0 === value) return 30;
        let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
        return 2 === value && (ansi += 60), ansi;
      }, convert.hsv.ansi16 = function(args) {
        return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
      }, convert.rgb.ansi256 = function(args) {
        const r = args[0], g = args[1], b = args[2];
        if (r === g && g === b) return r < 8 ? 16 : r > 248 ? 231 : Math.round((r - 8) / 247 * 24) + 232;
        return 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      }, convert.ansi16.rgb = function(args) {
        let color = args % 10;
        if (0 === color || 7 === color) return args > 50 && (color += 3.5), color = color / 10.5 * 255, 
        [ color, color, color ];
        const mult = .5 * (1 + ~~(args > 50));
        return [ (1 & color) * mult * 255, (color >> 1 & 1) * mult * 255, (color >> 2 & 1) * mult * 255 ];
      }, convert.ansi256.rgb = function(args) {
        if (args >= 232) {
          const c = 10 * (args - 232) + 8;
          return [ c, c, c ];
        }
        let rem;
        args -= 16;
        return [ Math.floor(args / 36) / 5 * 255, Math.floor((rem = args % 36) / 6) / 5 * 255, rem % 6 / 5 * 255 ];
      }, convert.rgb.hex = function(args) {
        const string = (((255 & Math.round(args[0])) << 16) + ((255 & Math.round(args[1])) << 8) + (255 & Math.round(args[2]))).toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
      }, convert.hex.rgb = function(args) {
        const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!match) return [ 0, 0, 0 ];
        let colorString = match[0];
        3 === match[0].length && (colorString = colorString.split("").map((char => char + char)).join(""));
        const integer = parseInt(colorString, 16);
        return [ integer >> 16 & 255, integer >> 8 & 255, 255 & integer ];
      }, convert.rgb.hcg = function(rgb) {
        const r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, max = Math.max(Math.max(r, g), b), min = Math.min(Math.min(r, g), b), chroma = max - min;
        let grayscale, hue;
        return grayscale = chroma < 1 ? min / (1 - chroma) : 0, hue = chroma <= 0 ? 0 : max === r ? (g - b) / chroma % 6 : max === g ? 2 + (b - r) / chroma : 4 + (r - g) / chroma, 
        hue /= 6, hue %= 1, [ 360 * hue, 100 * chroma, 100 * grayscale ];
      }, convert.hsl.hcg = function(hsl) {
        const s = hsl[1] / 100, l = hsl[2] / 100, c = l < .5 ? 2 * s * l : 2 * s * (1 - l);
        let f = 0;
        return c < 1 && (f = (l - .5 * c) / (1 - c)), [ hsl[0], 100 * c, 100 * f ];
      }, convert.hsv.hcg = function(hsv) {
        const s = hsv[1] / 100, v = hsv[2] / 100, c = s * v;
        let f = 0;
        return c < 1 && (f = (v - c) / (1 - c)), [ hsv[0], 100 * c, 100 * f ];
      }, convert.hcg.rgb = function(hcg) {
        const h = hcg[0] / 360, c = hcg[1] / 100, g = hcg[2] / 100;
        if (0 === c) return [ 255 * g, 255 * g, 255 * g ];
        const pure = [ 0, 0, 0 ], hi = h % 1 * 6, v = hi % 1, w = 1 - v;
        let mg = 0;
        switch (Math.floor(hi)) {
         case 0:
          pure[0] = 1, pure[1] = v, pure[2] = 0;
          break;

         case 1:
          pure[0] = w, pure[1] = 1, pure[2] = 0;
          break;

         case 2:
          pure[0] = 0, pure[1] = 1, pure[2] = v;
          break;

         case 3:
          pure[0] = 0, pure[1] = w, pure[2] = 1;
          break;

         case 4:
          pure[0] = v, pure[1] = 0, pure[2] = 1;
          break;

         default:
          pure[0] = 1, pure[1] = 0, pure[2] = w;
        }
        return mg = (1 - c) * g, [ 255 * (c * pure[0] + mg), 255 * (c * pure[1] + mg), 255 * (c * pure[2] + mg) ];
      }, convert.hcg.hsv = function(hcg) {
        const c = hcg[1] / 100, v = c + hcg[2] / 100 * (1 - c);
        let f = 0;
        return v > 0 && (f = c / v), [ hcg[0], 100 * f, 100 * v ];
      }, convert.hcg.hsl = function(hcg) {
        const c = hcg[1] / 100, l = hcg[2] / 100 * (1 - c) + .5 * c;
        let s = 0;
        return l > 0 && l < .5 ? s = c / (2 * l) : l >= .5 && l < 1 && (s = c / (2 * (1 - l))), 
        [ hcg[0], 100 * s, 100 * l ];
      }, convert.hcg.hwb = function(hcg) {
        const c = hcg[1] / 100, v = c + hcg[2] / 100 * (1 - c);
        return [ hcg[0], 100 * (v - c), 100 * (1 - v) ];
      }, convert.hwb.hcg = function(hwb) {
        const w = hwb[1] / 100, v = 1 - hwb[2] / 100, c = v - w;
        let g = 0;
        return c < 1 && (g = (v - c) / (1 - c)), [ hwb[0], 100 * c, 100 * g ];
      }, convert.apple.rgb = function(apple) {
        return [ apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255 ];
      }, convert.rgb.apple = function(rgb) {
        return [ rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535 ];
      }, convert.gray.rgb = function(args) {
        return [ args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255 ];
      }, convert.gray.hsl = function(args) {
        return [ 0, 0, args[0] ];
      }, convert.gray.hsv = convert.gray.hsl, convert.gray.hwb = function(gray) {
        return [ 0, 100, gray[0] ];
      }, convert.gray.cmyk = function(gray) {
        return [ 0, 0, 0, gray[0] ];
      }, convert.gray.lab = function(gray) {
        return [ gray[0], 0, 0 ];
      }, convert.gray.hex = function(gray) {
        const val = 255 & Math.round(gray[0] / 100 * 255), string = ((val << 16) + (val << 8) + val).toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
      }, convert.rgb.gray = function(rgb) {
        return [ (rgb[0] + rgb[1] + rgb[2]) / 3 / 255 * 100 ];
      };
    },
    70319: (module, __unused_webpack_exports, __webpack_require__) => {
      const conversions = __webpack_require__(47072), route = __webpack_require__(96525), convert = {};
      Object.keys(conversions).forEach((fromModel => {
        convert[fromModel] = {}, Object.defineProperty(convert[fromModel], "channels", {
          value: conversions[fromModel].channels
        }), Object.defineProperty(convert[fromModel], "labels", {
          value: conversions[fromModel].labels
        });
        const routes = route(fromModel);
        Object.keys(routes).forEach((toModel => {
          const fn = routes[toModel];
          convert[fromModel][toModel] = function(fn) {
            const wrappedFn = function(...args) {
              const arg0 = args[0];
              if (null == arg0) return arg0;
              arg0.length > 1 && (args = arg0);
              const result = fn(args);
              if ("object" == typeof result) for (let len = result.length, i = 0; i < len; i++) result[i] = Math.round(result[i]);
              return result;
            };
            return "conversion" in fn && (wrappedFn.conversion = fn.conversion), wrappedFn;
          }(fn), convert[fromModel][toModel].raw = function(fn) {
            const wrappedFn = function(...args) {
              const arg0 = args[0];
              return null == arg0 ? arg0 : (arg0.length > 1 && (args = arg0), fn(args));
            };
            return "conversion" in fn && (wrappedFn.conversion = fn.conversion), wrappedFn;
          }(fn);
        }));
      })), module.exports = convert;
    },
    96525: (module, __unused_webpack_exports, __webpack_require__) => {
      const conversions = __webpack_require__(47072);
      function deriveBFS(fromModel) {
        const graph = function() {
          const graph = {}, models = Object.keys(conversions);
          for (let len = models.length, i = 0; i < len; i++) graph[models[i]] = {
            distance: -1,
            parent: null
          };
          return graph;
        }(), queue = [ fromModel ];
        for (graph[fromModel].distance = 0; queue.length; ) {
          const current = queue.pop(), adjacents = Object.keys(conversions[current]);
          for (let len = adjacents.length, i = 0; i < len; i++) {
            const adjacent = adjacents[i], node = graph[adjacent];
            -1 === node.distance && (node.distance = graph[current].distance + 1, node.parent = current, 
            queue.unshift(adjacent));
          }
        }
        return graph;
      }
      function link(from, to) {
        return function(args) {
          return to(from(args));
        };
      }
      function wrapConversion(toModel, graph) {
        const path = [ graph[toModel].parent, toModel ];
        let fn = conversions[graph[toModel].parent][toModel], cur = graph[toModel].parent;
        for (;graph[cur].parent; ) path.unshift(graph[cur].parent), fn = link(conversions[graph[cur].parent][cur], fn), 
        cur = graph[cur].parent;
        return fn.conversion = path, fn;
      }
      module.exports = function(fromModel) {
        const graph = deriveBFS(fromModel), conversion = {}, models = Object.keys(graph);
        for (let len = models.length, i = 0; i < len; i++) {
          const toModel = models[i];
          null !== graph[toModel].parent && (conversion[toModel] = wrapConversion(toModel, graph));
        }
        return conversion;
      };
    },
    23435: module => {
      "use strict";
      module.exports = {
        aliceblue: [ 240, 248, 255 ],
        antiquewhite: [ 250, 235, 215 ],
        aqua: [ 0, 255, 255 ],
        aquamarine: [ 127, 255, 212 ],
        azure: [ 240, 255, 255 ],
        beige: [ 245, 245, 220 ],
        bisque: [ 255, 228, 196 ],
        black: [ 0, 0, 0 ],
        blanchedalmond: [ 255, 235, 205 ],
        blue: [ 0, 0, 255 ],
        blueviolet: [ 138, 43, 226 ],
        brown: [ 165, 42, 42 ],
        burlywood: [ 222, 184, 135 ],
        cadetblue: [ 95, 158, 160 ],
        chartreuse: [ 127, 255, 0 ],
        chocolate: [ 210, 105, 30 ],
        coral: [ 255, 127, 80 ],
        cornflowerblue: [ 100, 149, 237 ],
        cornsilk: [ 255, 248, 220 ],
        crimson: [ 220, 20, 60 ],
        cyan: [ 0, 255, 255 ],
        darkblue: [ 0, 0, 139 ],
        darkcyan: [ 0, 139, 139 ],
        darkgoldenrod: [ 184, 134, 11 ],
        darkgray: [ 169, 169, 169 ],
        darkgreen: [ 0, 100, 0 ],
        darkgrey: [ 169, 169, 169 ],
        darkkhaki: [ 189, 183, 107 ],
        darkmagenta: [ 139, 0, 139 ],
        darkolivegreen: [ 85, 107, 47 ],
        darkorange: [ 255, 140, 0 ],
        darkorchid: [ 153, 50, 204 ],
        darkred: [ 139, 0, 0 ],
        darksalmon: [ 233, 150, 122 ],
        darkseagreen: [ 143, 188, 143 ],
        darkslateblue: [ 72, 61, 139 ],
        darkslategray: [ 47, 79, 79 ],
        darkslategrey: [ 47, 79, 79 ],
        darkturquoise: [ 0, 206, 209 ],
        darkviolet: [ 148, 0, 211 ],
        deeppink: [ 255, 20, 147 ],
        deepskyblue: [ 0, 191, 255 ],
        dimgray: [ 105, 105, 105 ],
        dimgrey: [ 105, 105, 105 ],
        dodgerblue: [ 30, 144, 255 ],
        firebrick: [ 178, 34, 34 ],
        floralwhite: [ 255, 250, 240 ],
        forestgreen: [ 34, 139, 34 ],
        fuchsia: [ 255, 0, 255 ],
        gainsboro: [ 220, 220, 220 ],
        ghostwhite: [ 248, 248, 255 ],
        gold: [ 255, 215, 0 ],
        goldenrod: [ 218, 165, 32 ],
        gray: [ 128, 128, 128 ],
        green: [ 0, 128, 0 ],
        greenyellow: [ 173, 255, 47 ],
        grey: [ 128, 128, 128 ],
        honeydew: [ 240, 255, 240 ],
        hotpink: [ 255, 105, 180 ],
        indianred: [ 205, 92, 92 ],
        indigo: [ 75, 0, 130 ],
        ivory: [ 255, 255, 240 ],
        khaki: [ 240, 230, 140 ],
        lavender: [ 230, 230, 250 ],
        lavenderblush: [ 255, 240, 245 ],
        lawngreen: [ 124, 252, 0 ],
        lemonchiffon: [ 255, 250, 205 ],
        lightblue: [ 173, 216, 230 ],
        lightcoral: [ 240, 128, 128 ],
        lightcyan: [ 224, 255, 255 ],
        lightgoldenrodyellow: [ 250, 250, 210 ],
        lightgray: [ 211, 211, 211 ],
        lightgreen: [ 144, 238, 144 ],
        lightgrey: [ 211, 211, 211 ],
        lightpink: [ 255, 182, 193 ],
        lightsalmon: [ 255, 160, 122 ],
        lightseagreen: [ 32, 178, 170 ],
        lightskyblue: [ 135, 206, 250 ],
        lightslategray: [ 119, 136, 153 ],
        lightslategrey: [ 119, 136, 153 ],
        lightsteelblue: [ 176, 196, 222 ],
        lightyellow: [ 255, 255, 224 ],
        lime: [ 0, 255, 0 ],
        limegreen: [ 50, 205, 50 ],
        linen: [ 250, 240, 230 ],
        magenta: [ 255, 0, 255 ],
        maroon: [ 128, 0, 0 ],
        mediumaquamarine: [ 102, 205, 170 ],
        mediumblue: [ 0, 0, 205 ],
        mediumorchid: [ 186, 85, 211 ],
        mediumpurple: [ 147, 112, 219 ],
        mediumseagreen: [ 60, 179, 113 ],
        mediumslateblue: [ 123, 104, 238 ],
        mediumspringgreen: [ 0, 250, 154 ],
        mediumturquoise: [ 72, 209, 204 ],
        mediumvioletred: [ 199, 21, 133 ],
        midnightblue: [ 25, 25, 112 ],
        mintcream: [ 245, 255, 250 ],
        mistyrose: [ 255, 228, 225 ],
        moccasin: [ 255, 228, 181 ],
        navajowhite: [ 255, 222, 173 ],
        navy: [ 0, 0, 128 ],
        oldlace: [ 253, 245, 230 ],
        olive: [ 128, 128, 0 ],
        olivedrab: [ 107, 142, 35 ],
        orange: [ 255, 165, 0 ],
        orangered: [ 255, 69, 0 ],
        orchid: [ 218, 112, 214 ],
        palegoldenrod: [ 238, 232, 170 ],
        palegreen: [ 152, 251, 152 ],
        paleturquoise: [ 175, 238, 238 ],
        palevioletred: [ 219, 112, 147 ],
        papayawhip: [ 255, 239, 213 ],
        peachpuff: [ 255, 218, 185 ],
        peru: [ 205, 133, 63 ],
        pink: [ 255, 192, 203 ],
        plum: [ 221, 160, 221 ],
        powderblue: [ 176, 224, 230 ],
        purple: [ 128, 0, 128 ],
        rebeccapurple: [ 102, 51, 153 ],
        red: [ 255, 0, 0 ],
        rosybrown: [ 188, 143, 143 ],
        royalblue: [ 65, 105, 225 ],
        saddlebrown: [ 139, 69, 19 ],
        salmon: [ 250, 128, 114 ],
        sandybrown: [ 244, 164, 96 ],
        seagreen: [ 46, 139, 87 ],
        seashell: [ 255, 245, 238 ],
        sienna: [ 160, 82, 45 ],
        silver: [ 192, 192, 192 ],
        skyblue: [ 135, 206, 235 ],
        slateblue: [ 106, 90, 205 ],
        slategray: [ 112, 128, 144 ],
        slategrey: [ 112, 128, 144 ],
        snow: [ 255, 250, 250 ],
        springgreen: [ 0, 255, 127 ],
        steelblue: [ 70, 130, 180 ],
        tan: [ 210, 180, 140 ],
        teal: [ 0, 128, 128 ],
        thistle: [ 216, 191, 216 ],
        tomato: [ 255, 99, 71 ],
        turquoise: [ 64, 224, 208 ],
        violet: [ 238, 130, 238 ],
        wheat: [ 245, 222, 179 ],
        white: [ 255, 255, 255 ],
        whitesmoke: [ 245, 245, 245 ],
        yellow: [ 255, 255, 0 ],
        yellowgreen: [ 154, 205, 50 ]
      };
    },
    75231: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var wcwidth = __webpack_require__(36167), _require = __webpack_require__(47771), padRight = _require.padRight, padCenter = _require.padCenter, padLeft = _require.padLeft, splitIntoLines = _require.splitIntoLines, splitLongWords = _require.splitLongWords, truncateString = _require.truncateString, DEFAULT_HEADING_TRANSFORM = function(key) {
        return key.toUpperCase();
      }, DEFAULTS = Object.freeze({
        maxWidth: 1 / 0,
        minWidth: 0,
        columnSplitter: " ",
        truncate: !1,
        truncateMarker: "",
        preserveNewLines: !1,
        paddingChr: " ",
        showHeaders: !0,
        headingTransform: DEFAULT_HEADING_TRANSFORM,
        dataTransform: function(cell, column, index) {
          return cell;
        }
      });
      function createRows(items, columns, columnNames, paddingChr) {
        return items.map((function(item) {
          var row = [], numLines = 0;
          columnNames.forEach((function(columnName) {
            numLines = Math.max(numLines, item[columnName].length);
          }));
          for (var _loop = function(i) {
            row[i] = row[i] || [], columnNames.forEach((function(columnName) {
              var column = columns[columnName], val = item[columnName][i] || "";
              "right" === column.align ? row[i].push(padLeft(val, column.width, paddingChr)) : "center" === column.align || "centre" === column.align ? row[i].push(padCenter(val, column.width, paddingChr)) : row[i].push(padRight(val, column.width, paddingChr));
            }));
          }, i = 0; i < numLines; i++) _loop(i);
          return row;
        }));
      }
      function mixin() {
        return Object.assign ? Object.assign.apply(Object, arguments) : ObjectAssign.apply(void 0, arguments);
      }
      function ObjectAssign(target, firstSource) {
        if (null == target) throw new TypeError("Cannot convert first argument to object");
        for (var pendingException, to = Object(target), hasPendingException = !1, i = 1; i < arguments.length; i++) {
          var nextSource = arguments[i];
          if (null != nextSource) {
            for (var keysArray = Object.keys(Object(nextSource)), nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
              var nextKey = keysArray[nextIndex];
              try {
                var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                void 0 !== desc && desc.enumerable && (to[nextKey] = nextSource[nextKey]);
              } catch (e) {
                hasPendingException || (hasPendingException = !0, pendingException = e);
              }
            }
            if (hasPendingException) throw pendingException;
          }
        }
        return to;
      }
      function endsWith(target, searchString, position) {
        position = position || target.length, position -= searchString.length;
        var lastIndex = target.lastIndexOf(searchString);
        return -1 !== lastIndex && lastIndex === position;
      }
      function toArray(items, columnNames) {
        if (Array.isArray(items)) return items;
        var rows = [];
        for (var key in items) {
          var item = {};
          item[columnNames[0] || "key"] = key, item[columnNames[1] || "value"] = items[key], 
          rows.push(item);
        }
        return rows;
      }
      module.exports = function(items) {
        var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, columnConfigs = options.config || {};
        delete options.config;
        var maxLineWidth = options.maxLineWidth || 1 / 0;
        "auto" === maxLineWidth && (maxLineWidth = process.stdout.columns || 1 / 0), delete options.maxLineWidth, 
        (options = mixin({}, DEFAULTS, options)).config = options.config || Object.create(null), 
        options.spacing = options.spacing || "\n", options.preserveNewLines = !!options.preserveNewLines, 
        options.showHeaders = !!options.showHeaders, options.columns = options.columns || options.include;
        var columnNames = options.columns || [];
        items = toArray(items, columnNames), columnNames.length || items.forEach((function(item) {
          for (var columnName in item) -1 === columnNames.indexOf(columnName) && columnNames.push(columnName);
        }));
        var columns = columnNames.reduce((function(columns, columnName) {
          var column = Object.create(options);
          return columns[columnName] = mixin(column, columnConfigs[columnName]), columns;
        }), Object.create(null));
        columnNames.forEach((function(columnName) {
          var column = columns[columnName];
          column.name = columnName, column.maxWidth = Math.ceil(column.maxWidth), column.minWidth = Math.ceil(column.minWidth), 
          column.truncate = !!column.truncate, column.align = column.align || "left";
        })), items = items.map((function(item) {
          var result = Object.create(null);
          return columnNames.forEach((function(columnName) {
            result[columnName] = null != item[columnName] ? item[columnName] : "", result[columnName] = "" + result[columnName], 
            columns[columnName].preserveNewLines ? result[columnName] = result[columnName].replace(/[^\S\n]/gim, " ") : result[columnName] = result[columnName].replace(/\s/gim, " ");
          })), result;
        })), columnNames.forEach((function(columnName) {
          var column = columns[columnName];
          items = items.map((function(item, index) {
            var col = Object.create(column);
            item[columnName] = column.dataTransform(item[columnName], col, index);
            var changedKeys = Object.keys(col);
            if (-1 !== changedKeys.indexOf("name")) {
              if (column.headingTransform !== DEFAULT_HEADING_TRANSFORM) return;
              column.headingTransform = function(heading) {
                return heading;
              };
            }
            return changedKeys.forEach((function(key) {
              return column[key] = col[key];
            })), item;
          }));
        }));
        var headers = {};
        options.showHeaders && (columnNames.forEach((function(columnName) {
          var column = columns[columnName];
          column.showHeaders ? headers[columnName] = column.headingTransform(column.name) : headers[columnName] = "";
        })), items.unshift(headers)), columnNames.forEach((function(columnName) {
          var column = columns[columnName];
          column.width = items.map((function(item) {
            return item[columnName];
          })).reduce((function(min, cur) {
            return min >= column.maxWidth ? min : Math.max(min, Math.min(column.maxWidth, Math.max(column.minWidth, wcwidth(cur))));
          }), 0);
        })), columnNames.forEach((function(columnName) {
          var column = columns[columnName];
          items = items.map((function(item) {
            return item[columnName] = splitLongWords(item[columnName], column.width, column.truncateMarker), 
            item;
          }));
        })), columnNames.forEach((function(columnName) {
          var column = columns[columnName];
          items = items.map((function(item, index) {
            var cell = item[columnName];
            (item[columnName] = splitIntoLines(cell, column.width), column.truncate && item[columnName].length > 1) && (item[columnName] = splitIntoLines(cell, column.width - wcwidth(column.truncateMarker)), 
            endsWith(item[columnName][0], column.truncateMarker) || (item[columnName][0] += column.truncateMarker), 
            item[columnName] = item[columnName].slice(0, 1));
            return item;
          }));
        })), columnNames.forEach((function(columnName) {
          var column = columns[columnName];
          column.width = items.map((function(item) {
            return item[columnName].reduce((function(min, cur) {
              return min >= column.maxWidth ? min : Math.max(min, Math.min(column.maxWidth, Math.max(column.minWidth, wcwidth(cur))));
            }), 0);
          })).reduce((function(min, cur) {
            return min >= column.maxWidth ? min : Math.max(min, Math.min(column.maxWidth, Math.max(column.minWidth, cur)));
          }), 0);
        }));
        var rows = createRows(items, columns, columnNames, options.paddingChr);
        return rows.reduce((function(output, row) {
          return output.concat(row.reduce((function(rowOut, line) {
            return rowOut.concat(line.join(options.columnSplitter));
          }), []));
        }), []).map((function(line) {
          return truncateString(line, maxLineWidth);
        })).join(options.spacing);
      };
    },
    47771: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var wcwidth = __webpack_require__(36167);
      function repeatString(str, len) {
        return Array.apply(null, {
          length: len + 1
        }).join(str).slice(0, len);
      }
      module.exports.padRight = function(str, max, chr) {
        str = null != str ? str : "", str = String(str);
        var length = max - wcwidth(str);
        return length <= 0 ? str : str + repeatString(chr || " ", length);
      }, module.exports.padCenter = function(str, max, chr) {
        str = null != str ? str : "", str = String(str);
        var length = max - wcwidth(str);
        if (length <= 0) return str;
        var lengthLeft = Math.floor(length / 2), lengthRight = length - lengthLeft;
        return repeatString(chr || " ", lengthLeft) + str + repeatString(chr || " ", lengthRight);
      }, module.exports.padLeft = function(str, max, chr) {
        str = null != str ? str : "", str = String(str);
        var length = max - wcwidth(str);
        return length <= 0 ? str : repeatString(chr || " ", length) + str;
      }, module.exports.splitIntoLines = function(str, max) {
        return str.split("\n").map((function(str) {
          return function(str, max) {
            return str.trim().split(" ").reduce((function(lines, word) {
              var line = lines[lines.length - 1];
              return line && wcwidth(line.join(" ")) + wcwidth(word) < max ? lines[lines.length - 1].push(word) : lines.push([ word ]), 
              lines;
            }), []).map((function(l) {
              return l.join(" ");
            }));
          }(str, max);
        })).reduce((function(lines, line) {
          return lines.concat(line);
        }), []);
      }, module.exports.splitLongWords = function(str, max, truncationChar) {
        for (var result = [], words = (str = str.trim()).split(" "), remainder = "", truncationWidth = wcwidth(truncationChar); remainder || words.length; ) {
          if (remainder) {
            var word = remainder;
            remainder = "";
          } else word = words.shift();
          if (wcwidth(word) > max) {
            for (var i = 0, wwidth = 0, limit = max - truncationWidth; i < word.length; ) {
              var w = wcwidth(word.charAt(i));
              if (w + wwidth > limit) break;
              wwidth += w, ++i;
            }
            remainder = word.slice(i), word = word.slice(0, i), word += truncationChar;
          }
          result.push(word);
        }
        return result.join(" ");
      }, module.exports.truncateString = function(str, max) {
        if (str = null != str ? str : "", str = String(str), max == 1 / 0) return str;
        for (var i = 0, wwidth = 0; i < str.length; ) {
          var w = wcwidth(str.charAt(i));
          if (w + wwidth > max) break;
          wwidth += w, ++i;
        }
        return str.slice(0, i);
      };
    },
    36167: (module, __unused_webpack_exports, __webpack_require__) => {
      var stripAnsi = __webpack_require__(42935), wcwidth = __webpack_require__(7656);
      module.exports = function(str) {
        return wcwidth(stripAnsi(str));
      };
    },
    43090: (module, __unused_webpack_exports, __webpack_require__) => {
      const {parse, sep, normalize: norm} = __webpack_require__(71017);
      function* commonArrayMembers(a, b) {
        const [l, s] = a.length > b.length ? [ a, b ] : [ b, a ];
        for (const x of s) {
          if (x !== l.shift()) break;
          yield x;
        }
      }
      const commonAncestorPath = (a, b) => a === b ? a : parse(a).root !== parse(b).root ? null : [ ...commonArrayMembers(norm(a).split(sep), norm(b).split(sep)) ].join(sep);
      module.exports = (...paths) => paths.reduce(commonAncestorPath);
    },
    26129: module => {
      "use strict";
      var hasOwnProperty = {}.hasOwnProperty, regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/, regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/, regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, cssesc = function cssesc(string, options) {
        "single" != (options = function(options, defaults) {
          if (!options) return defaults;
          var result = {};
          for (var key in defaults) result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
          return result;
        }(options, cssesc.options)).quotes && "double" != options.quotes && (options.quotes = "single");
        for (var quote = "double" == options.quotes ? '"' : "'", isIdentifier = options.isIdentifier, firstChar = string.charAt(0), output = "", counter = 0, length = string.length; counter < length; ) {
          var character = string.charAt(counter++), codePoint = character.charCodeAt(), value = void 0;
          if (codePoint < 32 || codePoint > 126) {
            if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
              var extra = string.charCodeAt(counter++);
              56320 == (64512 & extra) ? codePoint = ((1023 & codePoint) << 10) + (1023 & extra) + 65536 : counter--;
            }
            value = "\\" + codePoint.toString(16).toUpperCase() + " ";
          } else value = options.escapeEverything ? regexAnySingleEscape.test(character) ? "\\" + character : "\\" + codePoint.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(character) ? "\\" + codePoint.toString(16).toUpperCase() + " " : "\\" == character || !isIdentifier && ('"' == character && quote == character || "'" == character && quote == character) || isIdentifier && regexSingleEscape.test(character) ? "\\" + character : character;
          output += value;
        }
        return isIdentifier && (/^-[-\d]/.test(output) ? output = "\\-" + output.slice(1) : /\d/.test(firstChar) && (output = "\\3" + firstChar + " " + output.slice(1))), 
        output = output.replace(regexExcessiveSpaces, (function($0, $1, $2) {
          return $1 && $1.length % 2 ? $0 : ($1 || "") + $2;
        })), !isIdentifier && options.wrap ? quote + output + quote : output;
      };
      cssesc.options = {
        escapeEverything: !1,
        isIdentifier: !1,
        quotes: "single",
        wrap: !1
      }, cssesc.version = "3.0.0", module.exports = cssesc;
    },
    1468: (module, exports, __webpack_require__) => {
      var util = __webpack_require__(73837);
      module.exports = util && util.debuglog || function(set) {
        if (set = set.toUpperCase(), !debugs[set]) if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = util.format.apply(exports, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else debugs[set] = function() {};
        return debugs[set];
      };
      var debugs = {}, debugEnviron = process.env.NODE_DEBUG || "";
    },
    21338: (module, __unused_webpack_exports, __webpack_require__) => {
      var clone = __webpack_require__(6120);
      module.exports = function(options, defaults) {
        return options = options || {}, Object.keys(defaults).forEach((function(key) {
          void 0 === options[key] && (options[key] = clone(defaults[key]));
        })), options;
      };
    },
    21248: (module, __unused_webpack_exports, __webpack_require__) => {
      var wrappy = __webpack_require__(68839);
      module.exports = wrappy((function(cb) {
        var sync = !0;
        return asap((function() {
          sync = !1;
        })), function() {
          var args = arguments, me = this;
          sync ? asap((function() {
            cb.apply(me, args);
          })) : cb.apply(me, args);
        };
      }));
      var asap = __webpack_require__(40574);
    },
    60957: module => {
      "use strict";
      module.exports = function() {
        return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
      };
    },
    50141: module => {
      "use strict";
      function assign(obj, props) {
        for (const key in props) Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: !0,
          configurable: !0
        });
        return obj;
      }
      module.exports = function(err, code, props) {
        if (!err || "string" == typeof err) throw new TypeError("Please pass an Error to err-code");
        props || (props = {}), "object" == typeof code && (props = code, code = void 0), 
        null != code && (props.code = code);
        try {
          return assign(err, props);
        } catch (_) {
          props.message = err.message, props.stack = err.stack;
          const ErrClass = function() {};
          return ErrClass.prototype = Object.create(Object.getPrototypeOf(err)), assign(new ErrClass, props);
        }
      };
    },
    18787: module => {
      "use strict";
      const peq = new Uint32Array(65536), distance = (a, b) => {
        if (a.length > b.length) {
          const tmp = b;
          b = a, a = tmp;
        }
        return 0 === a.length ? b.length : a.length <= 32 ? ((a, b) => {
          const n = a.length, m = b.length, lst = 1 << n - 1;
          let pv = -1, mv = 0, sc = n, i = n;
          for (;i--; ) peq[a.charCodeAt(i)] |= 1 << i;
          for (i = 0; i < m; i++) {
            let eq = peq[b.charCodeAt(i)];
            const xv = eq | mv;
            eq |= (eq & pv) + pv ^ pv, mv |= ~(eq | pv), pv &= eq, mv & lst && sc++, pv & lst && sc--, 
            mv = mv << 1 | 1, pv = pv << 1 | ~(xv | mv), mv &= xv;
          }
          for (i = n; i--; ) peq[a.charCodeAt(i)] = 0;
          return sc;
        })(a, b) : ((a, b) => {
          const n = a.length, m = b.length, mhc = [], phc = [], hsize = Math.ceil(n / 32), vsize = Math.ceil(m / 32);
          let score = m;
          for (let i = 0; i < hsize; i++) phc[i] = -1, mhc[i] = 0;
          let j = 0;
          for (;j < vsize - 1; j++) {
            let mv = 0, pv = -1;
            const start = 32 * j, end = Math.min(32, m) + start;
            for (let k = start; k < end; k++) peq[b.charCodeAt(k)] |= 1 << k;
            score = m;
            for (let i = 0; i < n; i++) {
              const eq = peq[a.charCodeAt(i)], pb = phc[i / 32 | 0] >>> i & 1, mb = mhc[i / 32 | 0] >>> i & 1, xv = eq | mv, xh = ((eq | mb) & pv) + pv ^ pv | eq | mb;
              let ph = mv | ~(xh | pv), mh = pv & xh;
              ph >>> 31 ^ pb && (phc[i / 32 | 0] ^= 1 << i), mh >>> 31 ^ mb && (mhc[i / 32 | 0] ^= 1 << i), 
              ph = ph << 1 | pb, mh = mh << 1 | mb, pv = mh | ~(xv | ph), mv = ph & xv;
            }
            for (let k = start; k < end; k++) peq[b.charCodeAt(k)] = 0;
          }
          let mv = 0, pv = -1;
          const start = 32 * j, end = Math.min(32, m - start) + start;
          for (let k = start; k < end; k++) peq[b.charCodeAt(k)] |= 1 << k;
          score = m;
          for (let i = 0; i < n; i++) {
            const eq = peq[a.charCodeAt(i)], pb = phc[i / 32 | 0] >>> i & 1, mb = mhc[i / 32 | 0] >>> i & 1, xv = eq | mv, xh = ((eq | mb) & pv) + pv ^ pv | eq | mb;
            let ph = mv | ~(xh | pv), mh = pv & xh;
            score += ph >>> m - 1 & 1, score -= mh >>> m - 1 & 1, ph >>> 31 ^ pb && (phc[i / 32 | 0] ^= 1 << i), 
            mh >>> 31 ^ mb && (mhc[i / 32 | 0] ^= 1 << i), ph = ph << 1 | pb, mh = mh << 1 | mb, 
            pv = mh | ~(xv | ph), mv = ph & xv;
          }
          for (let k = start; k < end; k++) peq[b.charCodeAt(k)] = 0;
          return score;
        })(a, b);
      };
      module.exports = {
        closest: (str, arr) => {
          let min_distance = 1 / 0, min_index = 0;
          for (let i = 0; i < arr.length; i++) {
            const dist = distance(str, arr[i]);
            dist < min_distance && (min_distance = dist, min_index = i);
          }
          return arr[min_index];
        },
        distance
      };
    },
    33975: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      const MiniPass = __webpack_require__(45018), EE = __webpack_require__(82361).EventEmitter, fs = __webpack_require__(57147);
      let writev = fs.writev;
      if (!writev) {
        const binding = process.binding("fs"), FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;
        writev = (fd, iovec, pos, cb) => {
          const req = new FSReqWrap;
          req.oncomplete = (er, bw) => cb(er, bw, iovec), binding.writeBuffers(fd, iovec, pos, req);
        };
      }
      const _autoClose = Symbol("_autoClose"), _close = Symbol("_close"), _ended = Symbol("_ended"), _fd = Symbol("_fd"), _finished = Symbol("_finished"), _flags = Symbol("_flags"), _flush = Symbol("_flush"), _handleChunk = Symbol("_handleChunk"), _makeBuf = Symbol("_makeBuf"), _mode = Symbol("_mode"), _needDrain = Symbol("_needDrain"), _onerror = Symbol("_onerror"), _onopen = Symbol("_onopen"), _onread = Symbol("_onread"), _onwrite = Symbol("_onwrite"), _open = Symbol("_open"), _path = Symbol("_path"), _pos = Symbol("_pos"), _queue = Symbol("_queue"), _read = Symbol("_read"), _readSize = Symbol("_readSize"), _reading = Symbol("_reading"), _remain = Symbol("_remain"), _size = Symbol("_size"), _write = Symbol("_write"), _writing = Symbol("_writing"), _defaultFlag = Symbol("_defaultFlag"), _errored = Symbol("_errored");
      class ReadStream extends MiniPass {
        constructor(path, opt) {
          if (super(opt = opt || {}), this.readable = !0, this.writable = !1, "string" != typeof path) throw new TypeError("path must be a string");
          this[_errored] = !1, this[_fd] = "number" == typeof opt.fd ? opt.fd : null, this[_path] = path, 
          this[_readSize] = opt.readSize || 16777216, this[_reading] = !1, this[_size] = "number" == typeof opt.size ? opt.size : 1 / 0, 
          this[_remain] = this[_size], this[_autoClose] = "boolean" != typeof opt.autoClose || opt.autoClose, 
          "number" == typeof this[_fd] ? this[_read]() : this[_open]();
        }
        get fd() {
          return this[_fd];
        }
        get path() {
          return this[_path];
        }
        write() {
          throw new TypeError("this is a readable stream");
        }
        end() {
          throw new TypeError("this is a readable stream");
        }
        [_open]() {
          fs.open(this[_path], "r", ((er, fd) => this[_onopen](er, fd)));
        }
        [_onopen](er, fd) {
          er ? this[_onerror](er) : (this[_fd] = fd, this.emit("open", fd), this[_read]());
        }
        [_makeBuf]() {
          return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
        }
        [_read]() {
          if (!this[_reading]) {
            this[_reading] = !0;
            const buf = this[_makeBuf]();
            if (0 === buf.length) return process.nextTick((() => this[_onread](null, 0, buf)));
            fs.read(this[_fd], buf, 0, buf.length, null, ((er, br, buf) => this[_onread](er, br, buf)));
          }
        }
        [_onread](er, br, buf) {
          this[_reading] = !1, er ? this[_onerror](er) : this[_handleChunk](br, buf) && this[_read]();
        }
        [_close]() {
          if (this[_autoClose] && "number" == typeof this[_fd]) {
            const fd = this[_fd];
            this[_fd] = null, fs.close(fd, (er => er ? this.emit("error", er) : this.emit("close")));
          }
        }
        [_onerror](er) {
          this[_reading] = !0, this[_close](), this.emit("error", er);
        }
        [_handleChunk](br, buf) {
          let ret = !1;
          return this[_remain] -= br, br > 0 && (ret = super.write(br < buf.length ? buf.slice(0, br) : buf)), 
          (0 === br || this[_remain] <= 0) && (ret = !1, this[_close](), super.end()), ret;
        }
        emit(ev, data) {
          switch (ev) {
           case "prefinish":
           case "finish":
            break;

           case "drain":
            "number" == typeof this[_fd] && this[_read]();
            break;

           case "error":
            if (this[_errored]) return;
            return this[_errored] = !0, super.emit(ev, data);

           default:
            return super.emit(ev, data);
          }
        }
      }
      class WriteStream extends EE {
        constructor(path, opt) {
          super(opt = opt || {}), this.readable = !1, this.writable = !0, this[_errored] = !1, 
          this[_writing] = !1, this[_ended] = !1, this[_needDrain] = !1, this[_queue] = [], 
          this[_path] = path, this[_fd] = "number" == typeof opt.fd ? opt.fd : null, this[_mode] = void 0 === opt.mode ? 438 : opt.mode, 
          this[_pos] = "number" == typeof opt.start ? opt.start : null, this[_autoClose] = "boolean" != typeof opt.autoClose || opt.autoClose;
          const defaultFlag = null !== this[_pos] ? "r+" : "w";
          this[_defaultFlag] = void 0 === opt.flags, this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags, 
          null === this[_fd] && this[_open]();
        }
        emit(ev, data) {
          if ("error" === ev) {
            if (this[_errored]) return;
            this[_errored] = !0;
          }
          return super.emit(ev, data);
        }
        get fd() {
          return this[_fd];
        }
        get path() {
          return this[_path];
        }
        [_onerror](er) {
          this[_close](), this[_writing] = !0, this.emit("error", er);
        }
        [_open]() {
          fs.open(this[_path], this[_flags], this[_mode], ((er, fd) => this[_onopen](er, fd)));
        }
        [_onopen](er, fd) {
          this[_defaultFlag] && "r+" === this[_flags] && er && "ENOENT" === er.code ? (this[_flags] = "w", 
          this[_open]()) : er ? this[_onerror](er) : (this[_fd] = fd, this.emit("open", fd), 
          this[_flush]());
        }
        end(buf, enc) {
          return buf && this.write(buf, enc), this[_ended] = !0, this[_writing] || this[_queue].length || "number" != typeof this[_fd] || this[_onwrite](null, 0), 
          this;
        }
        write(buf, enc) {
          return "string" == typeof buf && (buf = Buffer.from(buf, enc)), this[_ended] ? (this.emit("error", new Error("write() after end()")), 
          !1) : null === this[_fd] || this[_writing] || this[_queue].length ? (this[_queue].push(buf), 
          this[_needDrain] = !0, !1) : (this[_writing] = !0, this[_write](buf), !0);
        }
        [_write](buf) {
          fs.write(this[_fd], buf, 0, buf.length, this[_pos], ((er, bw) => this[_onwrite](er, bw)));
        }
        [_onwrite](er, bw) {
          er ? this[_onerror](er) : (null !== this[_pos] && (this[_pos] += bw), this[_queue].length ? this[_flush]() : (this[_writing] = !1, 
          this[_ended] && !this[_finished] ? (this[_finished] = !0, this[_close](), this.emit("finish")) : this[_needDrain] && (this[_needDrain] = !1, 
          this.emit("drain"))));
        }
        [_flush]() {
          if (0 === this[_queue].length) this[_ended] && this[_onwrite](null, 0); else if (1 === this[_queue].length) this[_write](this[_queue].pop()); else {
            const iovec = this[_queue];
            this[_queue] = [], writev(this[_fd], iovec, this[_pos], ((er, bw) => this[_onwrite](er, bw)));
          }
        }
        [_close]() {
          if (this[_autoClose] && "number" == typeof this[_fd]) {
            const fd = this[_fd];
            this[_fd] = null, fs.close(fd, (er => er ? this.emit("error", er) : this.emit("close")));
          }
        }
      }
      exports.ReadStream = ReadStream, exports.ReadStreamSync = class extends ReadStream {
        [_open]() {
          let threw = !0;
          try {
            this[_onopen](null, fs.openSync(this[_path], "r")), threw = !1;
          } finally {
            threw && this[_close]();
          }
        }
        [_read]() {
          let threw = !0;
          try {
            if (!this[_reading]) {
              for (this[_reading] = !0; ;) {
                const buf = this[_makeBuf](), br = 0 === buf.length ? 0 : fs.readSync(this[_fd], buf, 0, buf.length, null);
                if (!this[_handleChunk](br, buf)) break;
              }
              this[_reading] = !1;
            }
            threw = !1;
          } finally {
            threw && this[_close]();
          }
        }
        [_close]() {
          if (this[_autoClose] && "number" == typeof this[_fd]) {
            const fd = this[_fd];
            this[_fd] = null, fs.closeSync(fd), this.emit("close");
          }
        }
      }, exports.WriteStream = WriteStream, exports.WriteStreamSync = class extends WriteStream {
        [_open]() {
          let fd;
          if (this[_defaultFlag] && "r+" === this[_flags]) try {
            fd = fs.openSync(this[_path], this[_flags], this[_mode]);
          } catch (er) {
            if ("ENOENT" === er.code) return this[_flags] = "w", this[_open]();
            throw er;
          } else fd = fs.openSync(this[_path], this[_flags], this[_mode]);
          this[_onopen](null, fd);
        }
        [_close]() {
          if (this[_autoClose] && "number" == typeof this[_fd]) {
            const fd = this[_fd];
            this[_fd] = null, fs.closeSync(fd), this.emit("close");
          }
        }
        [_write](buf) {
          let threw = !0;
          try {
            this[_onwrite](null, fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos])), threw = !1;
          } finally {
            if (threw) try {
              this[_close]();
            } catch (_) {}
          }
        }
      };
    },
    59543: module => {
      "use strict";
      module.exports = function(obj) {
        if (null === obj || "object" != typeof obj) return obj;
        if (obj instanceof Object) var copy = {
          __proto__: getPrototypeOf(obj)
        }; else copy = Object.create(null);
        return Object.getOwnPropertyNames(obj).forEach((function(key) {
          Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
        })), copy;
      };
      var getPrototypeOf = Object.getPrototypeOf || function(obj) {
        return obj.__proto__;
      };
    },
    49809: (module, __unused_webpack_exports, __webpack_require__) => {
      var gracefulQueue, previousSymbol, fs = __webpack_require__(57147), polyfills = __webpack_require__(17529), legacy = __webpack_require__(66454), clone = __webpack_require__(59543), util = __webpack_require__(73837);
      function publishQueue(context, queue) {
        Object.defineProperty(context, gracefulQueue, {
          get: function() {
            return queue;
          }
        });
      }
      "function" == typeof Symbol && "function" == typeof Symbol.for ? (gracefulQueue = Symbol.for("graceful-fs.queue"), 
      previousSymbol = Symbol.for("graceful-fs.previous")) : (gracefulQueue = "___graceful-fs.queue", 
      previousSymbol = "___graceful-fs.previous");
      var retryTimer, debug = function() {};
      if (util.debuglog ? debug = util.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (debug = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: "), console.error(m);
      }), !fs[gracefulQueue]) {
        var queue = global[gracefulQueue] || [];
        publishQueue(fs, queue), fs.close = function(fs$close) {
          function close(fd, cb) {
            return fs$close.call(fs, fd, (function(err) {
              err || resetQueue(), "function" == typeof cb && cb.apply(this, arguments);
            }));
          }
          return Object.defineProperty(close, previousSymbol, {
            value: fs$close
          }), close;
        }(fs.close), fs.closeSync = function(fs$closeSync) {
          function closeSync(fd) {
            fs$closeSync.apply(fs, arguments), resetQueue();
          }
          return Object.defineProperty(closeSync, previousSymbol, {
            value: fs$closeSync
          }), closeSync;
        }(fs.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", (function() {
          debug(fs[gracefulQueue]), __webpack_require__(39491).equal(fs[gracefulQueue].length, 0);
        }));
      }
      function patch(fs) {
        polyfills(fs), fs.gracefulify = patch, fs.createReadStream = function(path, options) {
          return new fs.ReadStream(path, options);
        }, fs.createWriteStream = function(path, options) {
          return new fs.WriteStream(path, options);
        };
        var fs$readFile = fs.readFile;
        fs.readFile = function(path, options, cb) {
          "function" == typeof options && (cb = options, options = null);
          return function go$readFile(path, options, cb, startTime) {
            return fs$readFile(path, options, (function(err) {
              !err || "EMFILE" !== err.code && "ENFILE" !== err.code ? "function" == typeof cb && cb.apply(this, arguments) : enqueue([ go$readFile, [ path, options, cb ], err, startTime || Date.now(), Date.now() ]);
            }));
          }(path, options, cb);
        };
        var fs$writeFile = fs.writeFile;
        fs.writeFile = function(path, data, options, cb) {
          "function" == typeof options && (cb = options, options = null);
          return function go$writeFile(path, data, options, cb, startTime) {
            return fs$writeFile(path, data, options, (function(err) {
              !err || "EMFILE" !== err.code && "ENFILE" !== err.code ? "function" == typeof cb && cb.apply(this, arguments) : enqueue([ go$writeFile, [ path, data, options, cb ], err, startTime || Date.now(), Date.now() ]);
            }));
          }(path, data, options, cb);
        };
        var fs$appendFile = fs.appendFile;
        fs$appendFile && (fs.appendFile = function(path, data, options, cb) {
          "function" == typeof options && (cb = options, options = null);
          return function go$appendFile(path, data, options, cb, startTime) {
            return fs$appendFile(path, data, options, (function(err) {
              !err || "EMFILE" !== err.code && "ENFILE" !== err.code ? "function" == typeof cb && cb.apply(this, arguments) : enqueue([ go$appendFile, [ path, data, options, cb ], err, startTime || Date.now(), Date.now() ]);
            }));
          }(path, data, options, cb);
        });
        var fs$copyFile = fs.copyFile;
        fs$copyFile && (fs.copyFile = function(src, dest, flags, cb) {
          "function" == typeof flags && (cb = flags, flags = 0);
          return function go$copyFile(src, dest, flags, cb, startTime) {
            return fs$copyFile(src, dest, flags, (function(err) {
              !err || "EMFILE" !== err.code && "ENFILE" !== err.code ? "function" == typeof cb && cb.apply(this, arguments) : enqueue([ go$copyFile, [ src, dest, flags, cb ], err, startTime || Date.now(), Date.now() ]);
            }));
          }(src, dest, flags, cb);
        });
        var fs$readdir = fs.readdir;
        fs.readdir = function(path, options, cb) {
          "function" == typeof options && (cb = options, options = null);
          var go$readdir = noReaddirOptionVersions.test(process.version) ? function(path, options, cb, startTime) {
            return fs$readdir(path, fs$readdirCallback(path, options, cb, startTime));
          } : function(path, options, cb, startTime) {
            return fs$readdir(path, options, fs$readdirCallback(path, options, cb, startTime));
          };
          return go$readdir(path, options, cb);
          function fs$readdirCallback(path, options, cb, startTime) {
            return function(err, files) {
              !err || "EMFILE" !== err.code && "ENFILE" !== err.code ? (files && files.sort && files.sort(), 
              "function" == typeof cb && cb.call(this, err, files)) : enqueue([ go$readdir, [ path, options, cb ], err, startTime || Date.now(), Date.now() ]);
            };
          }
        };
        var noReaddirOptionVersions = /^v[0-5]\./;
        if ("v0.8" === process.version.substr(0, 4)) {
          var legStreams = legacy(fs);
          ReadStream = legStreams.ReadStream, WriteStream = legStreams.WriteStream;
        }
        var fs$ReadStream = fs.ReadStream;
        fs$ReadStream && (ReadStream.prototype = Object.create(fs$ReadStream.prototype), 
        ReadStream.prototype.open = function() {
          var that = this;
          open(that.path, that.flags, that.mode, (function(err, fd) {
            err ? (that.autoClose && that.destroy(), that.emit("error", err)) : (that.fd = fd, 
            that.emit("open", fd), that.read());
          }));
        });
        var fs$WriteStream = fs.WriteStream;
        fs$WriteStream && (WriteStream.prototype = Object.create(fs$WriteStream.prototype), 
        WriteStream.prototype.open = function() {
          var that = this;
          open(that.path, that.flags, that.mode, (function(err, fd) {
            err ? (that.destroy(), that.emit("error", err)) : (that.fd = fd, that.emit("open", fd));
          }));
        }), Object.defineProperty(fs, "ReadStream", {
          get: function() {
            return ReadStream;
          },
          set: function(val) {
            ReadStream = val;
          },
          enumerable: !0,
          configurable: !0
        }), Object.defineProperty(fs, "WriteStream", {
          get: function() {
            return WriteStream;
          },
          set: function(val) {
            WriteStream = val;
          },
          enumerable: !0,
          configurable: !0
        });
        var FileReadStream = ReadStream;
        Object.defineProperty(fs, "FileReadStream", {
          get: function() {
            return FileReadStream;
          },
          set: function(val) {
            FileReadStream = val;
          },
          enumerable: !0,
          configurable: !0
        });
        var FileWriteStream = WriteStream;
        function ReadStream(path, options) {
          return this instanceof ReadStream ? (fs$ReadStream.apply(this, arguments), this) : ReadStream.apply(Object.create(ReadStream.prototype), arguments);
        }
        function WriteStream(path, options) {
          return this instanceof WriteStream ? (fs$WriteStream.apply(this, arguments), this) : WriteStream.apply(Object.create(WriteStream.prototype), arguments);
        }
        Object.defineProperty(fs, "FileWriteStream", {
          get: function() {
            return FileWriteStream;
          },
          set: function(val) {
            FileWriteStream = val;
          },
          enumerable: !0,
          configurable: !0
        });
        var fs$open = fs.open;
        function open(path, flags, mode, cb) {
          return "function" == typeof mode && (cb = mode, mode = null), function go$open(path, flags, mode, cb, startTime) {
            return fs$open(path, flags, mode, (function(err, fd) {
              !err || "EMFILE" !== err.code && "ENFILE" !== err.code ? "function" == typeof cb && cb.apply(this, arguments) : enqueue([ go$open, [ path, flags, mode, cb ], err, startTime || Date.now(), Date.now() ]);
            }));
          }(path, flags, mode, cb);
        }
        return fs.open = open, fs;
      }
      function enqueue(elem) {
        debug("ENQUEUE", elem[0].name, elem[1]), fs[gracefulQueue].push(elem), retry();
      }
      function resetQueue() {
        for (var now = Date.now(), i = 0; i < fs[gracefulQueue].length; ++i) fs[gracefulQueue][i].length > 2 && (fs[gracefulQueue][i][3] = now, 
        fs[gracefulQueue][i][4] = now);
        retry();
      }
      function retry() {
        if (clearTimeout(retryTimer), retryTimer = void 0, 0 !== fs[gracefulQueue].length) {
          var elem = fs[gracefulQueue].shift(), fn = elem[0], args = elem[1], err = elem[2], startTime = elem[3], lastTime = elem[4];
          if (void 0 === startTime) debug("RETRY", fn.name, args), fn.apply(null, args); else if (Date.now() - startTime >= 6e4) {
            debug("TIMEOUT", fn.name, args);
            var cb = args.pop();
            "function" == typeof cb && cb.call(null, err);
          } else {
            var sinceAttempt = Date.now() - lastTime, sinceStart = Math.max(lastTime - startTime, 1);
            sinceAttempt >= Math.min(1.2 * sinceStart, 100) ? (debug("RETRY", fn.name, args), 
            fn.apply(null, args.concat([ startTime ]))) : fs[gracefulQueue].push(elem);
          }
          void 0 === retryTimer && (retryTimer = setTimeout(retry, 0));
        }
      }
      global[gracefulQueue] || publishQueue(global, fs[gracefulQueue]), module.exports = patch(clone(fs)), 
      process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched && (module.exports = patch(fs), 
      fs.__patched = !0);
    },
    66454: (module, __unused_webpack_exports, __webpack_require__) => {
      var Stream = __webpack_require__(12781).Stream;
      module.exports = function(fs) {
        return {
          ReadStream: function ReadStream(path, options) {
            if (!(this instanceof ReadStream)) return new ReadStream(path, options);
            Stream.call(this);
            var self = this;
            this.path = path, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", 
            this.mode = 438, this.bufferSize = 65536, options = options || {};
            for (var keys = Object.keys(options), index = 0, length = keys.length; index < length; index++) {
              var key = keys[index];
              this[key] = options[key];
            }
            this.encoding && this.setEncoding(this.encoding);
            if (void 0 !== this.start) {
              if ("number" != typeof this.start) throw TypeError("start must be a Number");
              if (void 0 === this.end) this.end = 1 / 0; else if ("number" != typeof this.end) throw TypeError("end must be a Number");
              if (this.start > this.end) throw new Error("start must be <= end");
              this.pos = this.start;
            }
            if (null !== this.fd) return void process.nextTick((function() {
              self._read();
            }));
            fs.open(this.path, this.flags, this.mode, (function(err, fd) {
              if (err) return self.emit("error", err), void (self.readable = !1);
              self.fd = fd, self.emit("open", fd), self._read();
            }));
          },
          WriteStream: function WriteStream(path, options) {
            if (!(this instanceof WriteStream)) return new WriteStream(path, options);
            Stream.call(this), this.path = path, this.fd = null, this.writable = !0, this.flags = "w", 
            this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, options = options || {};
            for (var keys = Object.keys(options), index = 0, length = keys.length; index < length; index++) {
              var key = keys[index];
              this[key] = options[key];
            }
            if (void 0 !== this.start) {
              if ("number" != typeof this.start) throw TypeError("start must be a Number");
              if (this.start < 0) throw new Error("start must be >= zero");
              this.pos = this.start;
            }
            this.busy = !1, this._queue = [], null === this.fd && (this._open = fs.open, this._queue.push([ this._open, this.path, this.flags, this.mode, void 0 ]), 
            this.flush());
          }
        };
      };
    },
    17529: (module, __unused_webpack_exports, __webpack_require__) => {
      var constants = __webpack_require__(22057), origCwd = process.cwd, cwd = null, platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
      process.cwd = function() {
        return cwd || (cwd = origCwd.call(process)), cwd;
      };
      try {
        process.cwd();
      } catch (er) {}
      if ("function" == typeof process.chdir) {
        var chdir = process.chdir;
        process.chdir = function(d) {
          cwd = null, chdir.call(process, d);
        }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, chdir);
      }
      module.exports = function(fs) {
        constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && function(fs) {
          fs.lchmod = function(path, mode, callback) {
            fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, (function(err, fd) {
              err ? callback && callback(err) : fs.fchmod(fd, mode, (function(err) {
                fs.close(fd, (function(err2) {
                  callback && callback(err || err2);
                }));
              }));
            }));
          }, fs.lchmodSync = function(path, mode) {
            var ret, fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode), threw = !0;
            try {
              ret = fs.fchmodSync(fd, mode), threw = !1;
            } finally {
              if (threw) try {
                fs.closeSync(fd);
              } catch (er) {} else fs.closeSync(fd);
            }
            return ret;
          };
        }(fs);
        fs.lutimes || function(fs) {
          constants.hasOwnProperty("O_SYMLINK") && fs.futimes ? (fs.lutimes = function(path, at, mt, cb) {
            fs.open(path, constants.O_SYMLINK, (function(er, fd) {
              er ? cb && cb(er) : fs.futimes(fd, at, mt, (function(er) {
                fs.close(fd, (function(er2) {
                  cb && cb(er || er2);
                }));
              }));
            }));
          }, fs.lutimesSync = function(path, at, mt) {
            var ret, fd = fs.openSync(path, constants.O_SYMLINK), threw = !0;
            try {
              ret = fs.futimesSync(fd, at, mt), threw = !1;
            } finally {
              if (threw) try {
                fs.closeSync(fd);
              } catch (er) {} else fs.closeSync(fd);
            }
            return ret;
          }) : fs.futimes && (fs.lutimes = function(_a, _b, _c, cb) {
            cb && process.nextTick(cb);
          }, fs.lutimesSync = function() {});
        }(fs);
        fs.chown = chownFix(fs.chown), fs.fchown = chownFix(fs.fchown), fs.lchown = chownFix(fs.lchown), 
        fs.chmod = chmodFix(fs.chmod), fs.fchmod = chmodFix(fs.fchmod), fs.lchmod = chmodFix(fs.lchmod), 
        fs.chownSync = chownFixSync(fs.chownSync), fs.fchownSync = chownFixSync(fs.fchownSync), 
        fs.lchownSync = chownFixSync(fs.lchownSync), fs.chmodSync = chmodFixSync(fs.chmodSync), 
        fs.fchmodSync = chmodFixSync(fs.fchmodSync), fs.lchmodSync = chmodFixSync(fs.lchmodSync), 
        fs.stat = statFix(fs.stat), fs.fstat = statFix(fs.fstat), fs.lstat = statFix(fs.lstat), 
        fs.statSync = statFixSync(fs.statSync), fs.fstatSync = statFixSync(fs.fstatSync), 
        fs.lstatSync = statFixSync(fs.lstatSync), fs.chmod && !fs.lchmod && (fs.lchmod = function(path, mode, cb) {
          cb && process.nextTick(cb);
        }, fs.lchmodSync = function() {});
        fs.chown && !fs.lchown && (fs.lchown = function(path, uid, gid, cb) {
          cb && process.nextTick(cb);
        }, fs.lchownSync = function() {});
        "win32" === platform && (fs.rename = "function" != typeof fs.rename ? fs.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now(), backoff = 0;
            fs$rename(from, to, (function CB(er) {
              if (er && ("EACCES" === er.code || "EPERM" === er.code) && Date.now() - start < 6e4) return setTimeout((function() {
                fs.stat(to, (function(stater, st) {
                  stater && "ENOENT" === stater.code ? fs$rename(from, to, CB) : cb(er);
                }));
              }), backoff), void (backoff < 100 && (backoff += 10));
              cb && cb(er);
            }));
          }
          return Object.setPrototypeOf && Object.setPrototypeOf(rename, fs$rename), rename;
        }(fs.rename));
        function chmodFix(orig) {
          return orig ? function(target, mode, cb) {
            return orig.call(fs, target, mode, (function(er) {
              chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
            }));
          } : orig;
        }
        function chmodFixSync(orig) {
          return orig ? function(target, mode) {
            try {
              return orig.call(fs, target, mode);
            } catch (er) {
              if (!chownErOk(er)) throw er;
            }
          } : orig;
        }
        function chownFix(orig) {
          return orig ? function(target, uid, gid, cb) {
            return orig.call(fs, target, uid, gid, (function(er) {
              chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
            }));
          } : orig;
        }
        function chownFixSync(orig) {
          return orig ? function(target, uid, gid) {
            try {
              return orig.call(fs, target, uid, gid);
            } catch (er) {
              if (!chownErOk(er)) throw er;
            }
          } : orig;
        }
        function statFix(orig) {
          return orig ? function(target, options, cb) {
            function callback(er, stats) {
              stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), 
              cb && cb.apply(this, arguments);
            }
            return "function" == typeof options && (cb = options, options = null), options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
          } : orig;
        }
        function statFixSync(orig) {
          return orig ? function(target, options) {
            var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
            return stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), 
            stats;
          } : orig;
        }
        function chownErOk(er) {
          return !er || ("ENOSYS" === er.code || !(process.getuid && 0 === process.getuid() || "EINVAL" !== er.code && "EPERM" !== er.code));
        }
        fs.read = "function" != typeof fs.read ? fs.read : function(fs$read) {
          function read(fd, buffer, offset, length, position, callback_) {
            var callback;
            if (callback_ && "function" == typeof callback_) {
              var eagCounter = 0;
              callback = function(er, _, __) {
                if (er && "EAGAIN" === er.code && eagCounter < 10) return eagCounter++, fs$read.call(fs, fd, buffer, offset, length, position, callback);
                callback_.apply(this, arguments);
              };
            }
            return fs$read.call(fs, fd, buffer, offset, length, position, callback);
          }
          return Object.setPrototypeOf && Object.setPrototypeOf(read, fs$read), read;
        }(fs.read), fs.readSync = "function" != typeof fs.readSync ? fs.readSync : (fs$readSync = fs.readSync, 
        function(fd, buffer, offset, length, position) {
          for (var eagCounter = 0; ;) try {
            return fs$readSync.call(fs, fd, buffer, offset, length, position);
          } catch (er) {
            if ("EAGAIN" === er.code && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
        });
        var fs$readSync;
      };
    },
    47682: module => {
      "use strict";
      module.exports = (flag, argv = process.argv) => {
        const prefix = flag.startsWith("-") ? "" : 1 === flag.length ? "-" : "--", position = argv.indexOf(prefix + flag), terminatorPosition = argv.indexOf("--");
        return -1 !== position && (-1 === terminatorPosition || position < terminatorPosition);
      };
    },
    45537: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const fs = __webpack_require__(57147), path = __webpack_require__(71017), EE = __webpack_require__(82361).EventEmitter, Minimatch = __webpack_require__(51191).Minimatch;
      class Walker extends EE {
        constructor(opts) {
          super(opts = opts || {}), this.isSymbolicLink = opts.isSymbolicLink, this.path = opts.path || process.cwd(), 
          this.basename = path.basename(this.path), this.ignoreFiles = opts.ignoreFiles || [ ".ignore" ], 
          this.ignoreRules = {}, this.parent = opts.parent || null, this.includeEmpty = !!opts.includeEmpty, 
          this.root = this.parent ? this.parent.root : this.path, this.follow = !!opts.follow, 
          this.result = this.parent ? this.parent.result : new Set, this.entries = null, this.sawError = !1;
        }
        sort(a, b) {
          return a.localeCompare(b, "en");
        }
        emit(ev, data) {
          let ret = !1;
          return this.sawError && "error" === ev || ("error" === ev ? this.sawError = !0 : "done" !== ev || this.parent || (data = Array.from(data).map((e => /^@/.test(e) ? `./${e}` : e)).sort(this.sort), 
          this.result = data), ret = "error" === ev && this.parent ? this.parent.emit("error", data) : super.emit(ev, data)), 
          ret;
        }
        start() {
          return fs.readdir(this.path, ((er, entries) => er ? this.emit("error", er) : this.onReaddir(entries))), 
          this;
        }
        isIgnoreFile(e) {
          return "." !== e && ".." !== e && -1 !== this.ignoreFiles.indexOf(e);
        }
        onReaddir(entries) {
          if (this.entries = entries, 0 === entries.length) this.includeEmpty && this.result.add(this.path.slice(this.root.length + 1)), 
          this.emit("done", this.result); else {
            this.entries.some((e => this.isIgnoreFile(e))) ? this.addIgnoreFiles() : this.filterEntries();
          }
        }
        addIgnoreFiles() {
          const newIg = this.entries.filter((e => this.isIgnoreFile(e)));
          let igCount = newIg.length;
          const then = _ => {
            0 == --igCount && this.filterEntries();
          };
          newIg.forEach((e => this.addIgnoreFile(e, then)));
        }
        addIgnoreFile(file, then) {
          const ig = path.resolve(this.path, file);
          fs.readFile(ig, "utf8", ((er, data) => er ? this.emit("error", er) : this.onReadIgnoreFile(file, data, then)));
        }
        onReadIgnoreFile(file, data, then) {
          const mmopt = {
            matchBase: !0,
            dot: !0,
            flipNegate: !0,
            nocase: !0
          }, rules = data.split(/\r?\n/).filter((line => !/^#|^$/.test(line.trim()))).map((rule => new Minimatch(rule.trim(), mmopt)));
          this.ignoreRules[file] = rules, then();
        }
        filterEntries() {
          const filtered = this.entries.map((entry => {
            const passFile = this.filterEntry(entry), passDir = this.filterEntry(entry, !0);
            return !(!passFile && !passDir) && [ entry, passFile, passDir ];
          })).filter((e => e));
          let entryCount = filtered.length;
          if (0 === entryCount) this.emit("done", this.result); else {
            const then = _ => {
              0 == --entryCount && this.emit("done", this.result);
            };
            filtered.forEach((filt => {
              const entry = filt[0], file = filt[1], dir = filt[2];
              this.stat({
                entry,
                file,
                dir
              }, then);
            }));
          }
        }
        onstat({st, entry, file, dir, isSymbolicLink}, then) {
          const abs = this.path + "/" + entry;
          st.isDirectory() ? dir ? this.walker(entry, {
            isSymbolicLink
          }, then) : then() : (file && this.result.add(abs.slice(this.root.length + 1)), then());
        }
        stat({entry, file, dir}, then) {
          const abs = this.path + "/" + entry;
          fs.lstat(abs, ((lstatErr, lstatResult) => {
            if (lstatErr) this.emit("error", lstatErr); else {
              const isSymbolicLink = lstatResult.isSymbolicLink();
              this.follow && isSymbolicLink ? fs.stat(abs, ((statErr, statResult) => {
                statErr ? this.emit("error", statErr) : this.onstat({
                  st: statResult,
                  entry,
                  file,
                  dir,
                  isSymbolicLink
                }, then);
              })) : this.onstat({
                st: lstatResult,
                entry,
                file,
                dir,
                isSymbolicLink
              }, then);
            }
          }));
        }
        walkerOpt(entry, opts) {
          return {
            path: this.path + "/" + entry,
            parent: this,
            ignoreFiles: this.ignoreFiles,
            follow: this.follow,
            includeEmpty: this.includeEmpty,
            ...opts
          };
        }
        walker(entry, opts, then) {
          new Walker(this.walkerOpt(entry, opts)).on("done", then).start();
        }
        filterEntry(entry, partial) {
          let included = !0;
          if (this.parent && this.parent.filterEntry) {
            var pt = this.basename + "/" + entry;
            included = this.parent.filterEntry(pt, partial);
          }
          return this.ignoreFiles.forEach((f => {
            this.ignoreRules[f] && this.ignoreRules[f].forEach((rule => {
              if (rule.negate !== included) {
                (rule.match("/" + entry) || rule.match(entry) || !!partial && (rule.match("/" + entry + "/") || rule.match(entry + "/")) || !!partial && rule.negate && (rule.match("/" + entry, !0) || rule.match(entry, !0))) && (included = rule.negate);
              }
            }));
          })), included;
        }
      }
      class WalkerSync extends Walker {
        start() {
          return this.onReaddir(fs.readdirSync(this.path)), this;
        }
        addIgnoreFile(file, then) {
          const ig = path.resolve(this.path, file);
          this.onReadIgnoreFile(file, fs.readFileSync(ig, "utf8"), then);
        }
        stat({entry, file, dir}, then) {
          const abs = this.path + "/" + entry;
          let st = fs.lstatSync(abs);
          const isSymbolicLink = st.isSymbolicLink();
          this.follow && isSymbolicLink && (st = fs.statSync(abs)), this.onstat({
            st,
            entry,
            file,
            dir,
            isSymbolicLink
          }, then);
        }
        walker(entry, opts, then) {
          new WalkerSync(this.walkerOpt(entry, opts)).start(), then();
        }
      }
      const walk = (opts, callback) => {
        const p = new Promise(((resolve, reject) => {
          new Walker(opts).on("done", resolve).on("error", reject).start();
        }));
        return callback ? p.then((res => callback(null, res)), callback) : p;
      };
      module.exports = walk, walk.sync = opts => new WalkerSync(opts).start().result, 
      walk.Walker = Walker, walk.WalkerSync = WalkerSync;
    },
    287: module => {
      !function() {
        var cache;
        function MurmurHash3(key, seed) {
          var m = this instanceof MurmurHash3 ? this : cache;
          if (m.reset(seed), "string" == typeof key && key.length > 0 && m.hash(key), m !== this) return m;
        }
        MurmurHash3.prototype.hash = function(key) {
          var h1, k1, i, top, len;
          switch (len = key.length, this.len += len, k1 = this.k1, i = 0, this.rem) {
           case 0:
            k1 ^= len > i ? 65535 & key.charCodeAt(i++) : 0;

           case 1:
            k1 ^= len > i ? (65535 & key.charCodeAt(i++)) << 8 : 0;

           case 2:
            k1 ^= len > i ? (65535 & key.charCodeAt(i++)) << 16 : 0;

           case 3:
            k1 ^= len > i ? (255 & key.charCodeAt(i)) << 24 : 0, k1 ^= len > i ? (65280 & key.charCodeAt(i++)) >> 8 : 0;
          }
          if (this.rem = len + this.rem & 3, (len -= this.rem) > 0) {
            for (h1 = this.h1; h1 = 5 * (h1 = (h1 ^= k1 = 13715 * (k1 = (k1 = 11601 * k1 + 3432906752 * (65535 & k1) & 4294967295) << 15 | k1 >>> 17) + 461832192 * (65535 & k1) & 4294967295) << 13 | h1 >>> 19) + 3864292196 & 4294967295, 
            !(i >= len); ) k1 = 65535 & key.charCodeAt(i++) ^ (65535 & key.charCodeAt(i++)) << 8 ^ (65535 & key.charCodeAt(i++)) << 16, 
            k1 ^= (255 & (top = key.charCodeAt(i++))) << 24 ^ (65280 & top) >> 8;
            switch (k1 = 0, this.rem) {
             case 3:
              k1 ^= (65535 & key.charCodeAt(i + 2)) << 16;

             case 2:
              k1 ^= (65535 & key.charCodeAt(i + 1)) << 8;

             case 1:
              k1 ^= 65535 & key.charCodeAt(i);
            }
            this.h1 = h1;
          }
          return this.k1 = k1, this;
        }, MurmurHash3.prototype.result = function() {
          var k1, h1;
          return k1 = this.k1, h1 = this.h1, k1 > 0 && (h1 ^= k1 = 13715 * (k1 = (k1 = 11601 * k1 + 3432906752 * (65535 & k1) & 4294967295) << 15 | k1 >>> 17) + 461832192 * (65535 & k1) & 4294967295), 
          h1 ^= this.len, h1 = 51819 * (h1 ^= h1 >>> 16) + 2246770688 * (65535 & h1) & 4294967295, 
          h1 = 44597 * (h1 ^= h1 >>> 13) + 3266445312 * (65535 & h1) & 4294967295, (h1 ^= h1 >>> 16) >>> 0;
        }, MurmurHash3.prototype.reset = function(seed) {
          return this.h1 = "number" == typeof seed ? seed : 0, this.rem = this.k1 = this.len = 0, 
          this;
        }, cache = new MurmurHash3, module.exports = MurmurHash3;
      }();
    },
    9057: module => {
      "use strict";
      module.exports = (string, count = 1, options) => {
        if (options = {
          indent: " ",
          includeEmptyLines: !1,
          ...options
        }, "string" != typeof string) throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof string}\``);
        if ("number" != typeof count) throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof count}\``);
        if ("string" != typeof options.indent) throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``);
        if (0 === count) return string;
        const regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
        return string.replace(regex, options.indent.repeat(count));
      };
    },
    84876: (module, __unused_webpack_exports, __webpack_require__) => {
      const cache = new Map, fs = __webpack_require__(57147), {dirname, resolve} = __webpack_require__(71017), inferOwner = path => {
        if (path = resolve(path), cache.has(path)) return Promise.resolve(cache.get(path));
        const parent = dirname(path), parentTrap = parent === path ? null : er => inferOwner(parent).then((owner => (cache.set(path, owner), 
        owner)));
        return (path => new Promise(((res, rej) => fs.lstat(path, ((er, st) => er ? rej(er) : res(st))))))(path).then((st => {
          const {uid, gid} = st;
          return cache.set(path, {
            uid,
            gid
          }), {
            uid,
            gid
          };
        }), parentTrap);
      }, inferOwnerSync = path => {
        if (path = resolve(path), cache.has(path)) return cache.get(path);
        const parent = dirname(path);
        let threw = !0;
        try {
          const st = fs.lstatSync(path);
          threw = !1;
          const {uid, gid} = st;
          return cache.set(path, {
            uid,
            gid
          }), {
            uid,
            gid
          };
        } finally {
          if (threw && parent !== path) {
            const owner = inferOwnerSync(parent);
            return cache.set(path, owner), owner;
          }
        }
      }, inflight = new Map;
      module.exports = path => {
        if (path = resolve(path), inflight.has(path)) return Promise.resolve(inflight.get(path));
        const p = inferOwner(path).then((owner => (inflight.delete(path), owner)));
        return inflight.set(path, p), p;
      }, module.exports.sync = inferOwnerSync, module.exports.clearCache = () => {
        cache.clear(), inflight.clear();
      };
    },
    92869: module => {
      const {hasOwnProperty} = Object.prototype, eol = "undefined" != typeof process && "win32" === process.platform ? "\r\n" : "\n", encode = (obj, opt) => {
        const children = [];
        let out = "";
        "string" == typeof opt ? opt = {
          section: opt,
          whitespace: !1
        } : (opt = opt || Object.create(null)).whitespace = !0 === opt.whitespace;
        const separator = opt.whitespace ? " = " : "=";
        for (const k of Object.keys(obj)) {
          const val = obj[k];
          if (val && Array.isArray(val)) for (const item of val) out += safe(k + "[]") + separator + safe(item) + eol; else val && "object" == typeof val ? children.push(k) : out += safe(k) + separator + safe(val) + eol;
        }
        opt.section && out.length && (out = "[" + safe(opt.section) + "]" + eol + out);
        for (const k of children) {
          const nk = dotSplit(k).join("\\."), section = (opt.section ? opt.section + "." : "") + nk, {whitespace} = opt, child = encode(obj[k], {
            section,
            whitespace
          });
          out.length && child.length && (out += eol), out += child;
        }
        return out;
      }, dotSplit = str => str.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map((part => part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, ""))), decode = str => {
        const out = Object.create(null);
        let p = out, section = null;
        const re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i, lines = str.split(/[\r\n]+/g);
        for (const line of lines) {
          if (!line || line.match(/^\s*[;#]/)) continue;
          const match = line.match(re);
          if (!match) continue;
          if (void 0 !== match[1]) {
            if (section = unsafe(match[1]), "__proto__" === section) {
              p = Object.create(null);
              continue;
            }
            p = out[section] = out[section] || Object.create(null);
            continue;
          }
          const keyRaw = unsafe(match[2]), isArray = keyRaw.length > 2 && "[]" === keyRaw.slice(-2), key = isArray ? keyRaw.slice(0, -2) : keyRaw;
          if ("__proto__" === key) continue;
          const valueRaw = !match[3] || unsafe(match[4]), value = "true" === valueRaw || "false" === valueRaw || "null" === valueRaw ? JSON.parse(valueRaw) : valueRaw;
          isArray && (hasOwnProperty.call(p, key) ? Array.isArray(p[key]) || (p[key] = [ p[key] ]) : p[key] = []), 
          Array.isArray(p[key]) ? p[key].push(value) : p[key] = value;
        }
        const remove = [];
        for (const k of Object.keys(out)) {
          if (!hasOwnProperty.call(out, k) || "object" != typeof out[k] || Array.isArray(out[k])) continue;
          const parts = dotSplit(k);
          p = out;
          const l = parts.pop(), nl = l.replace(/\\\./g, ".");
          for (const part of parts) "__proto__" !== part && (hasOwnProperty.call(p, part) && "object" == typeof p[part] || (p[part] = Object.create(null)), 
          p = p[part]);
          p === out && nl === l || (p[nl] = out[k], remove.push(k));
        }
        for (const del of remove) delete out[del];
        return out;
      }, isQuoted = val => val.startsWith('"') && val.endsWith('"') || val.startsWith("'") && val.endsWith("'"), safe = val => "string" != typeof val || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.split(";").join("\\;").split("#").join("\\#"), unsafe = (val, doUnesc) => {
        if (val = (val || "").trim(), !isQuoted(val)) {
          let esc = !1, unesc = "";
          for (let i = 0, l = val.length; i < l; i++) {
            const c = val.charAt(i);
            if (esc) -1 !== "\\;#".indexOf(c) ? unesc += c : unesc += "\\" + c, esc = !1; else {
              if (-1 !== ";#".indexOf(c)) break;
              "\\" === c ? esc = !0 : unesc += c;
            }
          }
          return esc && (unesc += "\\"), unesc.trim();
        }
        "'" === val.charAt(0) && (val = val.slice(1, -1));
        try {
          val = JSON.parse(val);
        } catch {}
        return val;
      };
      module.exports = {
        parse: decode,
        decode,
        stringify: encode,
        encode,
        safe,
        unsafe
      };
    },
    33573: module => {
      "use strict";
      const b = options => options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=[a-fA-F\\d:])|(?<=[a-fA-F\\d:])(?=\\s|$))" : "", v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", v6seg = "[a-fA-F\\d]{1,4}", v6 = `\n(?:\n(?:${v6seg}:){7}(?:${v6seg}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:${v6seg}:){6}(?:${v4}|:${v6seg}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:${v6seg}:){5}(?::${v4}|(?::${v6seg}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:${v6seg}:){4}(?:(?::${v6seg}){0,1}:${v4}|(?::${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:${v6seg}:){3}(?:(?::${v6seg}){0,2}:${v4}|(?::${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:${v6seg}:){2}(?:(?::${v6seg}){0,3}:${v4}|(?::${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:${v6seg}:){1}(?:(?::${v6seg}){0,4}:${v4}|(?::${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::${v6seg}){0,5}:${v4}|(?::${v6seg}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`), v4exact = new RegExp(`^${v4}$`), v6exact = new RegExp(`^${v6}$`), ip = options => options && options.exact ? v46Exact : new RegExp(`(?:${b(options)}${v4}${b(options)})|(?:${b(options)}${v6}${b(options)})`, "g");
      ip.v4 = options => options && options.exact ? v4exact : new RegExp(`${b(options)}${v4}${b(options)}`, "g"), 
      ip.v6 = options => options && options.exact ? v6exact : new RegExp(`${b(options)}${v6}${b(options)}`, "g"), 
      module.exports = ip;
    },
    24173: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const {v4, v6} = __webpack_require__(47535), re4 = v4({
        exact: !0
      }), re6 = v6({
        exact: !0
      });
      module.exports = str => re4.test(str) ? 4 : re6.test(str) ? 6 : 0, module.exports.v4 = str => re4.test(str), 
      module.exports.v6 = str => re6.test(str);
    },
    20386: module => {
      "use strict";
      const isFullwidthCodePoint = codePoint => !Number.isNaN(codePoint) && (codePoint >= 4352 && (codePoint <= 4447 || 9001 === codePoint || 9002 === codePoint || 11904 <= codePoint && codePoint <= 12871 && 12351 !== codePoint || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141));
      module.exports = isFullwidthCodePoint, module.exports.default = isFullwidthCodePoint;
    },
    23789: (module, __unused_webpack_exports, __webpack_require__) => {
      var core;
      function isexe(path, options, cb) {
        if ("function" == typeof options && (cb = options, options = {}), !cb) {
          if ("function" != typeof Promise) throw new TypeError("callback not provided");
          return new Promise((function(resolve, reject) {
            isexe(path, options || {}, (function(er, is) {
              er ? reject(er) : resolve(is);
            }));
          }));
        }
        core(path, options || {}, (function(er, is) {
          er && ("EACCES" === er.code || options && options.ignoreErrors) && (er = null, is = !1), 
          cb(er, is);
        }));
      }
      core = "win32" === process.platform || global.TESTING_WINDOWS ? __webpack_require__(34690) : __webpack_require__(62015), 
      module.exports = isexe, isexe.sync = function(path, options) {
        try {
          return core.sync(path, options || {});
        } catch (er) {
          if (options && options.ignoreErrors || "EACCES" === er.code) return !1;
          throw er;
        }
      };
    },
    62015: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = isexe, isexe.sync = function(path, options) {
        return checkStat(fs.statSync(path), options);
      };
      var fs = __webpack_require__(57147);
      function isexe(path, options, cb) {
        fs.stat(path, (function(er, stat) {
          cb(er, !er && checkStat(stat, options));
        }));
      }
      function checkStat(stat, options) {
        return stat.isFile() && function(stat, options) {
          var mod = stat.mode, uid = stat.uid, gid = stat.gid, myUid = void 0 !== options.uid ? options.uid : process.getuid && process.getuid(), myGid = void 0 !== options.gid ? options.gid : process.getgid && process.getgid(), u = parseInt("100", 8), g = parseInt("010", 8), o = parseInt("001", 8), ug = u | g;
          return mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && 0 === myUid;
        }(stat, options);
      }
    },
    34690: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = isexe, isexe.sync = function(path, options) {
        return checkStat(fs.statSync(path), path, options);
      };
      var fs = __webpack_require__(57147);
      function checkStat(stat, path, options) {
        return !(!stat.isSymbolicLink() && !stat.isFile()) && function(path, options) {
          var pathext = void 0 !== options.pathExt ? options.pathExt : process.env.PATHEXT;
          if (!pathext) return !0;
          if (-1 !== (pathext = pathext.split(";")).indexOf("")) return !0;
          for (var i = 0; i < pathext.length; i++) {
            var p = pathext[i].toLowerCase();
            if (p && path.substr(-p.length).toLowerCase() === p) return !0;
          }
          return !1;
        }(path, options);
      }
      function isexe(path, options, cb) {
        fs.stat(path, (function(er, stat) {
          cb(er, !er && checkStat(stat, path, options));
        }));
      }
    },
    40295: module => {
      "use strict";
      class JSONParseError extends SyntaxError {
        constructor(er, txt, context, caller) {
          const metadata = ((e, txt, context) => {
            if (!txt) return {
              message: e.message + " while parsing empty string",
              position: 0
            };
            const badToken = e.message.match(/^Unexpected token (.) .*position\s+(\d+)/i), errIdx = badToken ? +badToken[2] : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1 : null, msg = badToken ? e.message.replace(/^Unexpected token ./, `Unexpected token ${JSON.stringify(badToken[1])} (${(char => {
              const h = char.charCodeAt(0).toString(16).toUpperCase();
              return "0x" + (h.length % 2 ? "0" : "") + h;
            })(badToken[1])})`) : e.message;
            if (null != errIdx) {
              const start = errIdx <= context ? 0 : errIdx - context, end = errIdx + context >= txt.length ? txt.length : errIdx + context, slice = (0 === start ? "" : "...") + txt.slice(start, end) + (end === txt.length ? "" : "...");
              return {
                message: msg + ` while parsing ${txt === slice ? "" : "near "}${JSON.stringify(slice)}`,
                position: errIdx
              };
            }
            return {
              message: msg + ` while parsing '${txt.slice(0, 2 * context)}'`,
              position: 0
            };
          })(er, txt, context = context || 20);
          super(metadata.message), Object.assign(this, metadata), this.code = "EJSONPARSE", 
          this.systemError = er, Error.captureStackTrace(this, caller || this.constructor);
        }
        get name() {
          return this.constructor.name;
        }
        set name(n) {}
        get [Symbol.toStringTag]() {
          return this.constructor.name;
        }
      }
      const kIndent = Symbol.for("indent"), kNewline = Symbol.for("newline"), formatRE = /^\s*[{\[]((?:\r?\n)+)([\s\t]*)/, emptyRE = /^(?:\{\}|\[\])((?:\r?\n)+)?$/, parseJson = (txt, reviver, context) => {
        const parseText = stripBOM(txt);
        context = context || 20;
        try {
          const [, newline = "\n", indent = "  "] = parseText.match(emptyRE) || parseText.match(formatRE) || [ , "", "" ], result = JSON.parse(parseText, reviver);
          return result && "object" == typeof result && (result[kNewline] = newline, result[kIndent] = indent), 
          result;
        } catch (e) {
          if ("string" != typeof txt && !Buffer.isBuffer(txt)) {
            const isEmptyArray = Array.isArray(txt) && 0 === txt.length;
            throw Object.assign(new TypeError(`Cannot parse ${isEmptyArray ? "an empty array" : String(txt)}`), {
              code: "EJSONPARSE",
              systemError: e
            });
          }
          throw new JSONParseError(e, parseText, context, parseJson);
        }
      }, stripBOM = txt => String(txt).replace(/^\uFEFF/, "");
      module.exports = parseJson, parseJson.JSONParseError = JSONParseError, parseJson.noExceptions = (txt, reviver) => {
        try {
          return JSON.parse(stripBOM(txt), reviver);
        } catch (e) {}
      };
    },
    99091: module => {
      const isObj = val => !!val && !Array.isArray(val) && "object" == typeof val;
      module.exports = (obj, replacer, space = 2) => JSON.stringify(obj, ((replacer, seen) => (key, val) => {
        const prefKeys = Array.isArray(replacer) ? replacer : [];
        if ("function" == typeof replacer && (val = replacer(key, val)), !isObj(val)) return val;
        if (seen.has(val)) return seen.get(val);
        const ret = Object.entries(val).sort((([ak, av], [bk, bv]) => isObj(av) === isObj(bv) ? ((ak, bk, prefKeys) => prefKeys.includes(ak) && !prefKeys.includes(bk) ? -1 : prefKeys.includes(bk) && !prefKeys.includes(ak) ? 1 : prefKeys.includes(ak) && prefKeys.includes(bk) ? prefKeys.indexOf(ak) - prefKeys.indexOf(bk) : ak.localeCompare(bk, "en"))(ak, bk, prefKeys) : isObj(av) ? 1 : -1)).reduce(((set, [k, v]) => (set[k] = v, 
        set)), {});
        return seen.set(val, ret), ret;
      })(replacer, new Map), space) + (space ? "\n" : "");
    },
    84105: module => {
      var C = {}, LEFT_BRACE = C.LEFT_BRACE = 1, RIGHT_BRACE = C.RIGHT_BRACE = 2, LEFT_BRACKET = C.LEFT_BRACKET = 3, RIGHT_BRACKET = C.RIGHT_BRACKET = 4, COLON = C.COLON = 5, COMMA = C.COMMA = 6, TRUE = C.TRUE = 7, FALSE = C.FALSE = 8, NULL = C.NULL = 9, STRING = C.STRING = 10, NUMBER = C.NUMBER = 11, START = C.START = 17, STOP = C.STOP = 18, TRUE1 = C.TRUE1 = 33, TRUE2 = C.TRUE2 = 34, TRUE3 = C.TRUE3 = 35, FALSE1 = C.FALSE1 = 49, FALSE2 = C.FALSE2 = 50, FALSE3 = C.FALSE3 = 51, FALSE4 = C.FALSE4 = 52, NULL1 = C.NULL1 = 65, NULL2 = C.NULL2 = 66, NULL3 = C.NULL3 = 67, NUMBER1 = C.NUMBER1 = 81, NUMBER3 = C.NUMBER3 = 83, STRING1 = C.STRING1 = 97, STRING2 = C.STRING2 = 98, STRING3 = C.STRING3 = 99, STRING4 = C.STRING4 = 100, STRING5 = C.STRING5 = 101, STRING6 = C.STRING6 = 102, VALUE = C.VALUE = 113, KEY = C.KEY = 114, OBJECT = C.OBJECT = 129, ARRAY = C.ARRAY = 130, BACK_SLASH = "\\".charCodeAt(0), FORWARD_SLASH = "/".charCodeAt(0), BACKSPACE = "\b".charCodeAt(0), FORM_FEED = "\f".charCodeAt(0), NEWLINE = "\n".charCodeAt(0), CARRIAGE_RETURN = "\r".charCodeAt(0), TAB = "\t".charCodeAt(0);
      function Parser() {
        this.tState = START, this.value = void 0, this.string = void 0, this.stringBuffer = Buffer.alloc ? Buffer.alloc(65536) : new Buffer(65536), 
        this.stringBufferOffset = 0, this.unicode = void 0, this.highSurrogate = void 0, 
        this.key = void 0, this.mode = void 0, this.stack = [], this.state = VALUE, this.bytes_remaining = 0, 
        this.bytes_in_sequence = 0, this.temp_buffs = {
          2: new Buffer(2),
          3: new Buffer(3),
          4: new Buffer(4)
        }, this.offset = -1;
      }
      Parser.toknam = function(code) {
        for (var keys = Object.keys(C), i = 0, l = keys.length; i < l; i++) {
          var key = keys[i];
          if (C[key] === code) return key;
        }
        return code && "0x" + code.toString(16);
      };
      var proto = Parser.prototype;
      proto.onError = function(err) {
        throw err;
      }, proto.charError = function(buffer, i) {
        this.tState = STOP, this.onError(new Error("Unexpected " + JSON.stringify(String.fromCharCode(buffer[i])) + " at position " + i + " in state " + Parser.toknam(this.tState)));
      }, proto.appendStringChar = function(char) {
        this.stringBufferOffset >= 65536 && (this.string += this.stringBuffer.toString("utf8"), 
        this.stringBufferOffset = 0), this.stringBuffer[this.stringBufferOffset++] = char;
      }, proto.appendStringBuf = function(buf, start, end) {
        var size = buf.length;
        "number" == typeof start && (size = "number" == typeof end ? end < 0 ? buf.length - start + end : end - start : buf.length - start), 
        size < 0 && (size = 0), this.stringBufferOffset + size > 65536 && (this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset), 
        this.stringBufferOffset = 0), buf.copy(this.stringBuffer, this.stringBufferOffset, start, end), 
        this.stringBufferOffset += size;
      }, proto.write = function(buffer) {
        var n;
        "string" == typeof buffer && (buffer = new Buffer(buffer));
        for (var i = 0, l = buffer.length; i < l; i++) if (this.tState === START) {
          if (n = buffer[i], this.offset++, 123 === n) this.onToken(LEFT_BRACE, "{"); else if (125 === n) this.onToken(RIGHT_BRACE, "}"); else if (91 === n) this.onToken(LEFT_BRACKET, "["); else if (93 === n) this.onToken(RIGHT_BRACKET, "]"); else if (58 === n) this.onToken(COLON, ":"); else if (44 === n) this.onToken(COMMA, ","); else if (116 === n) this.tState = TRUE1; else if (102 === n) this.tState = FALSE1; else if (110 === n) this.tState = NULL1; else if (34 === n) this.string = "", 
          this.stringBufferOffset = 0, this.tState = STRING1; else if (45 === n) this.string = "-", 
          this.tState = NUMBER1; else if (n >= 48 && n < 64) this.string = String.fromCharCode(n), 
          this.tState = NUMBER3; else if (32 !== n && 9 !== n && 10 !== n && 13 !== n) return this.charError(buffer, i);
        } else if (this.tState === STRING1) if (n = buffer[i], this.bytes_remaining > 0) {
          for (var j = 0; j < this.bytes_remaining; j++) this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = buffer[j];
          this.appendStringBuf(this.temp_buffs[this.bytes_in_sequence]), this.bytes_in_sequence = this.bytes_remaining = 0, 
          i = i + j - 1;
        } else if (0 === this.bytes_remaining && n >= 128) {
          if (n <= 193 || n > 244) return this.onError(new Error("Invalid UTF-8 character at position " + i + " in state " + Parser.toknam(this.tState)));
          if (n >= 194 && n <= 223 && (this.bytes_in_sequence = 2), n >= 224 && n <= 239 && (this.bytes_in_sequence = 3), 
          n >= 240 && n <= 244 && (this.bytes_in_sequence = 4), this.bytes_in_sequence + i > buffer.length) {
            for (var k = 0; k <= buffer.length - 1 - i; k++) this.temp_buffs[this.bytes_in_sequence][k] = buffer[i + k];
            this.bytes_remaining = i + this.bytes_in_sequence - buffer.length, i = buffer.length - 1;
          } else this.appendStringBuf(buffer, i, i + this.bytes_in_sequence), i = i + this.bytes_in_sequence - 1;
        } else if (34 === n) this.tState = START, this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset), 
        this.stringBufferOffset = 0, this.onToken(STRING, this.string), this.offset += Buffer.byteLength(this.string, "utf8") + 1, 
        this.string = void 0; else if (92 === n) this.tState = STRING2; else {
          if (!(n >= 32)) return this.charError(buffer, i);
          this.appendStringChar(n);
        } else if (this.tState === STRING2) if (34 === (n = buffer[i])) this.appendStringChar(n), 
        this.tState = STRING1; else if (92 === n) this.appendStringChar(BACK_SLASH), this.tState = STRING1; else if (47 === n) this.appendStringChar(FORWARD_SLASH), 
        this.tState = STRING1; else if (98 === n) this.appendStringChar(BACKSPACE), this.tState = STRING1; else if (102 === n) this.appendStringChar(FORM_FEED), 
        this.tState = STRING1; else if (110 === n) this.appendStringChar(NEWLINE), this.tState = STRING1; else if (114 === n) this.appendStringChar(CARRIAGE_RETURN), 
        this.tState = STRING1; else if (116 === n) this.appendStringChar(TAB), this.tState = STRING1; else {
          if (117 !== n) return this.charError(buffer, i);
          this.unicode = "", this.tState = STRING3;
        } else if (this.tState === STRING3 || this.tState === STRING4 || this.tState === STRING5 || this.tState === STRING6) {
          if (!((n = buffer[i]) >= 48 && n < 64 || n > 64 && n <= 70 || n > 96 && n <= 102)) return this.charError(buffer, i);
          if (this.unicode += String.fromCharCode(n), this.tState++ === STRING6) {
            var intVal = parseInt(this.unicode, 16);
            this.unicode = void 0, void 0 !== this.highSurrogate && intVal >= 56320 && intVal < 57344 ? (this.appendStringBuf(new Buffer(String.fromCharCode(this.highSurrogate, intVal))), 
            this.highSurrogate = void 0) : void 0 === this.highSurrogate && intVal >= 55296 && intVal < 56320 ? this.highSurrogate = intVal : (void 0 !== this.highSurrogate && (this.appendStringBuf(new Buffer(String.fromCharCode(this.highSurrogate))), 
            this.highSurrogate = void 0), this.appendStringBuf(new Buffer(String.fromCharCode(intVal)))), 
            this.tState = STRING1;
          }
        } else if (this.tState === NUMBER1 || this.tState === NUMBER3) switch (n = buffer[i]) {
         case 48:
         case 49:
         case 50:
         case 51:
         case 52:
         case 53:
         case 54:
         case 55:
         case 56:
         case 57:
         case 46:
         case 101:
         case 69:
         case 43:
         case 45:
          this.string += String.fromCharCode(n), this.tState = NUMBER3;
          break;

         default:
          this.tState = START;
          var result = Number(this.string);
          if (isNaN(result)) return this.charError(buffer, i);
          this.string.match(/[0-9]+/) == this.string && result.toString() != this.string ? this.onToken(STRING, this.string) : this.onToken(NUMBER, result), 
          this.offset += this.string.length - 1, this.string = void 0, i--;
        } else if (this.tState === TRUE1) {
          if (114 !== buffer[i]) return this.charError(buffer, i);
          this.tState = TRUE2;
        } else if (this.tState === TRUE2) {
          if (117 !== buffer[i]) return this.charError(buffer, i);
          this.tState = TRUE3;
        } else if (this.tState === TRUE3) {
          if (101 !== buffer[i]) return this.charError(buffer, i);
          this.tState = START, this.onToken(TRUE, !0), this.offset += 3;
        } else if (this.tState === FALSE1) {
          if (97 !== buffer[i]) return this.charError(buffer, i);
          this.tState = FALSE2;
        } else if (this.tState === FALSE2) {
          if (108 !== buffer[i]) return this.charError(buffer, i);
          this.tState = FALSE3;
        } else if (this.tState === FALSE3) {
          if (115 !== buffer[i]) return this.charError(buffer, i);
          this.tState = FALSE4;
        } else if (this.tState === FALSE4) {
          if (101 !== buffer[i]) return this.charError(buffer, i);
          this.tState = START, this.onToken(FALSE, !1), this.offset += 4;
        } else if (this.tState === NULL1) {
          if (117 !== buffer[i]) return this.charError(buffer, i);
          this.tState = NULL2;
        } else if (this.tState === NULL2) {
          if (108 !== buffer[i]) return this.charError(buffer, i);
          this.tState = NULL3;
        } else if (this.tState === NULL3) {
          if (108 !== buffer[i]) return this.charError(buffer, i);
          this.tState = START, this.onToken(NULL, null), this.offset += 3;
        }
      }, proto.onToken = function(token, value) {}, proto.parseError = function(token, value) {
        this.tState = STOP, this.onError(new Error("Unexpected " + Parser.toknam(token) + (value ? "(" + JSON.stringify(value) + ")" : "") + " in state " + Parser.toknam(this.state)));
      }, proto.push = function() {
        this.stack.push({
          value: this.value,
          key: this.key,
          mode: this.mode
        });
      }, proto.pop = function() {
        var value = this.value, parent = this.stack.pop();
        this.value = parent.value, this.key = parent.key, this.mode = parent.mode, this.emit(value), 
        this.mode || (this.state = VALUE);
      }, proto.emit = function(value) {
        this.mode && (this.state = COMMA), this.onValue(value);
      }, proto.onValue = function(value) {}, proto.onToken = function(token, value) {
        if (this.state === VALUE) if (token === STRING || token === NUMBER || token === TRUE || token === FALSE || token === NULL) this.value && (this.value[this.key] = value), 
        this.emit(value); else if (token === LEFT_BRACE) this.push(), this.value ? this.value = this.value[this.key] = {} : this.value = {}, 
        this.key = void 0, this.state = KEY, this.mode = OBJECT; else if (token === LEFT_BRACKET) this.push(), 
        this.value ? this.value = this.value[this.key] = [] : this.value = [], this.key = 0, 
        this.mode = ARRAY, this.state = VALUE; else if (token === RIGHT_BRACE) {
          if (this.mode !== OBJECT) return this.parseError(token, value);
          this.pop();
        } else {
          if (token !== RIGHT_BRACKET) return this.parseError(token, value);
          if (this.mode !== ARRAY) return this.parseError(token, value);
          this.pop();
        } else if (this.state === KEY) if (token === STRING) this.key = value, this.state = COLON; else {
          if (token !== RIGHT_BRACE) return this.parseError(token, value);
          this.pop();
        } else if (this.state === COLON) {
          if (token !== COLON) return this.parseError(token, value);
          this.state = VALUE;
        } else {
          if (this.state !== COMMA) return this.parseError(token, value);
          if (token === COMMA) this.mode === ARRAY ? (this.key++, this.state = VALUE) : this.mode === OBJECT && (this.state = KEY); else {
            if (!(token === RIGHT_BRACKET && this.mode === ARRAY || token === RIGHT_BRACE && this.mode === OBJECT)) return this.parseError(token, value);
            this.pop();
          }
        }
      }, Parser.C = C, module.exports = Parser;
    },
    63167: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const Minipass = __webpack_require__(45018), npa = __webpack_require__(19932), npmFetch = __webpack_require__(92427), validate = __webpack_require__(95073), eu = encodeURIComponent, npar = spec => {
        if (!(spec = npa(spec)).registry) throw new Error("`spec` must be a registry spec");
        return spec;
      }, mapJSON = (value, [key]) => "read" === value ? [ key, "read-only" ] : "write" === value ? [ key, "read-write" ] : [ key, value ], cmd = module.exports = {};
      function setAccess(spec, access, opts = {}) {
        return Promise.resolve().then((() => {
          spec = npar(spec), validate("OSO", [ spec, access, opts ]);
          const uri = `/-/package/${eu(spec.name)}/access`;
          return npmFetch(uri, {
            ...opts,
            method: "POST",
            body: {
              access
            },
            spec
          }).then((() => !0));
        }));
      }
      function setRequires2fa(spec, required, opts = {}) {
        return Promise.resolve().then((() => {
          spec = npar(spec), validate("OBO", [ spec, required, opts ]);
          const uri = `/-/package/${eu(spec.name)}/access`;
          return npmFetch(uri, {
            ...opts,
            method: "POST",
            body: {
              publish_requires_tfa: required
            },
            spec,
            ignoreBody: !0
          }).then((() => !0));
        }));
      }
      function splitEntity(entity = "") {
        const [, scope, team] = entity.match(/^@?([^:]+)(?::(.*))?$/) || [];
        return {
          scope,
          team
        };
      }
      cmd.public = (spec, opts) => setAccess(spec, "public", opts), cmd.restricted = (spec, opts) => setAccess(spec, "restricted", opts), 
      cmd.grant = (spec, entity, permissions, opts = {}) => Promise.resolve().then((() => {
        spec = npar(spec);
        const {scope, team} = splitEntity(entity);
        if (validate("OSSSO", [ spec, scope, team, permissions, opts ]), "read-write" !== permissions && "read-only" !== permissions) throw new Error("`permissions` must be `read-write` or `read-only`. Got `" + permissions + "` instead");
        const uri = `/-/team/${eu(scope)}/${eu(team)}/package`;
        return npmFetch(uri, {
          ...opts,
          method: "PUT",
          body: {
            package: spec.name,
            permissions
          },
          scope,
          spec,
          ignoreBody: !0
        }).then((() => !0));
      })), cmd.revoke = (spec, entity, opts = {}) => Promise.resolve().then((() => {
        spec = npar(spec);
        const {scope, team} = splitEntity(entity);
        validate("OSSO", [ spec, scope, team, opts ]);
        const uri = `/-/team/${eu(scope)}/${eu(team)}/package`;
        return npmFetch(uri, {
          ...opts,
          method: "DELETE",
          body: {
            package: spec.name
          },
          scope,
          spec,
          ignoreBody: !0
        }).then((() => !0));
      })), cmd.lsPackages = (entity, opts) => cmd.lsPackages.stream(entity, opts).collect().then((data => data.reduce(((acc, [key, val]) => (acc || (acc = {}), 
      acc[key] = val, acc)), null))), cmd.lsPackages.stream = (entity, opts = {}) => {
        validate("SO|SZ", [ entity, opts ]);
        const {scope, team} = splitEntity(entity);
        let uri;
        uri = team ? `/-/team/${eu(scope)}/${eu(team)}/package` : `/-/org/${eu(scope)}/package`;
        const nextOpts = {
          ...opts,
          query: {
            format: "cli"
          },
          mapJSON
        }, ret = new Minipass({
          objectMode: !0
        });
        return npmFetch.json.stream(uri, "*", nextOpts).on("error", (err => {
          "E404" !== err.code || team ? ret.emit("error", err) : (uri = `/-/user/${eu(scope)}/package`, 
          npmFetch.json.stream(uri, "*", nextOpts).on("error", (streamErr => ret.emit("error", streamErr))).pipe(ret));
        })).pipe(ret), ret;
      }, cmd.lsCollaborators = (spec, user, opts) => Promise.resolve().then((() => cmd.lsCollaborators.stream(spec, user, opts).collect().then((data => data.reduce(((acc, [key, val]) => (acc || (acc = {}), 
      acc[key] = val, acc)), null))))), cmd.lsCollaborators.stream = (spec, user, opts) => {
        "object" != typeof user || opts ? opts || (opts = {}) : (opts = user, user = void 0), 
        spec = npar(spec), validate("OSO|OZO", [ spec, user, opts ]);
        const uri = `/-/package/${eu(spec.name)}/collaborators`;
        return npmFetch.json.stream(uri, "*", {
          ...opts,
          query: {
            format: "cli",
            user: user || void 0
          },
          mapJSON
        });
      }, cmd.tfaRequired = (spec, opts) => setRequires2fa(spec, !0, opts), cmd.tfaNotRequired = (spec, opts) => setRequires2fa(spec, !1, opts), 
      cmd.edit = () => {
        throw new Error("Not implemented yet");
      };
    },
    69956: (module, __unused_webpack_exports, __webpack_require__) => {
      const pacote = __webpack_require__(86585), formatDiff = __webpack_require__(85917), getTarball = __webpack_require__(28722), untar = __webpack_require__(96148);
      module.exports = async (specs, opts = {}) => {
        if (2 !== specs.length) throw Object.assign(new TypeError("libnpmdiff needs two arguments to compare"), {
          code: "EDIFFARGS"
        });
        const [aManifest, bManifest] = await Promise.all(specs.map((spec => pacote.manifest(spec, opts)))), versions = {
          a: aManifest.version,
          b: bManifest.version
        }, [a, b] = await Promise.all([ getTarball(aManifest, opts), getTarball(bManifest, opts) ]), {files, refs} = await untar([ {
          prefix: "a/",
          item: a
        }, {
          prefix: "b/",
          item: b
        } ], opts);
        return formatDiff({
          files,
          opts,
          refs,
          versions
        });
      };
    },
    241: (module, __unused_webpack_exports, __webpack_require__) => {
      const {basename, extname} = __webpack_require__(71017), binaryExtensions = __webpack_require__(62631);
      module.exports = (path, opts = {}) => {
        if (opts.diffText) return !0;
        const filename = basename(path), extension = (filename.startsWith(".") ? filename : extname(filename)).slice(1);
        return !binaryExtensions.includes(extension);
      };
    },
    28722: (module, __unused_webpack_exports, __webpack_require__) => {
      const {relative} = __webpack_require__(71017), npa = __webpack_require__(19932), pkgContents = __webpack_require__(20590), pacote = __webpack_require__(86585), {tarCreateOptions} = pacote.DirFetcher, tar = __webpack_require__(39148);
      module.exports = (manifest, opts) => {
        const resolved = manifest._resolved, where = opts.where || process.cwd();
        return "directory" === npa(resolved).type && /node_modules[\\/](@[^\\/]+\/)?[^\\/]+[\\/]?$/.test(relative(where, resolved)) ? ((manifest, opts) => pkgContents({
          path: manifest._resolved,
          depth: 1
        }).then((files => files.map((file => relative(manifest._resolved, file))))).then((files => tar.c(tarCreateOptions(manifest), files).concat())))(manifest) : pacote.tarball(manifest._resolved, opts);
      };
    },
    96148: (module, __unused_webpack_exports, __webpack_require__) => {
      const tar = __webpack_require__(39148), minimatch = __webpack_require__(51191), normalizeMatch = str => str.replace(/\\+/g, "/").replace(/^\.\/|^\./, ""), untar = ({files, refs}, {filterFiles, item, prefix}) => {
        tar.list({
          filter: (path, entry) => {
            if ("File" === entry.type && (!filterFiles.length || filterFiles.some((f => {
              const pattern = normalizeMatch(f);
              return minimatch(normalizeMatch(path), `{package/,}${pattern}`, {
                matchBase: pattern.startsWith("*")
              });
            })) || filterFiles.some((f => normalizeMatch(path).startsWith(normalizeMatch(f)) || normalizeMatch(path).startsWith(`package/${normalizeMatch(f)}`))))) {
              const key = path.replace(/^[^/]+\/?/, "");
              let content;
              files.add(key);
              try {
                entry.setEncoding("utf8"), content = entry.concat();
              } catch (e) {
                throw Object.assign(new Error("failed to read files"), {
                  code: "EDIFFUNTAR"
                });
              }
              return refs.set(`${prefix}${key}`, {
                content,
                mode: `100${entry.mode.toString(8)}`
              }), !0;
            }
          }
        }).on("error", (e => {
          throw e;
        })).end(item);
      };
      module.exports = async (tarballs, opts = {}) => {
        const files = new Set, refs = new Map, arr = [].concat(tarballs), filterFiles = opts.diffFiles || [];
        for (const i of arr) untar({
          files,
          refs
        }, {
          item: i.item,
          prefix: i.prefix,
          filterFiles
        });
        const allRefs = [ ...refs.values() ];
        return (await Promise.all(allRefs.map((async ref => ref.content)))).forEach(((content, index) => {
          allRefs[index].content = content;
        })), {
          files,
          refs
        };
      };
    },
    64004: (module, __unused_webpack_exports, __webpack_require__) => {
      const {resolve} = __webpack_require__(71017), fs = __webpack_require__(45264), walkUp = __webpack_require__(43967), fileExists = async file => {
        try {
          return (await fs.stat(file)).isFile();
        } catch {
          return !1;
        }
      };
      module.exports = {
        fileExists,
        localFileExists: async (dir, binName, root) => {
          for (const path of walkUp(dir)) {
            const binDir = resolve(path, "node_modules", ".bin");
            if (await fileExists(resolve(binDir, binName))) return binDir;
            if (path.toLowerCase() === resolve(root).toLowerCase()) return !1;
          }
          return !1;
        }
      };
    },
    16202: module => {
      module.exports = mani => {
        const bin = mani.bin || {};
        if (1 === new Set(Object.values(bin)).size) return Object.keys(bin)[0];
        const name = mani.name.replace(/^@[^/]+\//, "");
        if (bin[name]) return name;
        throw Object.assign(new Error("could not determine executable to run"), {
          pkgid: mani._id
        });
      };
    },
    97050: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const {promisify} = __webpack_require__(73837), Arborist = __webpack_require__(22290), ciDetect = __webpack_require__(21811), crypto = __webpack_require__(6113), log = __webpack_require__(46521), mkdirp = __webpack_require__(87700), npa = __webpack_require__(19932), npmlog = __webpack_require__(19334), pacote = __webpack_require__(86585), read = promisify(__webpack_require__(9547)), semver = __webpack_require__(5870), {fileExists, localFileExists} = __webpack_require__(64004), getBinFromManifest = __webpack_require__(16202), noTTY = __webpack_require__(97135), runScript = __webpack_require__(38553), isWindows = __webpack_require__(61768), {dirname, resolve} = __webpack_require__(71017), binPaths = [], manifests = new Map, getManifest = async (spec, flatOptions) => {
        if (!manifests.has(spec.raw)) {
          const manifest = await pacote.manifest(spec, {
            ...flatOptions,
            preferOnline: !0
          });
          manifests.set(spec.raw, manifest);
        }
        return manifests.get(spec.raw);
      }, missingFromTree = async ({spec, tree, flatOptions}) => {
        if (!spec.registry || "" !== spec.rawSpec && "tag" === spec.type) {
          const manifest = await getManifest(spec, flatOptions);
          if ("directory" === spec.type) return {
            manifest
          };
          const nodesByManifest = tree.inventory.query("packageName", manifest.name);
          for (const node of nodesByManifest) if (node.package.resolved === manifest._resolved) return {
            node
          };
          return {
            manifest
          };
        }
        {
          const nodesBySpec = tree.inventory.query("packageName", spec.name);
          for (const node of nodesBySpec) {
            if ("tag" === spec.type) return {
              node
            };
            if ("version" === spec.type) {
              if (node.pkgid === spec.raw) return {
                node
              };
            } else if (semver.satisfies(node.package.version, spec.rawSpec)) return {
              node
            };
          }
          return {
            manifest: await getManifest(spec, flatOptions)
          };
        }
      };
      module.exports = async opts => {
        const {args = [], call = "", color = !1, localBin = resolve("./node_modules/.bin"), locationMsg, globalBin = "", globalPath, output, packages: [...packages] = [], path = ".", runPath = ".", scriptShell = isWindows ? process.env.ComSpec || "cmd" : "sh", ...flatOptions} = opts;
        let yes = opts.yes;
        const run = () => runScript({
          args,
          call,
          color,
          flatOptions,
          locationMsg,
          output,
          path,
          binPaths,
          runPath,
          scriptShell
        });
        if (!call && !args.length && !packages.length) return run();
        const needPackageCommandSwap = args.length > 0 && 0 === packages.length;
        if (needPackageCommandSwap) {
          const dir = dirname(dirname(localBin)), localBinPath = await localFileExists(dir, args[0], "/");
          if (localBinPath) return binPaths.push(localBinPath), await run();
          if (globalPath && await fileExists(`${globalBin}/${args[0]}`)) return binPaths.push(globalBin), 
          await run();
          packages.push(args[0]);
        }
        for (const i in packages) {
          const pkg = packages[i], spec = npa(pkg);
          "directory" === spec.type && (packages[i] = spec.fetchSpec);
        }
        const localArb = new Arborist({
          ...flatOptions,
          path
        }), localTree = await localArb.loadActual(), needInstall = [];
        let commandManifest;
        if (await Promise.all(packages.map((async (pkg, i) => {
          const spec = npa(pkg, path), {manifest, node} = await missingFromTree({
            spec,
            tree: localTree,
            flatOptions
          });
          manifest ? (needInstall.push({
            spec,
            manifest
          }), 0 === i && (commandManifest = manifest)) : 0 === i && (commandManifest = node.package);
        }))), needPackageCommandSwap) {
          const spec = npa(args[0]);
          if ("directory" === spec.type && (yes = !0), args[0] = getBinFromManifest(commandManifest), 
          needInstall.length > 0 && globalPath) {
            const globalArb = new Arborist({
              ...flatOptions,
              path: globalPath,
              global: !0
            }), globalTree = await globalArb.loadActual(), {manifest: globalManifest} = await missingFromTree({
              spec,
              tree: globalTree,
              flatOptions
            });
            if (!globalManifest && await fileExists(`${globalBin}/${args[0]}`)) return binPaths.push(globalBin), 
            await run();
          }
        }
        const add = [];
        if (needInstall.length > 0) {
          const {npxCache} = flatOptions;
          if (!npxCache) throw new Error("Must provide a valid npxCache path");
          const hash = crypto.createHash("sha512").update(packages.map((p => {
            const spec = npa(p);
            return "directory" === spec.type ? spec.fetchSpec : p;
          })).sort(((a, b) => a.localeCompare(b, "en"))).join("\n")).digest("hex").slice(0, 16), installDir = resolve(npxCache, hash);
          await mkdirp(installDir);
          const npxArb = new Arborist({
            ...flatOptions,
            path: installDir
          }), npxTree = await npxArb.loadActual();
          if (await Promise.all(needInstall.map((async ({spec}) => {
            const {manifest} = await missingFromTree({
              spec,
              tree: npxTree,
              flatOptions
            });
            manifest && (spec.registry ? add.push(manifest._id) : add.push(manifest._from));
          }))), add.length) {
            if (!yes) {
              if (!1 === yes) throw new Error("canceled");
              if (noTTY() || ciDetect()) log.warn("exec", `The following package${1 === add.length ? " was" : "s were"} not found and will be installed: ${add.map((pkg => pkg.replace(/@$/, ""))).join(", ")}`); else {
                const prompt = `Need to install the following packages:\n${add.map((a => `  ${a.replace(/@$/, "")}`)).join("\n") + "\n"}Ok to proceed? `;
                npmlog.clearProgress();
                if ("y" !== (await read({
                  prompt,
                  default: "y"
                })).trim().toLowerCase().charAt(0)) throw new Error("canceled");
              }
            }
            await npxArb.reify({
              ...flatOptions,
              add
            });
          }
          binPaths.push(resolve(installDir, "node_modules/.bin"));
        }
        return await run();
      };
    },
    61768: module => {
      module.exports = "win32" === process.platform;
    },
    97135: module => {
      module.exports = () => !process.stdin.isTTY;
    },
    38553: (module, __unused_webpack_exports, __webpack_require__) => {
      const chalk = __webpack_require__(25433), ciDetect = __webpack_require__(21811), runScript = __webpack_require__(63036), readPackageJson = __webpack_require__(1759), npmlog = __webpack_require__(19334), log = __webpack_require__(46521), noTTY = __webpack_require__(97135), nocolor = {
        reset: s => s,
        bold: s => s,
        dim: s => s
      };
      module.exports = async ({args, call, color, flatOptions, locationMsg, output = () => {}, path, binPaths, runPath, scriptShell}) => {
        const script = call || args.shift() || scriptShell, colorize = color ? chalk : nocolor, realPkg = await readPackageJson(`${path}/package.json`).catch((() => ({}))), pkg = {
          ...realPkg,
          scripts: {
            ...realPkg.scripts || {},
            npx: script
          }
        };
        npmlog.disableProgress();
        try {
          if (script === scriptShell) {
            if (!noTTY()) {
              if (ciDetect()) return log.warn("exec", "Interactive mode disabled in CI environment");
              locationMsg = locationMsg || ` at location:\n${colorize.dim(runPath)}`, output(`${colorize.reset("\nEntering npm script environment")}${colorize.reset(locationMsg)}${colorize.bold("\nType 'exit' or ^D when finished\n")}`);
            }
          }
          return await runScript({
            ...flatOptions,
            pkg,
            banner: !1,
            path: runPath,
            stdioString: !0,
            binPaths,
            event: "npx",
            args,
            stdio: "inherit",
            scriptShell
          });
        } finally {
          npmlog.enableProgress();
        }
      };
    },
    77881: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const URL = __webpack_require__(57310).URL, Arborist = __webpack_require__(22290);
      function normalizeFunding(funding) {
        const sources = [].concat(funding || []).map((item => "string" == typeof item ? {
          url: item
        } : item));
        return Array.isArray(funding) ? sources : sources[0];
      }
      function isValidFunding(funding) {
        if (!funding) return !1;
        if (Array.isArray(funding)) return funding.every((f => !Array.isArray(f) && isValidFunding(f)));
        try {
          var parsed = new URL(funding.url || funding);
        } catch (error) {
          return !1;
        }
        return ("https:" === parsed.protocol || "http:" === parsed.protocol) && Boolean(parsed.host);
      }
      const empty = () => Object.create(null);
      function readTree(tree, opts) {
        let packageWithFundingCount = 0;
        const seen = new Set, {countOnly} = opts || {}, _trailingDependencies = Symbol("trailingDependencies");
        let filterSet;
        if (opts && opts.workspaces && opts.workspaces.length) {
          const arb = new Arborist(opts);
          filterSet = arb.workspaceDependencySet(tree, opts.workspaces);
        }
        function retrieveDependencies(dependencies) {
          const trailing = dependencies[_trailingDependencies];
          return trailing ? Object.assign(empty(), dependencies, trailing) : dependencies;
        }
        function hasDependencies(dependencies) {
          return dependencies && (Object.keys(dependencies).length || dependencies[_trailingDependencies]);
        }
        const treeDependencies = function getFundingDependencies(t) {
          const edges = t && t.edgesOut && t.edgesOut.values();
          return edges ? Array.from(edges).map((edge => {
            if (!edge || !edge.to) return empty();
            const node = edge.to.target || edge.to;
            if (!node.package) return empty();
            if (filterSet && filterSet.size > 0 && !filterSet.has(node)) return empty();
            const {name, funding, version} = node.package;
            if (function(name, version) {
              const key = String(name) + String(version);
              if (seen.has(key)) return !0;
              seen.add(key);
            }(name, version)) return empty();
            const fundingItem = {};
            return version && (fundingItem.version = version), function(target, funding) {
              funding && isValidFunding(funding) && (target.funding = normalizeFunding(funding), 
              packageWithFundingCount++);
            }(fundingItem, funding), {
              node,
              fundingItem
            };
          })).reduce(((res, {node, fundingItem}, i) => {
            if (!fundingItem || 0 === fundingItem.length || !node) return res;
            const transitiveDependencies = node.edgesOut && node.edgesOut.size > 0 && getFundingDependencies(node);
            return countOnly ? null : (hasDependencies(transitiveDependencies) && (fundingItem.dependencies = retrieveDependencies(transitiveDependencies)), 
            isValidFunding(fundingItem.funding) ? res[node.package.name] = fundingItem : hasDependencies(fundingItem.dependencies) && (res[_trailingDependencies] = Object.assign(empty(), res[_trailingDependencies], fundingItem.dependencies)), 
            res);
          }), countOnly ? null : empty()) : empty();
        }(tree), result = {
          length: packageWithFundingCount
        };
        if (!countOnly) {
          const name = tree && tree.package && tree.package.name || tree && tree.name;
          result.name = name || tree && tree.path, tree && tree.package && tree.package.version && (result.version = tree.package.version), 
          tree && tree.package && tree.package.funding && (result.funding = normalizeFunding(tree.package.funding)), 
          result.dependencies = retrieveDependencies(treeDependencies);
        }
        return result;
      }
      module.exports = {
        read: async function(opts) {
          const arb = new Arborist(opts);
          return readTree(await arb.loadActual(opts), opts);
        },
        readTree,
        normalizeFunding,
        isValidFunding
      };
    },
    76837: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const fetch = __webpack_require__(92427), validate = __webpack_require__(95073), eu = encodeURIComponent, cmd = module.exports = {};
      cmd.add = (name, endpoint, secret, opts = {}) => {
        validate("SSSO", [ name, endpoint, secret, opts ]);
        let type = "package";
        return name.match(/^@[^/]+$/) && (type = "scope"), "~" === name[0] && (type = "owner", 
        name = name.slice(1)), fetch.json("/-/npm/v1/hooks/hook", {
          ...opts,
          method: "POST",
          body: {
            type,
            name,
            endpoint,
            secret
          }
        });
      }, cmd.rm = (id, opts = {}) => (validate("SO", [ id, opts ]), fetch.json(`/-/npm/v1/hooks/hook/${eu(id)}`, {
        ...opts,
        method: "DELETE"
      }).catch((err => {
        if ("E404" === err.code) return null;
        throw err;
      }))), cmd.update = (id, endpoint, secret, opts = {}) => (validate("SSSO", [ id, endpoint, secret, opts ]), 
      fetch.json(`/-/npm/v1/hooks/hook/${eu(id)}`, {
        ...opts,
        method: "PUT",
        body: {
          endpoint,
          secret
        }
      })), cmd.find = (id, opts = {}) => (validate("SO", [ id, opts ]), fetch.json(`/-/npm/v1/hooks/hook/${eu(id)}`, opts)), 
      cmd.ls = (opts = {}) => cmd.ls.stream(opts).collect(), cmd.ls.stream = (opts = {}) => {
        const {package: pkg, limit, offset} = opts;
        return validate("S|Z", [ pkg ]), validate("N|Z", [ limit ]), validate("N|Z", [ offset ]), 
        fetch.json.stream("/-/npm/v1/hooks", "objects.*", {
          ...opts,
          query: {
            package: pkg,
            limit,
            offset
          }
        });
      };
    },
    88624: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const eu = encodeURIComponent, fetch = __webpack_require__(92427), validate = __webpack_require__(95073), cmd = module.exports;
      class MembershipDetail {}
      cmd.set = (org, user, role, opts = {}) => ("object" == typeof role && 0 === Object.keys(opts).length && (opts = role, 
      role = void 0), validate("SSSO|SSZO", [ org, user, role, opts ]), user = user.replace(/^@?/, ""), 
      org = org.replace(/^@?/, ""), fetch.json(`/-/org/${eu(org)}/user`, {
        ...opts,
        method: "PUT",
        body: {
          user,
          role
        }
      }).then((ret => Object.assign(new MembershipDetail, ret)))), cmd.rm = (org, user, opts = {}) => (validate("SSO", [ org, user, opts ]), 
      user = user.replace(/^@?/, ""), org = org.replace(/^@?/, ""), fetch(`/-/org/${eu(org)}/user`, {
        ...opts,
        method: "DELETE",
        body: {
          user
        },
        ignoreBody: !0
      }).then((() => null)));
      class Roster {}
      cmd.ls = (org, opts = {}) => cmd.ls.stream(org, opts).collect().then((data => data.reduce(((acc, [key, val]) => (acc || (acc = {}), 
      acc[key] = val, acc)), null))).then((ret => Object.assign(new Roster, ret))), cmd.ls.stream = (org, opts = {}) => (validate("SO", [ org, opts ]), 
      org = org.replace(/^@?/, ""), fetch.json.stream(`/-/org/${eu(org)}/user`, "*", {
        ...opts,
        mapJSON: (value, [key]) => [ key, value ]
      }));
    },
    67647: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const pacote = __webpack_require__(86585), npa = __webpack_require__(19932), runScript = __webpack_require__(63036), path = __webpack_require__(71017), writeFile = __webpack_require__(73837).promisify(__webpack_require__(57147).writeFile);
      module.exports = async function(spec = "file:.", opts = {}) {
        spec = npa(spec);
        const manifest = await pacote.manifest(spec, opts), banner = !opts.silent;
        "directory" === spec.type && await runScript({
          ...opts,
          event: "prepack",
          path: spec.fetchSpec,
          stdio: "inherit",
          pkg: manifest,
          banner
        });
        const tarball = await pacote.tarball(manifest._resolved, {
          ...opts,
          integrity: manifest._integrity
        });
        if (!1 === opts.dryRun) {
          const filename = `${manifest.name}-${manifest.version}.tgz`.replace(/^@/, "").replace(/\//, "-"), destination = path.resolve(opts.packDestination, filename);
          await writeFile(destination, tarball);
        }
        "directory" === spec.type && await runScript({
          ...opts,
          event: "postpack",
          path: spec.fetchSpec,
          stdio: "inherit",
          pkg: manifest,
          banner,
          env: {
            npm_package_from: tarball.from,
            npm_package_resolved: tarball.resolved,
            npm_package_integrity: tarball.integrity
          }
        });
        return tarball;
      };
    },
    76919: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = {
        publish: __webpack_require__(8610),
        unpublish: __webpack_require__(30622)
      };
    },
    8610: (module, __unused_webpack_exports, __webpack_require__) => {
      const {fixer} = __webpack_require__(17770), npmFetch = __webpack_require__(92427), npa = __webpack_require__(19932), semver = __webpack_require__(5870), {URL} = __webpack_require__(57310), ssri = __webpack_require__(60440), patchManifest = (_manifest, opts) => {
        const {npmVersion} = opts, manifest = {
          ..._manifest
        };
        manifest._nodeVersion = process.versions.node, npmVersion && (manifest._npmVersion = npmVersion), 
        fixer.fixNameField(manifest, {
          strict: !0,
          allowLegacyCase: !0
        });
        const version = semver.clean(manifest.version);
        if (!version) throw Object.assign(new Error("invalid semver: " + manifest.version), {
          code: "EBADSEMVER"
        });
        return manifest.version = version, manifest;
      }, buildMetadata = (registry, manifest, tarballData, opts) => {
        const {access, defaultTag, algorithms} = opts, root = {
          _id: manifest.name,
          name: manifest.name,
          description: manifest.description,
          "dist-tags": {},
          versions: {},
          access
        };
        root.versions[manifest.version] = manifest;
        const tag = manifest.tag || defaultTag;
        root["dist-tags"][tag] = manifest.version;
        const tarballName = `${manifest.name}-${manifest.version}.tgz`, tarballURI = `${manifest.name}/-/${tarballName}`, integrity = ssri.fromData(tarballData, {
          algorithms: [ ...new Set([ "sha1" ].concat(algorithms)) ]
        });
        return manifest._id = `${manifest.name}@${manifest.version}`, manifest.dist = {
          ...manifest.dist
        }, manifest.dist.integrity = integrity.sha512[0].toString(), manifest.dist.shasum = integrity.sha1[0].hexDigest(), 
        manifest.dist.tarball = new URL(tarballURI, registry).href.replace(/^https:\/\//, "http://"), 
        root._attachments = {}, root._attachments[tarballName] = {
          content_type: "application/octet-stream",
          data: tarballData.toString("base64"),
          length: tarballData.length
        }, root;
      }, patchMetadata = (current, newData) => {
        const curVers = Object.keys(current.versions || {}).map((v => semver.clean(v, !0))).concat(Object.keys(current.time || {}).map((v => semver.valid(v, !0) && semver.clean(v, !0))).filter((v => v))), newVersion = Object.keys(newData.versions)[0];
        if (-1 !== curVers.indexOf(newVersion)) {
          const {name: pkgid, version} = newData;
          throw Object.assign(new Error(`Cannot publish ${pkgid}@${version} over existing version.`), {
            code: "EPUBLISHCONFLICT",
            pkgid,
            version
          });
        }
        current.versions = current.versions || {}, current.versions[newVersion] = newData.versions[newVersion];
        for (const i in newData) switch (i) {
         case "dist-tags":
         case "versions":
         case "_attachments":
          for (const j in newData[i]) current[i] = current[i] || {}, current[i][j] = newData[i][j];
          break;

         default:
          current[i] = newData[i];
        }
        return current;
      };
      module.exports = async (manifest, tarballData, opts) => {
        if (manifest.private) throw Object.assign(new Error("This package has been marked as private\nRemove the 'private' field from the package.json to publish it."), {
          code: "EPRIVATE"
        });
        const spec = npa.resolve(manifest.name, manifest.version);
        opts = {
          defaultTag: "latest",
          access: spec.scope ? "restricted" : "public",
          algorithms: [ "sha512" ],
          ...opts,
          spec
        };
        const reg = npmFetch.pickRegistry(spec, opts), pubManifest = patchManifest(manifest, opts);
        if (!spec.scope && "restricted" === opts.access) throw Object.assign(new Error("Can't restrict access to unscoped packages."), {
          code: "EUNSCOPED"
        });
        const metadata = buildMetadata(reg, pubManifest, tarballData, opts);
        try {
          return await npmFetch(spec.escapedName, {
            ...opts,
            method: "PUT",
            body: metadata,
            ignoreBody: !0
          });
        } catch (err) {
          if ("E409" !== err.code) throw err;
          const current = await npmFetch.json(spec.escapedName, {
            ...opts,
            query: {
              write: !0
            }
          }), newMetadata = patchMetadata(current, metadata);
          return npmFetch(spec.escapedName, {
            ...opts,
            method: "PUT",
            body: newMetadata,
            ignoreBody: !0
          });
        }
      };
    },
    30622: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const {URL} = __webpack_require__(57310), npa = __webpack_require__(19932), npmFetch = __webpack_require__(92427), semver = __webpack_require__(5870);
      module.exports = async (spec, opts) => {
        spec = npa(spec), opts = {
          force: !1,
          ...opts,
          spec
        };
        try {
          const pkgUri = spec.escapedName, pkg = await npmFetch.json(pkgUri, {
            ...opts,
            query: {
              write: !0
            }
          }), version = spec.rawSpec, allVersions = pkg.versions || {}, versionData = allVersions[version], rawSpecs = !spec.rawSpec || "*" === spec.rawSpec, onlyVersion = 1 === Object.keys(allVersions).length, noVersions = !Object.keys(allVersions).length;
          if (!versionData && !rawSpecs && !noVersions) return !0;
          if (rawSpecs || onlyVersion || noVersions) return await npmFetch(`${pkgUri}/-rev/${pkg._rev}`, {
            ...opts,
            method: "DELETE",
            ignoreBody: !0
          }), !0;
          {
            const dist = allVersions[version].dist;
            delete allVersions[version];
            const latestVer = pkg["dist-tags"].latest;
            Object.keys(pkg["dist-tags"]).forEach((tag => {
              pkg["dist-tags"][tag] === version && delete pkg["dist-tags"][tag];
            })), latestVer === version && (pkg["dist-tags"].latest = Object.keys(allVersions).sort(semver.compareLoose).pop()), 
            delete pkg._revisions, delete pkg._attachments, await npmFetch(`${pkgUri}/-rev/${pkg._rev}`, {
              ...opts,
              method: "PUT",
              body: pkg,
              ignoreBody: !0
            });
            const {_rev} = await npmFetch.json(pkgUri, {
              ...opts,
              query: {
                write: !0
              }
            }), tarballUrl = ((tarball, registry) => {
              const registryUrl = new URL(registry).pathname.slice(1);
              let tarballUrl = new URL(tarball).pathname.slice(1);
              return registryUrl && (tarballUrl = tarballUrl.slice(registryUrl.length)), tarballUrl;
            })(dist.tarball, opts.registry);
            return await npmFetch(`${tarballUrl}/-rev/${_rev}`, {
              ...opts,
              method: "DELETE",
              ignoreBody: !0
            }), !0;
          }
        } catch (err) {
          if ("E404" !== err.code) throw err;
          return !0;
        }
      };
    },
    8895: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const npmFetch = __webpack_require__(92427);
      function search(query, opts) {
        return search.stream(query, opts).collect();
      }
      module.exports = search, search.stream = function(query, opts = {}) {
        switch ((opts = {
          detailed: !1,
          limit: 20,
          from: 0,
          quality: .65,
          popularity: .98,
          maintenance: .5,
          ...opts.opts,
          ...opts
        }).sortBy) {
         case "optimal":
          opts.quality = .65, opts.popularity = .98, opts.maintenance = .5;
          break;

         case "quality":
          opts.quality = 1, opts.popularity = 0, opts.maintenance = 0;
          break;

         case "popularity":
          opts.quality = 0, opts.popularity = 1, opts.maintenance = 0;
          break;

         case "maintenance":
          opts.quality = 0, opts.popularity = 0, opts.maintenance = 1;
        }
        return npmFetch.json.stream("/-/v1/search", "objects.*", {
          ...opts,
          query: {
            text: Array.isArray(query) ? query.join(" ") : query,
            size: opts.limit,
            from: opts.from,
            quality: opts.quality,
            popularity: opts.popularity,
            maintenance: opts.maintenance
          },
          mapJSON: obj => (obj.package.date && (obj.package.date = new Date(obj.package.date)), 
          opts.detailed ? obj : obj.package)
        });
      };
    },
    88166: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const eu = encodeURIComponent, npmFetch = __webpack_require__(92427), validate = __webpack_require__(95073), cmd = module.exports;
      function splitEntity(entity = "") {
        const [, scope, team] = entity.match(/^@?([^:]+):(.*)$/) || [];
        return {
          scope,
          team
        };
      }
      cmd.create = (entity, opts = {}) => Promise.resolve().then((() => {
        const {scope, team} = splitEntity(entity);
        validate("SSO", [ scope, team, opts ]);
        const uri = `/-/org/${eu(scope)}/team`;
        return npmFetch.json(uri, {
          ...opts,
          method: "PUT",
          scope,
          body: {
            name: team,
            description: opts.description
          }
        });
      })), cmd.destroy = (entity, opts = {}) => {
        const {scope, team} = splitEntity(entity);
        validate("SSO", [ scope, team, opts ]);
        const uri = `/-/team/${eu(scope)}/${eu(team)}`;
        return npmFetch.json(uri, {
          ...opts,
          method: "DELETE",
          scope
        });
      }, cmd.add = (user, entity, opts = {}) => {
        const {scope, team} = splitEntity(entity);
        validate("SSO", [ scope, team, opts ]);
        const uri = `/-/team/${eu(scope)}/${eu(team)}/user`;
        return npmFetch.json(uri, {
          ...opts,
          method: "PUT",
          scope,
          body: {
            user
          }
        });
      }, cmd.rm = (user, entity, opts = {}) => {
        const {scope, team} = splitEntity(entity);
        validate("SSO", [ scope, team, opts ]);
        const uri = `/-/team/${eu(scope)}/${eu(team)}/user`;
        return npmFetch.json(uri, {
          ...opts,
          method: "DELETE",
          scope,
          body: {
            user
          }
        });
      }, cmd.lsTeams = (...args) => cmd.lsTeams.stream(...args).collect(), cmd.lsTeams.stream = (scope, opts = {}) => {
        validate("SO", [ scope, opts ]);
        const uri = `/-/org/${eu(scope)}/team`;
        return npmFetch.json.stream(uri, ".*", {
          ...opts,
          query: {
            format: "cli"
          }
        });
      }, cmd.lsUsers = (...args) => cmd.lsUsers.stream(...args).collect(), cmd.lsUsers.stream = (entity, opts = {}) => {
        const {scope, team} = splitEntity(entity);
        validate("SSO", [ scope, team, opts ]);
        const uri = `/-/team/${eu(scope)}/${eu(team)}/user`;
        return npmFetch.json.stream(uri, ".*", {
          ...opts,
          query: {
            format: "cli"
          }
        });
      }, cmd.edit = () => {
        throw new Error("edit is not implemented yet");
      };
    },
    82288: (module, __unused_webpack_exports, __webpack_require__) => {
      const git = __webpack_require__(1626);
      module.exports = (version, opts) => {
        const {commitHooks, allowSameVersion, signGitCommit, message} = opts, args = [ "commit" ];
        return !1 === commitHooks && args.push("-n"), allowSameVersion && args.push("--allow-empty"), 
        signGitCommit && args.push("-S"), args.push("-m"), git.spawn([ ...args, message.replace(/%s/g, version) ], opts);
      };
    },
    75466: (module, __unused_webpack_exports, __webpack_require__) => {
      const git = __webpack_require__(1626), log = __webpack_require__(46521);
      module.exports = async opts => {
        const {force} = opts;
        let hadError = !1;
        if (!await git.isClean(opts).catch((er => {
          if ("ENOGIT" === er.code) return log.warn("version", "This is a Git checkout, but the git command was not found.", "npm could not create a Git tag for this release!"), 
          hadError = !0, !0;
          throw er;
        }))) {
          if (!force) throw new Error("Git working directory not clean.");
          log.warn("version", "Git working directory not clean, proceeding forcefully.");
        }
        return !hadError;
      };
    },
    25970: (module, __unused_webpack_exports, __webpack_require__) => {
      const readJson = __webpack_require__(86335), version = __webpack_require__(39041);
      module.exports = async (newversion, opts = {}) => {
        const {path = process.cwd(), allowSameVersion = !1, tagVersionPrefix = "v", commitHooks = !0, gitTagVersion = !0, signGitCommit = !1, signGitTag = !1, force = !1, ignoreScripts = !1, scriptShell, preid = null, message = "v%s", silent} = opts, pkg = opts.pkg || await readJson(path + "/package.json");
        return version(newversion, {
          path,
          cwd: path,
          allowSameVersion,
          tagVersionPrefix,
          commitHooks,
          gitTagVersion,
          signGitCommit,
          signGitTag,
          force,
          ignoreScripts,
          scriptShell,
          preid,
          pkg,
          message,
          silent
        });
      };
    },
    86335: (module, __unused_webpack_exports, __webpack_require__) => {
      const {promisify} = __webpack_require__(73837), readFile = promisify(__webpack_require__(57147).readFile), parse = __webpack_require__(40295);
      module.exports = async path => parse(await readFile(path));
    },
    87582: (module, __unused_webpack_exports, __webpack_require__) => {
      const {spawn} = __webpack_require__(1626), semver = __webpack_require__(5870);
      module.exports = async opts => {
        const tag = (await spawn([ "describe", "--tags", "--abbrev=0", "--match=*.*.*" ], opts)).stdout.trim(), ver = semver.coerce(tag, {
          loose: !0
        });
        if (ver) return ver.version;
        throw new Error(`Tag is not a valid version: ${JSON.stringify(tag)}`);
      };
    },
    27762: (module, __unused_webpack_exports, __webpack_require__) => {
      const git = __webpack_require__(1626);
      module.exports = async (version, opts) => {
        const {signGitTag, allowSameVersion, tagVersionPrefix, message} = opts, tag = `${tagVersionPrefix}${version}`, flags = [ "-" ];
        return signGitTag && flags.push("s"), allowSameVersion && flags.push("f"), flags.push("m"), 
        git.spawn([ "tag", flags.join(""), message.replace(/%s/g, version), tag ], opts);
      };
    },
    39041: (module, __unused_webpack_exports, __webpack_require__) => {
      const retrieveTag = __webpack_require__(87582), semver = __webpack_require__(5870), enforceClean = __webpack_require__(75466), writeJson = __webpack_require__(88580), readJson = __webpack_require__(86335), git = __webpack_require__(1626), commit = __webpack_require__(82288), tag = __webpack_require__(27762), log = __webpack_require__(46521), runScript = __webpack_require__(63036);
      module.exports = async (newversion, opts) => {
        const {path, allowSameVersion, gitTagVersion, ignoreScripts, preid, pkg, silent} = opts, {valid, clean, inc} = semver, current = pkg.version || "0.0.0", currentClean = clean(current);
        let newV;
        if (newV = valid(newversion, {
          loose: !0
        }) ? clean(newversion, {
          loose: !0
        }) : "from-git" === newversion ? await retrieveTag(opts) : inc(currentClean, newversion, {
          loose: !0
        }, preid), !newV) throw Object.assign(new Error("Invalid version: " + newversion), {
          current,
          requested: newversion
        });
        if (newV === currentClean && !allowSameVersion) throw Object.assign(new Error("Version not changed"), {
          current,
          requested: newversion,
          newVersion: newV
        });
        const isGitDir = "from-git" === newversion || await git.is(opts), doGit = gitTagVersion && isGitDir && await enforceClean(opts);
        ignoreScripts || await runScript({
          ...opts,
          pkg,
          stdio: "inherit",
          event: "preversion",
          banner: !silent,
          env: {
            npm_old_version: current,
            npm_new_version: newV
          }
        }), pkg.version = newV, delete pkg._id, await writeJson(`${path}/package.json`, pkg);
        const locks = [ `${path}/package-lock.json`, `${path}/npm-shrinkwrap.json` ], haveLocks = [];
        for (const lock of locks) try {
          const sw = await readJson(lock);
          sw.version = newV, sw.packages && sw.packages[""] && (sw.packages[""].version = newV), 
          await writeJson(lock, sw), haveLocks.push(lock);
        } catch {}
        if (ignoreScripts || await runScript({
          ...opts,
          pkg,
          stdio: "inherit",
          event: "version",
          banner: !silent,
          env: {
            npm_old_version: current,
            npm_new_version: newV
          }
        }), doGit) {
          await git.spawn([ "add", `${path}/package.json` ], opts);
          for (const lock of haveLocks) await git.spawn([ "add", lock ], opts).catch((() => {}));
          await commit(newV, opts), await tag(newV, opts);
        } else log.verbose("version", "Not tagging: not in a git repo or no git cmd");
        return ignoreScripts || await runScript({
          ...opts,
          pkg,
          stdio: "inherit",
          event: "postversion",
          banner: !silent,
          env: {
            npm_old_version: current,
            npm_new_version: newV
          }
        }), newV;
      };
    },
    88580: (module, __unused_webpack_exports, __webpack_require__) => {
      const {promisify} = __webpack_require__(73837), writeFile = promisify(__webpack_require__(57147).writeFile), kIndent = Symbol.for("indent"), kNewline = Symbol.for("newline");
      module.exports = async (path, pkg) => {
        const {[kIndent]: indent = 2, [kNewline]: newline = "\n"} = pkg;
        delete pkg._id;
        const raw = JSON.stringify(pkg, null, indent) + "\n", data = "\n" === newline ? raw : raw.split("\n").join(newline);
        return writeFile(path, data);
      };
    },
    55018: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const Parser = __webpack_require__(84105), Minipass = __webpack_require__(45018);
      class JSONStreamError extends Error {
        constructor(err, caller) {
          super(err.message), Error.captureStackTrace(this, caller || this.constructor);
        }
        get name() {
          return "JSONStreamError";
        }
        set name(n) {}
      }
      const check = (x, y) => "string" == typeof x ? String(y) === x : x && "function" == typeof x.test ? x.test(y) : "boolean" == typeof x || "object" == typeof x ? x : "function" == typeof x && x(y), _parser = Symbol("_parser"), _onValue = Symbol("_onValue"), _onTokenOriginal = Symbol("_onTokenOriginal"), _onToken = Symbol("_onToken"), _onError = Symbol("_onError"), _count = Symbol("_count"), _path = Symbol("_path"), _map = Symbol("_map"), _root = Symbol("_root"), _header = Symbol("_header"), _footer = Symbol("_footer"), _setHeaderFooter = Symbol("_setHeaderFooter"), _ending = Symbol("_ending");
      class JSONStream extends Minipass {
        constructor(opts = {}) {
          super({
            ...opts,
            objectMode: !0
          }), this[_ending] = !1;
          const parser = this[_parser] = new Parser;
          parser.onValue = value => this[_onValue](value), this[_onTokenOriginal] = parser.onToken, 
          parser.onToken = (token, value) => this[_onToken](token, value), parser.onError = er => this[_onError](er), 
          this[_count] = 0, this[_path] = "string" == typeof opts.path ? opts.path.split(".").map((e => "$*" === e ? {
            emitKey: !0
          } : "*" === e || ("" === e ? {
            recurse: !0
          } : e))) : Array.isArray(opts.path) && opts.path.length ? opts.path : null, this[_map] = "function" == typeof opts.map ? opts.map : null, 
          this[_root] = null, this[_header] = null, this[_footer] = null, this[_count] = 0;
        }
        [_setHeaderFooter](key, value) {
          !1 !== this[_header] && (this[_header] = this[_header] || {}, this[_header][key] = value), 
          !1 !== this[_footer] && !1 === this[_header] && (this[_footer] = this[_footer] || {}, 
          this[_footer][key] = value);
        }
        [_onError](er) {
          const caller = this[_ending] ? this.end : this.write;
          return this[_ending] = !1, this.emit("error", new JSONStreamError(er, caller));
        }
        [_onToken](token, value) {
          const parser = this[_parser];
          if (this[_onTokenOriginal].call(parser, token, value), 0 === parser.stack.length && this[_root]) {
            const root = this[_root];
            this[_path] || super.write(root), this[_root] = null, this[_count] = 0;
          }
        }
        [_onValue](value) {
          const parser = this[_parser];
          if (this[_root] = value, !this[_path]) return;
          let i = 0, j = 0, emitKey = !1, emitPath = !1;
          for (;i < this[_path].length; ) {
            const key = this[_path][i];
            if (j++, key && !key.recurse) {
              const c = j === parser.stack.length ? parser : parser.stack[j];
              if (!c) return;
              if (!check(key, c.key)) return void this[_setHeaderFooter](c.key, value);
              emitKey = !!key.emitKey, emitPath = !!key.emitPath, i++;
            } else {
              if (i++, i >= this[_path].length) return;
              const nextKey = this[_path][i];
              if (!nextKey) return;
              for (;;) {
                const c = j === parser.stack.length ? parser : parser.stack[j];
                if (!c) return;
                if (check(nextKey, c.key)) {
                  i++, Object.isFrozen(parser.stack[j]) || (parser.stack[j].value = null);
                  break;
                }
                this[_setHeaderFooter](c.key, value), j++;
              }
            }
          }
          if (this[_header]) {
            const header = this[_header];
            this[_header] = !1, this.emit("header", header);
          }
          if (j !== parser.stack.length) return;
          this[_count]++;
          const actualPath = parser.stack.slice(1).map((e => e.key)).concat([ parser.key ]);
          if (null != value) {
            const data = this[_map] ? this[_map](value, actualPath) : value;
            if (null != data) {
              const emit = emitKey || emitPath ? {
                value: data
              } : data;
              emitKey && (emit.key = parser.key), emitPath && (emit.path = actualPath), super.write(emit);
            }
          }
          parser.value && delete parser.value[parser.key];
          for (const k of parser.stack) k.value = null;
        }
        write(chunk, encoding, cb) {
          if ("function" == typeof encoding && (cb = encoding, encoding = null), "string" == typeof chunk) chunk = Buffer.from(chunk, encoding); else if (!Buffer.isBuffer(chunk)) return this.emit("error", new TypeError("Can only parse JSON from string or buffer input"));
          return this[_parser].write(chunk), cb && cb(), this.flowing;
        }
        end(chunk, encoding, cb) {
          this[_ending] = !0, "function" == typeof encoding && (cb = encoding, encoding = null), 
          "function" == typeof chunk && (cb = chunk, chunk = null), chunk && this.write(chunk, encoding), 
          cb && this.once("end", cb);
          const h = this[_header];
          this[_header] = null;
          const f = this[_footer];
          return this[_footer] = null, h && this.emit("header", h), f && this.emit("footer", f), 
          super.end();
        }
        static get JSONStreamError() {
          return JSONStreamError;
        }
        static parse(path, map) {
          return new JSONStream({
            path,
            map
          });
        }
      }
      module.exports = JSONStream;
    },
    31791: (module, __unused_webpack_exports, __webpack_require__) => {
      const Minipass = __webpack_require__(45018), EE = __webpack_require__(82361), _head = Symbol("_head"), _tail = Symbol("_tail"), _linkStreams = Symbol("_linkStreams"), _setHead = Symbol("_setHead"), _setTail = Symbol("_setTail"), _onError = Symbol("_onError"), _onData = Symbol("_onData"), _onEnd = Symbol("_onEnd"), _onDrain = Symbol("_onDrain"), _streams = Symbol("_streams");
      module.exports = class extends Minipass {
        constructor(opts, ...streams) {
          var s;
          (s = opts) && s instanceof EE && ("function" == typeof s.pipe || "function" == typeof s.write && "function" == typeof s.end) && (streams.unshift(opts), 
          opts = {}), super(opts), this[_streams] = [], streams.length && this.push(...streams);
        }
        [_linkStreams](streams) {
          return streams.reduce(((src, dest) => (src.on("error", (er => dest.emit("error", er))), 
          src.pipe(dest), dest)));
        }
        push(...streams) {
          this[_streams].push(...streams), this[_tail] && streams.unshift(this[_tail]);
          const linkRet = this[_linkStreams](streams);
          this[_setTail](linkRet), this[_head] || this[_setHead](streams[0]);
        }
        unshift(...streams) {
          this[_streams].unshift(...streams), this[_head] && streams.push(this[_head]);
          const linkRet = this[_linkStreams](streams);
          this[_setHead](streams[0]), this[_tail] || this[_setTail](linkRet);
        }
        destroy(er) {
          return this[_streams].forEach((s => "function" == typeof s.destroy && s.destroy())), 
          super.destroy(er);
        }
        [_setTail](stream) {
          this[_tail] = stream, stream.on("error", (er => this[_onError](stream, er))), stream.on("data", (chunk => this[_onData](stream, chunk))), 
          stream.on("end", (() => this[_onEnd](stream))), stream.on("finish", (() => this[_onEnd](stream)));
        }
        [_onError](stream, er) {
          stream === this[_tail] && this.emit("error", er);
        }
        [_onData](stream, chunk) {
          stream === this[_tail] && super.write(chunk);
        }
        [_onEnd](stream) {
          stream === this[_tail] && super.end();
        }
        pause() {
          return super.pause(), this[_tail] && this[_tail].pause && this[_tail].pause();
        }
        emit(ev, ...args) {
          return "resume" === ev && this[_tail] && this[_tail].resume && this[_tail].resume(), 
          super.emit(ev, ...args);
        }
        [_setHead](stream) {
          this[_head] = stream, stream.on("drain", (() => this[_onDrain](stream)));
        }
        [_onDrain](stream) {
          stream === this[_head] && this.emit("drain");
        }
        write(chunk, enc, cb) {
          return this[_head].write(chunk, enc, cb) && (this.flowing || 0 === this.buffer.length);
        }
        end(chunk, enc, cb) {
          return this[_head].end(chunk, enc, cb), this;
        }
      };
    },
    40091: (module, __unused_webpack_exports, __webpack_require__) => {
      const realZlibConstants = __webpack_require__(59796).constants || {
        ZLIB_VERNUM: 4736
      };
      module.exports = Object.freeze(Object.assign(Object.create(null), {
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        Z_MEM_ERROR: -4,
        Z_BUF_ERROR: -5,
        Z_VERSION_ERROR: -6,
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        DEFLATE: 1,
        INFLATE: 2,
        GZIP: 3,
        GUNZIP: 4,
        DEFLATERAW: 5,
        INFLATERAW: 6,
        UNZIP: 7,
        BROTLI_DECODE: 8,
        BROTLI_ENCODE: 9,
        Z_MIN_WINDOWBITS: 8,
        Z_MAX_WINDOWBITS: 15,
        Z_DEFAULT_WINDOWBITS: 15,
        Z_MIN_CHUNK: 64,
        Z_MAX_CHUNK: 1 / 0,
        Z_DEFAULT_CHUNK: 16384,
        Z_MIN_MEMLEVEL: 1,
        Z_MAX_MEMLEVEL: 9,
        Z_DEFAULT_MEMLEVEL: 8,
        Z_MIN_LEVEL: -1,
        Z_MAX_LEVEL: 9,
        Z_DEFAULT_LEVEL: -1,
        BROTLI_OPERATION_PROCESS: 0,
        BROTLI_OPERATION_FLUSH: 1,
        BROTLI_OPERATION_FINISH: 2,
        BROTLI_OPERATION_EMIT_METADATA: 3,
        BROTLI_MODE_GENERIC: 0,
        BROTLI_MODE_TEXT: 1,
        BROTLI_MODE_FONT: 2,
        BROTLI_DEFAULT_MODE: 0,
        BROTLI_MIN_QUALITY: 0,
        BROTLI_MAX_QUALITY: 11,
        BROTLI_DEFAULT_QUALITY: 11,
        BROTLI_MIN_WINDOW_BITS: 10,
        BROTLI_MAX_WINDOW_BITS: 24,
        BROTLI_LARGE_MAX_WINDOW_BITS: 30,
        BROTLI_DEFAULT_WINDOW: 22,
        BROTLI_MIN_INPUT_BLOCK_BITS: 16,
        BROTLI_MAX_INPUT_BLOCK_BITS: 24,
        BROTLI_PARAM_MODE: 0,
        BROTLI_PARAM_QUALITY: 1,
        BROTLI_PARAM_LGWIN: 2,
        BROTLI_PARAM_LGBLOCK: 3,
        BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
        BROTLI_PARAM_SIZE_HINT: 5,
        BROTLI_PARAM_LARGE_WINDOW: 6,
        BROTLI_PARAM_NPOSTFIX: 7,
        BROTLI_PARAM_NDIRECT: 8,
        BROTLI_DECODER_RESULT_ERROR: 0,
        BROTLI_DECODER_RESULT_SUCCESS: 1,
        BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
        BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
        BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
        BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
        BROTLI_DECODER_NO_ERROR: 0,
        BROTLI_DECODER_SUCCESS: 1,
        BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
        BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
        BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
        BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
        BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
        BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
        BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
        BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
        BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
        BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
        BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
        BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
        BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
        BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
        BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
        BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
        BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
        BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
        BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
        BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
        BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
        BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
        BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
        BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
        BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
        BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
        BROTLI_DECODER_ERROR_UNREACHABLE: -31
      }, realZlibConstants));
    },
    13118: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      const assert = __webpack_require__(39491), Buffer = __webpack_require__(14300).Buffer, realZlib = __webpack_require__(59796), constants = exports.constants = __webpack_require__(40091), Minipass = __webpack_require__(45018), OriginalBufferConcat = Buffer.concat, _superWrite = Symbol("_superWrite");
      class ZlibError extends Error {
        constructor(err) {
          super("zlib: " + err.message), this.code = err.code, this.errno = err.errno, this.code || (this.code = "ZLIB_ERROR"), 
          this.message = "zlib: " + err.message, Error.captureStackTrace(this, this.constructor);
        }
        get name() {
          return "ZlibError";
        }
      }
      const _opts = Symbol("opts"), _flushFlag = Symbol("flushFlag"), _finishFlushFlag = Symbol("finishFlushFlag"), _fullFlushFlag = Symbol("fullFlushFlag"), _handle = Symbol("handle"), _onError = Symbol("onError"), _sawError = Symbol("sawError"), _level = Symbol("level"), _strategy = Symbol("strategy"), _ended = Symbol("ended");
      Symbol("_defaultFullFlush");
      class ZlibBase extends Minipass {
        constructor(opts, mode) {
          if (!opts || "object" != typeof opts) throw new TypeError("invalid options for ZlibBase constructor");
          super(opts), this[_sawError] = !1, this[_ended] = !1, this[_opts] = opts, this[_flushFlag] = opts.flush, 
          this[_finishFlushFlag] = opts.finishFlush;
          try {
            this[_handle] = new realZlib[mode](opts);
          } catch (er) {
            throw new ZlibError(er);
          }
          this[_onError] = err => {
            this[_sawError] || (this[_sawError] = !0, this.close(), this.emit("error", err));
          }, this[_handle].on("error", (er => this[_onError](new ZlibError(er)))), this.once("end", (() => this.close));
        }
        close() {
          this[_handle] && (this[_handle].close(), this[_handle] = null, this.emit("close"));
        }
        reset() {
          if (!this[_sawError]) return assert(this[_handle], "zlib binding closed"), this[_handle].reset();
        }
        flush(flushFlag) {
          this.ended || ("number" != typeof flushFlag && (flushFlag = this[_fullFlushFlag]), 
          this.write(Object.assign(Buffer.alloc(0), {
            [_flushFlag]: flushFlag
          })));
        }
        end(chunk, encoding, cb) {
          return chunk && this.write(chunk, encoding), this.flush(this[_finishFlushFlag]), 
          this[_ended] = !0, super.end(null, null, cb);
        }
        get ended() {
          return this[_ended];
        }
        write(chunk, encoding, cb) {
          if ("function" == typeof encoding && (cb = encoding, encoding = "utf8"), "string" == typeof chunk && (chunk = Buffer.from(chunk, encoding)), 
          this[_sawError]) return;
          assert(this[_handle], "zlib binding closed");
          const nativeHandle = this[_handle]._handle, originalNativeClose = nativeHandle.close;
          nativeHandle.close = () => {};
          const originalClose = this[_handle].close;
          let result, writeReturn;
          this[_handle].close = () => {}, Buffer.concat = args => args;
          try {
            const flushFlag = "number" == typeof chunk[_flushFlag] ? chunk[_flushFlag] : this[_flushFlag];
            result = this[_handle]._processChunk(chunk, flushFlag), Buffer.concat = OriginalBufferConcat;
          } catch (err) {
            Buffer.concat = OriginalBufferConcat, this[_onError](new ZlibError(err));
          } finally {
            this[_handle] && (this[_handle]._handle = nativeHandle, nativeHandle.close = originalNativeClose, 
            this[_handle].close = originalClose, this[_handle].removeAllListeners("error"));
          }
          if (this[_handle] && this[_handle].on("error", (er => this[_onError](new ZlibError(er)))), 
          result) if (Array.isArray(result) && result.length > 0) {
            writeReturn = this[_superWrite](Buffer.from(result[0]));
            for (let i = 1; i < result.length; i++) writeReturn = this[_superWrite](result[i]);
          } else writeReturn = this[_superWrite](Buffer.from(result));
          return cb && cb(), writeReturn;
        }
        [_superWrite](data) {
          return super.write(data);
        }
      }
      class Zlib extends ZlibBase {
        constructor(opts, mode) {
          (opts = opts || {}).flush = opts.flush || constants.Z_NO_FLUSH, opts.finishFlush = opts.finishFlush || constants.Z_FINISH, 
          super(opts, mode), this[_fullFlushFlag] = constants.Z_FULL_FLUSH, this[_level] = opts.level, 
          this[_strategy] = opts.strategy;
        }
        params(level, strategy) {
          if (!this[_sawError]) {
            if (!this[_handle]) throw new Error("cannot switch params when binding is closed");
            if (!this[_handle].params) throw new Error("not supported in this implementation");
            if (this[_level] !== level || this[_strategy] !== strategy) {
              this.flush(constants.Z_SYNC_FLUSH), assert(this[_handle], "zlib binding closed");
              const origFlush = this[_handle].flush;
              this[_handle].flush = (flushFlag, cb) => {
                this.flush(flushFlag), cb();
              };
              try {
                this[_handle].params(level, strategy);
              } finally {
                this[_handle].flush = origFlush;
              }
              this[_handle] && (this[_level] = level, this[_strategy] = strategy);
            }
          }
        }
      }
      const _portable = Symbol("_portable");
      class Brotli extends ZlibBase {
        constructor(opts, mode) {
          (opts = opts || {}).flush = opts.flush || constants.BROTLI_OPERATION_PROCESS, opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH, 
          super(opts, mode), this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH;
        }
      }
      class BrotliCompress extends Brotli {
        constructor(opts) {
          super(opts, "BrotliCompress");
        }
      }
      class BrotliDecompress extends Brotli {
        constructor(opts) {
          super(opts, "BrotliDecompress");
        }
      }
      exports.Deflate = class extends Zlib {
        constructor(opts) {
          super(opts, "Deflate");
        }
      }, exports.Inflate = class extends Zlib {
        constructor(opts) {
          super(opts, "Inflate");
        }
      }, exports.Gzip = class extends Zlib {
        constructor(opts) {
          super(opts, "Gzip"), this[_portable] = opts && !!opts.portable;
        }
        [_superWrite](data) {
          return this[_portable] ? (this[_portable] = !1, data[9] = 255, super[_superWrite](data)) : super[_superWrite](data);
        }
      }, exports.Gunzip = class extends Zlib {
        constructor(opts) {
          super(opts, "Gunzip");
        }
      }, exports.DeflateRaw = class extends Zlib {
        constructor(opts) {
          super(opts, "DeflateRaw");
        }
      }, exports.InflateRaw = class extends Zlib {
        constructor(opts) {
          super(opts, "InflateRaw");
        }
      }, exports.Unzip = class extends Zlib {
        constructor(opts) {
          super(opts, "Unzip");
        }
      }, "function" == typeof realZlib.BrotliCompress ? (exports.BrotliCompress = BrotliCompress, 
      exports.BrotliDecompress = BrotliDecompress) : exports.BrotliCompress = exports.BrotliDecompress = class {
        constructor() {
          throw new Error("Brotli is not supported in this version of Node.js");
        }
      };
    },
    87700: (module, __unused_webpack_exports, __webpack_require__) => {
      const inferOwner = __webpack_require__(84876), mkdirp = __webpack_require__(41718), {promisify} = __webpack_require__(73837), chownr = promisify(__webpack_require__(13159)), isWindows = "win32" === (process.env.__TESTING_MKDIRP_INFER_OWNER_PLATFORM__ || process.platform), isRoot = process.getuid && 0 === process.getuid(), doChown = !isWindows && isRoot;
      module.exports = doChown ? (path, opts) => inferOwner(path).then((({uid, gid}) => mkdirp(path, opts).then((made => 0 !== uid || gid !== process.getgid() ? chownr(made || path, uid, gid).then((() => made)) : made)))) : (path, opts) => mkdirp(path, opts), 
      module.exports.sync = doChown ? (path, opts) => {
        const {uid, gid} = inferOwner.sync(path), made = mkdirp.sync(path);
        return 0 === uid && gid === process.getgid() || chownr.sync(made || path, uid, gid), 
        made;
      } : (path, opts) => mkdirp.sync(path, opts);
    },
    41718: (module, __unused_webpack_exports, __webpack_require__) => {
      const optsArg = __webpack_require__(56627), pathArg = __webpack_require__(64315), {mkdirpNative, mkdirpNativeSync} = __webpack_require__(13653), {mkdirpManual, mkdirpManualSync} = __webpack_require__(43974), {useNative, useNativeSync} = __webpack_require__(93e3), mkdirp = (path, opts) => (path = pathArg(path), 
      opts = optsArg(opts), useNative(opts) ? mkdirpNative(path, opts) : mkdirpManual(path, opts));
      mkdirp.sync = (path, opts) => (path = pathArg(path), opts = optsArg(opts), useNativeSync(opts) ? mkdirpNativeSync(path, opts) : mkdirpManualSync(path, opts)), 
      mkdirp.native = (path, opts) => mkdirpNative(pathArg(path), optsArg(opts)), mkdirp.manual = (path, opts) => mkdirpManual(pathArg(path), optsArg(opts)), 
      mkdirp.nativeSync = (path, opts) => mkdirpNativeSync(pathArg(path), optsArg(opts)), 
      mkdirp.manualSync = (path, opts) => mkdirpManualSync(pathArg(path), optsArg(opts)), 
      module.exports = mkdirp;
    },
    33408: (module, __unused_webpack_exports, __webpack_require__) => {
      const {dirname} = __webpack_require__(71017), findMade = (opts, parent, path) => path === parent ? Promise.resolve() : opts.statAsync(parent).then((st => st.isDirectory() ? path : void 0), (er => "ENOENT" === er.code ? findMade(opts, dirname(parent), parent) : void 0)), findMadeSync = (opts, parent, path) => {
        if (path !== parent) try {
          return opts.statSync(parent).isDirectory() ? path : void 0;
        } catch (er) {
          return "ENOENT" === er.code ? findMadeSync(opts, dirname(parent), parent) : void 0;
        }
      };
      module.exports = {
        findMade,
        findMadeSync
      };
    },
    43974: (module, __unused_webpack_exports, __webpack_require__) => {
      const {dirname} = __webpack_require__(71017), mkdirpManual = (path, opts, made) => {
        opts.recursive = !1;
        const parent = dirname(path);
        return parent === path ? opts.mkdirAsync(path, opts).catch((er => {
          if ("EISDIR" !== er.code) throw er;
        })) : opts.mkdirAsync(path, opts).then((() => made || path), (er => {
          if ("ENOENT" === er.code) return mkdirpManual(parent, opts).then((made => mkdirpManual(path, opts, made)));
          if ("EEXIST" !== er.code && "EROFS" !== er.code) throw er;
          return opts.statAsync(path).then((st => {
            if (st.isDirectory()) return made;
            throw er;
          }), (() => {
            throw er;
          }));
        }));
      }, mkdirpManualSync = (path, opts, made) => {
        const parent = dirname(path);
        if (opts.recursive = !1, parent === path) try {
          return opts.mkdirSync(path, opts);
        } catch (er) {
          if ("EISDIR" !== er.code) throw er;
          return;
        }
        try {
          return opts.mkdirSync(path, opts), made || path;
        } catch (er) {
          if ("ENOENT" === er.code) return mkdirpManualSync(path, opts, mkdirpManualSync(parent, opts, made));
          if ("EEXIST" !== er.code && "EROFS" !== er.code) throw er;
          try {
            if (!opts.statSync(path).isDirectory()) throw er;
          } catch (_) {
            throw er;
          }
        }
      };
      module.exports = {
        mkdirpManual,
        mkdirpManualSync
      };
    },
    13653: (module, __unused_webpack_exports, __webpack_require__) => {
      const {dirname} = __webpack_require__(71017), {findMade, findMadeSync} = __webpack_require__(33408), {mkdirpManual, mkdirpManualSync} = __webpack_require__(43974);
      module.exports = {
        mkdirpNative: (path, opts) => {
          opts.recursive = !0;
          return dirname(path) === path ? opts.mkdirAsync(path, opts) : findMade(opts, path).then((made => opts.mkdirAsync(path, opts).then((() => made)).catch((er => {
            if ("ENOENT" === er.code) return mkdirpManual(path, opts);
            throw er;
          }))));
        },
        mkdirpNativeSync: (path, opts) => {
          opts.recursive = !0;
          if (dirname(path) === path) return opts.mkdirSync(path, opts);
          const made = findMadeSync(opts, path);
          try {
            return opts.mkdirSync(path, opts), made;
          } catch (er) {
            if ("ENOENT" === er.code) return mkdirpManualSync(path, opts);
            throw er;
          }
        }
      };
    },
    56627: (module, __unused_webpack_exports, __webpack_require__) => {
      const {promisify} = __webpack_require__(73837), fs = __webpack_require__(57147);
      module.exports = opts => {
        if (opts) if ("object" == typeof opts) opts = {
          mode: 511,
          fs,
          ...opts
        }; else if ("number" == typeof opts) opts = {
          mode: opts,
          fs
        }; else {
          if ("string" != typeof opts) throw new TypeError("invalid options argument");
          opts = {
            mode: parseInt(opts, 8),
            fs
          };
        } else opts = {
          mode: 511,
          fs
        };
        return opts.mkdir = opts.mkdir || opts.fs.mkdir || fs.mkdir, opts.mkdirAsync = promisify(opts.mkdir), 
        opts.stat = opts.stat || opts.fs.stat || fs.stat, opts.statAsync = promisify(opts.stat), 
        opts.statSync = opts.statSync || opts.fs.statSync || fs.statSync, opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs.mkdirSync, 
        opts;
      };
    },
    64315: (module, __unused_webpack_exports, __webpack_require__) => {
      const platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform, {resolve, parse} = __webpack_require__(71017);
      module.exports = path => {
        if (/\0/.test(path)) throw Object.assign(new TypeError("path must be a string without null bytes"), {
          path,
          code: "ERR_INVALID_ARG_VALUE"
        });
        if (path = resolve(path), "win32" === platform) {
          const badWinChars = /[*|"<>?:]/, {root} = parse(path);
          if (badWinChars.test(path.substr(root.length))) throw Object.assign(new Error("Illegal characters in path."), {
            path,
            code: "EINVAL"
          });
        }
        return path;
      };
    },
    93e3: (module, __unused_webpack_exports, __webpack_require__) => {
      const fs = __webpack_require__(57147), versArr = (process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version).replace(/^v/, "").split("."), hasNative = +versArr[0] > 10 || 10 == +versArr[0] && +versArr[1] >= 12, useNative = hasNative ? opts => opts.mkdir === fs.mkdir : () => !1, useNativeSync = hasNative ? opts => opts.mkdirSync === fs.mkdirSync : () => !1;
      module.exports = {
        useNative,
        useNativeSync
      };
    },
    4682: module => {
      var s = 1e3, m = 60 * s, h = 60 * m, d = 24 * h, w = 7 * d, y = 365.25 * d;
      function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= 1.5 * n;
        return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
      }
      module.exports = function(val, options) {
        options = options || {};
        var type = typeof val;
        if ("string" === type && val.length > 0) return function(str) {
          if ((str = String(str)).length > 100) return;
          var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
          if (!match) return;
          var n = parseFloat(match[1]);
          switch ((match[2] || "ms").toLowerCase()) {
           case "years":
           case "year":
           case "yrs":
           case "yr":
           case "y":
            return n * y;

           case "weeks":
           case "week":
           case "w":
            return n * w;

           case "days":
           case "day":
           case "d":
            return n * d;

           case "hours":
           case "hour":
           case "hrs":
           case "hr":
           case "h":
            return n * h;

           case "minutes":
           case "minute":
           case "mins":
           case "min":
           case "m":
            return n * m;

           case "seconds":
           case "second":
           case "secs":
           case "sec":
           case "s":
            return n * s;

           case "milliseconds":
           case "millisecond":
           case "msecs":
           case "msec":
           case "ms":
            return n;

           default:
            return;
          }
        }(val);
        if ("number" === type && isFinite(val)) return options.long ? function(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d) return plural(ms, msAbs, d, "day");
          if (msAbs >= h) return plural(ms, msAbs, h, "hour");
          if (msAbs >= m) return plural(ms, msAbs, m, "minute");
          if (msAbs >= s) return plural(ms, msAbs, s, "second");
          return ms + " ms";
        }(val) : function(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d) return Math.round(ms / d) + "d";
          if (msAbs >= h) return Math.round(ms / h) + "h";
          if (msAbs >= m) return Math.round(ms / m) + "m";
          if (msAbs >= s) return Math.round(ms / s) + "s";
          return ms + "ms";
        }(val);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
      };
    },
    94464: (module, __unused_webpack_exports, __webpack_require__) => {
      var Stream = __webpack_require__(12781);
      function MuteStream(opts) {
        Stream.apply(this), opts = opts || {}, this.writable = this.readable = !0, this.muted = !1, 
        this.on("pipe", this._onpipe), this.replace = opts.replace, this._prompt = opts.prompt || null, 
        this._hadControl = !1;
      }
      function proxy(fn) {
        return function() {
          var d = this._dest, s = this._src;
          d && d[fn] && d[fn].apply(d, arguments), s && s[fn] && s[fn].apply(s, arguments);
        };
      }
      module.exports = MuteStream, MuteStream.prototype = Object.create(Stream.prototype), 
      Object.defineProperty(MuteStream.prototype, "constructor", {
        value: MuteStream,
        enumerable: !1
      }), MuteStream.prototype.mute = function() {
        this.muted = !0;
      }, MuteStream.prototype.unmute = function() {
        this.muted = !1;
      }, Object.defineProperty(MuteStream.prototype, "_onpipe", {
        value: function(src) {
          this._src = src;
        },
        enumerable: !1,
        writable: !0,
        configurable: !0
      }), Object.defineProperty(MuteStream.prototype, "isTTY", {
        get: function() {
          return this._dest ? this._dest.isTTY : !!this._src && this._src.isTTY;
        },
        set: function(isTTY) {
          Object.defineProperty(this, "isTTY", {
            value: isTTY,
            enumerable: !0,
            writable: !0,
            configurable: !0
          });
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(MuteStream.prototype, "rows", {
        get: function() {
          return this._dest ? this._dest.rows : this._src ? this._src.rows : void 0;
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(MuteStream.prototype, "columns", {
        get: function() {
          return this._dest ? this._dest.columns : this._src ? this._src.columns : void 0;
        },
        enumerable: !0,
        configurable: !0
      }), MuteStream.prototype.pipe = function(dest, options) {
        return this._dest = dest, Stream.prototype.pipe.call(this, dest, options);
      }, MuteStream.prototype.pause = function() {
        if (this._src) return this._src.pause();
      }, MuteStream.prototype.resume = function() {
        if (this._src) return this._src.resume();
      }, MuteStream.prototype.write = function(c) {
        if (this.muted) {
          if (!this.replace) return !0;
          if (c.match(/^\u001b/)) return 0 === c.indexOf(this._prompt) && (c = (c = c.substr(this._prompt.length)).replace(/./g, this.replace), 
          c = this._prompt + c), this._hadControl = !0, this.emit("data", c);
          this._prompt && this._hadControl && 0 === c.indexOf(this._prompt) && (this._hadControl = !1, 
          this.emit("data", this._prompt), c = c.substr(this._prompt.length)), c = c.toString().replace(/./g, this.replace);
        }
        this.emit("data", c);
      }, MuteStream.prototype.end = function(c) {
        this.muted && (c = c && this.replace ? c.toString().replace(/./g, this.replace) : null), 
        c && this.emit("data", c), this.emit("end");
      }, MuteStream.prototype.destroy = proxy("destroy"), MuteStream.prototype.destroySoon = proxy("destroySoon"), 
      MuteStream.prototype.close = proxy("close");
    },
    69892: (module, exports, __webpack_require__) => {
      var debug = process.env.DEBUG_NOPT || process.env.NOPT_DEBUG ? function() {
        console.error.apply(console, arguments);
      } : function() {}, url = __webpack_require__(57310), path = __webpack_require__(71017), Stream = __webpack_require__(12781).Stream, abbrev = __webpack_require__(70143), os = __webpack_require__(22037);
      function clean(data, types, typeDefs) {
        typeDefs = typeDefs || exports.typeDefs;
        var remove = {}, typeDefault = [ !1, !0, null, String, Array ];
        Object.keys(data).forEach((function(k) {
          if ("argv" !== k) {
            var val = data[k], isArray = Array.isArray(val), type = types[k];
            isArray || (val = [ val ]), type || (type = typeDefault), type === Array && (type = typeDefault.concat(Array)), 
            Array.isArray(type) || (type = [ type ]), debug("val=%j", val), debug("types=", type), 
            (val = val.map((function(v) {
              if ("string" == typeof v && (debug("string %j", v), "null" === (v = v.trim()) && ~type.indexOf(null) || "true" === v && (~type.indexOf(!0) || ~type.indexOf(Boolean)) || "false" === v && (~type.indexOf(!1) || ~type.indexOf(Boolean)) ? (v = JSON.parse(v), 
              debug("jsonable %j", v)) : ~type.indexOf(Number) && !isNaN(v) ? (debug("convert to number", v), 
              v = +v) : ~type.indexOf(Date) && !isNaN(Date.parse(v)) && (debug("convert to date", v), 
              v = new Date(v))), !Object.prototype.hasOwnProperty.call(types, k)) return v;
              !1 !== v || !~type.indexOf(null) || ~type.indexOf(!1) || ~type.indexOf(Boolean) || (v = null);
              var d = {};
              return d[k] = v, debug("prevalidated val", d, v, types[k]), validate(d, k, v, types[k], typeDefs) ? (debug("validated v", d, v, types[k]), 
              d[k]) : (exports.invalidHandler ? exports.invalidHandler(k, v, types[k], data) : !1 !== exports.invalidHandler && debug("invalid: " + k + "=" + v, types[k]), 
              remove);
            })).filter((function(v) {
              return v !== remove;
            }))).length || -1 !== type.indexOf(Array) ? isArray ? (debug(isArray, data[k], val), 
            data[k] = val) : data[k] = val[0] : (debug("VAL HAS NO LENGTH, DELETE IT", val, k, type.indexOf(Array)), 
            delete data[k]), debug("k=%s val=%j", k, val, data[k]);
          }
        }));
      }
      function validate(data, k, val, type, typeDefs) {
        if (Array.isArray(type)) {
          for (let i = 0, l = type.length; i < l; i++) if (type[i] !== Array && validate(data, k, val, type[i], typeDefs)) return !0;
          return delete data[k], !1;
        }
        if (type === Array) return !0;
        if (type != type) return debug("Poison NaN", k, val, type), delete data[k], !1;
        if (val === type) return debug("Explicitly allowed %j", val), data[k] = val, !0;
        var ok = !1, types = Object.keys(typeDefs);
        for (let i = 0, l = types.length; i < l; i++) {
          debug("test type %j %j %j", k, val, types[i]);
          var t = typeDefs[types[i]];
          if (t && (type && type.name && t.type && t.type.name ? type.name === t.type.name : type === t.type)) {
            var d = {};
            if (ok = !1 !== t.validate(d, k, val), val = d[k], ok) {
              data[k] = val;
              break;
            }
          }
        }
        return debug("OK? %j (%j %j %j)", ok, k, val, types[types.length - 1]), ok || delete data[k], 
        ok;
      }
      function resolveShort(arg, shorthands, shortAbbr, abbrevs) {
        if (abbrevs[arg = arg.replace(/^-+/, "")] === arg) return null;
        if (shorthands[arg]) return shorthands[arg] && !Array.isArray(shorthands[arg]) && (shorthands[arg] = shorthands[arg].split(/\s+/)), 
        shorthands[arg];
        var singles = shorthands.___singles;
        singles || (singles = Object.keys(shorthands).filter((function(s) {
          return 1 === s.length;
        })).reduce((function(l, r) {
          return l[r] = !0, l;
        }), {}), shorthands.___singles = singles, debug("shorthand singles", singles));
        var chrs = arg.split("").filter((function(c) {
          return singles[c];
        }));
        return chrs.join("") === arg ? chrs.map((function(c) {
          return shorthands[c];
        })).reduce((function(l, r) {
          return l.concat(r);
        }), []) : abbrevs[arg] && !shorthands[arg] ? null : (shortAbbr[arg] && (arg = shortAbbr[arg]), 
        shorthands[arg] && !Array.isArray(shorthands[arg]) && (shorthands[arg] = shorthands[arg].split(/\s+/)), 
        shorthands[arg]);
      }
      module.exports = exports = function(types, shorthands, args, slice) {
        args = args || process.argv, "number" != typeof slice && (slice = 2);
        debug(types = types || {}, shorthands = shorthands || {}, args, slice), args = args.slice(slice);
        var data = {}, argv = {
          remain: [],
          cooked: args,
          original: args.slice(0)
        };
        return function(args, data, remain, types, shorthands) {
          debug("parse", args, data, remain);
          for (var abbrevs = abbrev(Object.keys(types)), shortAbbr = abbrev(Object.keys(shorthands)), i = 0; i < args.length; i++) {
            var arg = args[i];
            if (debug("arg", arg), arg.match(/^-{2,}$/)) {
              remain.push.apply(remain, args.slice(i + 1)), args[i] = "--";
              break;
            }
            var hadEq = !1;
            if ("-" === arg.charAt(0) && arg.length > 1) {
              var at = arg.indexOf("=");
              if (at > -1) {
                hadEq = !0;
                var v = arg.slice(at + 1);
                arg = arg.slice(0, at), args.splice(i, 1, arg, v);
              }
              var shRes = resolveShort(arg, shorthands, shortAbbr, abbrevs);
              if (debug("arg=%j shRes=%j", arg, shRes), shRes && (debug(arg, shRes), args.splice.apply(args, [ i, 1 ].concat(shRes)), 
              arg !== shRes[0])) {
                i--;
                continue;
              }
              arg = arg.replace(/^-+/, "");
              for (var no = null; 0 === arg.toLowerCase().indexOf("no-"); ) no = !no, arg = arg.slice(3);
              abbrevs[arg] && (arg = abbrevs[arg]);
              var argType = types[arg], isTypeArray = Array.isArray(argType);
              isTypeArray && 1 === argType.length && (isTypeArray = !1, argType = argType[0]);
              var val, isArray = argType === Array || isTypeArray && -1 !== argType.indexOf(Array);
              !Object.prototype.hasOwnProperty.call(types, arg) && Object.prototype.hasOwnProperty.call(data, arg) && (Array.isArray(data[arg]) || (data[arg] = [ data[arg] ]), 
              isArray = !0);
              var la = args[i + 1];
              if ("boolean" == typeof no || argType === Boolean || isTypeArray && -1 !== argType.indexOf(Boolean) || void 0 === argType && !hadEq || "false" === la && (null === argType || isTypeArray && ~argType.indexOf(null))) {
                val = !no, "true" !== la && "false" !== la || (val = JSON.parse(la), la = null, 
                no && (val = !val), i++), isTypeArray && la && (~argType.indexOf(la) ? (val = la, 
                i++) : "null" === la && ~argType.indexOf(null) ? (val = null, i++) : la.match(/^-{2,}[^-]/) || isNaN(la) || !~argType.indexOf(Number) ? !la.match(/^-[^-]/) && ~argType.indexOf(String) && (val = la, 
                i++) : (val = +la, i++)), isArray ? (data[arg] = data[arg] || []).push(val) : data[arg] = val;
                continue;
              }
              argType === String && (void 0 === la ? la = "" : la.match(/^-{1,2}[^-]+/) && (la = "", 
              i--)), la && la.match(/^-{2,}$/) && (la = void 0, i--), val = void 0 === la || la, 
              isArray ? (data[arg] = data[arg] || []).push(val) : data[arg] = val, i++;
            } else remain.push(arg);
          }
        }(args, data, argv.remain, types, shorthands), clean(data, types, exports.typeDefs), 
        data.argv = argv, Object.defineProperty(data.argv, "toString", {
          value: function() {
            return this.original.map(JSON.stringify).join(" ");
          },
          enumerable: !1
        }), data;
      }, exports.clean = clean, exports.typeDefs = {
        String: {
          type: String,
          validate: function(data, k, val) {
            data[k] = String(val);
          }
        },
        Boolean: {
          type: Boolean,
          validate: function(data, k, val) {
            val = val instanceof Boolean ? val.valueOf() : "string" == typeof val ? isNaN(val) ? "null" !== val && "false" !== val : !!+val : !!val;
            data[k] = val;
          }
        },
        url: {
          type: url,
          validate: function(data, k, val) {
            if (!(val = url.parse(String(val))).host) return !1;
            data[k] = val.href;
          }
        },
        Number: {
          type: Number,
          validate: function(data, k, val) {
            if (debug("validate Number %j %j %j", k, val, isNaN(val)), isNaN(val)) return !1;
            data[k] = +val;
          }
        },
        path: {
          type: path,
          validate: function(data, k, val) {
            if (!0 === val) return !1;
            if (null === val) return !0;
            val = String(val);
            var homePattern = "win32" === process.platform ? /^~(\/|\\)/ : /^~\//, home = os.homedir();
            home && val.match(homePattern) ? data[k] = path.resolve(home, val.slice(2)) : data[k] = path.resolve(val);
            return !0;
          }
        },
        Stream: {
          type: Stream,
          validate: function(data, k, val) {
            if (!(val instanceof Stream)) return !1;
            data[k] = val;
          }
        },
        Date: {
          type: Date,
          validate: function(data, k, val) {
            var s = Date.parse(val);
            if (debug("validate Date %j %j %j", k, val, s), isNaN(s)) return !1;
            data[k] = new Date(val);
          }
        }
      };
    },
    58170: (module, __unused_webpack_exports, __webpack_require__) => {
      const chalk = __webpack_require__(25433);
      module.exports = color => {
        const identity = x => x, red = color ? s => chalk.red.bold(s) : identity, magenta = color ? s => chalk.magenta.bold(s) : identity, yellow = color ? s => chalk.yellow.bold(s) : identity, white = color ? s => chalk.bold(s) : identity;
        return {
          dim: color ? s => chalk.dim(s) : identity,
          green: color ? s => chalk.green.bold(s) : identity,
          red,
          magenta,
          yellow,
          white,
          severity: (sev, s) => "moderate" === sev.toLowerCase() ? yellow(s || sev) : "high" === sev.toLowerCase() ? red(s || sev) : "critical" === sev.toLowerCase() ? magenta(s || sev) : white(s || sev)
        };
      };
    },
    77176: module => {
      const severities = new Map(Object.entries([ "info", "low", "moderate", "high", "critical", "none" ]).map((s => s.reverse())));
      module.exports = (data, level) => Object.entries(data.metadata.vulnerabilities).some((([sev, count]) => count > 0 && severities.has(sev) && severities.get(sev) >= severities.get(level))) ? 1 : 0;
    },
    75126: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const reporters = {
        install: __webpack_require__(99563),
        detail: __webpack_require__(93400),
        json: __webpack_require__(5325),
        quiet: __webpack_require__(49841)
      }, exitCode = __webpack_require__(77176);
      module.exports = Object.assign(((data, options = {}) => {
        const {reporter = "install", color = !0, unicode = !0, indent = 2} = options, auditLevel = options.auditLevel || "low";
        if (!data) throw Object.assign(new TypeError("ENOAUDITDATA"), {
          code: "ENOAUDITDATA",
          message: "missing audit data"
        });
        return "function" == typeof data.toJSON && (data = data.toJSON()), {
          report: reporters[reporter](data, {
            color,
            unicode,
            indent
          }),
          exitCode: exitCode(data, auditLevel)
        };
      }), {
        reporters
      });
    },
    93400: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const colors = __webpack_require__(58170), install = __webpack_require__(99563);
      module.exports = (data, {color}) => {
        const summary = install.summary(data, {
          color
        });
        return 0 === data.metadata.vulnerabilities.total ? summary : fullReport(data, {
          color,
          summary
        });
      };
      const fullReport = (data, {color, summary}) => {
        const c = colors(color), output = [ c.white("# npm audit report"), "" ], printed = new Set;
        for (const [, vuln] of Object.entries(data.vulnerabilities)) 0 !== vuln.via.filter((v => "string" != typeof v)).length && output.push(printVuln(vuln, c, data.vulnerabilities, printed));
        return output.push(summary), output.join("\n");
      }, printVuln = (vuln, c, vulnerabilities, printed, indent = "") => {
        if (printed.has(vuln)) return null;
        printed.add(vuln);
        const output = [];
        output.push(c.white(vuln.name) + "  " + vuln.range), "" !== indent || "low" === vuln.severity && "info" !== vuln.severity || output.push(`Severity: ${c.severity(vuln.severity)}`);
        for (const via of vuln.via) "string" == typeof via ? output.push(`Depends on vulnerable versions of ${c.white(via)}`) : "" === indent && output.push(`${c.white(via.title)} - ${via.url}`);
        if ("" === indent) {
          const {fixAvailable: fa} = vuln;
          !1 === fa ? output.push(c.red("No fix available")) : !0 === fa ? output.push(c.green("fix available") + " via `npm audit fix`") : "object" == typeof fa && "" === indent && output.push(`${c.yellow("fix available")} via \`npm audit fix --force\``, `Will install ${fa.name}@${fa.version}, which is ` + (fa.isSemVerMajor ? "a breaking change" : "outside the stated dependency range"));
        }
        for (const path of vuln.nodes) output.push(c.dim(path));
        for (const effect of vuln.effects) {
          const e = printVuln(vulnerabilities[effect], c, vulnerabilities, printed, "  ");
          e && output.push(...e.split("\n"));
        }
        return "" === indent && output.push(""), output.map((l => `${indent}${l}`)).join("\n");
      };
    },
    99563: (module, __unused_webpack_exports, __webpack_require__) => {
      const colors = __webpack_require__(58170), calculate = (data, {color}) => {
        const c = colors(color), output = [], {metadata: {vulnerabilities}} = data, vulnCount = vulnerabilities.total;
        let someFixable = !1, someForceFixable = !1, forceFixSemVerMajor = !1, someUnfixable = !1;
        if (0 === vulnCount) output.push(`found ${c.green("0")} vulnerabilities`); else {
          for (const [, vuln] of Object.entries(data.vulnerabilities)) {
            const {fixAvailable} = vuln;
            someFixable = someFixable || !0 === fixAvailable, someUnfixable = someUnfixable || !1 === fixAvailable, 
            "object" == typeof fixAvailable && (someForceFixable = !0, forceFixSemVerMajor = forceFixSemVerMajor || fixAvailable.isSemVerMajor);
          }
          const total = vulnerabilities.total, sevs = Object.entries(vulnerabilities).filter((([s, count]) => ("low" === s || "moderate" === s || "high" === s || "critical" === s) && count > 0));
          if (sevs.length > 1) {
            const severities = sevs.map((([s, count]) => `${count} ${c.severity(s)}`)).join(", ");
            output.push(`${c.red(total)} vulnerabilities (${severities})`);
          } else {
            const [sev, count] = sevs[0];
            output.push(`${count} ${c.severity(sev)} severity vulnerabilit${1 === count ? "y" : "ies"}`);
          }
          someFixable && output.push("", "To address " + (someForceFixable || someUnfixable ? "issues that do not require attention" : "all issues") + ", run:\n  npm audit fix"), 
          someForceFixable && output.push("", "To address all issues" + (someUnfixable ? " possible" : "") + (forceFixSemVerMajor ? " (including breaking changes)" : "") + ", run:\n  npm audit fix --force"), 
          someUnfixable && output.push("", "Some issues need review, and may require choosing", "a different dependency.");
        }
        const summary = output.join("\n");
        return {
          summary,
          report: vulnCount > 0 ? `${summary}\n\nRun \`npm audit\` for details.` : summary
        };
      };
      module.exports = Object.assign(((data, opt) => calculate(data, opt).report), {
        summary: (data, opt) => calculate(data, opt).summary
      });
    },
    5325: module => {
      module.exports = (data, {indent}) => JSON.stringify(data, null, indent);
    },
    49841: module => {
      module.exports = () => "";
    },
    72053: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const fs = __webpack_require__(57147), path = __webpack_require__(71017), EE = __webpack_require__(82361).EventEmitter, normalizePackageBin = __webpack_require__(51234);
      class BundleWalker extends EE {
        constructor(opt) {
          if (super(opt = opt || {}), this.path = path.resolve(opt.path || process.cwd()), 
          this.parent = opt.parent || null, this.parent) {
            if (this.result = this.parent.result, !this.parent.parent) {
              const base = path.basename(this.path), scope = path.basename(path.dirname(this.path));
              this.result.add(/^@/.test(scope) ? scope + "/" + base : base);
            }
            this.root = this.parent.root, this.packageJsonCache = this.parent.packageJsonCache;
          } else this.result = new Set, this.root = this.path, this.packageJsonCache = opt.packageJsonCache || new Map;
          this.seen = new Set, this.didDone = !1, this.children = 0, this.node_modules = [], 
          this.package = null, this.bundle = null;
        }
        addListener(ev, fn) {
          return this.on(ev, fn);
        }
        on(ev, fn) {
          const ret = super.on(ev, fn);
          return "done" === ev && this.didDone && this.emit("done", this.result), ret;
        }
        done() {
          if (!this.didDone) if (this.didDone = !0, this.parent) this.emit("done"); else {
            const res = Array.from(this.result);
            this.result = res, this.emit("done", res);
          }
        }
        start() {
          const pj = path.resolve(this.path, "package.json");
          return this.packageJsonCache.has(pj) ? this.onPackage(this.packageJsonCache.get(pj)) : this.readPackageJson(pj), 
          this;
        }
        readPackageJson(pj) {
          fs.readFile(pj, ((er, data) => er ? this.done() : this.onPackageJson(pj, data)));
        }
        onPackageJson(pj, data) {
          try {
            this.package = normalizePackageBin(JSON.parse(data + ""));
          } catch (er) {
            return this.done();
          }
          this.packageJsonCache.set(pj, this.package), this.onPackage(this.package);
        }
        allDepsBundled(pkg) {
          return Object.keys(pkg.dependencies || {}).concat(Object.keys(pkg.optionalDependencies || {}));
        }
        onPackage(pkg) {
          const bdRaw = this.parent ? this.allDepsBundled(pkg) : pkg.bundleDependencies || pkg.bundledDependencies || [], bd = Array.from(new Set(Array.isArray(bdRaw) ? bdRaw : !0 === bdRaw ? this.allDepsBundled(pkg) : Object.keys(bdRaw)));
          if (!bd.length) return this.done();
          this.bundle = bd, this.readModules();
        }
        readModules() {
          readdirNodeModules(this.path + "/node_modules", ((er, nm) => er ? this.onReaddir([]) : this.onReaddir(nm)));
        }
        onReaddir(nm) {
          this.node_modules = nm, this.bundle.forEach((dep => this.childDep(dep))), 0 === this.children && this.done();
        }
        childDep(dep) {
          -1 !== this.node_modules.indexOf(dep) ? this.seen.has(dep) || (this.seen.add(dep), 
          this.child(dep)) : this.parent && this.parent.childDep(dep);
        }
        child(dep) {
          const p = this.path + "/node_modules/" + dep;
          this.children += 1;
          const child = new BundleWalker({
            path: p,
            parent: this
          });
          child.on("done", (_ => {
            0 == --this.children && this.done();
          })), child.start();
        }
      }
      class BundleWalkerSync extends BundleWalker {
        start() {
          return super.start(), this.done(), this;
        }
        readPackageJson(pj) {
          try {
            this.onPackageJson(pj, fs.readFileSync(pj));
          } catch {}
          return this;
        }
        readModules() {
          try {
            this.onReaddir(readdirNodeModulesSync(this.path + "/node_modules"));
          } catch {
            this.onReaddir([]);
          }
        }
        child(dep) {
          new BundleWalkerSync({
            path: this.path + "/node_modules/" + dep,
            parent: this
          }).start();
        }
      }
      const readdirNodeModules = (nm, cb) => {
        fs.readdir(nm, ((er, set) => {
          if (er) cb(er); else {
            const scopes = set.filter((f => /^@/.test(f)));
            if (scopes.length) {
              const unscoped = set.filter((f => !/^@/.test(f)));
              let count = scopes.length;
              scopes.forEach((scope => {
                fs.readdir(nm + "/" + scope, ((readdirEr, pkgs) => {
                  readdirEr || !pkgs.length ? unscoped.push(scope) : unscoped.push.apply(unscoped, pkgs.map((p => scope + "/" + p))), 
                  0 == --count && cb(null, unscoped);
                }));
              }));
            } else cb(null, set);
          }
        }));
      }, readdirNodeModulesSync = nm => {
        const set = fs.readdirSync(nm), unscoped = set.filter((f => !/^@/.test(f))), scopes = set.filter((f => /^@/.test(f))).map((scope => {
          try {
            const pkgs = fs.readdirSync(nm + "/" + scope);
            return pkgs.length ? pkgs.map((p => scope + "/" + p)) : [ scope ];
          } catch (er) {
            return [ scope ];
          }
        })).reduce(((a, b) => a.concat(b)), []);
        return unscoped.concat(scopes);
      }, walk = (options, callback) => {
        const p = new Promise(((resolve, reject) => {
          new BundleWalker(options).on("done", resolve).on("error", reject).start();
        }));
        return callback ? p.then((res => callback(null, res)), callback) : p;
      };
      module.exports = walk, walk.sync = options => new BundleWalkerSync(options).start().result, 
      walk.BundleWalker = BundleWalker, walk.BundleWalkerSync = BundleWalkerSync;
    },
    91126: (module, __unused_webpack_exports, __webpack_require__) => {
      const semver = __webpack_require__(5870), checkList = (value, list) => {
        if ("string" == typeof list && (list = [ list ]), 1 === list.length && "any" === list[0]) return !0;
        let negated = 0, match = !1;
        for (const entry of list) {
          const negate = "!" === entry.charAt(0), test = negate ? entry.slice(1) : entry;
          if (negate) {
            if (negated++, value === test) return !1;
          } else match = match || value === test;
        }
        return match || negated === list.length;
      };
      module.exports = {
        checkEngine: (target, npmVer, nodeVer, force = !1) => {
          const nodev = force ? null : nodeVer, eng = target.engines, opt = {
            includePrerelease: !0
          };
          if (!eng) return;
          const nodeFail = nodev && eng.node && !semver.satisfies(nodev, eng.node, opt), npmFail = npmVer && eng.npm && !semver.satisfies(npmVer, eng.npm, opt);
          if (nodeFail || npmFail) throw Object.assign(new Error("Unsupported engine"), {
            pkgid: target._id,
            current: {
              node: nodeVer,
              npm: npmVer
            },
            required: eng,
            code: "EBADENGINE"
          });
        },
        checkPlatform: (target, force = !1) => {
          if (force) return;
          const platform = process.platform, arch = process.arch, osOk = !target.os || checkList(platform, target.os), cpuOk = !target.cpu || checkList(arch, target.cpu);
          if (!osOk || !cpuOk) throw Object.assign(new Error("Unsupported platform"), {
            pkgid: target._id,
            current: {
              os: platform,
              cpu: arch
            },
            required: {
              os: target.os,
              cpu: target.cpu
            },
            code: "EBADPLATFORM"
          });
        }
      };
    },
    51234: (module, __unused_webpack_exports, __webpack_require__) => {
      const {join, basename} = __webpack_require__(71017), normalizeString = pkg => pkg.name ? (pkg.bin = {
        [pkg.name]: pkg.bin
      }, normalizeObject(pkg)) : removeBin(pkg), normalizeArray = pkg => (pkg.bin = pkg.bin.reduce(((acc, k) => (acc[basename(k)] = k, 
      acc)), {}), normalizeObject(pkg)), removeBin = pkg => (delete pkg.bin, pkg), normalizeObject = pkg => {
        const orig = pkg.bin, clean = {};
        let hasBins = !1;
        return Object.keys(orig).forEach((binKey => {
          const base = join("/", basename(binKey.replace(/\\|:/g, "/"))).slice(1);
          if ("string" != typeof orig[binKey] || !base) return;
          const binTarget = join("/", orig[binKey]).replace(/\\/g, "/").slice(1);
          binTarget && (clean[base] = binTarget, hasBins = !0);
        })), hasBins ? pkg.bin = clean : delete pkg.bin, pkg;
      };
      module.exports = pkg => pkg.bin ? "string" == typeof pkg.bin ? normalizeString(pkg) : Array.isArray(pkg.bin) ? normalizeArray(pkg) : "object" == typeof pkg.bin ? normalizeObject(pkg) : removeBin(pkg) : removeBin(pkg);
    },
    96226: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const BundleWalker = __webpack_require__(72053).BundleWalker, IgnoreWalker = __webpack_require__(45537).Walker, rootBuiltinRules = Symbol("root-builtin-rules"), packageNecessaryRules = Symbol("package-necessary-rules"), path = __webpack_require__(71017), normalizePackageBin = __webpack_require__(51234), packageMustHavesRE = new RegExp("^(readme|copying|license|licence)(\\..*[^~$])?$", "i"), fs = __webpack_require__(57147), glob = __webpack_require__(34436), globify = pattern => pattern.split("\\").join("/"), readOutOfTreeIgnoreFiles = (root, rel, result = "") => {
        for (const file of [ ".npmignore", ".gitignore" ]) try {
          result += fs.readFileSync(path.join(root, file), {
            encoding: "utf8"
          }) + "\n";
          break;
        } catch (err) {
          if ("ENOENT" !== err.code) throw err;
        }
        if (!rel) return result;
        const firstRel = rel.split(path.sep)[0], newRoot = path.join(root, firstRel), newRel = path.relative(newRoot, path.join(root, rel));
        return readOutOfTreeIgnoreFiles(newRoot, newRel, result);
      }, defaultRules = [ ".npmignore", ".gitignore", "**/.git", "**/.svn", "**/.hg", "**/CVS", "**/.git/**", "**/.svn/**", "**/.hg/**", "**/CVS/**", "/.lock-wscript", "/.wafpickle-*", "/build/config.gypi", "npm-debug.log", "**/.npmrc", ".*.swp", ".DS_Store", "**/.DS_Store/**", "._*", "**/._*/**", "*.orig", "/package-lock.json", "/yarn.lock", "/pnpm-lock.yaml", "/archived-packages/**" ];
      class Walker extends IgnoreWalker {
        constructor(opt) {
          (opt = opt || {}).ignoreFiles = [ rootBuiltinRules, "package.json", ".npmignore", ".gitignore", packageNecessaryRules ], 
          opt.includeEmpty = !1, opt.path = opt.path || process.cwd();
          const rootPath = opt.parent ? opt.parent.root : opt.path, followTestPath = opt.path.replace(/\\/g, "/").slice(rootPath.length);
          if (opt.follow = /^(?:\/node_modules\/(?:@[^/]+\/[^/]+|[^/]+)\/)*\/node_modules(?:\/@[^/]+)?$/.test(followTestPath), 
          super(opt), this.isProject) {
            this.bundled = opt.bundled || [], this.bundledScopes = Array.from(new Set(this.bundled.filter((f => /^@/.test(f))).map((f => f.split("/")[0])))), 
            this.packageJsonCache = this.parent ? this.parent.packageJsonCache : opt.packageJsonCache || new Map;
            let rules = defaultRules.join("\n") + "\n";
            if (opt.prefix && opt.workspaces) {
              const gPath = globify(opt.path), gPrefix = globify(opt.prefix), gWorkspaces = opt.workspaces.map((ws => globify(ws)));
              if (gPath !== gPrefix && gWorkspaces.includes(gPath)) {
                const relpath = path.relative(opt.prefix, path.dirname(opt.path));
                rules += readOutOfTreeIgnoreFiles(opt.prefix, relpath);
              } else gPath === gPrefix && (rules += opt.workspaces.map((ws => globify(path.relative(opt.path, ws)))).join("\n"));
            }
            super.onReadIgnoreFile(rootBuiltinRules, rules, (_ => _));
          } else this.bundled = [], this.bundledScopes = [], this.packageJsonCache = this.parent.packageJsonCache;
        }
        get isProject() {
          return !this.parent || this.parent.follow && this.isSymbolicLink;
        }
        onReaddir(entries) {
          if (this.isProject && (entries = entries.filter((e => ".git" !== e && !("node_modules" === e && 0 === this.bundled.length)))), 
          !this.isProject || !entries.includes("package.json")) return super.onReaddir(entries);
          const ig = path.resolve(this.path, "package.json");
          if (this.packageJsonCache.has(ig)) {
            const pkg = this.packageJsonCache.get(ig);
            return pkg && "object" == typeof pkg ? this.getPackageFiles(entries, JSON.stringify(pkg)) : this.readPackageJson(entries);
          }
          this.readPackageJson(entries);
        }
        onReadPackageJson(entries, er, pkg) {
          er ? this.emit("error", er) : this.getPackageFiles(entries, pkg);
        }
        mustHaveFilesFromPackage(pkg) {
          const files = [];
          if (pkg.browser && files.push("/" + pkg.browser), pkg.main && files.push("/" + pkg.main), 
          pkg.bin) for (const key in pkg.bin) files.push("/" + pkg.bin[key]);
          return files.push("/package.json", "/npm-shrinkwrap.json", "!/package-lock.json", "@(readme|copying|license|licence){,.*[^~$]}"), 
          files;
        }
        getPackageFiles(entries, pkg) {
          try {
            pkg = normalizePackageBin(JSON.parse(pkg.toString()));
          } catch (er) {
            return super.onReaddir(entries);
          }
          const ig = path.resolve(this.path, "package.json");
          if (this.packageJsonCache.set(ig, pkg), !Array.isArray(pkg.files)) return super.onReaddir(entries);
          pkg.files.push(...this.mustHaveFilesFromPackage(pkg)), (pkg.bundleDependencies || pkg.bundledDependencies) && entries.includes("node_modules") && pkg.files.push("node_modules");
          const patterns = Array.from(new Set(pkg.files)).reduce(((set, pattern) => {
            const excl = pattern.match(/^!+/);
            excl && (pattern = pattern.slice(excl[0].length)), pattern = pattern.replace(/^\.?\/+/, "");
            const negate = excl && excl[0].length % 2 == 1;
            return set.push({
              pattern,
              negate
            }), set;
          }), []);
          let n = patterns.length;
          const set = new Set, negates = new Set, results = [], then = (pattern, negate, er, fileList, i) => {
            if (er) return this.emit("error", er);
            results[i] = {
              negate,
              fileList
            }, 0 == --n && processResults(results);
          }, processResults = processed => {
            for (const {negate, fileList} of processed) negate ? fileList.forEach((f => {
              f = f.replace(/\/+$/, ""), set.delete(f), negates.add(f);
            })) : fileList.forEach((f => {
              f = f.replace(/\/+$/, ""), set.add(f), negates.delete(f);
            }));
            const list = Array.from(set);
            pkg.files = list.concat(Array.from(negates).map((f => "!" + f)));
            const rdResult = Array.from(new Set(list.map((f => f.replace(/^\/+/, "")))));
            super.onReaddir(rdResult);
          };
          patterns.forEach((({pattern, negate}, i) => this.globFiles(pattern, ((er, res) => then(0, negate, er, res, i)))));
        }
        filterEntry(entry, partial) {
          const p = this.path.slice(this.root.length + 1), {isProject} = this, pkg = isProject && (input => {
            if (!input.startsWith("node_modules/")) return !1;
            const segments = input.slice("node_modules/".length).split("/", 2);
            return !segments[0].startsWith("@") || 2 === segments.length;
          })(entry) ? (input => {
            const segments = input.slice("node_modules/".length).split("/", 2);
            return segments[0].startsWith("@") ? segments.join("/") : segments[0];
          })(entry) : null, rootNM = isProject && "node_modules" === entry, rootPJ = isProject && "package.json" === entry;
          return /^node_modules($|\/)/i.test(p) && !this.isProject ? this.parent.filterEntry(this.basename + "/" + entry, partial) : pkg ? -1 !== this.bundled.indexOf(pkg) || -1 !== this.bundledScopes.indexOf(pkg) : rootNM ? !!this.bundled.length : !!rootPJ || (!!packageMustHavesRE.test(entry) || (!(!isProject || "npm-shrinkwrap.json" !== entry && "package.json" !== entry) || (!isProject || "package-lock.json" !== entry) && super.filterEntry(entry, partial)));
        }
        filterEntries() {
          this.ignoreRules[".npmignore"] && (this.ignoreRules[".gitignore"] = null), this.filterEntries = super.filterEntries, 
          super.filterEntries();
        }
        addIgnoreFile(file, then) {
          const ig = path.resolve(this.path, file);
          "package.json" !== file || this.isProject ? this.packageJsonCache.has(ig) ? this.onPackageJson(ig, this.packageJsonCache.get(ig), then) : super.addIgnoreFile(file, then) : then();
        }
        onPackageJson(ig, pkg, then) {
          if (this.packageJsonCache.set(ig, pkg), Array.isArray(pkg.files)) super.onReadIgnoreFile("package.json", pkg.files.map((f => "!" + f)).join("\n") + "\n", then); else {
            const data = this.mustHaveFilesFromPackage(pkg).map((f => `!${f}`)).join("\n") + "\n";
            super.onReadIgnoreFile(packageNecessaryRules, data, then);
          }
        }
        stat({entry, file, dir}, then) {
          (file => /\*/.test(file))(entry) ? then() : super.stat({
            entry,
            file,
            dir
          }, then);
        }
        onstat({st, entry, file, dir, isSymbolicLink}, then) {
          st.isSymbolicLink() ? then() : super.onstat({
            st,
            entry,
            file,
            dir,
            isSymbolicLink
          }, then);
        }
        onReadIgnoreFile(file, data, then) {
          if ("package.json" === file) try {
            const ig = path.resolve(this.path, file);
            this.onPackageJson(ig, JSON.parse(data), then);
          } catch (er) {
            then();
          } else super.onReadIgnoreFile(file, data, then);
        }
        sort(a, b) {
          const exta = path.extname(a).toLowerCase(), extb = path.extname(b).toLowerCase(), basea = path.basename(a).toLowerCase(), baseb = path.basename(b).toLowerCase();
          return exta.localeCompare(extb, "en") || basea.localeCompare(baseb, "en") || a.localeCompare(b, "en");
        }
        globFiles(pattern, cb) {
          glob(globify(pattern), {
            dot: !0,
            cwd: this.path,
            nocase: !0
          }, cb);
        }
        readPackageJson(entries) {
          fs.readFile(this.path + "/package.json", ((er, pkg) => this.onReadPackageJson(entries, er, pkg)));
        }
        walker(entry, opt, then) {
          new Walker(this.walkerOpt(entry, opt)).on("done", then).start();
        }
      }
      const walk = (options, callback) => {
        options = options || {};
        const p = new Promise(((resolve, reject) => {
          const bw = new BundleWalker(options);
          bw.on("done", (bundled => {
            options.bundled = bundled, options.packageJsonCache = bw.packageJsonCache, new Walker(options).on("done", resolve).on("error", reject).start();
          })), bw.start();
        }));
        return callback ? p.then((res => callback(null, res)), callback) : p;
      };
      module.exports = walk, walk.Walker = Walker;
    },
    65732: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const npa = __webpack_require__(19932), semver = __webpack_require__(5870), {checkEngine} = __webpack_require__(91126), normalizeBin = __webpack_require__(51234), engineOk = (manifest, npmVersion, nodeVersion) => {
        try {
          return checkEngine(manifest, npmVersion, nodeVersion), !0;
        } catch (_) {
          return !1;
        }
      }, isBefore = (verTimes, ver, time) => !verTimes || !verTimes[ver] || Date.parse(verTimes[ver]) <= time, avoidSemverOpt = {
        includePrerelease: !0,
        loose: !0
      }, shouldAvoid = (ver, avoid) => avoid && semver.satisfies(ver, avoid, avoidSemverOpt), decorateAvoid = (result, avoid) => result && shouldAvoid(result.version, avoid) ? {
        ...result,
        _shouldAvoid: !0
      } : result, pickManifest = (packument, wanted, opts) => {
        const {defaultTag = "latest", before = null, nodeVersion = process.version, npmVersion = null, includeStaged = !1, avoid = null, avoidStrict = !1} = opts, {name, time: verTimes} = packument, versions = packument.versions || {};
        if (avoidStrict) {
          const looseOpts = {
            ...opts,
            avoidStrict: !1
          }, result = pickManifest(packument, wanted, looseOpts);
          if (!result || !result._shouldAvoid) return result;
          const caret = pickManifest(packument, `^${result.version}`, looseOpts);
          if (!caret || !caret._shouldAvoid) return {
            ...caret,
            _outsideDependencyRange: !0,
            _isSemVerMajor: !1
          };
          const star = pickManifest(packument, "*", looseOpts);
          if (!star || !star._shouldAvoid) return {
            ...star,
            _outsideDependencyRange: !0,
            _isSemVerMajor: !0
          };
          throw Object.assign(new Error(`No avoidable versions for ${name}`), {
            code: "ETARGET",
            name,
            wanted,
            avoid,
            before,
            versions: Object.keys(versions)
          });
        }
        const staged = includeStaged && packument.stagedVersions && packument.stagedVersions.versions || {}, restricted = packument.policyRestrictions && packument.policyRestrictions.versions || {}, time = before && verTimes ? +new Date(before) : 1 / 0, type = npa.resolve(name, wanted || defaultTag).type, distTags = packument["dist-tags"] || {};
        if ("tag" !== type && "version" !== type && "range" !== type) throw new Error("Only tag, version, and range are supported");
        if (wanted && "tag" === type) {
          const ver = distTags[wanted];
          return isBefore(verTimes, ver, time) ? decorateAvoid(versions[ver] || staged[ver] || restricted[ver], avoid) : pickManifest(packument, `<=${ver}`, opts);
        }
        if (wanted && "version" === type) {
          const ver = semver.clean(wanted, {
            loose: !0
          }), mani = versions[ver] || staged[ver] || restricted[ver];
          return isBefore(verTimes, ver, time) ? decorateAvoid(mani, avoid) : null;
        }
        const range = "range" === type ? wanted : "*", defaultVer = distTags[defaultTag];
        if (defaultVer && ("*" === range || semver.satisfies(defaultVer, range, {
          loose: !0
        })) && !shouldAvoid(defaultVer, avoid)) {
          const mani = versions[defaultVer];
          if (mani && isBefore(verTimes, defaultVer, time)) return mani;
        }
        const allEntries = Object.entries(versions).concat(Object.entries(staged)).concat(Object.entries(restricted)).filter((([ver, mani]) => isBefore(verTimes, ver, time)));
        if (!allEntries.length) throw Object.assign(new Error(`No versions available for ${name}`), {
          code: "ENOVERSIONS",
          name,
          type,
          wanted,
          before,
          versions: Object.keys(versions)
        });
        const sortSemverOpt = {
          loose: !0
        }, entries = allEntries.filter((([ver, mani]) => semver.satisfies(ver, range, {
          loose: !0
        }))).sort(((a, b) => {
          const [vera, mania] = a, [verb, manib] = b, notavoida = !shouldAvoid(vera, avoid), notavoidb = !shouldAvoid(verb, avoid), notrestra = !restricted[a], notrestrb = !restricted[b], notstagea = !staged[a], notstageb = !staged[b], notdepra = !mania.deprecated, notdeprb = !manib.deprecated, enginea = engineOk(mania, npmVersion, nodeVersion), engineb = engineOk(manib, npmVersion, nodeVersion);
          return notavoidb - notavoida || notrestrb - notrestra || notstageb - notstagea || (notdeprb && engineb) - (notdepra && enginea) || engineb - enginea || notdeprb - notdepra || semver.rcompare(vera, verb, sortSemverOpt);
        }));
        return decorateAvoid(entries[0] && entries[0][1], avoid);
      };
      module.exports = (packument, wanted, opts = {}) => {
        const mani = pickManifest(packument, wanted, opts), picked = mani && normalizeBin(mani), policyRestrictions = packument.policyRestrictions, restricted = policyRestrictions && policyRestrictions.versions || {};
        if (picked && !restricted[picked.version]) return picked;
        const {before = null, defaultTag = "latest"} = opts, bstr = before ? new Date(before).toLocaleString() : "", {name} = packument, pckg = `${name}@${wanted}` + (before ? ` with a date before ${bstr}` : ""), isForbidden = picked && !!restricted[picked.version], polMsg = isForbidden ? policyRestrictions.message : "", msg = isForbidden ? `Could not download ${pckg} due to policy violations:\n${polMsg}` : `No matching version found for ${pckg}.`, code = isForbidden ? "E403" : "ETARGET";
        throw Object.assign(new Error(msg), {
          code,
          type: npa.resolve(packument.name, wanted).type,
          wanted,
          versions: Object.keys(packument.versions),
          name,
          distTags: packument["dist-tags"],
          defaultTag
        });
      };
    },
    77969: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const fetch = __webpack_require__(92427), {HttpErrorBase} = __webpack_require__(71825), EventEmitter = __webpack_require__(82361), os = __webpack_require__(22037), {URL} = __webpack_require__(57310), log = __webpack_require__(46521), adduserWeb = (opener, opts = {}) => (log.verbose("web adduser", "before first POST"), 
      webAuth(opener, opts, {
        create: !0
      })), loginWeb = (opener, opts = {}) => (log.verbose("web login", "before first POST"), 
      webAuth(opener, opts, {})), isValidUrl = u => {
        try {
          return /^https?:$/.test(new URL(u).protocol);
        } catch (er) {
          return !1;
        }
      }, webAuth = (opener, opts, body) => {
        const {hostname} = opts;
        body.hostname = hostname || os.hostname();
        const doneEmitter = new EventEmitter;
        return fetch("/-/v1/login", {
          ...opts,
          method: "POST",
          body
        }).then((res => Promise.all([ res, res.json() ]))).then((([res, content]) => {
          const {doneUrl, loginUrl} = content;
          if (log.verbose("web auth", "got response", content), !isValidUrl(doneUrl) || !isValidUrl(loginUrl)) throw new WebLoginInvalidResponse("POST", res, content);
          return content;
        })).then((({doneUrl, loginUrl}) => {
          log.verbose("web auth", "opening url pair");
          const openPromise = opener(loginUrl, doneEmitter), webAuthCheckPromise = webAuthCheckLogin(doneUrl, {
            ...opts,
            cache: !1
          }).then((authResult => (log.verbose("web auth", "done-check finished"), doneEmitter.emit("abort"), 
          authResult)));
          return Promise.all([ openPromise, webAuthCheckPromise ]).then((([, authResult]) => authResult));
        })).catch((er => {
          throw doneEmitter.emit("abort"), er.statusCode >= 400 && er.statusCode <= 499 || 500 === er.statusCode ? new WebLoginNotSupported("POST", {
            status: er.statusCode,
            headers: {
              raw: () => er.headers
            }
          }, er.body) : er;
        }));
      }, webAuthCheckLogin = (doneUrl, opts) => fetch(doneUrl, opts).then((res => Promise.all([ res, res.json() ]))).then((([res, content]) => {
        if (200 === res.status) {
          if (content.token) return content;
          throw new WebLoginInvalidResponse("GET", res, content);
        }
        if (202 === res.status) {
          const retry = 1e3 * +res.headers.get("retry-after");
          return retry > 0 ? sleep(retry).then((() => webAuthCheckLogin(doneUrl, opts))) : webAuthCheckLogin(doneUrl, opts);
        }
        throw new WebLoginInvalidResponse("GET", res, content);
      })), adduserCouch = (username, email, password, opts = {}) => {
        const body = {
          _id: "org.couchdb.user:" + username,
          name: username,
          password,
          email,
          type: "user",
          roles: [],
          date: (new Date).toISOString()
        }, logObj = {
          ...body,
          password: "XXXXX"
        };
        log.verbose("adduser", "before first PUT", logObj);
        const target = "/-/user/org.couchdb.user:" + encodeURIComponent(username);
        return fetch.json(target, {
          ...opts,
          method: "PUT",
          body
        }).then((result => (result.username = username, result)));
      }, loginCouch = (username, password, opts = {}) => {
        const body = {
          _id: "org.couchdb.user:" + username,
          name: username,
          password,
          type: "user",
          roles: [],
          date: (new Date).toISOString()
        }, logObj = {
          ...body,
          password: "XXXXX"
        };
        log.verbose("login", "before first PUT", logObj);
        const target = "/-/user/org.couchdb.user:" + encodeURIComponent(username);
        return fetch.json(target, {
          ...opts,
          method: "PUT",
          body
        }).catch((err => {
          if ("E400" === err.code) throw err.message = `There is no user with the username "${username}".`, 
          err;
          if ("E409" !== err.code) throw err;
          return fetch.json(target, {
            ...opts,
            query: {
              write: !0
            }
          }).then((result => {
            Object.keys(result).forEach((k => {
              body[k] && "roles" !== k || (body[k] = result[k]);
            }));
            const {otp} = opts;
            return fetch.json(`${target}/-rev/${body._rev}`, {
              ...opts,
              method: "PUT",
              body,
              forceAuth: {
                username,
                password: Buffer.from(password, "utf8").toString("base64"),
                otp
              }
            });
          }));
        })).then((result => (result.username = username, result)));
      };
      class WebLoginInvalidResponse extends HttpErrorBase {
        constructor(method, res, body) {
          super(method, res, body), this.message = "Invalid response from web login endpoint", 
          Error.captureStackTrace(this, WebLoginInvalidResponse);
        }
      }
      class WebLoginNotSupported extends HttpErrorBase {
        constructor(method, res, body) {
          super(method, res, body), this.message = "Web login not supported", this.code = "ENYI", 
          Error.captureStackTrace(this, WebLoginNotSupported);
        }
      }
      const sleep = ms => new Promise(((resolve, reject) => setTimeout(resolve, ms)));
      module.exports = {
        adduserCouch,
        loginCouch,
        adduserWeb,
        loginWeb,
        login: (opener, prompter, opts = {}) => {
          const {creds} = opts;
          return loginWeb(opener, opts).catch((er => {
            if (er instanceof WebLoginNotSupported) return log.verbose("web login not supported, trying couch"), 
            prompter(creds).then((data => loginCouch(data.username, data.password, opts)));
            throw er;
          }));
        },
        adduser: (opener, prompter, opts = {}) => {
          const {creds} = opts;
          return adduserWeb(opener, opts).catch((er => {
            if (er instanceof WebLoginNotSupported) return log.verbose("web adduser not supported, trying couch"), 
            prompter(creds).then((data => adduserCouch(data.username, data.email, data.password, opts)));
            throw er;
          }));
        },
        get: (opts = {}) => fetch.json("/-/npm/v1/user", opts),
        set: (profile, opts = {}) => (Object.keys(profile).forEach((key => {
          "" === profile[key] && (profile[key] = null);
        })), fetch.json("/-/npm/v1/user", {
          ...opts,
          method: "POST",
          body: profile
        })),
        listTokens: (opts = {}) => {
          const untilLastPage = (href, objects) => fetch.json(href, opts).then((result => (objects = objects ? objects.concat(result.objects) : result.objects, 
          result.urls.next ? untilLastPage(result.urls.next, objects) : objects)));
          return untilLastPage("/-/npm/v1/tokens");
        },
        removeToken: (tokenKey, opts = {}) => fetch(`/-/npm/v1/tokens/token/${tokenKey}`, {
          ...opts,
          method: "DELETE",
          ignoreBody: !0
        }).then((() => null)),
        createToken: (password, readonly, cidrs, opts = {}) => fetch.json("/-/npm/v1/tokens", {
          ...opts,
          method: "POST",
          body: {
            password,
            readonly,
            cidr_whitelist: cidrs
          }
        }),
        webAuthCheckLogin
      };
    },
    35425: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const fs = __webpack_require__(57147), npa = __webpack_require__(19932), {URL} = __webpack_require__(57310), regKeyFromURI = (uri, opts) => {
        const parsed = new URL(uri);
        let regKey = `//${parsed.host}${parsed.pathname}`;
        for (;regKey.length > "//".length; ) {
          if (hasAuth(regKey, opts)) return regKey;
          regKey = regKey.replace(/([^/]+|\/)$/, "");
        }
      }, hasAuth = (regKey, opts) => opts[`${regKey}:_authToken`] || opts[`${regKey}:_auth`] || opts[`${regKey}:username`] && opts[`${regKey}:_password`] || opts[`${regKey}:certfile`] && opts[`${regKey}:keyfile`], maybeReadFile = file => {
        try {
          return fs.readFileSync(file, "utf8");
        } catch (er) {
          if ("ENOENT" !== er.code) throw er;
          return null;
        }
      }, getAuth = (uri, opts = {}) => {
        const {forceAuth} = opts;
        if (!uri) throw new Error("URI is required");
        const regKey = regKeyFromURI(uri, forceAuth || opts);
        if (forceAuth && !regKey) return new Auth({
          scopeAuthKey: null,
          token: forceAuth._authToken || forceAuth.token,
          username: forceAuth.username,
          password: forceAuth._password || forceAuth.password,
          auth: forceAuth._auth || forceAuth.auth,
          certfile: forceAuth.certfile,
          keyfile: forceAuth.keyfile
        });
        if (!regKey) {
          const registry = (opts => {
            const {spec} = opts, {scope: specScope, subSpec} = spec ? npa(spec) : {}, subSpecScope = subSpec && subSpec.scope, scope = subSpec ? subSpecScope : specScope;
            return scope && opts[`${scope}:registry`] || opts.registry;
          })(opts);
          if (registry && uri !== registry && ((a, b) => {
            const parsedA = new URL(a), parsedB = new URL(b);
            return parsedA.host === parsedB.host;
          })(uri, registry)) return getAuth(registry, opts);
          if (registry !== opts.registry) {
            const scopeAuthKey = regKeyFromURI(registry, opts);
            return new Auth({
              scopeAuthKey
            });
          }
        }
        const {[`${regKey}:_authToken`]: token, [`${regKey}:username`]: username, [`${regKey}:_password`]: password, [`${regKey}:_auth`]: auth, [`${regKey}:certfile`]: certfile, [`${regKey}:keyfile`]: keyfile} = opts;
        return new Auth({
          scopeAuthKey: null,
          token,
          auth,
          username,
          password,
          certfile,
          keyfile
        });
      };
      class Auth {
        constructor({token, auth, username, password, scopeAuthKey, certfile, keyfile}) {
          if (this.scopeAuthKey = scopeAuthKey, this.token = null, this.auth = null, this.isBasicAuth = !1, 
          this.cert = null, this.key = null, token) this.token = token; else if (auth) this.auth = auth; else if (username && password) {
            const p = Buffer.from(password, "base64").toString("utf8");
            this.auth = Buffer.from(`${username}:${p}`, "utf8").toString("base64"), this.isBasicAuth = !0;
          }
          if (certfile && keyfile) {
            const cert = maybeReadFile(certfile), key = maybeReadFile(keyfile);
            cert && key && (this.cert = cert, this.key = key);
          }
        }
      }
      module.exports = getAuth;
    },
    20336: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const errors = __webpack_require__(71825), {Response} = __webpack_require__(67105), defaultOpts = __webpack_require__(5158), log = __webpack_require__(46521), cleanUrl = __webpack_require__(65910);
      function logRequest(method, res, startTime) {
        const elapsedTime = Date.now() - startTime, attempt = res.headers.get("x-fetch-attempts"), attemptStr = attempt && attempt > 1 ? ` attempt #${attempt}` : "", cacheStatus = res.headers.get("x-local-cache-status"), cacheStr = cacheStatus ? ` (cache ${cacheStatus})` : "", urlStr = cleanUrl(res.url);
        log.http("fetch", `${method.toUpperCase()} ${res.status} ${urlStr} ${elapsedTime}ms${attemptStr}${cacheStr}`);
      }
      module.exports = async ({method, uri, res, startTime, auth, opts}) => (opts = {
        ...defaultOpts,
        ...opts
      }, res.headers.has("npm-notice") && !res.headers.has("x-local-cache") && log.notice("", res.headers.get("npm-notice")), 
      res.status >= 400 ? (logRequest(method, res, startTime), auth && auth.scopeAuthKey && !auth.token && !auth.auth && log.warn("registry", `No auth for URI, but auth present for scoped registry.\n\nURI: ${uri}\nScoped Registry Key: ${auth.scopeAuthKey}\n\nMore info here: https://github.com/npm/cli/wiki/No-auth-for-URI,-but-auth-present-for-scoped-registry`), 
      function(method, res, startTime, opts) {
        return res.buffer().catch((() => null)).then((body => {
          let parsed = body;
          try {
            parsed = JSON.parse(body.toString("utf8"));
          } catch {}
          if (401 === res.status && res.headers.get("www-authenticate")) {
            const auth = res.headers.get("www-authenticate").split(/,\s*/).map((s => s.toLowerCase()));
            throw -1 !== auth.indexOf("ipaddress") ? new errors.HttpErrorAuthIPAddress(method, res, parsed, opts.spec) : -1 !== auth.indexOf("otp") ? new errors.HttpErrorAuthOTP(method, res, parsed, opts.spec) : new errors.HttpErrorAuthUnknown(method, res, parsed, opts.spec);
          }
          throw 401 === res.status && null != body && /one-time pass/.test(body.toString("utf8")) ? new errors.HttpErrorAuthOTP(method, res, parsed, opts.spec) : new errors.HttpErrorGeneral(method, res, parsed, opts.spec);
        }));
      }(method, res, 0, opts)) : (res.body.on("end", (() => logRequest(method, res, startTime))), 
      opts.ignoreBody ? (res.body.resume(), new Response(null, res)) : res));
    },
    65910: (module, __unused_webpack_exports, __webpack_require__) => {
      const {URL} = __webpack_require__(57310), tokenRegex = /\bnpm_[a-zA-Z0-9]{36}\b/g, guidRegex = /\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/g;
      module.exports = str => {
        if ("string" != typeof str || !str) return str;
        try {
          const url = new URL(str);
          url.password && (str = str.replace(url.password, "***"));
        } catch {}
        return str.replace(tokenRegex, "npm_***").replace(guidRegex, "npm_***");
      };
    },
    5158: (module, __unused_webpack_exports, __webpack_require__) => {
      const pkg = __webpack_require__(82803);
      module.exports = {
        maxSockets: 12,
        method: "GET",
        registry: "https://registry.npmjs.org/",
        timeout: 3e5,
        strictSSL: !0,
        noProxy: process.env.NOPROXY,
        userAgent: `${pkg.name}@${pkg.version}/node@${process.version}+${process.arch} (${process.platform})`
      };
    },
    71825: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const url = __webpack_require__(57310);
      class HttpErrorBase extends Error {
        constructor(method, res, body, spec) {
          super(), this.name = this.constructor.name, this.headers = res.headers.raw(), this.statusCode = res.status, 
          this.code = `E${res.status}`, this.method = method, this.uri = res.url, this.body = body, 
          this.pkgid = spec ? spec.toString() : function(href) {
            try {
              let basePath = new url.URL(href).pathname.slice(1);
              if (!basePath.match(/^-/)) {
                basePath = basePath.split("/");
                var index = basePath.indexOf("_rewrite");
                return -1 === index ? index = basePath.length - 1 : index++, decodeURIComponent(basePath[index]);
              }
            } catch (_) {}
          }(res.url);
        }
      }
      module.exports.HttpErrorBase = HttpErrorBase;
      class HttpErrorGeneral extends HttpErrorBase {
        constructor(method, res, body, spec) {
          super(method, res, body, spec), this.message = `${res.status} ${res.statusText} - ${this.method.toUpperCase()} ${this.spec || this.uri}${body && body.error ? " - " + body.error : ""}`, 
          Error.captureStackTrace(this, HttpErrorGeneral);
        }
      }
      module.exports.HttpErrorGeneral = HttpErrorGeneral;
      class HttpErrorAuthOTP extends HttpErrorBase {
        constructor(method, res, body, spec) {
          super(method, res, body, spec), this.message = "OTP required for authentication", 
          this.code = "EOTP", Error.captureStackTrace(this, HttpErrorAuthOTP);
        }
      }
      module.exports.HttpErrorAuthOTP = HttpErrorAuthOTP;
      class HttpErrorAuthIPAddress extends HttpErrorBase {
        constructor(method, res, body, spec) {
          super(method, res, body, spec), this.message = "Login is not allowed from your IP address", 
          this.code = "EAUTHIP", Error.captureStackTrace(this, HttpErrorAuthIPAddress);
        }
      }
      module.exports.HttpErrorAuthIPAddress = HttpErrorAuthIPAddress;
      class HttpErrorAuthUnknown extends HttpErrorBase {
        constructor(method, res, body, spec) {
          super(method, res, body, spec), this.message = "Unable to authenticate, need: " + res.headers.get("www-authenticate"), 
          Error.captureStackTrace(this, HttpErrorAuthUnknown);
        }
      }
      module.exports.HttpErrorAuthUnknown = HttpErrorAuthUnknown;
    },
    92427: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const {HttpErrorAuthOTP} = __webpack_require__(71825), checkResponse = __webpack_require__(20336), getAuth = __webpack_require__(35425), fetch = __webpack_require__(14936), JSONStream = __webpack_require__(55018), npa = __webpack_require__(19932), qs = __webpack_require__(63477), url = __webpack_require__(57310), zlib = __webpack_require__(13118), Minipass = __webpack_require__(45018), defaultOpts = __webpack_require__(5158);
      function regFetch(uri, opts_ = {}) {
        const opts = {
          ...defaultOpts,
          ...opts_
        }, uriValid = (u => {
          try {
            return !!new url.URL(u);
          } catch (_) {
            return !1;
          }
        })(uri);
        let registry = opts.registry || defaultOpts.registry;
        uriValid || (registry = opts.registry = opts.spec && pickRegistry(opts.spec, opts) || opts.registry || registry, 
        uri = `${registry.trim().replace(/\/?$/g, "")}/${uri.trim().replace(/^\//, "")}`, 
        new url.URL(uri));
        const method = opts.method || "GET", startTime = Date.now(), auth = getAuth(uri, opts), headers = function(uri, auth, opts) {
          const headers = Object.assign({
            "user-agent": opts.userAgent
          }, opts.headers || {});
          opts.authType && (headers["npm-auth-type"] = opts.authType);
          opts.scope && (headers["npm-scope"] = opts.scope);
          opts.npmSession && (headers["npm-session"] = opts.npmSession);
          opts.npmCommand && (headers["npm-command"] = opts.npmCommand);
          auth.token ? headers.authorization = `Bearer ${auth.token}` : auth.auth && (headers.authorization = `Basic ${auth.auth}`);
          opts.otp && (headers["npm-otp"] = opts.otp);
          return headers;
        }(0, auth, opts);
        let body = opts.body;
        const bodyIsStream = Minipass.isStream(body), bodyIsPromise = body && "object" == typeof body && "function" == typeof body.then;
        if (!body || bodyIsStream || bodyIsPromise || "string" == typeof body || Buffer.isBuffer(body) ? body && !headers["content-type"] && (headers["content-type"] = "application/octet-stream") : (headers["content-type"] = headers["content-type"] || "application/json", 
        body = JSON.stringify(body)), opts.gzip) if (headers["content-encoding"] = "gzip", 
        bodyIsStream) {
          const gz = new zlib.Gzip;
          body.on("error", (err => gz.emit("error", err))), body = body.pipe(gz);
        } else bodyIsPromise || (body = (new zlib.Gzip).end(body).concat());
        const parsed = new url.URL(uri);
        if (opts.query) {
          const q = "string" == typeof opts.query ? qs.parse(opts.query) : opts.query;
          Object.keys(q).forEach((key => {
            void 0 !== q[key] && parsed.searchParams.set(key, q[key]);
          })), uri = url.format(parsed);
        }
        "true" === parsed.searchParams.get("write") && "GET" === method && (opts.offline = !1, 
        opts.preferOffline = !1, opts.preferOnline = !0);
        return Promise.resolve(body).then((async fetchBody => {
          const p = fetch(uri, {
            agent: opts.agent,
            algorithms: opts.algorithms,
            body: fetchBody,
            cache: getCacheMode(opts),
            cachePath: opts.cache,
            ca: opts.ca,
            cert: auth.cert || opts.cert,
            headers,
            integrity: opts.integrity,
            key: auth.key || opts.key,
            localAddress: opts.localAddress,
            maxSockets: opts.maxSockets,
            memoize: opts.memoize,
            method,
            noProxy: opts.noProxy,
            proxy: opts.httpsProxy || opts.proxy,
            retry: opts.retry ? opts.retry : {
              retries: opts.fetchRetries,
              factor: opts.fetchRetryFactor,
              minTimeout: opts.fetchRetryMintimeout,
              maxTimeout: opts.fetchRetryMaxtimeout
            },
            strictSSL: opts.strictSSL,
            timeout: opts.timeout || 3e4
          }).then((res => checkResponse({
            method,
            uri,
            res,
            registry,
            startTime,
            auth,
            opts
          })));
          return "function" == typeof opts.otpPrompt ? p.catch((async er => {
            if (er instanceof HttpErrorAuthOTP) {
              let otp;
              try {
                otp = await opts.otpPrompt();
              } catch (_) {}
              if (!otp) throw er;
              return regFetch(uri, {
                ...opts,
                otp
              });
            }
            throw er;
          })) : p;
        }));
      }
      function pickRegistry(spec, opts = {}) {
        let registry = (spec = npa(spec)).scope && opts[spec.scope.replace(/^@?/, "@") + ":registry"];
        return !registry && opts.scope && (registry = opts[opts.scope.replace(/^@?/, "@") + ":registry"]), 
        registry || (registry = opts.registry || defaultOpts.registry), registry;
      }
      function getCacheMode(opts) {
        return opts.offline ? "only-if-cached" : opts.preferOffline ? "force-cache" : opts.preferOnline ? "no-cache" : "default";
      }
      module.exports = regFetch, module.exports.json = function(uri, opts) {
        return regFetch(uri, opts).then((res => res.json()));
      }, module.exports.json.stream = function(uri, jsonPath, opts_ = {}) {
        const opts = {
          ...defaultOpts,
          ...opts_
        }, parser = JSONStream.parse(jsonPath, opts.mapJSON);
        return regFetch(uri, opts).then((res => res.body.on("error", (er => parser.emit("error", er))).pipe(parser))).catch((er => parser.emit("error", er))), 
        parser;
      }, module.exports.pickRegistry = pickRegistry, module.exports.cleanUrl = __webpack_require__(65910);
    },
    49598: (__unused_webpack_module, exports) => {
      exports.email = function(em) {
        if (em.length > 254) return new Error(requirements.email.length);
        if (!em.match(/^[^@]+@.+\..+$/)) return new Error(requirements.email.valid);
        return null;
      }, exports.pw = function(pw) {
        return null;
      }, exports.username = function(un) {
        if (un !== un.toLowerCase()) return new Error(requirements.username.lowerCase);
        if (un !== encodeURIComponent(un)) return new Error(requirements.username.urlSafe);
        if ("." === un.charAt(0)) return new Error(requirements.username.dot);
        if (un.length > 214) return new Error(requirements.username.length);
        var illegal = un.match(illegalCharacterRe);
        if (illegal) return new Error(requirements.username.illegal + ' "' + illegal[0] + '"');
        return null;
      };
      var requirements = exports.requirements = {
        username: {
          length: "Name length must be less than or equal to 214 characters long",
          lowerCase: "Name must be lowercase",
          urlSafe: "Name may not contain non-url-safe chars",
          dot: 'Name may not start with "."',
          illegal: "Name may not contain illegal character"
        },
        password: {},
        email: {
          length: "Email length must be less then or equal to 254 characters long",
          valid: "Email must be an email address"
        }
      }, illegalCharacterRe = new RegExp("([" + [ "'" ].join() + "])");
    },
    38412: (module, __unused_webpack_exports, __webpack_require__) => {
      var wrappy = __webpack_require__(68839);
      function once(fn) {
        var f = function() {
          return f.called ? f.value : (f.called = !0, f.value = fn.apply(this, arguments));
        };
        return f.called = !1, f;
      }
      function onceStrict(fn) {
        var f = function() {
          if (f.called) throw new Error(f.onceError);
          return f.called = !0, f.value = fn.apply(this, arguments);
        }, name = fn.name || "Function wrapped with `once`";
        return f.onceError = name + " shouldn't be called more than once", f.called = !1, 
        f;
      }
      module.exports = wrappy(once), module.exports.strict = wrappy(onceStrict), once.proto = once((function() {
        Object.defineProperty(Function.prototype, "once", {
          value: function() {
            return once(this);
          },
          configurable: !0
        }), Object.defineProperty(Function.prototype, "onceStrict", {
          value: function() {
            return onceStrict(this);
          },
          configurable: !0
        });
      }));
    },
    95815: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var childProcess = __webpack_require__(32081), os = __webpack_require__(22037);
      module.exports = function(args, options, callback) {
        var command, platform = process.platform;
        switch ("linux" === platform && -1 !== os.release().indexOf("Microsoft") && (platform = "win32"), 
        platform) {
         case "win32":
          command = "cmd.exe";
          break;

         case "darwin":
          command = "open";
          break;

         default:
          command = "xdg-open";
        }
        return "string" == typeof args && (args = [ args ]), "function" == typeof options && (callback = options, 
        options = {}), options && "object" == typeof options && options.command && ("win32" === platform ? args = [ options.command ].concat(args) : command = options.command), 
        "win32" === platform && (args = args.map((function(value) {
          return value.replace(/[&^]/g, "^$&");
        })), args = [ "/c", "start", '""' ].concat(args)), childProcess.execFile(command, args, options, callback);
      };
    },
    94812: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const AggregateError = __webpack_require__(64708);
      module.exports = async (iterable, mapper, {concurrency = 1 / 0, stopOnError = !0} = {}) => new Promise(((resolve, reject) => {
        if ("function" != typeof mapper) throw new TypeError("Mapper function is required");
        if (!Number.isSafeInteger(concurrency) && concurrency !== 1 / 0 || !(concurrency >= 1)) throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
        const result = [], errors = [], iterator = iterable[Symbol.iterator]();
        let isRejected = !1, isIterableDone = !1, resolvingCount = 0, currentIndex = 0;
        const next = () => {
          if (isRejected) return;
          const nextItem = iterator.next(), index = currentIndex;
          if (currentIndex++, nextItem.done) return isIterableDone = !0, void (0 === resolvingCount && (stopOnError || 0 === errors.length ? resolve(result) : reject(new AggregateError(errors))));
          resolvingCount++, (async () => {
            try {
              const element = await nextItem.value;
              result[index] = await mapper(element, index), resolvingCount--, next();
            } catch (error) {
              stopOnError ? (isRejected = !0, reject(error)) : (errors.push(error), resolvingCount--, 
              next());
            }
          })();
        };
        for (let i = 0; i < concurrency && (next(), !isIterableDone); i++) ;
      }));
    },
    94720: (module, __unused_webpack_exports, __webpack_require__) => {
      const Fetcher = __webpack_require__(68171), FileFetcher = __webpack_require__(26248), Minipass = __webpack_require__(45018), tarCreateOptions = __webpack_require__(80866), packlist = __webpack_require__(96226), tar = __webpack_require__(39148), _prepareDir = Symbol("_prepareDir"), {resolve} = __webpack_require__(71017), _readPackageJson = Symbol.for("package.Fetcher._readPackageJson"), runScript = __webpack_require__(63036), _tarballFromResolved = Symbol.for("pacote.Fetcher._tarballFromResolved");
      module.exports = class extends Fetcher {
        constructor(spec, opts) {
          super(spec, opts), this.resolved = this.spec.fetchSpec;
        }
        static tarCreateOptions(manifest) {
          return tarCreateOptions(manifest);
        }
        get types() {
          return [ "directory" ];
        }
        [_prepareDir]() {
          return this.manifest().then((mani => {
            if (!mani.scripts || !mani.scripts.prepare) return;
            const stdio = this.opts.foregroundScripts ? "inherit" : "pipe", banner = !this.opts.silent && "inherit" === stdio;
            return runScript({
              pkg: mani,
              event: "prepare",
              path: this.resolved,
              stdioString: !0,
              stdio,
              banner,
              env: {
                npm_package_resolved: this.resolved,
                npm_package_integrity: this.integrity,
                npm_package_json: resolve(this.resolved, "package.json")
              }
            });
          }));
        }
        [_tarballFromResolved]() {
          const stream = new Minipass;
          stream.resolved = this.resolved, stream.integrity = this.integrity;
          const {prefix, workspaces} = this.opts;
          return this[_prepareDir]().then((() => packlist({
            path: this.resolved,
            prefix,
            workspaces
          }))).then((files => tar.c(tarCreateOptions(this.package), files).on("error", (er => stream.emit("error", er))).pipe(stream))).catch((er => stream.emit("error", er))), 
          stream;
        }
        manifest() {
          return this.package ? Promise.resolve(this.package) : this[_readPackageJson](this.resolved + "/package.json").then((mani => this.package = {
            ...mani,
            _integrity: this.integrity && String(this.integrity),
            _resolved: this.resolved,
            _from: this.from
          }));
        }
        packument() {
          return FileFetcher.prototype.packument.apply(this);
        }
      };
    },
    68171: (module, __unused_webpack_exports, __webpack_require__) => {
      const npa = __webpack_require__(19932), ssri = __webpack_require__(60440), {promisify} = __webpack_require__(73837), {basename, dirname} = __webpack_require__(71017), rimraf = promisify(__webpack_require__(11567)), tar = __webpack_require__(39148), log = __webpack_require__(46521), retry = __webpack_require__(49776), fsm = __webpack_require__(33975), cacache = __webpack_require__(99269), isPackageBin = __webpack_require__(36182), removeTrailingSlashes = __webpack_require__(77785), getContents = __webpack_require__(20590), readPackageJsonFast = __webpack_require__(1759), readPackageJson = promisify(__webpack_require__(62965)), Minipass = __webpack_require__(45018), selfOwner = process.getuid && 0 === process.getuid() ? {
        uid: 0,
        gid: process.getgid()
      } : null, chownr = selfOwner ? promisify(__webpack_require__(13159)) : null, inferOwner = selfOwner ? __webpack_require__(84876) : null, mkdirp = __webpack_require__(41718), cacheDir = __webpack_require__(31083), _chown = Symbol("_chown"), _extract = Symbol("_extract"), _mkdir = Symbol("_mkdir"), _empty = Symbol("_empty"), _toFile = Symbol("_toFile"), _tarxOptions = Symbol("_tarxOptions"), _entryMode = Symbol("_entryMode"), _istream = Symbol("_istream"), _assertType = Symbol("_assertType"), _tarballFromCache = Symbol("_tarballFromCache"), _tarballFromResolved = Symbol.for("pacote.Fetcher._tarballFromResolved"), _cacheFetches = Symbol.for("pacote.Fetcher._cacheFetches"), _readPackageJson = Symbol.for("package.Fetcher._readPackageJson");
      class FetcherBase {
        constructor(spec, opts) {
          if (!opts || "object" != typeof opts) throw new TypeError("options object is required");
          this.spec = npa(spec, opts.where), this.allowGitIgnore = !!opts.allowGitIgnore, 
          this.from = this.spec.registry ? `${this.spec.name}@${this.spec.rawSpec}` : this.spec.saveSpec, 
          this[_assertType](), this.opts = {
            ...opts
          }, this.cache = opts.cache || cacheDir(), this.resolved = opts.resolved || null, 
          this.defaultIntegrityAlgorithm = opts.defaultIntegrityAlgorithm || "sha512", "string" == typeof opts.integrity && (this.opts.integrity = ssri.parse(opts.integrity)), 
          this.package = null, this.type = this.constructor.name, this.fmode = opts.fmode || 438, 
          this.dmode = opts.dmode || 511, this.umask = opts.umask || 0, this.preferOnline = !!opts.preferOnline, 
          this.preferOffline = !!opts.preferOffline, this.offline = !!opts.offline, this.before = opts.before, 
          this.fullMetadata = !!this.before || !!opts.fullMetadata, this.fullReadJson = !!opts.fullReadJson, 
          this.fullReadJson ? this[_readPackageJson] = readPackageJson : this[_readPackageJson] = readPackageJsonFast, 
          this.replaceRegistryHost = opts.replaceRegistryHost && "npmjs" !== opts.replaceRegistryHost ? opts.replaceRegistryHost : "registry.npmjs.org", 
          this.defaultTag = opts.defaultTag || "latest", this.registry = removeTrailingSlashes(opts.registry || "https://registry.npmjs.org"), 
          this.npmBin = opts.npmBin || "npm", this.npmInstallCmd = opts.npmInstallCmd || [ "install", "--force" ], 
          this.npmCliConfig = opts.npmCliConfig || [ `--cache=${dirname(this.cache)}`, `--prefer-offline=${!!this.preferOffline}`, `--prefer-online=${!!this.preferOnline}`, `--offline=${!!this.offline}`, ...this.before ? [ `--before=${this.before.toISOString()}` ] : [], "--no-progress", "--no-save", "--no-audit", "--include=dev", "--include=peer", "--include=optional", "--no-package-lock-only", "--no-dry-run" ];
        }
        get integrity() {
          return this.opts.integrity || null;
        }
        set integrity(i) {
          if (!i) return;
          i = ssri.parse(i);
          const current = this.opts.integrity;
          current ? current.merge(i) : this.opts.integrity = i;
        }
        get notImplementedError() {
          return new Error("not implemented in this fetcher type: " + this.type);
        }
        resolve() {
          return this.resolved ? Promise.resolve(this.resolved) : Promise.reject(this.notImplementedError);
        }
        packument() {
          return Promise.reject(this.notImplementedError);
        }
        manifest() {
          return Promise.reject(this.notImplementedError);
        }
        [_tarballFromResolved]() {
          throw this.notImplementedError;
        }
        tarball() {
          return this.tarballStream((stream => stream.concat().then((data => (data.integrity = this.integrity && String(this.integrity), 
          data.resolved = this.resolved, data.from = this.from, data)))));
        }
        [_tarballFromCache]() {
          return cacache.get.stream.byDigest(this.cache, this.integrity, this.opts);
        }
        get [_cacheFetches]() {
          return !0;
        }
        [_istream](stream) {
          if (!this.opts.cache || !this[_cacheFetches]) {
            if (stream.hasIntegrityEmitter) return stream.on("integrity", (i => this.integrity = i)), 
            stream;
            const istream = ssri.integrityStream(this.opts);
            return istream.on("integrity", (i => this.integrity = i)), stream.on("error", (err => istream.emit("error", err))), 
            stream.pipe(istream);
          }
          const middleStream = new Minipass;
          stream.on("error", (err => middleStream.emit("error", err))), stream.pipe(middleStream, {
            end: !1
          });
          const cstream = cacache.put.stream(this.opts.cache, `pacote:tarball:${this.from}`, this.opts);
          return cstream.on("integrity", (i => this.integrity = i)), cstream.on("error", (err => stream.emit("error", err))), 
          stream.pipe(cstream), cstream.promise().catch((() => {})).then((() => middleStream.end())), 
          middleStream;
        }
        pickIntegrityAlgorithm() {
          return this.integrity ? this.integrity.pickAlgorithm(this.opts) : this.defaultIntegrityAlgorithm;
        }
        isDataCorruptionError(er) {
          return "EINTEGRITY" === er.code || "Z_DATA_ERROR" === er.code;
        }
        get types() {
          return !1;
        }
        [_assertType]() {
          if (this.types && !this.types.includes(this.spec.type)) throw new TypeError(`Wrong spec type (${this.spec.type}) for ${this.constructor.name}. Supported types: ${this.types.join(", ")}`);
        }
        isRetriableError(er) {
          return this.isDataCorruptionError(er) || "ENOENT" === er.code || "EISDIR" === er.code;
        }
        tarballStream(streamHandler) {
          const fromCache = !this.preferOnline && this.integrity && this.resolved ? streamHandler(this[_tarballFromCache]()).catch((er => {
            if (this.isDataCorruptionError(er)) return log.warn("tarball", `cached data for ${this.spec} (${this.integrity}) seems to be corrupted. Refreshing cache.`), 
            this.cleanupCached().then((() => {
              throw er;
            }));
            throw er;
          })) : null, fromResolved = er => {
            if (er) {
              if (!this.isRetriableError(er)) throw er;
              log.silly("tarball", `no local data for ${this.spec}. Extracting by manifest.`);
            }
            return this.resolve().then((() => retry((tryAgain => streamHandler(this[_istream](this[_tarballFromResolved]())).catch((streamErr => {
              if (this.isRetriableError(streamErr)) return log.warn("tarball", `tarball data for ${this.spec} (${this.integrity}) seems to be corrupted. Trying again.`), 
              this.cleanupCached().then((() => tryAgain(streamErr)));
              throw streamErr;
            }))), {
              retries: 1,
              minTimeout: 0,
              maxTimeout: 0
            })));
          };
          return fromCache ? fromCache.catch(fromResolved) : fromResolved();
        }
        cleanupCached() {
          return cacache.rm.content(this.cache, this.integrity, this.opts);
        }
        async [_chown](path, uid, gid) {
          return !selfOwner || selfOwner.gid === gid && selfOwner.uid === uid ? null : chownr(path, uid, gid);
        }
        [_empty](path) {
          return getContents({
            path,
            depth: 1
          }).then((contents => Promise.all(contents.map((entry => rimraf(entry))))));
        }
        [_mkdir](dest) {
          return inferOwner ? inferOwner(dest).then((({uid, gid}) => this[_empty](dest).then((() => mkdirp(dest))).then((made => {
            const dir = made || dest;
            return this[_chown](dir, uid, gid);
          })).then((() => ({
            uid,
            gid
          }))))) : this[_empty](dest).then((() => mkdirp(dest))).then((() => ({})));
        }
        extract(dest) {
          return this[_mkdir](dest).then((({uid, gid}) => this.tarballStream((tarball => this[_extract](dest, tarball, uid, gid)))));
        }
        [_toFile](dest) {
          return this.tarballStream((str => new Promise(((res, rej) => {
            const writer = new fsm.WriteStream(dest);
            str.on("error", (er => writer.emit("error", er))), writer.on("error", (er => rej(er))), 
            writer.on("close", (() => res({
              integrity: this.integrity && String(this.integrity),
              resolved: this.resolved,
              from: this.from
            }))), str.pipe(writer);
          }))));
        }
        tarballFile(dest) {
          const dir = dirname(dest);
          return inferOwner ? inferOwner(dest).then((({uid, gid}) => mkdirp(dir).then((made => this[_toFile](dest).then((res => this[_chown](made || dir, uid, gid).then((() => res)))))))) : mkdirp(dir).then((() => this[_toFile](dest)));
        }
        [_extract](dest, tarball, uid, gid) {
          const extractor = tar.x(this[_tarxOptions]({
            cwd: dest,
            uid,
            gid
          })), p = new Promise(((resolve, reject) => {
            extractor.on("end", (() => {
              resolve({
                resolved: this.resolved,
                integrity: this.integrity && String(this.integrity),
                from: this.from
              });
            })), extractor.on("error", (er => {
              log.warn("tar", er.message), log.silly("tar", er), reject(er);
            })), tarball.on("error", (er => reject(er)));
          }));
          return tarball.pipe(extractor), p;
        }
        [_entryMode](path, mode, type) {
          const m = /Directory|GNUDumpDir/.test(type) ? this.dmode : /File$/.test(type) ? this.fmode : 0, exe = isPackageBin(this.package, path) ? 73 : 0;
          return (mode | m) & ~this.umask | exe | 384;
        }
        [_tarxOptions]({cwd, uid, gid}) {
          const sawIgnores = new Set;
          return {
            cwd,
            noChmod: !0,
            noMtime: !0,
            filter: (name, entry) => {
              if (/Link$/.test(entry.type)) return !1;
              if (entry.mode = this[_entryMode](entry.path, entry.mode, entry.type), /File$/.test(entry.type)) {
                const base = basename(entry.path);
                if (".npmignore" === base) sawIgnores.add(entry.path); else if (".gitignore" === base && !this.allowGitIgnore) {
                  const ni = entry.path.replace(/\.gitignore$/, ".npmignore");
                  if (sawIgnores.has(ni)) return !1;
                  entry.path = ni;
                }
                return !0;
              }
            },
            strip: 1,
            onwarn: (code, msg, data) => {
              log.warn("tar", code, msg), log.silly("tar", code, msg, data);
            },
            uid,
            gid,
            umask: this.umask
          };
        }
      }
      module.exports = FetcherBase;
      const GitFetcher = __webpack_require__(5313), RegistryFetcher = __webpack_require__(89168), FileFetcher = __webpack_require__(26248), DirFetcher = __webpack_require__(94720), RemoteFetcher = __webpack_require__(34496);
      FetcherBase.get = (rawSpec, opts = {}) => {
        const spec = npa(rawSpec, opts.where);
        switch (spec.type) {
         case "git":
          return new GitFetcher(spec, opts);

         case "remote":
          return new RemoteFetcher(spec, opts);

         case "version":
         case "range":
         case "tag":
         case "alias":
          return new RegistryFetcher(spec.subSpec || spec, opts);

         case "file":
          return new FileFetcher(spec, opts);

         case "directory":
          return new DirFetcher(spec, opts);

         default:
          throw new TypeError("Unknown spec type: " + spec.type);
        }
      };
    },
    26248: (module, __unused_webpack_exports, __webpack_require__) => {
      const Fetcher = __webpack_require__(68171), fsm = __webpack_require__(33975), cacache = __webpack_require__(99269), _tarballFromResolved = Symbol.for("pacote.Fetcher._tarballFromResolved"), _exeBins = Symbol("_exeBins"), {resolve} = __webpack_require__(71017), fs = __webpack_require__(57147), _readPackageJson = Symbol.for("package.Fetcher._readPackageJson");
      module.exports = class extends Fetcher {
        constructor(spec, opts) {
          super(spec, opts), this.resolved = this.spec.fetchSpec;
        }
        get types() {
          return [ "file" ];
        }
        manifest() {
          return this.package ? Promise.resolve(this.package) : cacache.tmp.withTmp(this.cache, this.opts, (dir => this.extract(dir).then((() => this[_readPackageJson](dir + "/package.json"))).then((mani => this.package = {
            ...mani,
            _integrity: this.integrity && String(this.integrity),
            _resolved: this.resolved,
            _from: this.from
          }))));
        }
        [_exeBins](pkg, dest) {
          return pkg.bin ? Promise.all(Object.keys(pkg.bin).map((k => new Promise((res => {
            const script = resolve(dest, pkg.bin[k]);
            fs.stat(script, ((er, st) => {
              if (er) return res();
              const mode = 73 | st.mode;
              if (mode === st.mode) return res();
              fs.chmod(script, mode, res);
            }));
          }))))) : Promise.resolve();
        }
        extract(dest) {
          return super.extract(dest).then((result => this.package ? result : this[_readPackageJson](dest + "/package.json").then((pkg => this[_exeBins](pkg, dest))).then((() => result))));
        }
        [_tarballFromResolved]() {
          return new fsm.ReadStream(this.resolved);
        }
        packument() {
          return this.manifest().then((mani => ({
            name: mani.name,
            "dist-tags": {
              [this.defaultTag]: mani.version
            },
            versions: {
              [mani.version]: {
                ...mani,
                dist: {
                  tarball: `file:${this.resolved}`,
                  integrity: this.integrity && String(this.integrity)
                }
              }
            }
          })));
        }
      };
    },
    5313: (module, __unused_webpack_exports, __webpack_require__) => {
      const Fetcher = __webpack_require__(68171), FileFetcher = __webpack_require__(26248), RemoteFetcher = __webpack_require__(34496), DirFetcher = __webpack_require__(94720), hashre = /^[a-f0-9]{40}$/, git = __webpack_require__(1626), pickManifest = __webpack_require__(65732), npa = __webpack_require__(19932), Minipass = __webpack_require__(45018), cacache = __webpack_require__(99269), log = __webpack_require__(46521), npm = __webpack_require__(22548), _resolvedFromRepo = Symbol("_resolvedFromRepo"), _resolvedFromHosted = Symbol("_resolvedFromHosted"), _resolvedFromClone = Symbol("_resolvedFromClone"), _tarballFromResolved = Symbol.for("pacote.Fetcher._tarballFromResolved"), _addGitSha = Symbol("_addGitSha"), addGitSha = __webpack_require__(9065), _clone = Symbol("_clone"), _cloneHosted = Symbol("_cloneHosted"), _cloneRepo = Symbol("_cloneRepo"), _setResolvedWithSha = Symbol("_setResolvedWithSha"), _prepareDir = Symbol("_prepareDir"), _readPackageJson = Symbol.for("package.Fetcher._readPackageJson"), repoUrl = (h, opts) => h.sshurl && !(h.https && h.auth) && addGitPlus(h.sshurl(opts)) || h.https && addGitPlus(h.https(opts)), addGitPlus = url => url && `git+${url}`.replace(/^(git\+)+/, "git+");
      module.exports = class extends Fetcher {
        constructor(spec, opts) {
          super(spec, opts), this.opts.integrity && (delete this.opts.integrity, log.warn(`skipping integrity check for git dependency ${this.spec.fetchSpec}`)), 
          this.resolvedRef = null, this.spec.hosted && (this.from = this.spec.hosted.shortcut({
            noCommittish: !1
          })), this.spec.gitCommittish && hashre.test(this.spec.gitCommittish) ? (this.resolvedSha = this.spec.gitCommittish, 
          this.resolved = this.spec.hosted ? repoUrl(this.spec.hosted, {
            noCommittish: !1
          }) : this.spec.rawSpec) : this.resolvedSha = "";
        }
        static repoUrl(hosted, opts) {
          return repoUrl(hosted, opts);
        }
        get types() {
          return [ "git" ];
        }
        resolve() {
          if (this.resolved) return super.resolve();
          const h = this.spec.hosted;
          return h ? this[_resolvedFromHosted](h) : this[_resolvedFromRepo](this.spec.fetchSpec);
        }
        [_resolvedFromHosted](hosted) {
          return this[_resolvedFromRepo](hosted.https && hosted.https()).catch((er => {
            if (er instanceof git.errors.GitPathspecError) throw er;
            const ssh = hosted.sshurl && hosted.sshurl();
            if (!ssh || hosted.auth) throw er;
            return this[_resolvedFromRepo](ssh);
          }));
        }
        [_resolvedFromRepo](gitRemote) {
          if (!gitRemote) return Promise.reject(new Error(`No git url for ${this.spec}`));
          const gitRange = this.spec.gitRange, name = this.spec.name;
          return git.revs(gitRemote, this.opts).then((remoteRefs => gitRange ? pickManifest({
            versions: remoteRefs.versions,
            "dist-tags": remoteRefs["dist-tags"],
            name
          }, gitRange, this.opts) : this.spec.gitCommittish ? remoteRefs.refs[this.spec.gitCommittish] || remoteRefs.refs[remoteRefs.shas[this.spec.gitCommittish]] : remoteRefs.refs.HEAD)).then((revDoc => revDoc && revDoc.sha ? (this.resolvedRef = revDoc, 
          this.resolvedSha = revDoc.sha, this[_addGitSha](revDoc.sha), this.resolved) : this[_resolvedFromClone]()));
        }
        [_setResolvedWithSha](withSha) {
          this.resolved = this.spec.hosted ? repoUrl(npa(withSha).hosted, {
            noCommittish: !1
          }) : withSha;
        }
        [_addGitSha](sha) {
          this[_setResolvedWithSha](addGitSha(this.spec, sha));
        }
        [_resolvedFromClone]() {
          return this[_clone]((dir => this.resolved));
        }
        [_prepareDir](dir) {
          return this[_readPackageJson](dir + "/package.json").then((mani => {
            const scripts = mani.scripts;
            if (!(mani.workspaces || scripts && (scripts.postinstall || scripts.build || scripts.preinstall || scripts.install || scripts.prepack || scripts.prepare))) return;
            const noPrepare = process.env._PACOTE_NO_PREPARE_ ? process.env._PACOTE_NO_PREPARE_.split("\n") : [];
            if (!noPrepare.includes(this.resolved)) return noPrepare.push(this.resolved), npm(this.npmBin, [].concat(this.npmInstallCmd).concat(this.npmCliConfig), dir, {
              ...process.env,
              _PACOTE_NO_PREPARE_: noPrepare.join("\n")
            }, {
              message: "git dep preparation failed"
            });
            log.info("prepare", "skip prepare, already seen", this.resolved);
          }));
        }
        [_tarballFromResolved]() {
          const stream = new Minipass;
          return stream.resolved = this.resolved, stream.from = this.from, this[_clone]((dir => this[_prepareDir](dir).then((() => new Promise(((res, rej) => {
            const dirStream = new DirFetcher(`file:${dir}`, {
              ...this.opts,
              resolved: null,
              integrity: null
            })[_tarballFromResolved]();
            dirStream.on("error", rej), dirStream.on("end", res), dirStream.pipe(stream);
          })))))).catch((er => stream.emit("error", er))), stream;
        }
        [_clone](handler, tarballOk = !0) {
          const ref = this.resolvedSha || this.spec.gitCommittish, h = this.spec.hosted, resolved = this.resolved;
          return tarballOk = tarballOk && h && resolved === repoUrl(h, {
            noCommittish: !1
          }) && h.tarball, cacache.tmp.withTmp(this.cache, {
            tmpPrefix: "git-clone"
          }, (async tmp => {
            if (tarballOk) {
              const nameat = this.spec.name ? `${this.spec.name}@` : "";
              return new RemoteFetcher(h.tarball({
                noCommittish: !1
              }), {
                ...this.opts,
                allowGitIgnore: !0,
                pkgid: `git:${nameat}${this.resolved}`,
                resolved: this.resolved,
                integrity: null
              }).extract(tmp).then((() => handler(tmp)), (er => {
                if (er.constructor.name.match(/^Http/)) return this[_clone](handler, !1);
                throw er;
              }));
            }
            const sha = await (h ? this[_cloneHosted](ref, tmp) : this[_cloneRepo](this.spec.fetchSpec, ref, tmp));
            return this.resolvedSha = sha, this.resolved || await this[_addGitSha](sha), handler(tmp);
          }));
        }
        [_cloneHosted](ref, tmp) {
          const hosted = this.spec.hosted;
          return this[_cloneRepo](hosted.https({
            noCommittish: !0
          }), ref, tmp).catch((er => {
            if (er instanceof git.errors.GitPathspecError) throw er;
            const ssh = hosted.sshurl && hosted.sshurl({
              noCommittish: !0
            });
            if (!ssh || hosted.auth) throw er;
            return this[_cloneRepo](ssh, ref, tmp);
          }));
        }
        [_cloneRepo](repo, ref, tmp) {
          const {opts, spec} = this;
          return git.clone(repo, ref, tmp, {
            ...opts,
            spec
          });
        }
        manifest() {
          return this.package ? Promise.resolve(this.package) : this.spec.hosted && this.resolved ? FileFetcher.prototype.manifest.apply(this) : this[_clone]((dir => this[_readPackageJson](dir + "/package.json").then((mani => this.package = {
            ...mani,
            _resolved: this.resolved,
            _from: this.from
          }))));
        }
        packument() {
          return FileFetcher.prototype.packument.apply(this);
        }
      };
    },
    86585: (module, __unused_webpack_exports, __webpack_require__) => {
      const {get} = __webpack_require__(68171), GitFetcher = __webpack_require__(5313), RegistryFetcher = __webpack_require__(89168), FileFetcher = __webpack_require__(26248), DirFetcher = __webpack_require__(94720), RemoteFetcher = __webpack_require__(34496);
      module.exports = {
        GitFetcher,
        RegistryFetcher,
        FileFetcher,
        DirFetcher,
        RemoteFetcher,
        resolve: (spec, opts) => get(spec, opts).resolve(),
        extract: (spec, dest, opts) => get(spec, opts).extract(dest),
        manifest: (spec, opts) => get(spec, opts).manifest(),
        tarball: (spec, opts) => get(spec, opts).tarball(),
        packument: (spec, opts) => get(spec, opts).packument()
      }, module.exports.tarball.stream = (spec, handler, opts) => get(spec, opts).tarballStream(handler), 
      module.exports.tarball.file = (spec, dest, opts) => get(spec, opts).tarballFile(dest);
    },
    89168: (module, __unused_webpack_exports, __webpack_require__) => {
      const Fetcher = __webpack_require__(68171), RemoteFetcher = __webpack_require__(34496), _tarballFromResolved = Symbol.for("pacote.Fetcher._tarballFromResolved"), pacoteVersion = __webpack_require__(19194).i8, removeTrailingSlashes = __webpack_require__(77785), npa = __webpack_require__(19932), rpj = __webpack_require__(1759), pickManifest = __webpack_require__(65732), ssri = __webpack_require__(60440), crypto = __webpack_require__(6113), fetch = __webpack_require__(92427), _headers = Symbol("_headers");
      module.exports = class extends Fetcher {
        constructor(spec, opts) {
          super(spec, opts), this.packumentCache = this.opts.packumentCache || null, "tag" === this.spec.type && "" === this.spec.rawSpec && "latest" !== this.defaultTag && (this.spec = npa(`${this.spec.name}@${this.defaultTag}`)), 
          this.registry = fetch.pickRegistry(spec, opts), this.packumentUrl = removeTrailingSlashes(this.registry) + "/" + this.spec.escapedName;
          const parsed = new URL(this.registry), regKey = `//${parsed.host}${parsed.pathname}`;
          this.opts[`${regKey}:_keys`] && (this.registryKeys = this.opts[`${regKey}:_keys`]);
        }
        async resolve() {
          if (await this.manifest(), !this.resolved) throw Object.assign(new Error("Invalid package manifest: no `dist.tarball` field"), {
            package: this.spec.toString()
          });
          return this.resolved;
        }
        [_headers]() {
          return {
            "user-agent": this.opts.userAgent || `pacote/${pacoteVersion} node/${process.version}`,
            ...this.opts.headers || {},
            "pacote-version": pacoteVersion,
            "pacote-req-type": "packument",
            "pacote-pkg-id": `registry:${this.spec.name}`,
            accept: this.fullMetadata ? "application/json" : "application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*"
          };
        }
        async packument() {
          if (this.packumentCache && this.packumentCache.has(this.packumentUrl)) return this.packumentCache.get(this.packumentUrl);
          try {
            const res = await fetch(this.packumentUrl, {
              ...this.opts,
              headers: this[_headers](),
              spec: this.spec,
              integrity: null
            }), packument = await res.json();
            return packument._cached = res.headers.has("x-local-cache"), packument._contentLength = +res.headers.get("content-length"), 
            this.packumentCache && this.packumentCache.set(this.packumentUrl, packument), packument;
          } catch (err) {
            if (this.packumentCache && this.packumentCache.delete(this.packumentUrl), "E404" !== err.code || this.fullMetadata) throw err;
            return this.fullMetadata = !0, this.packument();
          }
        }
        async manifest() {
          if (this.package) return this.package;
          const packument = await this.packument();
          let mani = await pickManifest(packument, this.spec.fetchSpec, {
            ...this.opts,
            defaultTag: this.defaultTag,
            before: this.before
          });
          mani = rpj.normalize(mani);
          const {dist} = mani;
          if (dist) {
            this.resolved = mani._resolved = dist.tarball, mani._from = this.from;
            const distIntegrity = dist.integrity ? ssri.parse(dist.integrity) : dist.shasum ? ssri.fromHex(dist.shasum, "sha1", {
              ...this.opts
            }) : null;
            if (distIntegrity) {
              if (this.integrity && !this.integrity.match(distIntegrity)) for (const algo of Object.keys(this.integrity)) if (distIntegrity[algo]) throw Object.assign(new Error(`Integrity checksum failed when using ${algo}: wanted ${this.integrity} but got ${distIntegrity}.`), {
                code: "EINTEGRITY"
              });
              this.integrity = distIntegrity;
            }
          }
          if (this.integrity && (mani._integrity = String(this.integrity), dist.signatures)) if (this.opts.verifySignatures) {
            const message = `${mani._id}:${mani._integrity}`;
            for (const signature of dist.signatures) {
              const publicKey = this.registryKeys && this.registryKeys.filter((key => key.keyid === signature.keyid))[0];
              if (!publicKey) throw Object.assign(new Error(`${mani._id} has a registry signature with keyid: ${signature.keyid} but no corresponding public key can be found`), {
                code: "EMISSINGSIGNATUREKEY"
              });
              if (!(!publicKey.expires || Date.parse(publicKey.expires) > Date.now())) throw Object.assign(new Error(`${mani._id} has a registry signature with keyid: ${signature.keyid} but the corresponding public key has expired ${publicKey.expires}`), {
                code: "EEXPIREDSIGNATUREKEY"
              });
              const verifier = crypto.createVerify("SHA256");
              verifier.write(message), verifier.end();
              if (!verifier.verify(publicKey.pemkey, signature.sig, "base64")) throw Object.assign(new Error(`${mani._id} has an invalid registry signature with keyid: ${publicKey.keyid} and signature: ${signature.sig}`), {
                code: "EINTEGRITYSIGNATURE",
                keyid: publicKey.keyid,
                signature: signature.sig,
                resolved: mani._resolved,
                integrity: mani._integrity
              });
            }
            mani._signatures = dist.signatures;
          } else mani._signatures = dist.signatures;
          return this.package = mani, this.package;
        }
        [_tarballFromResolved]() {
          return new RemoteFetcher(this.resolved, {
            ...this.opts,
            resolved: this.resolved,
            pkgid: `registry:${this.spec.name}@${this.resolved}`
          })[_tarballFromResolved]();
        }
        get types() {
          return [ "tag", "version", "range" ];
        }
      };
    },
    34496: (module, __unused_webpack_exports, __webpack_require__) => {
      const Fetcher = __webpack_require__(68171), FileFetcher = __webpack_require__(26248), _tarballFromResolved = Symbol.for("pacote.Fetcher._tarballFromResolved"), pacoteVersion = __webpack_require__(19194).i8, fetch = __webpack_require__(92427), Minipass = __webpack_require__(45018), _cacheFetches = Symbol.for("pacote.Fetcher._cacheFetches"), _headers = Symbol("_headers");
      module.exports = class extends Fetcher {
        constructor(spec, opts) {
          super(spec, opts), this.resolved = this.spec.fetchSpec;
          const resolvedURL = new URL(this.resolved);
          "never" === this.replaceRegistryHost || "always" !== this.replaceRegistryHost && this.replaceRegistryHost !== resolvedURL.host || (this.resolved = new URL(resolvedURL.pathname, this.registry).href);
          const nameat = this.spec.name ? `${this.spec.name}@` : "";
          this.pkgid = opts.pkgid ? opts.pkgid : `remote:${nameat}${this.resolved}`;
        }
        get [_cacheFetches]() {
          return !1;
        }
        [_tarballFromResolved]() {
          const stream = new Minipass;
          stream.hasIntegrityEmitter = !0;
          const fetchOpts = {
            ...this.opts,
            headers: this[_headers](),
            spec: this.spec,
            integrity: this.integrity,
            algorithms: [ this.pickIntegrityAlgorithm() ]
          };
          return fetch(this.resolved, fetchOpts).then((res => {
            res.body.on("error", (er => stream.emit("error", er))), res.body.on("integrity", (i => {
              this.integrity = i, stream.emit("integrity", i);
            })), res.body.pipe(stream);
          })).catch((er => stream.emit("error", er))), stream;
        }
        [_headers]() {
          return {
            "user-agent": this.opts.userAgent || `pacote/${pacoteVersion} node/${process.version}`,
            ...this.opts.headers || {},
            "pacote-version": pacoteVersion,
            "pacote-req-type": "tarball",
            "pacote-pkg-id": this.pkgid,
            ...this.integrity ? {
              "pacote-integrity": String(this.integrity)
            } : {},
            ...this.opts.headers || {}
          };
        }
        get types() {
          return [ "remote" ];
        }
        packument() {
          return FileFetcher.prototype.packument.apply(this);
        }
        manifest() {
          return FileFetcher.prototype.manifest.apply(this);
        }
      };
    },
    9065: module => {
      module.exports = (spec, sha) => {
        if (spec.hosted) {
          const h = spec.hosted, opt = {
            noCommittish: !0
          };
          return `${h.https && h.auth ? h.https(opt) : h.shortcut(opt)}#${sha}`;
        }
        return spec.rawSpec.replace(/#.*$/, "") + `#${sha}`;
      };
    },
    31083: (module, __unused_webpack_exports, __webpack_require__) => {
      const os = __webpack_require__(22037), {resolve} = __webpack_require__(71017);
      module.exports = (fakePlatform = !1) => {
        const temp = os.tmpdir(), uidOrPid = process.getuid ? process.getuid() : process.pid, home = os.homedir() || resolve(temp, "npm-" + uidOrPid), platform = fakePlatform || process.platform, cacheExtra = "win32" === platform ? "npm-cache" : ".npm", cacheRoot = "win32" === platform && process.env.LOCALAPPDATA || home;
        return resolve(cacheRoot, cacheExtra, "_cacache");
      };
    },
    36182: module => {
      module.exports = (pkg, path) => !(!pkg || !pkg.bin) && ((pkg, path) => {
        const bin = ((name, bin) => "string" == typeof bin ? {
          [name]: bin
        } : bin)(pkg.name, pkg.bin), p = path.replace(/^[^\\/]*\//, "");
        for (const kv of Object.entries(bin)) if (kv[1] === p) return !0;
        return !1;
      })(pkg, path);
    },
    22548: (module, __unused_webpack_exports, __webpack_require__) => {
      const spawn = __webpack_require__(26035);
      module.exports = (npmBin, npmCommand, cwd, env, extra) => {
        const isJS = npmBin.endsWith(".js"), cmd = isJS ? process.execPath : npmBin, args = (isJS ? [ npmBin ] : []).concat(npmCommand);
        return spawn(cmd, args, {
          cwd,
          stdioString: !0,
          env
        }, extra);
      };
    },
    80866: (module, __unused_webpack_exports, __webpack_require__) => {
      const isPackageBin = __webpack_require__(36182);
      module.exports = manifest => ({
        cwd: manifest._resolved,
        prefix: "package/",
        portable: !0,
        gzip: {
          level: 9
        },
        filter: (path, stat) => (isPackageBin(manifest, path) && (stat.mode |= 73), !0),
        mtime: new Date("1985-10-26T08:15:00.000Z")
      });
    },
    77785: module => {
      module.exports = input => {
        let output = input;
        for (;output.endsWith("/"); ) output = output.slice(0, -1);
        return output;
      };
    },
    2513: (module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      var obj, _processor = (obj = __webpack_require__(78023)) && obj.__esModule ? obj : {
        default: obj
      }, selectors = function(obj) {
        if (obj && obj.__esModule) return obj;
        if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
          default: obj
        };
        var cache = _getRequireWildcardCache();
        if (cache && cache.has(obj)) return cache.get(obj);
        var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
        newObj.default = obj, cache && cache.set(obj, newObj);
        return newObj;
      }(__webpack_require__(95980));
      function _getRequireWildcardCache() {
        if ("function" != typeof WeakMap) return null;
        var cache = new WeakMap;
        return _getRequireWildcardCache = function() {
          return cache;
        }, cache;
      }
      var parser = function(processor) {
        return new _processor.default(processor);
      };
      Object.assign(parser, selectors), delete parser.__esModule;
      var _default = parser;
      exports.default = _default, module.exports = exports.default;
    },
    8754: (module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      var _WHITESPACE_TOKENS, _Object$assign, _root = _interopRequireDefault(__webpack_require__(32191)), _selector = _interopRequireDefault(__webpack_require__(42909)), _className = _interopRequireDefault(__webpack_require__(27585)), _comment = _interopRequireDefault(__webpack_require__(65683)), _id = _interopRequireDefault(__webpack_require__(94152)), _tag = _interopRequireDefault(__webpack_require__(83297)), _string = _interopRequireDefault(__webpack_require__(64614)), _pseudo = _interopRequireDefault(__webpack_require__(22951)), _attribute = _interopRequireWildcard(__webpack_require__(79467)), _universal = _interopRequireDefault(__webpack_require__(73825)), _combinator = _interopRequireDefault(__webpack_require__(55107)), _nesting = _interopRequireDefault(__webpack_require__(27353)), _sortAscending = _interopRequireDefault(__webpack_require__(66219)), _tokenize = _interopRequireWildcard(__webpack_require__(11671)), tokens = _interopRequireWildcard(__webpack_require__(86712)), types = _interopRequireWildcard(__webpack_require__(31640)), _util = __webpack_require__(58244);
      function _getRequireWildcardCache() {
        if ("function" != typeof WeakMap) return null;
        var cache = new WeakMap;
        return _getRequireWildcardCache = function() {
          return cache;
        }, cache;
      }
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) return obj;
        if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
          default: obj
        };
        var cache = _getRequireWildcardCache();
        if (cache && cache.has(obj)) return cache.get(obj);
        var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
        return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
      }
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
          "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      var WHITESPACE_TOKENS = ((_WHITESPACE_TOKENS = {})[tokens.space] = !0, _WHITESPACE_TOKENS[tokens.cr] = !0, 
      _WHITESPACE_TOKENS[tokens.feed] = !0, _WHITESPACE_TOKENS[tokens.newline] = !0, _WHITESPACE_TOKENS[tokens.tab] = !0, 
      _WHITESPACE_TOKENS), WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, ((_Object$assign = {})[tokens.comment] = !0, 
      _Object$assign));
      function tokenStart(token) {
        return {
          line: token[_tokenize.FIELDS.START_LINE],
          column: token[_tokenize.FIELDS.START_COL]
        };
      }
      function tokenEnd(token) {
        return {
          line: token[_tokenize.FIELDS.END_LINE],
          column: token[_tokenize.FIELDS.END_COL]
        };
      }
      function getSource(startLine, startColumn, endLine, endColumn) {
        return {
          start: {
            line: startLine,
            column: startColumn
          },
          end: {
            line: endLine,
            column: endColumn
          }
        };
      }
      function getTokenSource(token) {
        return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
      }
      function getTokenSourceSpan(startToken, endToken) {
        if (startToken) return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
      }
      function unescapeProp(node, prop) {
        var value = node[prop];
        if ("string" == typeof value) return -1 !== value.indexOf("\\") && ((0, _util.ensureObject)(node, "raws"), 
        node[prop] = (0, _util.unesc)(value), void 0 === node.raws[prop] && (node.raws[prop] = value)), 
        node;
      }
      function indexesOf(array, item) {
        for (var i = -1, indexes = []; -1 !== (i = array.indexOf(item, i + 1)); ) indexes.push(i);
        return indexes;
      }
      var Parser = function() {
        function Parser(rule, options) {
          void 0 === options && (options = {}), this.rule = rule, this.options = Object.assign({
            lossy: !1,
            safe: !1
          }, options), this.position = 0, this.css = "string" == typeof this.rule ? this.rule : this.rule.selector, 
          this.tokens = (0, _tokenize.default)({
            css: this.css,
            error: this._errorGenerator(),
            safe: this.options.safe
          });
          var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
          this.root = new _root.default({
            source: rootSource
          }), this.root.errorGenerator = this._errorGenerator();
          var selector = new _selector.default({
            source: {
              start: {
                line: 1,
                column: 1
              }
            }
          });
          this.root.append(selector), this.current = selector, this.loop();
        }
        var Constructor, protoProps, staticProps, _proto = Parser.prototype;
        return _proto._errorGenerator = function() {
          var _this = this;
          return function(message, errorOptions) {
            return "string" == typeof _this.rule ? new Error(message) : _this.rule.error(message, errorOptions);
          };
        }, _proto.attribute = function() {
          var attr = [], startingToken = this.currToken;
          for (this.position++; this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare; ) attr.push(this.currToken), 
          this.position++;
          if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) return this.expected("closing square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
          var len = attr.length, node = {
            source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
            sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
          };
          if (1 === len && !~[ tokens.word ].indexOf(attr[0][_tokenize.FIELDS.TYPE])) return this.expected("attribute", attr[0][_tokenize.FIELDS.START_POS]);
          for (var pos = 0, spaceBefore = "", commentBefore = "", lastAdded = null, spaceAfterMeaningfulToken = !1; pos < len; ) {
            var token = attr[pos], content = this.content(token), next = attr[pos + 1];
            switch (token[_tokenize.FIELDS.TYPE]) {
             case tokens.space:
              if (spaceAfterMeaningfulToken = !0, this.options.lossy) break;
              if (lastAdded) {
                (0, _util.ensureObject)(node, "spaces", lastAdded);
                var prevContent = node.spaces[lastAdded].after || "";
                node.spaces[lastAdded].after = prevContent + content;
                var existingComment = (0, _util.getProp)(node, "raws", "spaces", lastAdded, "after") || null;
                existingComment && (node.raws.spaces[lastAdded].after = existingComment + content);
              } else spaceBefore += content, commentBefore += content;
              break;

             case tokens.asterisk:
              if (next[_tokenize.FIELDS.TYPE] === tokens.equals) node.operator = content, lastAdded = "operator"; else if ((!node.namespace || "namespace" === lastAdded && !spaceAfterMeaningfulToken) && next) {
                spaceBefore && ((0, _util.ensureObject)(node, "spaces", "attribute"), node.spaces.attribute.before = spaceBefore, 
                spaceBefore = ""), commentBefore && ((0, _util.ensureObject)(node, "raws", "spaces", "attribute"), 
                node.raws.spaces.attribute.before = spaceBefore, commentBefore = ""), node.namespace = (node.namespace || "") + content, 
                ((0, _util.getProp)(node, "raws", "namespace") || null) && (node.raws.namespace += content), 
                lastAdded = "namespace";
              }
              spaceAfterMeaningfulToken = !1;
              break;

             case tokens.dollar:
              if ("value" === lastAdded) {
                var oldRawValue = (0, _util.getProp)(node, "raws", "value");
                node.value += "$", oldRawValue && (node.raws.value = oldRawValue + "$");
                break;
              }

             case tokens.caret:
              next[_tokenize.FIELDS.TYPE] === tokens.equals && (node.operator = content, lastAdded = "operator"), 
              spaceAfterMeaningfulToken = !1;
              break;

             case tokens.combinator:
              if ("~" === content && next[_tokenize.FIELDS.TYPE] === tokens.equals && (node.operator = content, 
              lastAdded = "operator"), "|" !== content) {
                spaceAfterMeaningfulToken = !1;
                break;
              }
              next[_tokenize.FIELDS.TYPE] === tokens.equals ? (node.operator = content, lastAdded = "operator") : node.namespace || node.attribute || (node.namespace = !0), 
              spaceAfterMeaningfulToken = !1;
              break;

             case tokens.word:
              if (next && "|" === this.content(next) && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && !node.operator && !node.namespace) node.namespace = content, 
              lastAdded = "namespace"; else if (!node.attribute || "attribute" === lastAdded && !spaceAfterMeaningfulToken) {
                spaceBefore && ((0, _util.ensureObject)(node, "spaces", "attribute"), node.spaces.attribute.before = spaceBefore, 
                spaceBefore = ""), commentBefore && ((0, _util.ensureObject)(node, "raws", "spaces", "attribute"), 
                node.raws.spaces.attribute.before = commentBefore, commentBefore = ""), node.attribute = (node.attribute || "") + content, 
                ((0, _util.getProp)(node, "raws", "attribute") || null) && (node.raws.attribute += content), 
                lastAdded = "attribute";
              } else if (!node.value && "" !== node.value || "value" === lastAdded && !spaceAfterMeaningfulToken) {
                var _unescaped = (0, _util.unesc)(content), _oldRawValue = (0, _util.getProp)(node, "raws", "value") || "", oldValue = node.value || "";
                node.value = oldValue + _unescaped, node.quoteMark = null, (_unescaped !== content || _oldRawValue) && ((0, 
                _util.ensureObject)(node, "raws"), node.raws.value = (_oldRawValue || oldValue) + content), 
                lastAdded = "value";
              } else {
                var insensitive = "i" === content || "I" === content;
                !node.value && "" !== node.value || !node.quoteMark && !spaceAfterMeaningfulToken ? (node.value || "" === node.value) && (lastAdded = "value", 
                node.value += content, node.raws.value && (node.raws.value += content)) : (node.insensitive = insensitive, 
                insensitive && "I" !== content || ((0, _util.ensureObject)(node, "raws"), node.raws.insensitiveFlag = content), 
                lastAdded = "insensitive", spaceBefore && ((0, _util.ensureObject)(node, "spaces", "insensitive"), 
                node.spaces.insensitive.before = spaceBefore, spaceBefore = ""), commentBefore && ((0, 
                _util.ensureObject)(node, "raws", "spaces", "insensitive"), node.raws.spaces.insensitive.before = commentBefore, 
                commentBefore = ""));
              }
              spaceAfterMeaningfulToken = !1;
              break;

             case tokens.str:
              if (!node.attribute || !node.operator) return this.error("Expected an attribute followed by an operator preceding the string.", {
                index: token[_tokenize.FIELDS.START_POS]
              });
              var _unescapeValue = (0, _attribute.unescapeValue)(content), unescaped = _unescapeValue.unescaped, quoteMark = _unescapeValue.quoteMark;
              node.value = unescaped, node.quoteMark = quoteMark, lastAdded = "value", (0, _util.ensureObject)(node, "raws"), 
              node.raws.value = content, spaceAfterMeaningfulToken = !1;
              break;

             case tokens.equals:
              if (!node.attribute) return this.expected("attribute", token[_tokenize.FIELDS.START_POS], content);
              if (node.value) return this.error('Unexpected "=" found; an operator was already defined.', {
                index: token[_tokenize.FIELDS.START_POS]
              });
              node.operator = node.operator ? node.operator + content : content, lastAdded = "operator", 
              spaceAfterMeaningfulToken = !1;
              break;

             case tokens.comment:
              if (lastAdded) if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || "insensitive" === lastAdded) {
                var lastComment = (0, _util.getProp)(node, "spaces", lastAdded, "after") || "", rawLastComment = (0, 
                _util.getProp)(node, "raws", "spaces", lastAdded, "after") || lastComment;
                (0, _util.ensureObject)(node, "raws", "spaces", lastAdded), node.raws.spaces[lastAdded].after = rawLastComment + content;
              } else {
                var lastValue = node[lastAdded] || "", rawLastValue = (0, _util.getProp)(node, "raws", lastAdded) || lastValue;
                (0, _util.ensureObject)(node, "raws"), node.raws[lastAdded] = rawLastValue + content;
              } else commentBefore += content;
              break;

             default:
              return this.error('Unexpected "' + content + '" found.', {
                index: token[_tokenize.FIELDS.START_POS]
              });
            }
            pos++;
          }
          unescapeProp(node, "attribute"), unescapeProp(node, "namespace"), this.newNode(new _attribute.default(node)), 
          this.position++;
        }, _proto.parseWhitespaceEquivalentTokens = function(stopPosition) {
          stopPosition < 0 && (stopPosition = this.tokens.length);
          var startPosition = this.position, nodes = [], space = "", lastComment = void 0;
          do {
            if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) this.options.lossy || (space += this.content()); else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
              var spaces = {};
              space && (spaces.before = space, space = ""), lastComment = new _comment.default({
                value: this.content(),
                source: getTokenSource(this.currToken),
                sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
                spaces
              }), nodes.push(lastComment);
            }
          } while (++this.position < stopPosition);
          if (space) if (lastComment) lastComment.spaces.after = space; else if (!this.options.lossy) {
            var firstToken = this.tokens[startPosition], lastToken = this.tokens[this.position - 1];
            nodes.push(new _string.default({
              value: "",
              source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
              sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
              spaces: {
                before: space,
                after: ""
              }
            }));
          }
          return nodes;
        }, _proto.convertWhitespaceNodesToSpace = function(nodes, requiredSpace) {
          var _this2 = this;
          void 0 === requiredSpace && (requiredSpace = !1);
          var space = "", rawSpace = "";
          return nodes.forEach((function(n) {
            var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace), rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);
            space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && 0 === spaceBefore.length), 
            rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && 0 === rawSpaceBefore.length);
          })), rawSpace === space && (rawSpace = void 0), {
            space,
            rawSpace
          };
        }, _proto.isNamedCombinator = function(position) {
          return void 0 === position && (position = this.position), this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
        }, _proto.namedCombinator = function() {
          if (this.isNamedCombinator()) {
            var nameRaw = this.content(this.tokens[this.position + 1]), name = (0, _util.unesc)(nameRaw).toLowerCase(), raws = {};
            name !== nameRaw && (raws.value = "/" + nameRaw + "/");
            var node = new _combinator.default({
              value: "/" + name + "/",
              source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
              raws
            });
            return this.position = this.position + 3, node;
          }
          this.unexpected();
        }, _proto.combinator = function() {
          var _this3 = this;
          if ("|" === this.content()) return this.namespace();
          var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);
          if (!(nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma)) {
            var node, firstToken = this.currToken, spaceOrDescendantSelectorNodes = void 0;
            if (nextSigTokenPos > this.position && (spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos)), 
            this.isNamedCombinator() ? node = this.namedCombinator() : this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator ? (node = new _combinator.default({
              value: this.content(),
              source: getTokenSource(this.currToken),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
            }), this.position++) : WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]] || spaceOrDescendantSelectorNodes || this.unexpected(), 
            node) {
              if (spaceOrDescendantSelectorNodes) {
                var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes), _space = _this$convertWhitespa2.space, _rawSpace = _this$convertWhitespa2.rawSpace;
                node.spaces.before = _space, node.rawSpaceBefore = _rawSpace;
              }
            } else {
              var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, !0), _space2 = _this$convertWhitespa3.space, _rawSpace2 = _this$convertWhitespa3.rawSpace;
              _rawSpace2 || (_rawSpace2 = _space2);
              var spaces = {}, raws = {
                spaces: {}
              };
              _space2.endsWith(" ") && _rawSpace2.endsWith(" ") ? (spaces.before = _space2.slice(0, _space2.length - 1), 
              raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1)) : _space2.startsWith(" ") && _rawSpace2.startsWith(" ") ? (spaces.after = _space2.slice(1), 
              raws.spaces.after = _rawSpace2.slice(1)) : raws.value = _rawSpace2, node = new _combinator.default({
                value: " ",
                source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
                sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
                spaces,
                raws
              });
            }
            return this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space && (node.spaces.after = this.optionalSpace(this.content()), 
            this.position++), this.newNode(node);
          }
          var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
          if (nodes.length > 0) {
            var last = this.current.last;
            if (last) {
              var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes), space = _this$convertWhitespa.space, rawSpace = _this$convertWhitespa.rawSpace;
              void 0 !== rawSpace && (last.rawSpaceAfter += rawSpace), last.spaces.after += space;
            } else nodes.forEach((function(n) {
              return _this3.newNode(n);
            }));
          }
        }, _proto.comma = function() {
          if (this.position === this.tokens.length - 1) return this.root.trailingComma = !0, 
          void this.position++;
          this.current._inferEndPosition();
          var selector = new _selector.default({
            source: {
              start: tokenStart(this.tokens[this.position + 1])
            }
          });
          this.current.parent.append(selector), this.current = selector, this.position++;
        }, _proto.comment = function() {
          var current = this.currToken;
          this.newNode(new _comment.default({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          })), this.position++;
        }, _proto.error = function(message, opts) {
          throw this.root.error(message, opts);
        }, _proto.missingBackslash = function() {
          return this.error("Expected a backslash preceding the semicolon.", {
            index: this.currToken[_tokenize.FIELDS.START_POS]
          });
        }, _proto.missingParenthesis = function() {
          return this.expected("opening parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
        }, _proto.missingSquareBracket = function() {
          return this.expected("opening square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
        }, _proto.unexpected = function() {
          return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
        }, _proto.namespace = function() {
          var before = this.prevToken && this.content(this.prevToken) || !0;
          return this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word ? (this.position++, 
          this.word(before)) : this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk ? (this.position++, 
          this.universal(before)) : void 0;
        }, _proto.nesting = function() {
          if (this.nextToken && "|" === this.content(this.nextToken)) return void this.position++;
          var current = this.currToken;
          this.newNode(new _nesting.default({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          })), this.position++;
        }, _proto.parentheses = function() {
          var last = this.current.last, unbalanced = 1;
          if (this.position++, last && last.type === types.PSEUDO) {
            var selector = new _selector.default({
              source: {
                start: tokenStart(this.tokens[this.position - 1])
              }
            }), cache = this.current;
            for (last.append(selector), this.current = selector; this.position < this.tokens.length && unbalanced; ) this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis && unbalanced++, 
            this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis && unbalanced--, 
            unbalanced ? this.parse() : (this.current.source.end = tokenEnd(this.currToken), 
            this.current.parent.source.end = tokenEnd(this.currToken), this.position++);
            this.current = cache;
          } else {
            for (var parenEnd, parenStart = this.currToken, parenValue = "("; this.position < this.tokens.length && unbalanced; ) this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis && unbalanced++, 
            this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis && unbalanced--, 
            parenEnd = this.currToken, parenValue += this.parseParenthesisToken(this.currToken), 
            this.position++;
            last ? last.appendToPropertyAndEscape("value", parenValue, parenValue) : this.newNode(new _string.default({
              value: parenValue,
              source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
              sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
            }));
          }
          if (unbalanced) return this.expected("closing parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
        }, _proto.pseudo = function() {
          for (var _this4 = this, pseudoStr = "", startingToken = this.currToken; this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon; ) pseudoStr += this.content(), 
          this.position++;
          return this.currToken ? this.currToken[_tokenize.FIELDS.TYPE] !== tokens.word ? this.expected([ "pseudo-class", "pseudo-element" ], this.currToken[_tokenize.FIELDS.START_POS]) : void this.splitWord(!1, (function(first, length) {
            pseudoStr += first, _this4.newNode(new _pseudo.default({
              value: pseudoStr,
              source: getTokenSourceSpan(startingToken, _this4.currToken),
              sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
            })), length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis && _this4.error("Misplaced parenthesis.", {
              index: _this4.nextToken[_tokenize.FIELDS.START_POS]
            });
          })) : this.expected([ "pseudo-class", "pseudo-element" ], this.position - 1);
        }, _proto.space = function() {
          var content = this.content();
          0 === this.position || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every((function(node) {
            return "comment" === node.type;
          })) ? (this.spaces = this.optionalSpace(content), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(content), 
          this.position++) : this.combinator();
        }, _proto.string = function() {
          var current = this.currToken;
          this.newNode(new _string.default({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          })), this.position++;
        }, _proto.universal = function(namespace) {
          var nextToken = this.nextToken;
          if (nextToken && "|" === this.content(nextToken)) return this.position++, this.namespace();
          var current = this.currToken;
          this.newNode(new _universal.default({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }), namespace), this.position++;
        }, _proto.splitWord = function(namespace, firstCallback) {
          for (var _this5 = this, nextToken = this.nextToken, word = this.content(); nextToken && ~[ tokens.dollar, tokens.caret, tokens.equals, tokens.word ].indexOf(nextToken[_tokenize.FIELDS.TYPE]); ) {
            this.position++;
            var current = this.content();
            if (word += current, current.lastIndexOf("\\") === current.length - 1) {
              var next = this.nextToken;
              next && next[_tokenize.FIELDS.TYPE] === tokens.space && (word += this.requiredSpace(this.content(next)), 
              this.position++);
            }
            nextToken = this.nextToken;
          }
          var hasClass = indexesOf(word, ".").filter((function(i) {
            var escapedDot = "\\" === word[i - 1], isKeyframesPercent = /^\d+\.\d+%$/.test(word);
            return !escapedDot && !isKeyframesPercent;
          })), hasId = indexesOf(word, "#").filter((function(i) {
            return "\\" !== word[i - 1];
          })), interpolations = indexesOf(word, "#{");
          interpolations.length && (hasId = hasId.filter((function(hashIndex) {
            return !~interpolations.indexOf(hashIndex);
          })));
          var indices = (0, _sortAscending.default)(function() {
            var list = Array.prototype.concat.apply([], arguments);
            return list.filter((function(item, i) {
              return i === list.indexOf(item);
            }));
          }([ 0 ].concat(hasClass, hasId)));
          indices.forEach((function(ind, i) {
            var node, index = indices[i + 1] || word.length, value = word.slice(ind, index);
            if (0 === i && firstCallback) return firstCallback.call(_this5, value, indices.length);
            var current = _this5.currToken, sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i], source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));
            if (~hasClass.indexOf(ind)) {
              var classNameOpts = {
                value: value.slice(1),
                source,
                sourceIndex
              };
              node = new _className.default(unescapeProp(classNameOpts, "value"));
            } else if (~hasId.indexOf(ind)) {
              var idOpts = {
                value: value.slice(1),
                source,
                sourceIndex
              };
              node = new _id.default(unescapeProp(idOpts, "value"));
            } else {
              var tagOpts = {
                value,
                source,
                sourceIndex
              };
              unescapeProp(tagOpts, "value"), node = new _tag.default(tagOpts);
            }
            _this5.newNode(node, namespace), namespace = null;
          })), this.position++;
        }, _proto.word = function(namespace) {
          var nextToken = this.nextToken;
          return nextToken && "|" === this.content(nextToken) ? (this.position++, this.namespace()) : this.splitWord(namespace);
        }, _proto.loop = function() {
          for (;this.position < this.tokens.length; ) this.parse(!0);
          return this.current._inferEndPosition(), this.root;
        }, _proto.parse = function(throwOnParenthesis) {
          switch (this.currToken[_tokenize.FIELDS.TYPE]) {
           case tokens.space:
            this.space();
            break;

           case tokens.comment:
            this.comment();
            break;

           case tokens.openParenthesis:
            this.parentheses();
            break;

           case tokens.closeParenthesis:
            throwOnParenthesis && this.missingParenthesis();
            break;

           case tokens.openSquare:
            this.attribute();
            break;

           case tokens.dollar:
           case tokens.caret:
           case tokens.equals:
           case tokens.word:
            this.word();
            break;

           case tokens.colon:
            this.pseudo();
            break;

           case tokens.comma:
            this.comma();
            break;

           case tokens.asterisk:
            this.universal();
            break;

           case tokens.ampersand:
            this.nesting();
            break;

           case tokens.slash:
           case tokens.combinator:
            this.combinator();
            break;

           case tokens.str:
            this.string();
            break;

           case tokens.closeSquare:
            this.missingSquareBracket();

           case tokens.semicolon:
            this.missingBackslash();

           default:
            this.unexpected();
          }
        }, _proto.expected = function(description, index, found) {
          if (Array.isArray(description)) {
            var last = description.pop();
            description = description.join(", ") + " or " + last;
          }
          var an = /^[aeiou]/.test(description[0]) ? "an" : "a";
          return found ? this.error("Expected " + an + " " + description + ', found "' + found + '" instead.', {
            index
          }) : this.error("Expected " + an + " " + description + ".", {
            index
          });
        }, _proto.requiredSpace = function(space) {
          return this.options.lossy ? " " : space;
        }, _proto.optionalSpace = function(space) {
          return this.options.lossy ? "" : space;
        }, _proto.lossySpace = function(space, required) {
          return this.options.lossy ? required ? " " : "" : space;
        }, _proto.parseParenthesisToken = function(token) {
          var content = this.content(token);
          return token[_tokenize.FIELDS.TYPE] === tokens.space ? this.requiredSpace(content) : content;
        }, _proto.newNode = function(node, namespace) {
          return namespace && (/^ +$/.test(namespace) && (this.options.lossy || (this.spaces = (this.spaces || "") + namespace), 
          namespace = !0), node.namespace = namespace, unescapeProp(node, "namespace")), this.spaces && (node.spaces.before = this.spaces, 
          this.spaces = ""), this.current.append(node);
        }, _proto.content = function(token) {
          return void 0 === token && (token = this.currToken), this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
        }, _proto.locateNextMeaningfulToken = function(startPosition) {
          void 0 === startPosition && (startPosition = this.position + 1);
          for (var searchPosition = startPosition; searchPosition < this.tokens.length; ) {
            if (!WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) return searchPosition;
            searchPosition++;
          }
          return -1;
        }, Constructor = Parser, (protoProps = [ {
          key: "currToken",
          get: function() {
            return this.tokens[this.position];
          }
        }, {
          key: "nextToken",
          get: function() {
            return this.tokens[this.position + 1];
          }
        }, {
          key: "prevToken",
          get: function() {
            return this.tokens[this.position - 1];
          }
        } ]) && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), 
        Parser;
      }();
      exports.default = Parser, module.exports = exports.default;
    },
    78023: (module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      var obj, _parser = (obj = __webpack_require__(8754)) && obj.__esModule ? obj : {
        default: obj
      };
      var Processor = function() {
        function Processor(func, options) {
          this.func = func || function() {}, this.funcRes = null, this.options = options;
        }
        var _proto = Processor.prototype;
        return _proto._shouldUpdateSelector = function(rule, options) {
          return void 0 === options && (options = {}), !1 !== Object.assign({}, this.options, options).updateSelector && "string" != typeof rule;
        }, _proto._isLossy = function(options) {
          return void 0 === options && (options = {}), !1 === Object.assign({}, this.options, options).lossless;
        }, _proto._root = function(rule, options) {
          return void 0 === options && (options = {}), new _parser.default(rule, this._parseOptions(options)).root;
        }, _proto._parseOptions = function(options) {
          return {
            lossy: this._isLossy(options)
          };
        }, _proto._run = function(rule, options) {
          var _this = this;
          return void 0 === options && (options = {}), new Promise((function(resolve, reject) {
            try {
              var root = _this._root(rule, options);
              Promise.resolve(_this.func(root)).then((function(transform) {
                var string = void 0;
                return _this._shouldUpdateSelector(rule, options) && (string = root.toString(), 
                rule.selector = string), {
                  transform,
                  root,
                  string
                };
              })).then(resolve, reject);
            } catch (e) {
              return void reject(e);
            }
          }));
        }, _proto._runSync = function(rule, options) {
          void 0 === options && (options = {});
          var root = this._root(rule, options), transform = this.func(root);
          if (transform && "function" == typeof transform.then) throw new Error("Selector processor returned a promise to a synchronous call.");
          var string = void 0;
          return options.updateSelector && "string" != typeof rule && (string = root.toString(), 
          rule.selector = string), {
            transform,
            root,
            string
          };
        }, _proto.ast = function(rule, options) {
          return this._run(rule, options).then((function(result) {
            return result.root;
          }));
        }, _proto.astSync = function(rule, options) {
          return this._runSync(rule, options).root;
        }, _proto.transform = function(rule, options) {
          return this._run(rule, options).then((function(result) {
            return result.transform;
          }));
        }, _proto.transformSync = function(rule, options) {
          return this._runSync(rule, options).transform;
        }, _proto.process = function(rule, options) {
          return this._run(rule, options).then((function(result) {
            return result.string || result.root.toString();
          }));
        }, _proto.processSync = function(rule, options) {
          var result = this._runSync(rule, options);
          return result.string || result.root.toString();
        }, Processor;
      }();
      exports.default = Processor, module.exports = exports.default;
    },
    79467: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.unescapeValue = unescapeValue, exports.default = void 0;
      var _CSSESC_QUOTE_OPTIONS, _cssesc = _interopRequireDefault(__webpack_require__(26129)), _unesc = _interopRequireDefault(__webpack_require__(92501)), _namespace = _interopRequireDefault(__webpack_require__(62040)), _types = __webpack_require__(31640);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
          "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _setPrototypeOf(o, p) {
        return _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
          return o.__proto__ = p, o;
        }, _setPrototypeOf(o, p);
      }
      var deprecate = __webpack_require__(97439), WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/, warnOfDeprecatedValueAssignment = deprecate((function() {}), "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), warnOfDeprecatedQuotedAssignment = deprecate((function() {}), "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), warnOfDeprecatedConstructor = deprecate((function() {}), "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
      function unescapeValue(value) {
        var deprecatedUsage = !1, quoteMark = null, unescaped = value, m = unescaped.match(WRAPPED_IN_QUOTES);
        return m && (quoteMark = m[1], unescaped = m[2]), (unescaped = (0, _unesc.default)(unescaped)) !== value && (deprecatedUsage = !0), 
        {
          deprecatedUsage,
          unescaped,
          quoteMark
        };
      }
      var Attribute = function(_Namespace) {
        var subClass, superClass;
        function Attribute(opts) {
          var _this;
          return void 0 === opts && (opts = {}), _this = _Namespace.call(this, function(opts) {
            if (void 0 !== opts.quoteMark) return opts;
            if (void 0 === opts.value) return opts;
            warnOfDeprecatedConstructor();
            var _unescapeValue = unescapeValue(opts.value), quoteMark = _unescapeValue.quoteMark, unescaped = _unescapeValue.unescaped;
            return opts.raws || (opts.raws = {}), void 0 === opts.raws.value && (opts.raws.value = opts.value), 
            opts.value = unescaped, opts.quoteMark = quoteMark, opts;
          }(opts)) || this, _this.type = _types.ATTRIBUTE, _this.raws = _this.raws || {}, 
          Object.defineProperty(_this.raws, "unquoted", {
            get: deprecate((function() {
              return _this.value;
            }), "attr.raws.unquoted is deprecated. Call attr.value instead."),
            set: deprecate((function() {
              return _this.value;
            }), "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
          }), _this._constructed = !0, _this;
        }
        superClass = _Namespace, (subClass = Attribute).prototype = Object.create(superClass.prototype), 
        subClass.prototype.constructor = subClass, _setPrototypeOf(subClass, superClass);
        var Constructor, protoProps, staticProps, _proto = Attribute.prototype;
        return _proto.getQuotedValue = function(options) {
          void 0 === options && (options = {});
          var quoteMark = this._determineQuoteMark(options), cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
          return (0, _cssesc.default)(this._value, cssescopts);
        }, _proto._determineQuoteMark = function(options) {
          return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);
        }, _proto.setValue = function(value, options) {
          void 0 === options && (options = {}), this._value = value, this._quoteMark = this._determineQuoteMark(options), 
          this._syncRawValue();
        }, _proto.smartQuoteMark = function(options) {
          var v = this.value, numSingleQuotes = v.replace(/[^']/g, "").length, numDoubleQuotes = v.replace(/[^"]/g, "").length;
          if (numSingleQuotes + numDoubleQuotes === 0) {
            var escaped = (0, _cssesc.default)(v, {
              isIdentifier: !0
            });
            if (escaped === v) return Attribute.NO_QUOTE;
            var pref = this.preferredQuoteMark(options);
            if (pref === Attribute.NO_QUOTE) {
              var quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE, opts = CSSESC_QUOTE_OPTIONS[quote];
              if ((0, _cssesc.default)(v, opts).length < escaped.length) return quote;
            }
            return pref;
          }
          return numDoubleQuotes === numSingleQuotes ? this.preferredQuoteMark(options) : numDoubleQuotes < numSingleQuotes ? Attribute.DOUBLE_QUOTE : Attribute.SINGLE_QUOTE;
        }, _proto.preferredQuoteMark = function(options) {
          var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;
          return void 0 === quoteMark && (quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark), 
          void 0 === quoteMark && (quoteMark = Attribute.DOUBLE_QUOTE), quoteMark;
        }, _proto._syncRawValue = function() {
          var rawValue = (0, _cssesc.default)(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);
          rawValue === this._value ? this.raws && delete this.raws.value : this.raws.value = rawValue;
        }, _proto._handleEscapes = function(prop, value) {
          if (this._constructed) {
            var escaped = (0, _cssesc.default)(value, {
              isIdentifier: !0
            });
            escaped !== value ? this.raws[prop] = escaped : delete this.raws[prop];
          }
        }, _proto._spacesFor = function(name) {
          var spaces = this.spaces[name] || {}, rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
          return Object.assign({
            before: "",
            after: ""
          }, spaces, rawSpaces);
        }, _proto._stringFor = function(name, spaceName, concat) {
          void 0 === spaceName && (spaceName = name), void 0 === concat && (concat = defaultAttrConcat);
          var attrSpaces = this._spacesFor(spaceName);
          return concat(this.stringifyProperty(name), attrSpaces);
        }, _proto.offsetOf = function(name) {
          var count = 1, attributeSpaces = this._spacesFor("attribute");
          if (count += attributeSpaces.before.length, "namespace" === name || "ns" === name) return this.namespace ? count : -1;
          if ("attributeNS" === name) return count;
          if (count += this.namespaceString.length, this.namespace && (count += 1), "attribute" === name) return count;
          count += this.stringifyProperty("attribute").length, count += attributeSpaces.after.length;
          var operatorSpaces = this._spacesFor("operator");
          count += operatorSpaces.before.length;
          var operator = this.stringifyProperty("operator");
          if ("operator" === name) return operator ? count : -1;
          count += operator.length, count += operatorSpaces.after.length;
          var valueSpaces = this._spacesFor("value");
          count += valueSpaces.before.length;
          var value = this.stringifyProperty("value");
          return "value" === name ? value ? count : -1 : (count += value.length, count += valueSpaces.after.length, 
          count += this._spacesFor("insensitive").before.length, "insensitive" === name && this.insensitive ? count : -1);
        }, _proto.toString = function() {
          var _this2 = this, selector = [ this.rawSpaceBefore, "[" ];
          return selector.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || "" === this.value) && (selector.push(this._stringFor("operator")), 
          selector.push(this._stringFor("value")), selector.push(this._stringFor("insensitiveFlag", "insensitive", (function(attrValue, attrSpaces) {
            return !(attrValue.length > 0) || _this2.quoted || 0 !== attrSpaces.before.length || _this2.spaces.value && _this2.spaces.value.after || (attrSpaces.before = " "), 
            defaultAttrConcat(attrValue, attrSpaces);
          })))), selector.push("]"), selector.push(this.rawSpaceAfter), selector.join("");
        }, Constructor = Attribute, (protoProps = [ {
          key: "quoted",
          get: function() {
            var qm = this.quoteMark;
            return "'" === qm || '"' === qm;
          },
          set: function(value) {
            warnOfDeprecatedQuotedAssignment();
          }
        }, {
          key: "quoteMark",
          get: function() {
            return this._quoteMark;
          },
          set: function(quoteMark) {
            this._constructed ? this._quoteMark !== quoteMark && (this._quoteMark = quoteMark, 
            this._syncRawValue()) : this._quoteMark = quoteMark;
          }
        }, {
          key: "qualifiedAttribute",
          get: function() {
            return this.qualifiedName(this.raws.attribute || this.attribute);
          }
        }, {
          key: "insensitiveFlag",
          get: function() {
            return this.insensitive ? "i" : "";
          }
        }, {
          key: "value",
          get: function() {
            return this._value;
          },
          set: function(v) {
            if (this._constructed) {
              var _unescapeValue2 = unescapeValue(v), deprecatedUsage = _unescapeValue2.deprecatedUsage, unescaped = _unescapeValue2.unescaped, quoteMark = _unescapeValue2.quoteMark;
              if (deprecatedUsage && warnOfDeprecatedValueAssignment(), unescaped === this._value && quoteMark === this._quoteMark) return;
              this._value = unescaped, this._quoteMark = quoteMark, this._syncRawValue();
            } else this._value = v;
          }
        }, {
          key: "attribute",
          get: function() {
            return this._attribute;
          },
          set: function(name) {
            this._handleEscapes("attribute", name), this._attribute = name;
          }
        } ]) && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), 
        Attribute;
      }(_namespace.default);
      exports.default = Attribute, Attribute.NO_QUOTE = null, Attribute.SINGLE_QUOTE = "'", 
      Attribute.DOUBLE_QUOTE = '"';
      var CSSESC_QUOTE_OPTIONS = ((_CSSESC_QUOTE_OPTIONS = {
        "'": {
          quotes: "single",
          wrap: !0
        },
        '"': {
          quotes: "double",
          wrap: !0
        }
      }).null = {
        isIdentifier: !0
      }, _CSSESC_QUOTE_OPTIONS);
      function defaultAttrConcat(attrValue, attrSpaces) {
        return "" + attrSpaces.before + attrValue + attrSpaces.after;
      }
    },
    27585: (module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      var _cssesc = _interopRequireDefault(__webpack_require__(26129)), _util = __webpack_require__(58244), _node = _interopRequireDefault(__webpack_require__(23880)), _types = __webpack_require__(31640);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
          "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _setPrototypeOf(o, p) {
        return _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
          return o.__proto__ = p, o;
        }, _setPrototypeOf(o, p);
      }
      var ClassName = function(_Node) {
        var subClass, superClass, Constructor, protoProps, staticProps;
        function ClassName(opts) {
          var _this;
          return (_this = _Node.call(this, opts) || this).type = _types.CLASS, _this._constructed = !0, 
          _this;
        }
        return superClass = _Node, (subClass = ClassName).prototype = Object.create(superClass.prototype), 
        subClass.prototype.constructor = subClass, _setPrototypeOf(subClass, superClass), 
        ClassName.prototype.valueToString = function() {
          return "." + _Node.prototype.valueToString.call(this);
        }, Constructor = ClassName, (protoProps = [ {
          key: "value",
          get: function() {
            return this._value;
          },
          set: function(v) {
            if (this._constructed) {
              var escaped = (0, _cssesc.default)(v, {
                isIdentifier: !0
              });
              escaped !== v ? ((0, _util.ensureObject)(this, "raws"), this.raws.value = escaped) : this.raws && delete this.raws.value;
            }
            this._value = v;
          }
        } ]) && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), 
        ClassName;
      }(_node.default);
      exports.default = ClassName, module.exports = exports.default;
    },
    55107: (module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      var obj, _node = (obj = __webpack_require__(23880)) && obj.__esModule ? obj : {
        default: obj
      }, _types = __webpack_require__(31640);
      function _setPrototypeOf(o, p) {
        return _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
          return o.__proto__ = p, o;
        }, _setPrototypeOf(o, p);
      }
      var Combinator = function(_Node) {
        var subClass, superClass;
        function Combinator(opts) {
          var _this;
          return (_this = _Node.call(this, opts) || this).type = _types.COMBINATOR, _this;
        }
        return superClass = _Node, (subClass = Combinator).prototype = Object.create(superClass.prototype), 
        subClass.prototype.constructor = subClass, _setPrototypeOf(subClass, superClass), 
        Combinator;
      }(_node.default);
      exports.default = Combinator, module.exports = exports.default;
    },
    65683: (module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      var obj, _node = (obj = __webpack_require__(23880)) && obj.__esModule ? obj : {
        default: obj
      }, _types = __webpack_require__(31640);
      function _setPrototypeOf(o, p) {
        return _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
          return o.__proto__ = p, o;
        }, _setPrototypeOf(o, p);
      }
      var Comment = function(_Node) {
        var subClass, superClass;
        function Comment(opts) {
          var _this;
          return (_this = _Node.call(this, opts) || this).type = _types.COMMENT, _this;
        }
        return superClass = _Node, (subClass = Comment).prototype = Object.create(superClass.prototype), 
        subClass.prototype.constructor = subClass, _setPrototypeOf(subClass, superClass), 
        Comment;
      }(_node.default);
      exports.default = Comment, module.exports = exports.default;
    },
    19278: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.universal = exports.tag = exports.string = exports.selector = exports.root = exports.pseudo = exports.nesting = exports.id = exports.comment = exports.combinator = exports.className = exports.attribute = void 0;
      var _attribute = _interopRequireDefault(__webpack_require__(79467)), _className = _interopRequireDefault(__webpack_require__(27585)), _combinator = _interopRequireDefault(__webpack_require__(55107)), _comment = _interopRequireDefault(__webpack_require__(65683)), _id = _interopRequireDefault(__webpack_require__(94152)), _nesting = _interopRequireDefault(__webpack_require__(27353)), _pseudo = _interopRequireDefault(__webpack_require__(22951)), _root = _interopRequireDefault(__webpack_require__(32191)), _selector = _interopRequireDefault(__webpack_require__(42909)), _string = _interopRequireDefault(__webpack_require__(64614)), _tag = _interopRequireDefault(__webpack_require__(83297)), _universal = _interopRequireDefault(__webpack_require__(73825));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }
      exports.attribute = function(opts) {
        return new _attribute.default(opts);
      };
      exports.className = function(opts) {
        return new _className.default(opts);
      };
      exports.combinator = function(opts) {
        return new _combinator.default(opts);
      };
      exports.comment = function(opts) {
        return new _comment.default(opts);
      };
      exports.id = function(opts) {
        return new _id.default(opts);
      };
      exports.nesting = function(opts) {
        return new _nesting.default(opts);
      };
      exports.pseudo = function(opts) {
        return new _pseudo.default(opts);
      };
      exports.root = function(opts) {
        return new _root.default(opts);
      };
      exports.selector = function(opts) {
        return new _selector.default(opts);
      };
      exports.string = function(opts) {
        return new _string.default(opts);
      };
      exports.tag = function(opts) {
        return new _tag.default(opts);
      };
      exports.universal = function(opts) {
        return new _universal.default(opts);
      };
    },
    27183: (module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      var obj, _node = (obj = __webpack_require__(23880)) && obj.__esModule ? obj : {
        default: obj
      }, types = function(obj) {
        if (obj && obj.__esModule) return obj;
        if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
          default: obj
        };
        var cache = _getRequireWildcardCache();
        if (cache && cache.has(obj)) return cache.get(obj);
        var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
        newObj.default = obj, cache && cache.set(obj, newObj);
        return newObj;
      }(__webpack_require__(31640));
      function _getRequireWildcardCache() {
        if ("function" != typeof WeakMap) return null;
        var cache = new WeakMap;
        return _getRequireWildcardCache = function() {
          return cache;
        }, cache;
      }
      function _createForOfIteratorHelperLoose(o, allowArrayLike) {
        var it;
        if ("undefined" == typeof Symbol || null == o[Symbol.iterator]) {
          if (Array.isArray(o) || (it = function(o, minLen) {
            if (!o) return;
            if ("string" == typeof o) return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            "Object" === n && o.constructor && (n = o.constructor.name);
            if ("Map" === n || "Set" === n) return Array.from(o);
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
          }(o)) || allowArrayLike && o && "number" == typeof o.length) {
            it && (o = it);
            var i = 0;
            return function() {
              return i >= o.length ? {
                done: !0
              } : {
                done: !1,
                value: o[i++]
              };
            };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        return (it = o[Symbol.iterator]()).next.bind(it);
      }
      function _arrayLikeToArray(arr, len) {
        (null == len || len > arr.length) && (len = arr.length);
        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
        return arr2;
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
          "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _setPrototypeOf(o, p) {
        return _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
          return o.__proto__ = p, o;
        }, _setPrototypeOf(o, p);
      }
      var Container = function(_Node) {
        var subClass, superClass;
        function Container(opts) {
          var _this;
          return (_this = _Node.call(this, opts) || this).nodes || (_this.nodes = []), _this;
        }
        superClass = _Node, (subClass = Container).prototype = Object.create(superClass.prototype), 
        subClass.prototype.constructor = subClass, _setPrototypeOf(subClass, superClass);
        var Constructor, protoProps, staticProps, _proto = Container.prototype;
        return _proto.append = function(selector) {
          return selector.parent = this, this.nodes.push(selector), this;
        }, _proto.prepend = function(selector) {
          return selector.parent = this, this.nodes.unshift(selector), this;
        }, _proto.at = function(index) {
          return this.nodes[index];
        }, _proto.index = function(child) {
          return "number" == typeof child ? child : this.nodes.indexOf(child);
        }, _proto.removeChild = function(child) {
          var index;
          for (var id in child = this.index(child), this.at(child).parent = void 0, this.nodes.splice(child, 1), 
          this.indexes) (index = this.indexes[id]) >= child && (this.indexes[id] = index - 1);
          return this;
        }, _proto.removeAll = function() {
          for (var _step, _iterator = _createForOfIteratorHelperLoose(this.nodes); !(_step = _iterator()).done; ) {
            _step.value.parent = void 0;
          }
          return this.nodes = [], this;
        }, _proto.empty = function() {
          return this.removeAll();
        }, _proto.insertAfter = function(oldNode, newNode) {
          newNode.parent = this;
          var index, oldIndex = this.index(oldNode);
          for (var id in this.nodes.splice(oldIndex + 1, 0, newNode), newNode.parent = this, 
          this.indexes) oldIndex <= (index = this.indexes[id]) && (this.indexes[id] = index + 1);
          return this;
        }, _proto.insertBefore = function(oldNode, newNode) {
          newNode.parent = this;
          var index, oldIndex = this.index(oldNode);
          for (var id in this.nodes.splice(oldIndex, 0, newNode), newNode.parent = this, this.indexes) (index = this.indexes[id]) <= oldIndex && (this.indexes[id] = index + 1);
          return this;
        }, _proto._findChildAtPosition = function(line, col) {
          var found = void 0;
          return this.each((function(node) {
            if (node.atPosition) {
              var foundChild = node.atPosition(line, col);
              if (foundChild) return found = foundChild, !1;
            } else if (node.isAtPosition(line, col)) return found = node, !1;
          })), found;
        }, _proto.atPosition = function(line, col) {
          return this.isAtPosition(line, col) ? this._findChildAtPosition(line, col) || this : void 0;
        }, _proto._inferEndPosition = function() {
          this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, 
          this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
        }, _proto.each = function(callback) {
          this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
          var id = this.lastEach;
          if (this.indexes[id] = 0, this.length) {
            for (var index, result; this.indexes[id] < this.length && (index = this.indexes[id], 
            !1 !== (result = callback(this.at(index), index))); ) this.indexes[id] += 1;
            return delete this.indexes[id], !1 !== result && void 0;
          }
        }, _proto.walk = function(callback) {
          return this.each((function(node, i) {
            var result = callback(node, i);
            if (!1 !== result && node.length && (result = node.walk(callback)), !1 === result) return !1;
          }));
        }, _proto.walkAttributes = function(callback) {
          var _this2 = this;
          return this.walk((function(selector) {
            if (selector.type === types.ATTRIBUTE) return callback.call(_this2, selector);
          }));
        }, _proto.walkClasses = function(callback) {
          var _this3 = this;
          return this.walk((function(selector) {
            if (selector.type === types.CLASS) return callback.call(_this3, selector);
          }));
        }, _proto.walkCombinators = function(callback) {
          var _this4 = this;
          return this.walk((function(selector) {
            if (selector.type === types.COMBINATOR) return callback.call(_this4, selector);
          }));
        }, _proto.walkComments = function(callback) {
          var _this5 = this;
          return this.walk((function(selector) {
            if (selector.type === types.COMMENT) return callback.call(_this5, selector);
          }));
        }, _proto.walkIds = function(callback) {
          var _this6 = this;
          return this.walk((function(selector) {
            if (selector.type === types.ID) return callback.call(_this6, selector);
          }));
        }, _proto.walkNesting = function(callback) {
          var _this7 = this;
          return this.walk((function(selector) {
            if (selector.type === types.NESTING) return callback.call(_this7, selector);
          }));
        }, _proto.walkPseudos = function(callback) {
          var _this8 = this;
          return this.walk((function(selector) {
            if (selector.type === types.PSEUDO) return callback.call(_this8, selector);
          }));
        }, _proto.walkTags = function(callback) {
          var _this9 = this;
          return this.walk((function(selector) {
            if (selector.type === types.TAG) return callback.call(_this9, selector);
          }));
        }, _proto.walkUniversals = function(callback) {
          var _this10 = this;
          return this.walk((function(selector) {
            if (selector.type === types.UNIVERSAL) return callback.call(_this10, selector);
          }));
        }, _proto.split = function(callback) {
          var _this11 = this, current = [];
          return this.reduce((function(memo, node, index) {
            var split = callback.call(_this11, node);
            return current.push(node), split ? (memo.push(current), current = []) : index === _this11.length - 1 && memo.push(current), 
            memo;
          }), []);
        }, _proto.map = function(callback) {
          return this.nodes.map(callback);
        }, _proto.reduce = function(callback, memo) {
          return this.nodes.reduce(callback, memo);
        }, _proto.every = function(callback) {
          return this.nodes.every(callback);
        }, _proto.some = function(callback) {
          return this.nodes.some(callback);
        }, _proto.filter = function(callback) {
          return this.nodes.filter(callback);
        }, _proto.sort = function(callback) {
          return this.nodes.sort(callback);
        }, _proto.toString = function() {
          return this.map(String).join("");
        }, Constructor = Container, (protoProps = [ {
          key: "first",
          get: function() {
            return this.at(0);
          }
        }, {
          key: "last",
          get: function() {
            return this.at(this.length - 1);
          }
        }, {
          key: "length",
          get: function() {
            return this.nodes.length;
          }
        } ]) && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), 
        Container;
      }(_node.default);
      exports.default = Container, module.exports = exports.default;
    },
    96814: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.isNode = isNode, exports.isPseudoElement = isPseudoElement, 
      exports.isPseudoClass = function(node) {
        return isPseudo(node) && !isPseudoElement(node);
      }, exports.isContainer = function(node) {
        return !(!isNode(node) || !node.walk);
      }, exports.isNamespace = function(node) {
        return isAttribute(node) || isTag(node);
      }, exports.isUniversal = exports.isTag = exports.isString = exports.isSelector = exports.isRoot = exports.isPseudo = exports.isNesting = exports.isIdentifier = exports.isComment = exports.isCombinator = exports.isClassName = exports.isAttribute = void 0;
      var _IS_TYPE, _types = __webpack_require__(31640), IS_TYPE = ((_IS_TYPE = {})[_types.ATTRIBUTE] = !0, 
      _IS_TYPE[_types.CLASS] = !0, _IS_TYPE[_types.COMBINATOR] = !0, _IS_TYPE[_types.COMMENT] = !0, 
      _IS_TYPE[_types.ID] = !0, _IS_TYPE[_types.NESTING] = !0, _IS_TYPE[_types.PSEUDO] = !0, 
      _IS_TYPE[_types.ROOT] = !0, _IS_TYPE[_types.SELECTOR] = !0, _IS_TYPE[_types.STRING] = !0, 
      _IS_TYPE[_types.TAG] = !0, _IS_TYPE[_types.UNIVERSAL] = !0, _IS_TYPE);
      function isNode(node) {
        return "object" == typeof node && IS_TYPE[node.type];
      }
      function isNodeType(type, node) {
        return isNode(node) && node.type === type;
      }
      var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
      exports.isAttribute = isAttribute;
      var isClassName = isNodeType.bind(null, _types.CLASS);
      exports.isClassName = isClassName;
      var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
      exports.isCombinator = isCombinator;
      var isComment = isNodeType.bind(null, _types.COMMENT);
      exports.isComment = isComment;
      var isIdentifier = isNodeType.bind(null, _types.ID);
      exports.isIdentifier = isIdentifier;
      var isNesting = isNodeType.bind(null, _types.NESTING);
      exports.isNesting = isNesting;
      var isPseudo = isNodeType.bind(null, _types.PSEUDO);
      exports.isPseudo = isPseudo;
      var isRoot = isNodeType.bind(null, _types.ROOT);
      exports.isRoot = isRoot;
      var isSelector = isNodeType.bind(null, _types.SELECTOR);
      exports.isSelector = isSelector;
      var isString = isNodeType.bind(null, _types.STRING);
      exports.isString = isString;
      var isTag = isNodeType.bind(null, _types.TAG);
      exports.isTag = isTag;
      var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
      function isPseudoElement(node) {
        return isPseudo(node) && node.value && (node.value.startsWith("::") || ":before" === node.value.toLowerCase() || ":after" === node.value.toLowerCase() || ":first-letter" === node.value.toLowerCase() || ":first-line" === node.value.toLowerCase());
      }
      exports.isUniversal = isUniversal;
    },
    94152: (module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      var obj, _node = (obj = __webpack_require__(23880)) && obj.__esModule ? obj : {
        default: obj
      }, _types = __webpack_require__(31640);
      function _setPrototypeOf(o, p) {
        return _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
          return o.__proto__ = p, o;
        }, _setPrototypeOf(o, p);
      }
      var ID = function(_Node) {
        var subClass, superClass;
        function ID(opts) {
          var _this;
          return (_this = _Node.call(this, opts) || this).type = _types.ID, _this;
        }
        return superClass = _Node, (subClass = ID).prototype = Object.create(superClass.prototype), 
        subClass.prototype.constructor = subClass, _setPrototypeOf(subClass, superClass), 
        ID.prototype.valueToString = function() {
          return "#" + _Node.prototype.valueToString.call(this);
        }, ID;
      }(_node.default);
      exports.default = ID, module.exports = exports.default;
    },
    95980: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0;
      var _types = __webpack_require__(31640);
      Object.keys(_types).forEach((function(key) {
        "default" !== key && "__esModule" !== key && (key in exports && exports[key] === _types[key] || (exports[key] = _types[key]));
      }));
      var _constructors = __webpack_require__(19278);
      Object.keys(_constructors).forEach((function(key) {
        "default" !== key && "__esModule" !== key && (key in exports && exports[key] === _constructors[key] || (exports[key] = _constructors[key]));
      }));
      var _guards = __webpack_require__(96814);
      Object.keys(_guards).forEach((function(key) {
        "default" !== key && "__esModule" !== key && (key in exports && exports[key] === _guards[key] || (exports[key] = _guards[key]));
      }));
    },
    62040: (module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      var _cssesc = _interopRequireDefault(__webpack_require__(26129)), _util = __webpack_require__(58244);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
          "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _setPrototypeOf(o, p) {
        return _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
          return o.__proto__ = p, o;
        }, _setPrototypeOf(o, p);
      }
      var Namespace = function(_Node) {
        var subClass, superClass;
        function Namespace() {
          return _Node.apply(this, arguments) || this;
        }
        superClass = _Node, (subClass = Namespace).prototype = Object.create(superClass.prototype), 
        subClass.prototype.constructor = subClass, _setPrototypeOf(subClass, superClass);
        var Constructor, protoProps, staticProps, _proto = Namespace.prototype;
        return _proto.qualifiedName = function(value) {
          return this.namespace ? this.namespaceString + "|" + value : value;
        }, _proto.valueToString = function() {
          return this.qualifiedName(_Node.prototype.valueToString.call(this));
        }, Constructor = Namespace, (protoProps = [ {
          key: "namespace",
          get: function() {
            return this._namespace;
          },
          set: function(namespace) {
            if (!0 === namespace || "*" === namespace || "&" === namespace) return this._namespace = namespace, 
            void (this.raws && delete this.raws.namespace);
            var escaped = (0, _cssesc.default)(namespace, {
              isIdentifier: !0
            });
            this._namespace = namespace, escaped !== namespace ? ((0, _util.ensureObject)(this, "raws"), 
            this.raws.namespace = escaped) : this.raws && delete this.raws.namespace;
          }
        }, {
          key: "ns",
          get: function() {
            return this._namespace;
          },
          set: function(namespace) {
            this.namespace = namespace;
          }
        }, {
          key: "namespaceString",
          get: function() {
            if (this.namespace) {
              var ns = this.stringifyProperty("namespace");
              return !0 === ns ? "" : ns;
            }
            return "";
          }
        } ]) && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), 
        Namespace;
      }(_interopRequireDefault(__webpack_require__(23880)).default);
      exports.default = Namespace, module.exports = exports.default;
    },
    27353: (module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      var obj, _node = (obj = __webpack_require__(23880)) && obj.__esModule ? obj : {
        default: obj
      }, _types = __webpack_require__(31640);
      function _setPrototypeOf(o, p) {
        return _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
          return o.__proto__ = p, o;
        }, _setPrototypeOf(o, p);
      }
      var Nesting = function(_Node) {
        var subClass, superClass;
        function Nesting(opts) {
          var _this;
          return (_this = _Node.call(this, opts) || this).type = _types.NESTING, _this.value = "&", 
          _this;
        }
        return superClass = _Node, (subClass = Nesting).prototype = Object.create(superClass.prototype), 
        subClass.prototype.constructor = subClass, _setPrototypeOf(subClass, superClass), 
        Nesting;
      }(_node.default);
      exports.default = Nesting, module.exports = exports.default;
    },
    23880: (module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      var _util = __webpack_require__(58244);
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
          "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      var cloneNode = function cloneNode(obj, parent) {
        if ("object" != typeof obj || null === obj) return obj;
        var cloned = new obj.constructor;
        for (var i in obj) if (obj.hasOwnProperty(i)) {
          var value = obj[i];
          "parent" === i && "object" === typeof value ? parent && (cloned[i] = parent) : cloned[i] = value instanceof Array ? value.map((function(j) {
            return cloneNode(j, cloned);
          })) : cloneNode(value, cloned);
        }
        return cloned;
      }, Node = function() {
        function Node(opts) {
          void 0 === opts && (opts = {}), Object.assign(this, opts), this.spaces = this.spaces || {}, 
          this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
        }
        var Constructor, protoProps, staticProps, _proto = Node.prototype;
        return _proto.remove = function() {
          return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
        }, _proto.replaceWith = function() {
          if (this.parent) {
            for (var index in arguments) this.parent.insertBefore(this, arguments[index]);
            this.remove();
          }
          return this;
        }, _proto.next = function() {
          return this.parent.at(this.parent.index(this) + 1);
        }, _proto.prev = function() {
          return this.parent.at(this.parent.index(this) - 1);
        }, _proto.clone = function(overrides) {
          void 0 === overrides && (overrides = {});
          var cloned = cloneNode(this);
          for (var name in overrides) cloned[name] = overrides[name];
          return cloned;
        }, _proto.appendToPropertyAndEscape = function(name, value, valueEscaped) {
          this.raws || (this.raws = {});
          var originalValue = this[name], originalEscaped = this.raws[name];
          this[name] = originalValue + value, originalEscaped || valueEscaped !== value ? this.raws[name] = (originalEscaped || originalValue) + valueEscaped : delete this.raws[name];
        }, _proto.setPropertyAndEscape = function(name, value, valueEscaped) {
          this.raws || (this.raws = {}), this[name] = value, this.raws[name] = valueEscaped;
        }, _proto.setPropertyWithoutEscape = function(name, value) {
          this[name] = value, this.raws && delete this.raws[name];
        }, _proto.isAtPosition = function(line, column) {
          if (this.source && this.source.start && this.source.end) return !(this.source.start.line > line) && (!(this.source.end.line < line) && (!(this.source.start.line === line && this.source.start.column > column) && !(this.source.end.line === line && this.source.end.column < column)));
        }, _proto.stringifyProperty = function(name) {
          return this.raws && this.raws[name] || this[name];
        }, _proto.valueToString = function() {
          return String(this.stringifyProperty("value"));
        }, _proto.toString = function() {
          return [ this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter ].join("");
        }, Constructor = Node, (protoProps = [ {
          key: "rawSpaceBefore",
          get: function() {
            var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;
            return void 0 === rawSpace && (rawSpace = this.spaces && this.spaces.before), rawSpace || "";
          },
          set: function(raw) {
            (0, _util.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = raw;
          }
        }, {
          key: "rawSpaceAfter",
          get: function() {
            var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;
            return void 0 === rawSpace && (rawSpace = this.spaces.after), rawSpace || "";
          },
          set: function(raw) {
            (0, _util.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = raw;
          }
        } ]) && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), 
        Node;
      }();
      exports.default = Node, module.exports = exports.default;
    },
    22951: (module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      var obj, _container = (obj = __webpack_require__(27183)) && obj.__esModule ? obj : {
        default: obj
      }, _types = __webpack_require__(31640);
      function _setPrototypeOf(o, p) {
        return _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
          return o.__proto__ = p, o;
        }, _setPrototypeOf(o, p);
      }
      var Pseudo = function(_Container) {
        var subClass, superClass;
        function Pseudo(opts) {
          var _this;
          return (_this = _Container.call(this, opts) || this).type = _types.PSEUDO, _this;
        }
        return superClass = _Container, (subClass = Pseudo).prototype = Object.create(superClass.prototype), 
        subClass.prototype.constructor = subClass, _setPrototypeOf(subClass, superClass), 
        Pseudo.prototype.toString = function() {
          var params = this.length ? "(" + this.map(String).join(",") + ")" : "";
          return [ this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter ].join("");
        }, Pseudo;
      }(_container.default);
      exports.default = Pseudo, module.exports = exports.default;
    },
    32191: (module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      var obj, _container = (obj = __webpack_require__(27183)) && obj.__esModule ? obj : {
        default: obj
      }, _types = __webpack_require__(31640);
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
          "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _setPrototypeOf(o, p) {
        return _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
          return o.__proto__ = p, o;
        }, _setPrototypeOf(o, p);
      }
      var Root = function(_Container) {
        var subClass, superClass;
        function Root(opts) {
          var _this;
          return (_this = _Container.call(this, opts) || this).type = _types.ROOT, _this;
        }
        superClass = _Container, (subClass = Root).prototype = Object.create(superClass.prototype), 
        subClass.prototype.constructor = subClass, _setPrototypeOf(subClass, superClass);
        var Constructor, protoProps, staticProps, _proto = Root.prototype;
        return _proto.toString = function() {
          var str = this.reduce((function(memo, selector) {
            return memo.push(String(selector)), memo;
          }), []).join(",");
          return this.trailingComma ? str + "," : str;
        }, _proto.error = function(message, options) {
          return this._error ? this._error(message, options) : new Error(message);
        }, Constructor = Root, (protoProps = [ {
          key: "errorGenerator",
          set: function(handler) {
            this._error = handler;
          }
        } ]) && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), 
        Root;
      }(_container.default);
      exports.default = Root, module.exports = exports.default;
    },
    42909: (module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      var obj, _container = (obj = __webpack_require__(27183)) && obj.__esModule ? obj : {
        default: obj
      }, _types = __webpack_require__(31640);
      function _setPrototypeOf(o, p) {
        return _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
          return o.__proto__ = p, o;
        }, _setPrototypeOf(o, p);
      }
      var Selector = function(_Container) {
        var subClass, superClass;
        function Selector(opts) {
          var _this;
          return (_this = _Container.call(this, opts) || this).type = _types.SELECTOR, _this;
        }
        return superClass = _Container, (subClass = Selector).prototype = Object.create(superClass.prototype), 
        subClass.prototype.constructor = subClass, _setPrototypeOf(subClass, superClass), 
        Selector;
      }(_container.default);
      exports.default = Selector, module.exports = exports.default;
    },
    64614: (module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      var obj, _node = (obj = __webpack_require__(23880)) && obj.__esModule ? obj : {
        default: obj
      }, _types = __webpack_require__(31640);
      function _setPrototypeOf(o, p) {
        return _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
          return o.__proto__ = p, o;
        }, _setPrototypeOf(o, p);
      }
      var String = function(_Node) {
        var subClass, superClass;
        function String(opts) {
          var _this;
          return (_this = _Node.call(this, opts) || this).type = _types.STRING, _this;
        }
        return superClass = _Node, (subClass = String).prototype = Object.create(superClass.prototype), 
        subClass.prototype.constructor = subClass, _setPrototypeOf(subClass, superClass), 
        String;
      }(_node.default);
      exports.default = String, module.exports = exports.default;
    },
    83297: (module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      var obj, _namespace = (obj = __webpack_require__(62040)) && obj.__esModule ? obj : {
        default: obj
      }, _types = __webpack_require__(31640);
      function _setPrototypeOf(o, p) {
        return _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
          return o.__proto__ = p, o;
        }, _setPrototypeOf(o, p);
      }
      var Tag = function(_Namespace) {
        var subClass, superClass;
        function Tag(opts) {
          var _this;
          return (_this = _Namespace.call(this, opts) || this).type = _types.TAG, _this;
        }
        return superClass = _Namespace, (subClass = Tag).prototype = Object.create(superClass.prototype), 
        subClass.prototype.constructor = subClass, _setPrototypeOf(subClass, superClass), 
        Tag;
      }(_namespace.default);
      exports.default = Tag, module.exports = exports.default;
    },
    31640: (__unused_webpack_module, exports) => {
      "use strict";
      exports.__esModule = !0, exports.UNIVERSAL = exports.ATTRIBUTE = exports.CLASS = exports.COMBINATOR = exports.COMMENT = exports.ID = exports.NESTING = exports.PSEUDO = exports.ROOT = exports.SELECTOR = exports.STRING = exports.TAG = void 0;
      exports.TAG = "tag";
      exports.STRING = "string";
      exports.SELECTOR = "selector";
      exports.ROOT = "root";
      exports.PSEUDO = "pseudo";
      exports.NESTING = "nesting";
      exports.ID = "id";
      exports.COMMENT = "comment";
      exports.COMBINATOR = "combinator";
      exports.CLASS = "class";
      exports.ATTRIBUTE = "attribute";
      exports.UNIVERSAL = "universal";
    },
    73825: (module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      var obj, _namespace = (obj = __webpack_require__(62040)) && obj.__esModule ? obj : {
        default: obj
      }, _types = __webpack_require__(31640);
      function _setPrototypeOf(o, p) {
        return _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
          return o.__proto__ = p, o;
        }, _setPrototypeOf(o, p);
      }
      var Universal = function(_Namespace) {
        var subClass, superClass;
        function Universal(opts) {
          var _this;
          return (_this = _Namespace.call(this, opts) || this).type = _types.UNIVERSAL, _this.value = "*", 
          _this;
        }
        return superClass = _Namespace, (subClass = Universal).prototype = Object.create(superClass.prototype), 
        subClass.prototype.constructor = subClass, _setPrototypeOf(subClass, superClass), 
        Universal;
      }(_namespace.default);
      exports.default = Universal, module.exports = exports.default;
    },
    66219: (module, exports) => {
      "use strict";
      exports.__esModule = !0, exports.default = function(list) {
        return list.sort((function(a, b) {
          return a - b;
        }));
      }, module.exports = exports.default;
    },
    86712: (__unused_webpack_module, exports) => {
      "use strict";
      exports.__esModule = !0, exports.combinator = exports.word = exports.comment = exports.str = exports.tab = exports.newline = exports.feed = exports.cr = exports.backslash = exports.bang = exports.slash = exports.doubleQuote = exports.singleQuote = exports.space = exports.greaterThan = exports.pipe = exports.equals = exports.plus = exports.caret = exports.tilde = exports.dollar = exports.closeSquare = exports.openSquare = exports.closeParenthesis = exports.openParenthesis = exports.semicolon = exports.colon = exports.comma = exports.at = exports.asterisk = exports.ampersand = void 0;
      exports.ampersand = 38;
      exports.asterisk = 42;
      exports.at = 64;
      exports.comma = 44;
      exports.colon = 58;
      exports.semicolon = 59;
      exports.openParenthesis = 40;
      exports.closeParenthesis = 41;
      exports.openSquare = 91;
      exports.closeSquare = 93;
      exports.dollar = 36;
      exports.tilde = 126;
      exports.caret = 94;
      exports.plus = 43;
      exports.equals = 61;
      exports.pipe = 124;
      exports.greaterThan = 62;
      exports.space = 32;
      exports.singleQuote = 39;
      exports.doubleQuote = 34;
      exports.slash = 47;
      exports.bang = 33;
      exports.backslash = 92;
      exports.cr = 13;
      exports.feed = 12;
      exports.newline = 10;
      exports.tab = 9;
      exports.str = 39;
      exports.comment = -1;
      exports.word = -2;
      exports.combinator = -3;
    },
    11671: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = function(input) {
        var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType, tokens = [], css = input.css.valueOf(), length = css.length, offset = -1, line = 1, start = 0, end = 0;
        function unclosed(what, fix) {
          if (!input.safe) throw input.error("Unclosed " + what, line, start - offset, start);
          next = (css += fix).length - 1;
        }
        for (;start < length; ) {
          switch ((code = css.charCodeAt(start)) === t.newline && (offset = start, line += 1), 
          code) {
           case t.space:
           case t.tab:
           case t.newline:
           case t.cr:
           case t.feed:
            next = start;
            do {
              next += 1, (code = css.charCodeAt(next)) === t.newline && (offset = next, line += 1);
            } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);
            tokenType = t.space, endLine = line, endColumn = next - offset - 1, end = next;
            break;

           case t.plus:
           case t.greaterThan:
           case t.tilde:
           case t.pipe:
            next = start;
            do {
              next += 1, code = css.charCodeAt(next);
            } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);
            tokenType = t.combinator, endLine = line, endColumn = start - offset, end = next;
            break;

           case t.asterisk:
           case t.ampersand:
           case t.bang:
           case t.comma:
           case t.equals:
           case t.dollar:
           case t.caret:
           case t.openSquare:
           case t.closeSquare:
           case t.colon:
           case t.semicolon:
           case t.openParenthesis:
           case t.closeParenthesis:
            tokenType = code, endLine = line, endColumn = start - offset, end = (next = start) + 1;
            break;

           case t.singleQuote:
           case t.doubleQuote:
            quote = code === t.singleQuote ? "'" : '"', next = start;
            do {
              for (escaped = !1, -1 === (next = css.indexOf(quote, next + 1)) && unclosed("quote", quote), 
              escapePos = next; css.charCodeAt(escapePos - 1) === t.backslash; ) escapePos -= 1, 
              escaped = !escaped;
            } while (escaped);
            tokenType = t.str, endLine = line, endColumn = start - offset, end = next + 1;
            break;

           default:
            code === t.slash && css.charCodeAt(start + 1) === t.asterisk ? (0 === (next = css.indexOf("*/", start + 2) + 1) && unclosed("comment", "*/"), 
            content = css.slice(start, next + 1), lines = content.split("\n"), (last = lines.length - 1) > 0 ? (nextLine = line + last, 
            nextOffset = next - lines[last].length) : (nextLine = line, nextOffset = offset), 
            tokenType = t.comment, line = nextLine, endLine = nextLine, endColumn = next - nextOffset) : code === t.slash ? (tokenType = code, 
            endLine = line, endColumn = start - offset, end = (next = start) + 1) : (next = consumeWord(css, start), 
            tokenType = t.word, endLine = line, endColumn = next - offset), end = next + 1;
          }
          tokens.push([ tokenType, line, start - offset, endLine, endColumn, start, end ]), 
          nextOffset && (offset = nextOffset, nextOffset = null), start = end;
        }
        return tokens;
      }, exports.FIELDS = void 0;
      var _unescapable, _wordDelimiters, t = function(obj) {
        if (obj && obj.__esModule) return obj;
        if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
          default: obj
        };
        var cache = _getRequireWildcardCache();
        if (cache && cache.has(obj)) return cache.get(obj);
        var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
        newObj.default = obj, cache && cache.set(obj, newObj);
        return newObj;
      }(__webpack_require__(86712));
      function _getRequireWildcardCache() {
        if ("function" != typeof WeakMap) return null;
        var cache = new WeakMap;
        return _getRequireWildcardCache = function() {
          return cache;
        }, cache;
      }
      for (var unescapable = ((_unescapable = {})[t.tab] = !0, _unescapable[t.newline] = !0, 
      _unescapable[t.cr] = !0, _unescapable[t.feed] = !0, _unescapable), wordDelimiters = ((_wordDelimiters = {})[t.space] = !0, 
      _wordDelimiters[t.tab] = !0, _wordDelimiters[t.newline] = !0, _wordDelimiters[t.cr] = !0, 
      _wordDelimiters[t.feed] = !0, _wordDelimiters[t.ampersand] = !0, _wordDelimiters[t.asterisk] = !0, 
      _wordDelimiters[t.bang] = !0, _wordDelimiters[t.comma] = !0, _wordDelimiters[t.colon] = !0, 
      _wordDelimiters[t.semicolon] = !0, _wordDelimiters[t.openParenthesis] = !0, _wordDelimiters[t.closeParenthesis] = !0, 
      _wordDelimiters[t.openSquare] = !0, _wordDelimiters[t.closeSquare] = !0, _wordDelimiters[t.singleQuote] = !0, 
      _wordDelimiters[t.doubleQuote] = !0, _wordDelimiters[t.plus] = !0, _wordDelimiters[t.pipe] = !0, 
      _wordDelimiters[t.tilde] = !0, _wordDelimiters[t.greaterThan] = !0, _wordDelimiters[t.equals] = !0, 
      _wordDelimiters[t.dollar] = !0, _wordDelimiters[t.caret] = !0, _wordDelimiters[t.slash] = !0, 
      _wordDelimiters), hex = {}, i = 0; i < "0123456789abcdefABCDEF".length; i++) hex["0123456789abcdefABCDEF".charCodeAt(i)] = !0;
      function consumeWord(css, start) {
        var code, next = start;
        do {
          if (code = css.charCodeAt(next), wordDelimiters[code]) return next - 1;
          code === t.backslash ? next = consumeEscape(css, next) + 1 : next++;
        } while (next < css.length);
        return next - 1;
      }
      function consumeEscape(css, start) {
        var next = start, code = css.charCodeAt(next + 1);
        if (unescapable[code]) ; else if (hex[code]) {
          var hexDigits = 0;
          do {
            next++, hexDigits++, code = css.charCodeAt(next + 1);
          } while (hex[code] && hexDigits < 6);
          hexDigits < 6 && code === t.space && next++;
        } else next++;
        return next;
      }
      exports.FIELDS = {
        TYPE: 0,
        START_LINE: 1,
        START_COL: 2,
        END_LINE: 3,
        END_COL: 4,
        START_POS: 5,
        END_POS: 6
      };
    },
    41125: (module, exports) => {
      "use strict";
      exports.__esModule = !0, exports.default = function(obj) {
        for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) props[_key - 1] = arguments[_key];
        for (;props.length > 0; ) {
          var prop = props.shift();
          obj[prop] || (obj[prop] = {}), obj = obj[prop];
        }
      }, module.exports = exports.default;
    },
    4339: (module, exports) => {
      "use strict";
      exports.__esModule = !0, exports.default = function(obj) {
        for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) props[_key - 1] = arguments[_key];
        for (;props.length > 0; ) {
          var prop = props.shift();
          if (!obj[prop]) return;
          obj = obj[prop];
        }
        return obj;
      }, module.exports = exports.default;
    },
    58244: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.stripComments = exports.ensureObject = exports.getProp = exports.unesc = void 0;
      var _unesc = _interopRequireDefault(__webpack_require__(92501));
      exports.unesc = _unesc.default;
      var _getProp = _interopRequireDefault(__webpack_require__(4339));
      exports.getProp = _getProp.default;
      var _ensureObject = _interopRequireDefault(__webpack_require__(41125));
      exports.ensureObject = _ensureObject.default;
      var _stripComments = _interopRequireDefault(__webpack_require__(72532));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }
      exports.stripComments = _stripComments.default;
    },
    72532: (module, exports) => {
      "use strict";
      exports.__esModule = !0, exports.default = function(str) {
        var s = "", commentStart = str.indexOf("/*"), lastEnd = 0;
        for (;commentStart >= 0; ) {
          s += str.slice(lastEnd, commentStart);
          var commentEnd = str.indexOf("*/", commentStart + 2);
          if (commentEnd < 0) return s;
          lastEnd = commentEnd + 2, commentStart = str.indexOf("/*", lastEnd);
        }
        return s += str.slice(lastEnd);
      }, module.exports = exports.default;
    },
    92501: (module, exports) => {
      "use strict";
      function gobbleHex(str) {
        for (var lower = str.toLowerCase(), hex = "", spaceTerminated = !1, i = 0; i < 6 && void 0 !== lower[i]; i++) {
          var code = lower.charCodeAt(i);
          if (spaceTerminated = 32 === code, !(code >= 97 && code <= 102 || code >= 48 && code <= 57)) break;
          hex += lower[i];
        }
        if (0 !== hex.length) {
          var codePoint = parseInt(hex, 16);
          return codePoint >= 55296 && codePoint <= 57343 || 0 === codePoint || codePoint > 1114111 ? [ "", hex.length + (spaceTerminated ? 1 : 0) ] : [ String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0) ];
        }
      }
      exports.__esModule = !0, exports.default = function(str) {
        if (!CONTAINS_ESCAPE.test(str)) return str;
        for (var ret = "", i = 0; i < str.length; i++) if ("\\" !== str[i]) ret += str[i]; else {
          var gobbled = gobbleHex(str.slice(i + 1, i + 7));
          if (void 0 !== gobbled) {
            ret += gobbled[0], i += gobbled[1];
            continue;
          }
          if ("\\" === str[i + 1]) {
            ret += "\\", i++;
            continue;
          }
          str.length === i + 1 && (ret += str[i]);
        }
        return ret;
      };
      var CONTAINS_ESCAPE = /\\/;
      module.exports = exports.default;
    },
    46521: module => {
      const LEVELS = [ "notice", "error", "warn", "info", "verbose", "http", "silly", "pause", "resume" ], log = level => (...args) => process.emit("log", level, ...args), logger = {};
      for (const level of LEVELS) logger[level] = log(level);
      logger.LEVELS = LEVELS, module.exports = logger;
    },
    40639: module => {
      const allSettled = Promise.allSettled ? promises => Promise.allSettled(promises) : promises => {
        const reflections = [];
        for (let i = 0; i < promises.length; i++) reflections[i] = Promise.resolve(promises[i]).then((value => ({
          status: "fulfilled",
          value
        })), (reason => ({
          status: "rejected",
          reason
        })));
        return Promise.all(reflections);
      };
      module.exports = promises => allSettled(promises).then((results => {
        const ret = new Array(results.length);
        return results.forEach(((result, i) => {
          if ("rejected" === result.status) throw result.reason;
          ret[i] = result.value;
        })), ret;
      }));
    },
    37180: (module, __unused_webpack_exports, __webpack_require__) => {
      const defLimit = __webpack_require__(22037).cpus().length;
      module.exports = (queue, limit = defLimit) => new Promise(((res, rej) => {
        let active = 0, current = 0;
        const results = [];
        let rejected = !1;
        const reject = er => {
          rejected || (rejected = !0, rej(er));
        };
        let resolved = !1;
        const run = () => {
          const c = current++;
          c >= queue.length ? resolved || active > 0 || (resolved = !0, res(results)) : (active++, 
          results[c] = queue[c]().then((result => (active--, results[c] = result, run(), result)), reject));
        };
        for (let i = 0; i < limit; i++) run();
      }));
    },
    10978: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      let Bluebird;
      module.exports = inflight;
      try {
        Bluebird = __webpack_require__(29270);
      } catch (_) {
        Bluebird = Promise;
      }
      const active = {};
      function inflight(unique, doFly) {
        return Bluebird.all([ unique, doFly ]).then((function(args) {
          const unique = args[0], doFly = args[1];
          return Array.isArray(unique) ? Bluebird.all(unique).then((function(uniqueArr) {
            return _inflight(uniqueArr.join(""), doFly);
          })) : _inflight(unique, doFly);
        }));
        function _inflight(unique, doFly) {
          if (!active[unique]) {
            function cleanup() {
              delete active[unique];
            }
            active[unique] = new Bluebird((function(resolve) {
              return resolve(doFly());
            })), active[unique].then(cleanup, cleanup);
          }
          return active[unique];
        }
      }
      inflight.active = active;
    },
    49776: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var errcode = __webpack_require__(50141), retry = __webpack_require__(64876), hasOwn = Object.prototype.hasOwnProperty;
      function isRetryError(err) {
        return err && "EPROMISERETRY" === err.code && hasOwn.call(err, "retried");
      }
      module.exports = function(fn, options) {
        var temp, operation;
        return "object" == typeof fn && "function" == typeof options && (temp = options, 
        options = fn, fn = temp), operation = retry.operation(options), new Promise((function(resolve, reject) {
          operation.attempt((function(number) {
            Promise.resolve().then((function() {
              return fn((function(err) {
                throw isRetryError(err) && (err = err.retried), errcode(new Error("Retrying"), "EPROMISERETRY", {
                  retried: err
                });
              }), number);
            })).then(resolve, (function(err) {
              isRetryError(err) && (err = err.retried, operation.retry(err || new Error)) || reject(err);
            }));
          }));
        }));
      };
    },
    854: (module, exports, __webpack_require__) => {
      (module = __webpack_require__.nmd(module)).exports = promzard, promzard.PromZard = PromZard;
      var fs = __webpack_require__(57147), vm = __webpack_require__(26144), util = __webpack_require__(73837), files = {}, crypto = __webpack_require__(6113), EventEmitter = __webpack_require__(82361).EventEmitter, read = __webpack_require__(9547), Module = __webpack_require__(98188).Module, path = __webpack_require__(71017);
      function promzard(file, ctx, cb) {
        "function" == typeof ctx && (cb = ctx, ctx = null), ctx || (ctx = {});
        var pz = new PromZard(file, ctx);
        pz.on("error", cb), pz.on("data", (function(data) {
          cb(null, data);
        }));
      }
      function PromZard(file, ctx) {
        if (!(this instanceof PromZard)) return new PromZard(file, ctx);
        EventEmitter.call(this), this.file = file, this.ctx = ctx, this.unique = crypto.randomBytes(8).toString("hex"), 
        this.load();
      }
      promzard.fromBuffer = function(buf, ctx, cb) {
        var filename = 0;
        do {
          filename = "\0" + Math.random();
        } while (files[filename]);
        files[filename] = buf;
        var ret = promzard(filename, ctx, cb);
        return delete files[filename], ret;
      }, PromZard.prototype = Object.create(EventEmitter.prototype, {
        constructor: {
          value: PromZard,
          readable: !0,
          configurable: !0,
          writable: !0,
          enumerable: !1
        }
      }), PromZard.prototype.load = function() {
        if (files[this.file]) return this.loaded();
        fs.readFile(this.file, "utf8", function(er, d) {
          return er && this.backupFile ? (this.file = this.backupFile, delete this.backupFile, 
          this.load()) : er ? this.emit("error", this.error = er) : (files[this.file] = d, 
          void this.loaded());
        }.bind(this));
      }, PromZard.prototype.loaded = function() {
        this.ctx.prompt = this.makePrompt(), this.ctx.__filename = this.file, this.ctx.__dirname = path.dirname(this.file), 
        this.ctx.__basename = path.basename(this.file);
        var mod = this.ctx.module = this.makeModule();
        this.ctx.require = function(path) {
          return mod.require(path);
        }, this.ctx.require.resolve = function(path) {
          return Module._resolveFilename(path, mod);
        }, this.ctx.exports = mod.exports, this.script = this.wrap(files[this.file]);
        var fn = vm.runInThisContext(this.script, this.file), args = Object.keys(this.ctx).map(function(k) {
          return this.ctx[k];
        }.bind(this));
        try {
          var res = fn.apply(this.ctx, args);
        } catch (er) {
          this.emit("error", er);
        }
        res && "object" == typeof res && exports === mod.exports && 1 === Object.keys(exports).length ? this.result = res : this.result = mod.exports, 
        this.walk();
      }, PromZard.prototype.makeModule = function() {
        var mod = new Module(this.file, module);
        return mod.loaded = !0, mod.filename = this.file, mod.id = this.file, mod.paths = Module._nodeModulePaths(path.dirname(this.file)), 
        mod;
      }, PromZard.prototype.wrap = function(body) {
        var args = Object.keys(this.ctx).join(", ");
        return util.format("(function( %s ) { %s\n })", args, body);
      }, PromZard.prototype.makePrompt = function() {
        return this.prompts = [], function() {
          for (var p, d, t, i = 0; i < arguments.length; i++) {
            var a = arguments[i];
            "string" == typeof a && p ? d = a : "string" == typeof a ? p = a : "function" == typeof a ? t = a : a && "object" == typeof a && (p = a.prompt || p, 
            d = a.default || d, t = a.transform || t);
          }
          try {
            return this.unique + "-" + this.prompts.length;
          } finally {
            this.prompts.push([ p, d, t ]);
          }
        }.bind(this);
      }, PromZard.prototype.walk = function(o, cb) {
        o = o || this.result, cb = (cb = cb || function(er, res) {
          return er ? this.emit("error", this.error = er) : (this.result = res, this.emit("data", res));
        }).bind(this);
        var keys = Object.keys(o), i = 0, len = keys.length;
        (function L() {
          if (this.error) return;
          for (;i < len; ) {
            var k = keys[i], v = o[k];
            if (i++, v && "object" == typeof v) return this.walk(v, function(er, res) {
              if (er) return cb(er);
              o[k] = res, L.call(this);
            }.bind(this));
            if (v && "string" == typeof v && 0 === v.indexOf(this.unique)) {
              var n = +v.substr(this.unique.length + 1), prompt = this.prompts[n];
              if (isNaN(n) || !prompt) continue;
              return void 0 === prompt[0] && (prompt[0] = k), void 0 === prompt[1] && (prompt[1] = this.ctx[k]), 
              this.prompt(prompt, function(er, res) {
                if (er) return er.notValid ? (console.log(er.message), i--, L.call(this)) : this.emit("error", this.error = er);
                o[k] = res, L.call(this);
              }.bind(this));
            }
            if ("function" == typeof v) try {
              return v.call(this.ctx, function(er, res) {
                if (er) return this.emit("error", this.error = er);
                o[k] = res, i--, L.call(this);
              }.bind(this));
            } catch (er) {
              this.emit("error", er);
            }
          }
          if (i >= len) return cb(null, o);
        }).call(this);
      }, PromZard.prototype.prompt = function(pdt, cb) {
        var prompt = pdt[0], def = pdt[1], tx = pdt[2];
        tx && (cb = function(cb) {
          return function(er, data) {
            try {
              var res = tx(data);
              return !er && res instanceof Error && res.notValid ? cb(res, null) : cb(er, res);
            } catch (er) {
              this.emit("error", er);
            }
          };
        }(cb).bind(this)), read({
          prompt: prompt + ":",
          default: def
        }, cb);
      };
    },
    50860: (module, __unused_webpack_exports, __webpack_require__) => {
      var QRCode = __webpack_require__(93245), QRErrorCorrectLevel = __webpack_require__(51434), white = "[47m  [0m", toCell = function(isBlack) {
        return isBlack ? "[40m  [0m" : white;
      }, repeat = function(color) {
        return {
          times: function(count) {
            return new Array(count).join(color);
          }
        };
      };
      module.exports = {
        error: QRErrorCorrectLevel.L,
        generate: function(input, opts, cb) {
          "function" == typeof opts && (cb = opts, opts = {});
          var qrcode = new QRCode(-1, this.error);
          qrcode.addData(input), qrcode.make();
          var output = "";
          if (opts && opts.small) {
            var moduleCount = qrcode.getModuleCount(), moduleData = qrcode.modules.slice(), oddRow = moduleCount % 2 == 1;
            oddRow && moduleData.push(function(length, value) {
              for (var arr = new Array(length), i = 0; i < length; i++) arr[i] = value;
              return arr;
            }(moduleCount, false));
            var platte = {
              WHITE_ALL: "",
              WHITE_BLACK: "",
              BLACK_WHITE: "",
              BLACK_ALL: " "
            }, borderTop = repeat(platte.BLACK_WHITE).times(moduleCount + 3), borderBottom = repeat(platte.WHITE_BLACK).times(moduleCount + 3);
            output += borderTop + "\n";
            for (var row = 0; row < moduleCount; row += 2) {
              output += platte.WHITE_ALL;
              for (var col = 0; col < moduleCount; col++) false === moduleData[row][col] && false === moduleData[row + 1][col] ? output += platte.WHITE_ALL : false === moduleData[row][col] && true === moduleData[row + 1][col] ? output += platte.WHITE_BLACK : true === moduleData[row][col] && false === moduleData[row + 1][col] ? output += platte.BLACK_WHITE : output += platte.BLACK_ALL;
              output += platte.WHITE_ALL + "\n";
            }
            oddRow || (output += borderBottom);
          } else {
            var border = repeat(white).times(qrcode.getModuleCount() + 3);
            output += border + "\n", qrcode.modules.forEach((function(row) {
              output += white, output += row.map(toCell).join(""), output += white + "\n";
            })), output += border;
          }
          cb ? cb(output) : console.log(output);
        },
        setErrorLevel: function(error) {
          this.error = QRErrorCorrectLevel[error] || this.error;
        }
      };
    },
    31861: (module, __unused_webpack_exports, __webpack_require__) => {
      var QRMode = __webpack_require__(82463);
      function QR8bitByte(data) {
        this.mode = QRMode.MODE_8BIT_BYTE, this.data = data;
      }
      QR8bitByte.prototype = {
        getLength: function() {
          return this.data.length;
        },
        write: function(buffer) {
          for (var i = 0; i < this.data.length; i++) buffer.put(this.data.charCodeAt(i), 8);
        }
      }, module.exports = QR8bitByte;
    },
    99727: module => {
      function QRBitBuffer() {
        this.buffer = [], this.length = 0;
      }
      QRBitBuffer.prototype = {
        get: function(index) {
          var bufIndex = Math.floor(index / 8);
          return 1 == (this.buffer[bufIndex] >>> 7 - index % 8 & 1);
        },
        put: function(num, length) {
          for (var i = 0; i < length; i++) this.putBit(1 == (num >>> length - i - 1 & 1));
        },
        getLengthInBits: function() {
          return this.length;
        },
        putBit: function(bit) {
          var bufIndex = Math.floor(this.length / 8);
          this.buffer.length <= bufIndex && this.buffer.push(0), bit && (this.buffer[bufIndex] |= 128 >>> this.length % 8), 
          this.length++;
        }
      }, module.exports = QRBitBuffer;
    },
    51434: module => {
      module.exports = {
        L: 1,
        M: 0,
        Q: 3,
        H: 2
      };
    },
    54556: module => {
      module.exports = {
        PATTERN000: 0,
        PATTERN001: 1,
        PATTERN010: 2,
        PATTERN011: 3,
        PATTERN100: 4,
        PATTERN101: 5,
        PATTERN110: 6,
        PATTERN111: 7
      };
    },
    57889: module => {
      for (var QRMath = {
        glog: function(n) {
          if (n < 1) throw new Error("glog(" + n + ")");
          return QRMath.LOG_TABLE[n];
        },
        gexp: function(n) {
          for (;n < 0; ) n += 255;
          for (;n >= 256; ) n -= 255;
          return QRMath.EXP_TABLE[n];
        },
        EXP_TABLE: new Array(256),
        LOG_TABLE: new Array(256)
      }, i = 0; i < 8; i++) QRMath.EXP_TABLE[i] = 1 << i;
      for (i = 8; i < 256; i++) QRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4] ^ QRMath.EXP_TABLE[i - 5] ^ QRMath.EXP_TABLE[i - 6] ^ QRMath.EXP_TABLE[i - 8];
      for (i = 0; i < 255; i++) QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;
      module.exports = QRMath;
    },
    82463: module => {
      module.exports = {
        MODE_NUMBER: 1,
        MODE_ALPHA_NUM: 2,
        MODE_8BIT_BYTE: 4,
        MODE_KANJI: 8
      };
    },
    98977: (module, __unused_webpack_exports, __webpack_require__) => {
      var QRMath = __webpack_require__(57889);
      function QRPolynomial(num, shift) {
        if (void 0 === num.length) throw new Error(num.length + "/" + shift);
        for (var offset = 0; offset < num.length && 0 === num[offset]; ) offset++;
        this.num = new Array(num.length - offset + shift);
        for (var i = 0; i < num.length - offset; i++) this.num[i] = num[i + offset];
      }
      QRPolynomial.prototype = {
        get: function(index) {
          return this.num[index];
        },
        getLength: function() {
          return this.num.length;
        },
        multiply: function(e) {
          for (var num = new Array(this.getLength() + e.getLength() - 1), i = 0; i < this.getLength(); i++) for (var j = 0; j < e.getLength(); j++) num[i + j] ^= QRMath.gexp(QRMath.glog(this.get(i)) + QRMath.glog(e.get(j)));
          return new QRPolynomial(num, 0);
        },
        mod: function(e) {
          if (this.getLength() - e.getLength() < 0) return this;
          for (var ratio = QRMath.glog(this.get(0)) - QRMath.glog(e.get(0)), num = new Array(this.getLength()), i = 0; i < this.getLength(); i++) num[i] = this.get(i);
          for (var x = 0; x < e.getLength(); x++) num[x] ^= QRMath.gexp(QRMath.glog(e.get(x)) + ratio);
          return new QRPolynomial(num, 0).mod(e);
        }
      }, module.exports = QRPolynomial;
    },
    6685: (module, __unused_webpack_exports, __webpack_require__) => {
      var QRErrorCorrectLevel = __webpack_require__(51434);
      function QRRSBlock(totalCount, dataCount) {
        this.totalCount = totalCount, this.dataCount = dataCount;
      }
      QRRSBlock.RS_BLOCK_TABLE = [ [ 1, 26, 19 ], [ 1, 26, 16 ], [ 1, 26, 13 ], [ 1, 26, 9 ], [ 1, 44, 34 ], [ 1, 44, 28 ], [ 1, 44, 22 ], [ 1, 44, 16 ], [ 1, 70, 55 ], [ 1, 70, 44 ], [ 2, 35, 17 ], [ 2, 35, 13 ], [ 1, 100, 80 ], [ 2, 50, 32 ], [ 2, 50, 24 ], [ 4, 25, 9 ], [ 1, 134, 108 ], [ 2, 67, 43 ], [ 2, 33, 15, 2, 34, 16 ], [ 2, 33, 11, 2, 34, 12 ], [ 2, 86, 68 ], [ 4, 43, 27 ], [ 4, 43, 19 ], [ 4, 43, 15 ], [ 2, 98, 78 ], [ 4, 49, 31 ], [ 2, 32, 14, 4, 33, 15 ], [ 4, 39, 13, 1, 40, 14 ], [ 2, 121, 97 ], [ 2, 60, 38, 2, 61, 39 ], [ 4, 40, 18, 2, 41, 19 ], [ 4, 40, 14, 2, 41, 15 ], [ 2, 146, 116 ], [ 3, 58, 36, 2, 59, 37 ], [ 4, 36, 16, 4, 37, 17 ], [ 4, 36, 12, 4, 37, 13 ], [ 2, 86, 68, 2, 87, 69 ], [ 4, 69, 43, 1, 70, 44 ], [ 6, 43, 19, 2, 44, 20 ], [ 6, 43, 15, 2, 44, 16 ], [ 4, 101, 81 ], [ 1, 80, 50, 4, 81, 51 ], [ 4, 50, 22, 4, 51, 23 ], [ 3, 36, 12, 8, 37, 13 ], [ 2, 116, 92, 2, 117, 93 ], [ 6, 58, 36, 2, 59, 37 ], [ 4, 46, 20, 6, 47, 21 ], [ 7, 42, 14, 4, 43, 15 ], [ 4, 133, 107 ], [ 8, 59, 37, 1, 60, 38 ], [ 8, 44, 20, 4, 45, 21 ], [ 12, 33, 11, 4, 34, 12 ], [ 3, 145, 115, 1, 146, 116 ], [ 4, 64, 40, 5, 65, 41 ], [ 11, 36, 16, 5, 37, 17 ], [ 11, 36, 12, 5, 37, 13 ], [ 5, 109, 87, 1, 110, 88 ], [ 5, 65, 41, 5, 66, 42 ], [ 5, 54, 24, 7, 55, 25 ], [ 11, 36, 12 ], [ 5, 122, 98, 1, 123, 99 ], [ 7, 73, 45, 3, 74, 46 ], [ 15, 43, 19, 2, 44, 20 ], [ 3, 45, 15, 13, 46, 16 ], [ 1, 135, 107, 5, 136, 108 ], [ 10, 74, 46, 1, 75, 47 ], [ 1, 50, 22, 15, 51, 23 ], [ 2, 42, 14, 17, 43, 15 ], [ 5, 150, 120, 1, 151, 121 ], [ 9, 69, 43, 4, 70, 44 ], [ 17, 50, 22, 1, 51, 23 ], [ 2, 42, 14, 19, 43, 15 ], [ 3, 141, 113, 4, 142, 114 ], [ 3, 70, 44, 11, 71, 45 ], [ 17, 47, 21, 4, 48, 22 ], [ 9, 39, 13, 16, 40, 14 ], [ 3, 135, 107, 5, 136, 108 ], [ 3, 67, 41, 13, 68, 42 ], [ 15, 54, 24, 5, 55, 25 ], [ 15, 43, 15, 10, 44, 16 ], [ 4, 144, 116, 4, 145, 117 ], [ 17, 68, 42 ], [ 17, 50, 22, 6, 51, 23 ], [ 19, 46, 16, 6, 47, 17 ], [ 2, 139, 111, 7, 140, 112 ], [ 17, 74, 46 ], [ 7, 54, 24, 16, 55, 25 ], [ 34, 37, 13 ], [ 4, 151, 121, 5, 152, 122 ], [ 4, 75, 47, 14, 76, 48 ], [ 11, 54, 24, 14, 55, 25 ], [ 16, 45, 15, 14, 46, 16 ], [ 6, 147, 117, 4, 148, 118 ], [ 6, 73, 45, 14, 74, 46 ], [ 11, 54, 24, 16, 55, 25 ], [ 30, 46, 16, 2, 47, 17 ], [ 8, 132, 106, 4, 133, 107 ], [ 8, 75, 47, 13, 76, 48 ], [ 7, 54, 24, 22, 55, 25 ], [ 22, 45, 15, 13, 46, 16 ], [ 10, 142, 114, 2, 143, 115 ], [ 19, 74, 46, 4, 75, 47 ], [ 28, 50, 22, 6, 51, 23 ], [ 33, 46, 16, 4, 47, 17 ], [ 8, 152, 122, 4, 153, 123 ], [ 22, 73, 45, 3, 74, 46 ], [ 8, 53, 23, 26, 54, 24 ], [ 12, 45, 15, 28, 46, 16 ], [ 3, 147, 117, 10, 148, 118 ], [ 3, 73, 45, 23, 74, 46 ], [ 4, 54, 24, 31, 55, 25 ], [ 11, 45, 15, 31, 46, 16 ], [ 7, 146, 116, 7, 147, 117 ], [ 21, 73, 45, 7, 74, 46 ], [ 1, 53, 23, 37, 54, 24 ], [ 19, 45, 15, 26, 46, 16 ], [ 5, 145, 115, 10, 146, 116 ], [ 19, 75, 47, 10, 76, 48 ], [ 15, 54, 24, 25, 55, 25 ], [ 23, 45, 15, 25, 46, 16 ], [ 13, 145, 115, 3, 146, 116 ], [ 2, 74, 46, 29, 75, 47 ], [ 42, 54, 24, 1, 55, 25 ], [ 23, 45, 15, 28, 46, 16 ], [ 17, 145, 115 ], [ 10, 74, 46, 23, 75, 47 ], [ 10, 54, 24, 35, 55, 25 ], [ 19, 45, 15, 35, 46, 16 ], [ 17, 145, 115, 1, 146, 116 ], [ 14, 74, 46, 21, 75, 47 ], [ 29, 54, 24, 19, 55, 25 ], [ 11, 45, 15, 46, 46, 16 ], [ 13, 145, 115, 6, 146, 116 ], [ 14, 74, 46, 23, 75, 47 ], [ 44, 54, 24, 7, 55, 25 ], [ 59, 46, 16, 1, 47, 17 ], [ 12, 151, 121, 7, 152, 122 ], [ 12, 75, 47, 26, 76, 48 ], [ 39, 54, 24, 14, 55, 25 ], [ 22, 45, 15, 41, 46, 16 ], [ 6, 151, 121, 14, 152, 122 ], [ 6, 75, 47, 34, 76, 48 ], [ 46, 54, 24, 10, 55, 25 ], [ 2, 45, 15, 64, 46, 16 ], [ 17, 152, 122, 4, 153, 123 ], [ 29, 74, 46, 14, 75, 47 ], [ 49, 54, 24, 10, 55, 25 ], [ 24, 45, 15, 46, 46, 16 ], [ 4, 152, 122, 18, 153, 123 ], [ 13, 74, 46, 32, 75, 47 ], [ 48, 54, 24, 14, 55, 25 ], [ 42, 45, 15, 32, 46, 16 ], [ 20, 147, 117, 4, 148, 118 ], [ 40, 75, 47, 7, 76, 48 ], [ 43, 54, 24, 22, 55, 25 ], [ 10, 45, 15, 67, 46, 16 ], [ 19, 148, 118, 6, 149, 119 ], [ 18, 75, 47, 31, 76, 48 ], [ 34, 54, 24, 34, 55, 25 ], [ 20, 45, 15, 61, 46, 16 ] ], 
      QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
        var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
        if (void 0 === rsBlock) throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
        for (var length = rsBlock.length / 3, list = [], i = 0; i < length; i++) for (var count = rsBlock[3 * i + 0], totalCount = rsBlock[3 * i + 1], dataCount = rsBlock[3 * i + 2], j = 0; j < count; j++) list.push(new QRRSBlock(totalCount, dataCount));
        return list;
      }, QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {
        switch (errorCorrectLevel) {
         case QRErrorCorrectLevel.L:
          return QRRSBlock.RS_BLOCK_TABLE[4 * (typeNumber - 1) + 0];

         case QRErrorCorrectLevel.M:
          return QRRSBlock.RS_BLOCK_TABLE[4 * (typeNumber - 1) + 1];

         case QRErrorCorrectLevel.Q:
          return QRRSBlock.RS_BLOCK_TABLE[4 * (typeNumber - 1) + 2];

         case QRErrorCorrectLevel.H:
          return QRRSBlock.RS_BLOCK_TABLE[4 * (typeNumber - 1) + 3];

         default:
          return;
        }
      }, module.exports = QRRSBlock;
    },
    38588: (module, __unused_webpack_exports, __webpack_require__) => {
      var QRMode = __webpack_require__(82463), QRPolynomial = __webpack_require__(98977), QRMath = __webpack_require__(57889), QRMaskPattern = __webpack_require__(54556), QRUtil = {
        PATTERN_POSITION_TABLE: [ [], [ 6, 18 ], [ 6, 22 ], [ 6, 26 ], [ 6, 30 ], [ 6, 34 ], [ 6, 22, 38 ], [ 6, 24, 42 ], [ 6, 26, 46 ], [ 6, 28, 50 ], [ 6, 30, 54 ], [ 6, 32, 58 ], [ 6, 34, 62 ], [ 6, 26, 46, 66 ], [ 6, 26, 48, 70 ], [ 6, 26, 50, 74 ], [ 6, 30, 54, 78 ], [ 6, 30, 56, 82 ], [ 6, 30, 58, 86 ], [ 6, 34, 62, 90 ], [ 6, 28, 50, 72, 94 ], [ 6, 26, 50, 74, 98 ], [ 6, 30, 54, 78, 102 ], [ 6, 28, 54, 80, 106 ], [ 6, 32, 58, 84, 110 ], [ 6, 30, 58, 86, 114 ], [ 6, 34, 62, 90, 118 ], [ 6, 26, 50, 74, 98, 122 ], [ 6, 30, 54, 78, 102, 126 ], [ 6, 26, 52, 78, 104, 130 ], [ 6, 30, 56, 82, 108, 134 ], [ 6, 34, 60, 86, 112, 138 ], [ 6, 30, 58, 86, 114, 142 ], [ 6, 34, 62, 90, 118, 146 ], [ 6, 30, 54, 78, 102, 126, 150 ], [ 6, 24, 50, 76, 102, 128, 154 ], [ 6, 28, 54, 80, 106, 132, 158 ], [ 6, 32, 58, 84, 110, 136, 162 ], [ 6, 26, 54, 82, 110, 138, 166 ], [ 6, 30, 58, 86, 114, 142, 170 ] ],
        G15: 1335,
        G18: 7973,
        G15_MASK: 21522,
        getBCHTypeInfo: function(data) {
          for (var d = data << 10; QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0; ) d ^= QRUtil.G15 << QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15);
          return (data << 10 | d) ^ QRUtil.G15_MASK;
        },
        getBCHTypeNumber: function(data) {
          for (var d = data << 12; QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0; ) d ^= QRUtil.G18 << QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18);
          return data << 12 | d;
        },
        getBCHDigit: function(data) {
          for (var digit = 0; 0 !== data; ) digit++, data >>>= 1;
          return digit;
        },
        getPatternPosition: function(typeNumber) {
          return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
        },
        getMask: function(maskPattern, i, j) {
          switch (maskPattern) {
           case QRMaskPattern.PATTERN000:
            return (i + j) % 2 == 0;

           case QRMaskPattern.PATTERN001:
            return i % 2 == 0;

           case QRMaskPattern.PATTERN010:
            return j % 3 == 0;

           case QRMaskPattern.PATTERN011:
            return (i + j) % 3 == 0;

           case QRMaskPattern.PATTERN100:
            return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;

           case QRMaskPattern.PATTERN101:
            return i * j % 2 + i * j % 3 == 0;

           case QRMaskPattern.PATTERN110:
            return (i * j % 2 + i * j % 3) % 2 == 0;

           case QRMaskPattern.PATTERN111:
            return (i * j % 3 + (i + j) % 2) % 2 == 0;

           default:
            throw new Error("bad maskPattern:" + maskPattern);
          }
        },
        getErrorCorrectPolynomial: function(errorCorrectLength) {
          for (var a = new QRPolynomial([ 1 ], 0), i = 0; i < errorCorrectLength; i++) a = a.multiply(new QRPolynomial([ 1, QRMath.gexp(i) ], 0));
          return a;
        },
        getLengthInBits: function(mode, type) {
          if (1 <= type && type < 10) switch (mode) {
           case QRMode.MODE_NUMBER:
            return 10;

           case QRMode.MODE_ALPHA_NUM:
            return 9;

           case QRMode.MODE_8BIT_BYTE:
           case QRMode.MODE_KANJI:
            return 8;

           default:
            throw new Error("mode:" + mode);
          } else if (type < 27) switch (mode) {
           case QRMode.MODE_NUMBER:
            return 12;

           case QRMode.MODE_ALPHA_NUM:
            return 11;

           case QRMode.MODE_8BIT_BYTE:
            return 16;

           case QRMode.MODE_KANJI:
            return 10;

           default:
            throw new Error("mode:" + mode);
          } else {
            if (!(type < 41)) throw new Error("type:" + type);
            switch (mode) {
             case QRMode.MODE_NUMBER:
              return 14;

             case QRMode.MODE_ALPHA_NUM:
              return 13;

             case QRMode.MODE_8BIT_BYTE:
              return 16;

             case QRMode.MODE_KANJI:
              return 12;

             default:
              throw new Error("mode:" + mode);
            }
          }
        },
        getLostPoint: function(qrCode) {
          var moduleCount = qrCode.getModuleCount(), lostPoint = 0, row = 0, col = 0;
          for (row = 0; row < moduleCount; row++) for (col = 0; col < moduleCount; col++) {
            for (var sameCount = 0, dark = qrCode.isDark(row, col), r = -1; r <= 1; r++) if (!(row + r < 0 || moduleCount <= row + r)) for (var c = -1; c <= 1; c++) col + c < 0 || moduleCount <= col + c || 0 === r && 0 === c || dark === qrCode.isDark(row + r, col + c) && sameCount++;
            sameCount > 5 && (lostPoint += 3 + sameCount - 5);
          }
          for (row = 0; row < moduleCount - 1; row++) for (col = 0; col < moduleCount - 1; col++) {
            var count = 0;
            qrCode.isDark(row, col) && count++, qrCode.isDark(row + 1, col) && count++, qrCode.isDark(row, col + 1) && count++, 
            qrCode.isDark(row + 1, col + 1) && count++, 0 !== count && 4 !== count || (lostPoint += 3);
          }
          for (row = 0; row < moduleCount; row++) for (col = 0; col < moduleCount - 6; col++) qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) && qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) && qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) && qrCode.isDark(row, col + 6) && (lostPoint += 40);
          for (col = 0; col < moduleCount; col++) for (row = 0; row < moduleCount - 6; row++) qrCode.isDark(row, col) && !qrCode.isDark(row + 1, col) && qrCode.isDark(row + 2, col) && qrCode.isDark(row + 3, col) && qrCode.isDark(row + 4, col) && !qrCode.isDark(row + 5, col) && qrCode.isDark(row + 6, col) && (lostPoint += 40);
          var darkCount = 0;
          for (col = 0; col < moduleCount; col++) for (row = 0; row < moduleCount; row++) qrCode.isDark(row, col) && darkCount++;
          return lostPoint += 10 * (Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5);
        }
      };
      module.exports = QRUtil;
    },
    93245: (module, __unused_webpack_exports, __webpack_require__) => {
      var QR8bitByte = __webpack_require__(31861), QRUtil = __webpack_require__(38588), QRPolynomial = __webpack_require__(98977), QRRSBlock = __webpack_require__(6685), QRBitBuffer = __webpack_require__(99727);
      function QRCode(typeNumber, errorCorrectLevel) {
        this.typeNumber = typeNumber, this.errorCorrectLevel = errorCorrectLevel, this.modules = null, 
        this.moduleCount = 0, this.dataCache = null, this.dataList = [];
      }
      QRCode.prototype = {
        addData: function(data) {
          var newData = new QR8bitByte(data);
          this.dataList.push(newData), this.dataCache = null;
        },
        isDark: function(row, col) {
          if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) throw new Error(row + "," + col);
          return this.modules[row][col];
        },
        getModuleCount: function() {
          return this.moduleCount;
        },
        make: function() {
          if (this.typeNumber < 1) {
            var typeNumber = 1;
            for (typeNumber = 1; typeNumber < 40; typeNumber++) {
              for (var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, this.errorCorrectLevel), buffer = new QRBitBuffer, totalDataCount = 0, i = 0; i < rsBlocks.length; i++) totalDataCount += rsBlocks[i].dataCount;
              for (var x = 0; x < this.dataList.length; x++) {
                var data = this.dataList[x];
                buffer.put(data.mode, 4), buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber)), 
                data.write(buffer);
              }
              if (buffer.getLengthInBits() <= 8 * totalDataCount) break;
            }
            this.typeNumber = typeNumber;
          }
          this.makeImpl(!1, this.getBestMaskPattern());
        },
        makeImpl: function(test, maskPattern) {
          this.moduleCount = 4 * this.typeNumber + 17, this.modules = new Array(this.moduleCount);
          for (var row = 0; row < this.moduleCount; row++) {
            this.modules[row] = new Array(this.moduleCount);
            for (var col = 0; col < this.moduleCount; col++) this.modules[row][col] = null;
          }
          this.setupPositionProbePattern(0, 0), this.setupPositionProbePattern(this.moduleCount - 7, 0), 
          this.setupPositionProbePattern(0, this.moduleCount - 7), this.setupPositionAdjustPattern(), 
          this.setupTimingPattern(), this.setupTypeInfo(test, maskPattern), this.typeNumber >= 7 && this.setupTypeNumber(test), 
          null === this.dataCache && (this.dataCache = QRCode.createData(this.typeNumber, this.errorCorrectLevel, this.dataList)), 
          this.mapData(this.dataCache, maskPattern);
        },
        setupPositionProbePattern: function(row, col) {
          for (var r = -1; r <= 7; r++) if (!(row + r <= -1 || this.moduleCount <= row + r)) for (var c = -1; c <= 7; c++) col + c <= -1 || this.moduleCount <= col + c || (this.modules[row + r][col + c] = 0 <= r && r <= 6 && (0 === c || 6 === c) || 0 <= c && c <= 6 && (0 === r || 6 === r) || 2 <= r && r <= 4 && 2 <= c && c <= 4);
        },
        getBestMaskPattern: function() {
          for (var minLostPoint = 0, pattern = 0, i = 0; i < 8; i++) {
            this.makeImpl(!0, i);
            var lostPoint = QRUtil.getLostPoint(this);
            (0 === i || minLostPoint > lostPoint) && (minLostPoint = lostPoint, pattern = i);
          }
          return pattern;
        },
        createMovieClip: function(target_mc, instance_name, depth) {
          var qr_mc = target_mc.createEmptyMovieClip(instance_name, depth);
          this.make();
          for (var row = 0; row < this.modules.length; row++) for (var y = 1 * row, col = 0; col < this.modules[row].length; col++) {
            var x = 1 * col;
            this.modules[row][col] && (qr_mc.beginFill(0, 100), qr_mc.moveTo(x, y), qr_mc.lineTo(x + 1, y), 
            qr_mc.lineTo(x + 1, y + 1), qr_mc.lineTo(x, y + 1), qr_mc.endFill());
          }
          return qr_mc;
        },
        setupTimingPattern: function() {
          for (var r = 8; r < this.moduleCount - 8; r++) null === this.modules[r][6] && (this.modules[r][6] = r % 2 == 0);
          for (var c = 8; c < this.moduleCount - 8; c++) null === this.modules[6][c] && (this.modules[6][c] = c % 2 == 0);
        },
        setupPositionAdjustPattern: function() {
          for (var pos = QRUtil.getPatternPosition(this.typeNumber), i = 0; i < pos.length; i++) for (var j = 0; j < pos.length; j++) {
            var row = pos[i], col = pos[j];
            if (null === this.modules[row][col]) for (var r = -2; r <= 2; r++) for (var c = -2; c <= 2; c++) 2 === Math.abs(r) || 2 === Math.abs(c) || 0 === r && 0 === c ? this.modules[row + r][col + c] = !0 : this.modules[row + r][col + c] = !1;
          }
        },
        setupTypeNumber: function(test) {
          for (var mod, bits = QRUtil.getBCHTypeNumber(this.typeNumber), i = 0; i < 18; i++) mod = !test && 1 == (bits >> i & 1), 
          this.modules[Math.floor(i / 3)][i % 3 + this.moduleCount - 8 - 3] = mod;
          for (var x = 0; x < 18; x++) mod = !test && 1 == (bits >> x & 1), this.modules[x % 3 + this.moduleCount - 8 - 3][Math.floor(x / 3)] = mod;
        },
        setupTypeInfo: function(test, maskPattern) {
          for (var mod, data = this.errorCorrectLevel << 3 | maskPattern, bits = QRUtil.getBCHTypeInfo(data), v = 0; v < 15; v++) mod = !test && 1 == (bits >> v & 1), 
          v < 6 ? this.modules[v][8] = mod : v < 8 ? this.modules[v + 1][8] = mod : this.modules[this.moduleCount - 15 + v][8] = mod;
          for (var h = 0; h < 15; h++) mod = !test && 1 == (bits >> h & 1), h < 8 ? this.modules[8][this.moduleCount - h - 1] = mod : h < 9 ? this.modules[8][15 - h - 1 + 1] = mod : this.modules[8][15 - h - 1] = mod;
          this.modules[this.moduleCount - 8][8] = !test;
        },
        mapData: function(data, maskPattern) {
          for (var inc = -1, row = this.moduleCount - 1, bitIndex = 7, byteIndex = 0, col = this.moduleCount - 1; col > 0; col -= 2) for (6 === col && col--; ;) {
            for (var c = 0; c < 2; c++) if (null === this.modules[row][col - c]) {
              var dark = !1;
              byteIndex < data.length && (dark = 1 == (data[byteIndex] >>> bitIndex & 1)), QRUtil.getMask(maskPattern, row, col - c) && (dark = !dark), 
              this.modules[row][col - c] = dark, -1 === --bitIndex && (byteIndex++, bitIndex = 7);
            }
            if ((row += inc) < 0 || this.moduleCount <= row) {
              row -= inc, inc = -inc;
              break;
            }
          }
        }
      }, QRCode.PAD0 = 236, QRCode.PAD1 = 17, QRCode.createData = function(typeNumber, errorCorrectLevel, dataList) {
        for (var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel), buffer = new QRBitBuffer, i = 0; i < dataList.length; i++) {
          var data = dataList[i];
          buffer.put(data.mode, 4), buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber)), 
          data.write(buffer);
        }
        for (var totalDataCount = 0, x = 0; x < rsBlocks.length; x++) totalDataCount += rsBlocks[x].dataCount;
        if (buffer.getLengthInBits() > 8 * totalDataCount) throw new Error("code length overflow. (" + buffer.getLengthInBits() + ">" + 8 * totalDataCount + ")");
        for (buffer.getLengthInBits() + 4 <= 8 * totalDataCount && buffer.put(0, 4); buffer.getLengthInBits() % 8 != 0; ) buffer.putBit(!1);
        for (;!(buffer.getLengthInBits() >= 8 * totalDataCount || (buffer.put(QRCode.PAD0, 8), 
        buffer.getLengthInBits() >= 8 * totalDataCount)); ) buffer.put(QRCode.PAD1, 8);
        return QRCode.createBytes(buffer, rsBlocks);
      }, QRCode.createBytes = function(buffer, rsBlocks) {
        for (var offset = 0, maxDcCount = 0, maxEcCount = 0, dcdata = new Array(rsBlocks.length), ecdata = new Array(rsBlocks.length), r = 0; r < rsBlocks.length; r++) {
          var dcCount = rsBlocks[r].dataCount, ecCount = rsBlocks[r].totalCount - dcCount;
          maxDcCount = Math.max(maxDcCount, dcCount), maxEcCount = Math.max(maxEcCount, ecCount), 
          dcdata[r] = new Array(dcCount);
          for (var i = 0; i < dcdata[r].length; i++) dcdata[r][i] = 255 & buffer.buffer[i + offset];
          offset += dcCount;
          var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount), modPoly = new QRPolynomial(dcdata[r], rsPoly.getLength() - 1).mod(rsPoly);
          ecdata[r] = new Array(rsPoly.getLength() - 1);
          for (var x = 0; x < ecdata[r].length; x++) {
            var modIndex = x + modPoly.getLength() - ecdata[r].length;
            ecdata[r][x] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
          }
        }
        for (var totalCodeCount = 0, y = 0; y < rsBlocks.length; y++) totalCodeCount += rsBlocks[y].totalCount;
        for (var data = new Array(totalCodeCount), index = 0, z = 0; z < maxDcCount; z++) for (var s = 0; s < rsBlocks.length; s++) z < dcdata[s].length && (data[index++] = dcdata[s][z]);
        for (var xx = 0; xx < maxEcCount; xx++) for (var t = 0; t < rsBlocks.length; t++) xx < ecdata[t].length && (data[index++] = ecdata[t][xx]);
        return data;
      }, module.exports = QRCode;
    },
    84554: (module, __unused_webpack_exports, __webpack_require__) => {
      const fs = __webpack_require__(57147), {promisify} = __webpack_require__(73837), {readFileSync} = fs, readFile = promisify(fs.readFile), extractPath = (path, cmdshimContents) => /[.]cmd$/.test(path) ? extractPathFromCmd(cmdshimContents) : /[.]ps1$/.test(path) ? extractPathFromPowershell(cmdshimContents) : extractPathFromCygwin(cmdshimContents), extractPathFromPowershell = cmdshimContents => {
        const matches = cmdshimContents.match(/"[$]basedir[/]([^"]+?)"\s+[$]args/);
        return matches && matches[1];
      }, extractPathFromCmd = cmdshimContents => {
        const matches = cmdshimContents.match(/"%(?:~dp0|dp0%)\\([^"]+?)"\s+%[*]/);
        return matches && matches[1];
      }, extractPathFromCygwin = cmdshimContents => {
        const matches = cmdshimContents.match(/"[$]basedir[/]([^"]+?)"\s+"[$]@"/);
        return matches && matches[1];
      }, notaShim = (path, er) => (er || (er = new Error, Error.captureStackTrace(er, notaShim)), 
      er.code = "ENOTASHIM", er.message = `Can't read shim path from '${path}', it doesn't appear to be a cmd-shim`, 
      er), readCmdShim = path => {
        const er = new Error;
        return Error.captureStackTrace(er, readCmdShim), readFile(path).then((contents => {
          const destination = extractPath(path, contents.toString());
          return destination || Promise.reject(notaShim(path, er));
        }), (readFileEr => {
          return Promise.reject((thrown = readFileEr, (newError = er).message = thrown.message, 
          newError.code = thrown.code, newError.path = thrown.path, newError));
          var thrown, newError;
        }));
      };
      readCmdShim.sync = path => {
        const contents = readFileSync(path), destination = extractPath(path, contents.toString());
        if (!destination) throw notaShim(path);
        return destination;
      }, module.exports = readCmdShim;
    },
    62965: (module, __unused_webpack_exports, __webpack_require__) => {
      var fs = __webpack_require__(57147), path = __webpack_require__(71017), glob = __webpack_require__(34436), normalizeData = __webpack_require__(17770), safeJSON = __webpack_require__(40295), util = __webpack_require__(73837), normalizePackageBin = __webpack_require__(51234);
      module.exports = readJson, readJson.extraSet = [ function(file, data, cb) {
        var bd = "bundleDependencies", bdd = "bundledDependencies";
        void 0 !== data[bdd] && (void 0 === data[bd] && (data[bd] = data[bdd]), delete data[bdd]);
        !1 === data[bd] ? delete data[bd] : !0 === data[bd] ? data[bd] = Object.keys(data.dependencies || {}) : void 0 === data[bd] || Array.isArray(data[bd]) || delete data[bd];
        return cb(null, data);
      }, function(file, data, cb) {
        var dir = path.dirname(file), s = data.scripts || {};
        if (s.install || s.preinstall) return cb(null, data);
        glob("*.gyp", {
          cwd: dir
        }, (function(er, files) {
          return er ? cb(er) : !1 === data.gypfile ? cb(null, data) : void function(file, data, files, cb) {
            if (!files.length) return cb(null, data);
            var s = data.scripts || {};
            s.install = "node-gyp rebuild", data.scripts = s, data.gypfile = !0, cb(null, data);
          }(0, data, files, cb);
        }));
      }, function(file, data, cb) {
        var dir = path.dirname(file);
        if ((data.scripts || {}).start) return cb(null, data);
        glob("server.js", {
          cwd: dir
        }, (function(er, files) {
          if (er) return cb(er);
          !function(file, data, files, cb) {
            if (!files.length) return cb(null, data);
            var s = data.scripts || {};
            s.start = "node server.js", data.scripts = s, cb(null, data);
          }(0, data, files, cb);
        }));
      }, function(file, data, cb) {
        if (!data.scripts) return cb(null, data);
        Object.keys(data.scripts).forEach(scriptpath_, data.scripts), cb(null, data);
      }, function(file, data, cb) {
        if (data.contributors) return cb(null, data);
        var af = path.resolve(path.dirname(file), "AUTHORS");
        fs.readFile(af, "utf8", (function(er, ad) {
          if (er) return cb(null, data);
          !function(file, data, ad, cb) {
            ad = ad.split(/\r?\n/g).map((function(line) {
              return line.replace(/^\s*#.*$/, "").trim();
            })).filter((function(line) {
              return line;
            })), data.contributors = ad, cb(null, data);
          }(0, data, ad, cb);
        }));
      }, function(file, data, cb) {
        if (data.readme) return cb(null, data);
        var dir = path.dirname(file);
        glob("{README,README.*}", {
          cwd: dir,
          nocase: !0,
          mark: !0
        }, (function(er, files) {
          if (er) return cb(er);
          if (!(files = files.filter((function(filtered) {
            return !filtered.match(/\/$/);
          }))).length) return cb();
          var fn = function(files) {
            for (var fallback = 0, re = /\.m?a?r?k?d?o?w?n?$/i, i = 0; i < files.length; i++) {
              if (files[i].match(re)) return files[i];
              files[i].match(/README$/) && (fallback = i);
            }
            return files[fallback];
          }(files), rm = path.resolve(dir, fn);
          !function(file, data, rm, cb) {
            var rmfn = path.basename(rm);
            fs.readFile(rm, "utf8", (function(er, rmData) {
              return er ? cb() : (data.readme = rmData, data.readmeFilename = rmfn, cb(er, data));
            }));
          }(0, data, rm, cb);
        }));
      }, function(file, data, cb) {
        let cwd = data.directories && data.directories.man;
        if (data.man || !cwd) return cb(null, data);
        const dirname = path.dirname(file);
        cwd = path.resolve(path.dirname(file), cwd), glob("**/*.[0-9]", {
          cwd
        }, (function(er, mansGlob) {
          return er ? cb(er) : (data.man = mansGlob.map((man => path.relative(dirname, path.join(cwd, man)).split(path.sep).join("/"))), 
          cb(null, data));
        }));
      }, function(file, data, cb) {
        var m = (data = normalizePackageBin(data)).directories && data.directories.bin;
        if (data.bin || !m) return cb(null, data);
        m = path.resolve(path.dirname(file), m), glob("**", {
          cwd: m
        }, (function(er, binsGlob) {
          if (er) return cb(er);
          !function(file, data, binsGlob, cb) {
            var m = data.directories && data.directories.bin || ".";
            data.bin = binsGlob.reduce((function(acc, mf) {
              mf && "." !== mf.charAt(0) && (acc[path.basename(mf)] = path.join(m, mf));
              return acc;
            }), {}), cb(null, normalizePackageBin(data));
          }(0, data, binsGlob, cb);
        }));
      }, function githead(file, data, cb) {
        if (data.gitHead) return cb(null, data);
        var dir = path.dirname(file), head = path.resolve(dir, ".git/HEAD");
        fs.readFile(head, "utf8", (function(er, headData) {
          if (er) return path.dirname(dir) === dir ? cb(null, data) : githead(dir, data, cb);
          !function(data, dir, head, cb) {
            if (!head.match(/^ref: /)) return data.gitHead = head.trim(), cb(null, data);
            var headRef = head.replace(/^ref: /, "").trim(), headFile = path.resolve(dir, ".git", headRef);
            fs.readFile(headFile, "utf8", (function(er, headData) {
              if (er || !headData) {
                var packFile = path.resolve(dir, ".git/packed-refs");
                return fs.readFile(packFile, "utf8", (function(readFileErr, refs) {
                  if (readFileErr || !refs) return cb(null, data);
                  refs = refs.split("\n");
                  for (var i = 0; i < refs.length; i++) {
                    var match = refs[i].match(/^([0-9a-f]{40}) (.+)$/);
                    if (match && match[2].trim() === headRef) {
                      data.gitHead = match[1];
                      break;
                    }
                  }
                  return cb(null, data);
                }));
              }
              return headData = headData.replace(/^ref: /, "").trim(), data.gitHead = headData, 
              cb(null, data);
            }));
          }(data, dir, headData, cb);
        }));
      }, function(file, data, cb) {
        var index = data.main ? data.main : "index.js";
        if ("string" != typeof index) return cb(new TypeError('The "main" attribute must be of type string.'));
        var dts = `./${path.join(path.dirname(index), path.basename(index, path.extname(index)))}.d.ts`, dtsPath = path.join(path.dirname(file), dts);
        "types" in data || "typings" in data || !fs.existsSync(dtsPath) || (data.types = dts.split(path.sep).join("/"));
        cb(null, data);
      } ];
      var typoWarned = {}, cache = {};
      function readJson(file, log_, strict_, cb_) {
        for (var log, strict, i = 1; i < arguments.length - 1; i++) "boolean" == typeof arguments[i] ? strict = arguments[i] : "function" == typeof arguments[i] && (log = arguments[i]);
        log || (log = function() {}), readJson_(file, log, strict, arguments[arguments.length - 1]);
      }
      function readJson_(file, log, strict, cb) {
        fs.readFile(file, "utf8", (function(er, d) {
          !function(file, er, d, log, strict, cb) {
            if (er && "ENOENT" === er.code) return fs.stat(path.dirname(file), (function(err, stat) {
              return err || !stat || stat.isDirectory() ? function(file, er, log, strict, cb) {
                if ("index.js" === path.basename(file)) return cb(er);
                var index = path.resolve(path.dirname(file), "index.js");
                fs.readFile(index, "utf8", (function(er2, d) {
                  if (er2) return cb(er);
                  if (cache[d]) return cb(null, cache[d]);
                  var data = parseIndex(d);
                  if (!data) return cb(er);
                  extrasCached(file, d, data, log, strict, cb);
                }));
              }(file, er, log, strict, cb) : ((er = Object.create(er)).code = "ENOTDIR", cb(er));
            }));
            if (er) return cb(er);
            if (cache[d]) return cb(null, jsonClone(cache[d]));
            var data;
            try {
              for (var key in data = safeJSON(function(content) {
                65279 === content.charCodeAt(0) && (content = content.slice(1));
                return content;
              }(d))) /^_/.test(key) && delete data[key];
            } catch (jsonErr) {
              if (!(data = parseIndex(d))) return cb(function(ex, file) {
                var e = new Error("Failed to parse json\n" + ex.message);
                return e.code = "EJSONPARSE", e.path = file, e;
              }(jsonErr, file));
            }
            extrasCached(file, d, data, log, strict, cb);
          }(file, er, d, log, strict, cb);
        }));
      }
      function jsonClone(obj) {
        if (null == obj) return obj;
        if (Array.isArray(obj)) {
          var newarr = new Array(obj.length);
          for (var ii in obj) newarr[ii] = obj[ii];
        } else {
          if ("object" != typeof obj) return obj;
          var newobj = {};
          for (var kk in obj) newobj[kk] = jsonClone[kk];
        }
      }
      function extrasCached(file, d, data, log, strict, cb) {
        extras(file, data, log, strict, (function(err, extrasData) {
          err || (cache[d] = jsonClone(extrasData)), cb(err, extrasData);
        }));
      }
      function extras(file, data, log_, strict_, cb_) {
        for (var log, strict, cb, i = 2; i < arguments.length - 1; i++) "boolean" == typeof arguments[i] ? strict = arguments[i] : "function" == typeof arguments[i] && (log = arguments[i]);
        log || (log = function() {}), cb = arguments[i];
        var set = readJson.extraSet, n = set.length, errState = null;
        function then(er) {
          if (!errState) return er ? cb(errState = er) : void (--n > 0 || final(file, data, log, strict, cb));
        }
        set.forEach((function(fn) {
          fn(file, data, then);
        }));
      }
      function scriptpath_(key) {
        var s = this[key];
        if ("string" != typeof s) return delete this[key];
        var spre = /^(\.[/\\])?node_modules[/\\].bin[\\/]/;
        s.match(spre) && (this[key] = this[key].replace(spre, ""));
      }
      function final(file, data, log, strict, cb) {
        var pId = function(data) {
          var name = cleanString(data.name), ver = cleanString(data.version);
          return name + "@" + ver;
        }(data);
        function warn(msg) {
          typoWarned[pId] || log && log("package.json", pId, msg);
        }
        try {
          normalizeData(data, warn, strict);
        } catch (error) {
          return cb(error);
        }
        !function(file, data, warn, cb) {
          if (!(data.bin instanceof Object)) return cb();
          var keys = Object.keys(data.bin), keysLeft = keys.length;
          if (!keysLeft) return cb();
          function handleExists(relName, result) {
            keysLeft--, result || warn("No bin file found at " + relName), keysLeft || cb();
          }
          keys.forEach((function(key) {
            var dirName = path.dirname(file), relName = data.bin[key];
            if ("string" != typeof relName) {
              var msg = "Bin filename for " + key + " is not a string: " + util.inspect(relName);
              return warn(msg), delete data.bin[key], void handleExists(relName, !0);
            }
            var binPath = path.resolve(dirName, relName);
            fs.stat(binPath, (err => handleExists(relName, !err)));
          }));
        }(file, data, warn, (function() {
          typoWarned[pId] = !0, cb(null, data);
        }));
      }
      function cleanString(str) {
        return str && "string" == typeof str ? str.trim() : "";
      }
      function parseIndex(data) {
        if ((data = data.split(/^\/\*\*package(?:\s|$)/m)).length < 2) return null;
        if ((data = (data = data[1]).split(/\*\*\/$/m)).length < 2) return null;
        data = (data = data[0]).replace(/^\s*\*/gm, "");
        try {
          return safeJSON(data);
        } catch (er) {
          return null;
        }
      }
      readJson.extras = extras;
    },
    9547: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = function(opts, cb) {
        if (opts.num) throw new Error("read() no longer accepts a char number limit");
        if (void 0 !== opts.default && "string" != typeof opts.default && "number" != typeof opts.default) throw new Error("default value must be string or number");
        var input = opts.input || process.stdin, output = opts.output || process.stdout, prompt = (opts.prompt || "").trim() + " ", silent = opts.silent, editDef = !1, timeout = opts.timeout, def = opts.default || "";
        def && (silent ? prompt += "(<default hidden>) " : opts.edit ? editDef = !0 : prompt += "(" + def + ") ");
        var terminal = !(!opts.terminal && !output.isTTY), m = new Mute({
          replace: opts.replace,
          prompt
        });
        m.pipe(output, {
          end: !1
        });
        var rlOpts = {
          input,
          output: output = m,
          terminal
        };
        if (process.version.match(/^v0\.6/)) var rl = readline.createInterface(rlOpts.input, rlOpts.output); else rl = readline.createInterface(rlOpts);
        output.unmute(), rl.setPrompt(prompt), rl.prompt(), silent ? output.mute() : editDef && (rl.line = def, 
        rl.cursor = def.length, rl._refreshLine());
        var timer, called = !1;
        rl.on("line", (function(line) {
          if (called) return;
          silent && terminal && (output.unmute(), output.write("\r\n"));
          done(), line = line.replace(/\r?\n$/, "");
          var isDefault = !(!editDef || line !== def);
          def && !line && (isDefault = !0, line = def);
          cb(null, line, isDefault);
        })), rl.on("error", onError), rl.on("SIGINT", (function() {
          rl.close(), onError(new Error("canceled"));
        })), timeout && (timer = setTimeout((function() {
          onError(new Error("timed out"));
        }), timeout));
        function done() {
          called = !0, rl.close(), process.version.match(/^v0\.6/) && (rl.input.removeAllListeners("data"), 
          rl.input.removeAllListeners("keypress"), rl.input.pause()), clearTimeout(timer), 
          output.mute(), output.end();
        }
        function onError(er) {
          if (!called) return done(), cb(er);
        }
      };
      var readline = __webpack_require__(14521), Mute = __webpack_require__(94464);
    },
    51981: (module, __unused_webpack_exports, __webpack_require__) => {
      var fs = __webpack_require__(49809), dz = __webpack_require__(21248), once = __webpack_require__(38412), path = __webpack_require__(71017), debug = __webpack_require__(1468)("rds");
      function readdir(dir, cb) {
        fs.readdir(dir, (function(er, kids) {
          if (er) return cb(er);
          debug("dir=%j, kids=%j", dir, kids), function(root, kids, cb) {
            var scopes = kids.filter((function(kid) {
              return "@" === kid.charAt(0);
            }));
            kids = kids.filter((function(kid) {
              return "@" !== kid.charAt(0);
            })), debug("scopes=%j", scopes), 0 === scopes.length && dz(cb)(null, kids);
            cb = once(cb);
            var l = scopes.length;
            function then(scope, er, scopekids) {
              if (er) return cb(er);
              scopekids = scopekids.filter((function(scopekid) {
                return !("." === scopekid || ".." === scopekid || !scopekid);
              })), kids.push.apply(kids, scopekids.map((function(scopekid) {
                return scope + "/" + scopekid;
              }))), debug("scope=%j scopekids=%j kids=%j", scope, scopekids, kids), 0 == --l && cb(null, kids);
            }
            scopes.forEach((function(scope) {
              var scopedir = path.resolve(root, scope);
              debug("root=%j scope=%j scopedir=%j", root, scope, scopedir), fs.readdir(scopedir, then.bind(null, scope));
            }));
          }(dir, kids, (function(er, data) {
            return er ? cb(er) : (data = data.sort((function(a, b) {
              return a > b ? 1 : -1;
            })), cb(null, data));
          }));
        }));
      }
      module.exports = readdir, readdir.sync = function(dir) {
        var kids = fs.readdirSync(dir);
        debug("dir=%j, kids=%j", dir, kids);
        var data = function(root, kids) {
          var scopes = kids.filter((function(kid) {
            return "@" === kid.charAt(0);
          }));
          if (kids = kids.filter((function(kid) {
            return "@" !== kid.charAt(0);
          })), debug("scopes=%j", scopes), 0 === scopes.length) return kids;
          scopes.length;
          function then(scope, scopekids) {
            scopekids = scopekids.filter((function(scopekid) {
              return !("." === scopekid || ".." === scopekid || !scopekid);
            })), kids.push.apply(kids, scopekids.map((function(scopekid) {
              return scope + "/" + scopekid;
            }))), debug("scope=%j scopekids=%j kids=%j", scope, scopekids, kids);
          }
          return scopes.forEach((function(scope) {
            var scopedir = path.resolve(root, scope);
            debug("root=%j scope=%j scopedir=%j", root, scope, scopedir), then(scope, fs.readdirSync(scopedir));
          })), kids;
        }(dir, kids);
        return data = data.sort((function(a, b) {
          return a > b ? 1 : -1;
        }));
      };
    },
    64876: (__unused_webpack_module, exports, __webpack_require__) => {
      var RetryOperation = __webpack_require__(32120);
      exports.operation = function(options) {
        var timeouts = exports.timeouts(options);
        return new RetryOperation(timeouts, {
          forever: options && options.forever,
          unref: options && options.unref,
          maxRetryTime: options && options.maxRetryTime
        });
      }, exports.timeouts = function(options) {
        if (options instanceof Array) return [].concat(options);
        var opts = {
          retries: 10,
          factor: 2,
          minTimeout: 1e3,
          maxTimeout: 1 / 0,
          randomize: !1
        };
        for (var key in options) opts[key] = options[key];
        if (opts.minTimeout > opts.maxTimeout) throw new Error("minTimeout is greater than maxTimeout");
        for (var timeouts = [], i = 0; i < opts.retries; i++) timeouts.push(this.createTimeout(i, opts));
        return options && options.forever && !timeouts.length && timeouts.push(this.createTimeout(i, opts)), 
        timeouts.sort((function(a, b) {
          return a - b;
        })), timeouts;
      }, exports.createTimeout = function(attempt, opts) {
        var random = opts.randomize ? Math.random() + 1 : 1, timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));
        return timeout = Math.min(timeout, opts.maxTimeout);
      }, exports.wrap = function(obj, options, methods) {
        if (options instanceof Array && (methods = options, options = null), !methods) for (var key in methods = [], 
        obj) "function" == typeof obj[key] && methods.push(key);
        for (var i = 0; i < methods.length; i++) {
          var method = methods[i], original = obj[method];
          obj[method] = function(original) {
            var op = exports.operation(options), args = Array.prototype.slice.call(arguments, 1), callback = args.pop();
            args.push((function(err) {
              op.retry(err) || (err && (arguments[0] = op.mainError()), callback.apply(this, arguments));
            })), op.attempt((function() {
              original.apply(obj, args);
            }));
          }.bind(obj, original), obj[method].options = options;
        }
      };
    },
    32120: module => {
      function RetryOperation(timeouts, options) {
        "boolean" == typeof options && (options = {
          forever: options
        }), this._originalTimeouts = JSON.parse(JSON.stringify(timeouts)), this._timeouts = timeouts, 
        this._options = options || {}, this._maxRetryTime = options && options.maxRetryTime || 1 / 0, 
        this._fn = null, this._errors = [], this._attempts = 1, this._operationTimeout = null, 
        this._operationTimeoutCb = null, this._timeout = null, this._operationStart = null, 
        this._options.forever && (this._cachedTimeouts = this._timeouts.slice(0));
      }
      module.exports = RetryOperation, RetryOperation.prototype.reset = function() {
        this._attempts = 1, this._timeouts = this._originalTimeouts;
      }, RetryOperation.prototype.stop = function() {
        this._timeout && clearTimeout(this._timeout), this._timeouts = [], this._cachedTimeouts = null;
      }, RetryOperation.prototype.retry = function(err) {
        if (this._timeout && clearTimeout(this._timeout), !err) return !1;
        var currentTime = (new Date).getTime();
        if (err && currentTime - this._operationStart >= this._maxRetryTime) return this._errors.unshift(new Error("RetryOperation timeout occurred")), 
        !1;
        this._errors.push(err);
        var timeout = this._timeouts.shift();
        if (void 0 === timeout) {
          if (!this._cachedTimeouts) return !1;
          this._errors.splice(this._errors.length - 1, this._errors.length), this._timeouts = this._cachedTimeouts.slice(0), 
          timeout = this._timeouts.shift();
        }
        var self = this, timer = setTimeout((function() {
          self._attempts++, self._operationTimeoutCb && (self._timeout = setTimeout((function() {
            self._operationTimeoutCb(self._attempts);
          }), self._operationTimeout), self._options.unref && self._timeout.unref()), self._fn(self._attempts);
        }), timeout);
        return this._options.unref && timer.unref(), !0;
      }, RetryOperation.prototype.attempt = function(fn, timeoutOps) {
        this._fn = fn, timeoutOps && (timeoutOps.timeout && (this._operationTimeout = timeoutOps.timeout), 
        timeoutOps.cb && (this._operationTimeoutCb = timeoutOps.cb));
        var self = this;
        this._operationTimeoutCb && (this._timeout = setTimeout((function() {
          self._operationTimeoutCb();
        }), self._operationTimeout)), this._operationStart = (new Date).getTime(), this._fn(this._attempts);
      }, RetryOperation.prototype.try = function(fn) {
        console.log("Using RetryOperation.try() is deprecated"), this.attempt(fn);
      }, RetryOperation.prototype.start = function(fn) {
        console.log("Using RetryOperation.start() is deprecated"), this.attempt(fn);
      }, RetryOperation.prototype.start = RetryOperation.prototype.try, RetryOperation.prototype.errors = function() {
        return this._errors;
      }, RetryOperation.prototype.attempts = function() {
        return this._attempts;
      }, RetryOperation.prototype.mainError = function() {
        if (0 === this._errors.length) return null;
        for (var counts = {}, mainError = null, mainErrorCount = 0, i = 0; i < this._errors.length; i++) {
          var error = this._errors[i], message = error.message, count = (counts[message] || 0) + 1;
          counts[message] = count, count >= mainErrorCount && (mainError = error, mainErrorCount = count);
        }
        return mainError;
      };
    },
    20459: (module, __unused_webpack_exports, __webpack_require__) => {
      var process = global.process;
      const processOk = function(process) {
        return process && "object" == typeof process && "function" == typeof process.removeListener && "function" == typeof process.emit && "function" == typeof process.reallyExit && "function" == typeof process.listeners && "function" == typeof process.kill && "number" == typeof process.pid && "function" == typeof process.on;
      };
      if (processOk(process)) {
        var emitter, assert = __webpack_require__(39491), signals = __webpack_require__(56126), isWin = /^win/i.test(process.platform), EE = __webpack_require__(82361);
        "function" != typeof EE && (EE = EE.EventEmitter), process.__signal_exit_emitter__ ? emitter = process.__signal_exit_emitter__ : ((emitter = process.__signal_exit_emitter__ = new EE).count = 0, 
        emitter.emitted = {}), emitter.infinite || (emitter.setMaxListeners(1 / 0), emitter.infinite = !0), 
        module.exports = function(cb, opts) {
          if (!processOk(global.process)) return function() {};
          assert.equal(typeof cb, "function", "a callback must be provided for exit handler"), 
          !1 === loaded && load();
          var ev = "exit";
          opts && opts.alwaysLast && (ev = "afterexit");
          return emitter.on(ev, cb), function() {
            emitter.removeListener(ev, cb), 0 === emitter.listeners("exit").length && 0 === emitter.listeners("afterexit").length && unload();
          };
        };
        var unload = function() {
          loaded && processOk(global.process) && (loaded = !1, signals.forEach((function(sig) {
            try {
              process.removeListener(sig, sigListeners[sig]);
            } catch (er) {}
          })), process.emit = originalProcessEmit, process.reallyExit = originalProcessReallyExit, 
          emitter.count -= 1);
        };
        module.exports.unload = unload;
        var emit = function(event, code, signal) {
          emitter.emitted[event] || (emitter.emitted[event] = !0, emitter.emit(event, code, signal));
        }, sigListeners = {};
        signals.forEach((function(sig) {
          sigListeners[sig] = function() {
            processOk(global.process) && (process.listeners(sig).length === emitter.count && (unload(), 
            emit("exit", null, sig), emit("afterexit", null, sig), isWin && "SIGHUP" === sig && (sig = "SIGINT"), 
            process.kill(process.pid, sig)));
          };
        })), module.exports.signals = function() {
          return signals;
        };
        var loaded = !1, load = function() {
          !loaded && processOk(global.process) && (loaded = !0, emitter.count += 1, signals = signals.filter((function(sig) {
            try {
              return process.on(sig, sigListeners[sig]), !0;
            } catch (er) {
              return !1;
            }
          })), process.emit = processEmit, process.reallyExit = processReallyExit);
        };
        module.exports.load = load;
        var originalProcessReallyExit = process.reallyExit, processReallyExit = function(code) {
          processOk(global.process) && (process.exitCode = code || 0, emit("exit", process.exitCode, null), 
          emit("afterexit", process.exitCode, null), originalProcessReallyExit.call(process, process.exitCode));
        }, originalProcessEmit = process.emit, processEmit = function(ev, arg) {
          if ("exit" === ev && processOk(global.process)) {
            void 0 !== arg && (process.exitCode = arg);
            var ret = originalProcessEmit.apply(this, arguments);
            return emit("exit", process.exitCode, null), emit("afterexit", process.exitCode, null), 
            ret;
          }
          return originalProcessEmit.apply(this, arguments);
        };
      } else module.exports = function() {
        return function() {};
      };
    },
    56126: module => {
      module.exports = [ "SIGABRT", "SIGALRM", "SIGHUP", "SIGINT", "SIGTERM" ], "win32" !== process.platform && module.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT"), 
      "linux" === process.platform && module.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
    },
    41055: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const stripAnsi = __webpack_require__(42935), isFullwidthCodePoint = __webpack_require__(20386), emojiRegex = __webpack_require__(60957), stringWidth = string => {
        if ("string" != typeof string || 0 === string.length) return 0;
        if (0 === (string = stripAnsi(string)).length) return 0;
        string = string.replace(emojiRegex(), "  ");
        let width = 0;
        for (let i = 0; i < string.length; i++) {
          const code = string.codePointAt(i);
          code <= 31 || code >= 127 && code <= 159 || (code >= 768 && code <= 879 || (code > 65535 && i++, 
          width += isFullwidthCodePoint(code) ? 2 : 1));
        }
        return width;
      };
      module.exports = stringWidth, module.exports.default = stringWidth;
    },
    42935: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const ansiRegex = __webpack_require__(71882);
      module.exports = string => "string" == typeof string ? string.replace(ansiRegex(), "") : string;
    },
    90760: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const os = __webpack_require__(22037), tty = __webpack_require__(76224), hasFlag = __webpack_require__(47682), {env} = process;
      let forceColor;
      function translateLevel(level) {
        return 0 !== level && {
          level,
          hasBasic: !0,
          has256: level >= 2,
          has16m: level >= 3
        };
      }
      function supportsColor(haveStream, streamIsTTY) {
        if (0 === forceColor) return 0;
        if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) return 3;
        if (hasFlag("color=256")) return 2;
        if (haveStream && !streamIsTTY && void 0 === forceColor) return 0;
        const min = forceColor || 0;
        if ("dumb" === env.TERM) return min;
        if ("win32" === process.platform) {
          const osRelease = os.release().split(".");
          return Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586 ? Number(osRelease[2]) >= 14931 ? 3 : 2 : 1;
        }
        if ("CI" in env) return [ "TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE" ].some((sign => sign in env)) || "codeship" === env.CI_NAME ? 1 : min;
        if ("TEAMCITY_VERSION" in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
        if ("truecolor" === env.COLORTERM) return 3;
        if ("TERM_PROGRAM" in env) {
          const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          switch (env.TERM_PROGRAM) {
           case "iTerm.app":
            return version >= 3 ? 3 : 2;

           case "Apple_Terminal":
            return 2;
          }
        }
        return /-256(color)?$/i.test(env.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM) || "COLORTERM" in env ? 1 : min;
      }
      hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never") ? forceColor = 0 : (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) && (forceColor = 1), 
      "FORCE_COLOR" in env && (forceColor = "true" === env.FORCE_COLOR ? 1 : "false" === env.FORCE_COLOR ? 0 : 0 === env.FORCE_COLOR.length ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3)), 
      module.exports = {
        supportsColor: function(stream) {
          return translateLevel(supportsColor(stream, stream && stream.isTTY));
        },
        stdout: translateLevel(supportsColor(!0, tty.isatty(1))),
        stderr: translateLevel(supportsColor(!0, tty.isatty(2)))
      };
    },
    5371: module => {
      function dotindex(c) {
        var m = /\.[^.]*$/.exec(c);
        return m ? m.index + 1 : c.length;
      }
      function reduce(xs, f, init) {
        if (xs.reduce) return xs.reduce(f, init);
        for (var i = 0, acc = arguments.length >= 3 ? init : xs[i++]; i < xs.length; i++) f(acc, xs[i], i);
        return acc;
      }
      function forEach(xs, f) {
        if (xs.forEach) return xs.forEach(f);
        for (var i = 0; i < xs.length; i++) f.call(xs, xs[i], i);
      }
      function map(xs, f) {
        if (xs.map) return xs.map(f);
        for (var res = [], i = 0; i < xs.length; i++) res.push(f.call(xs, xs[i], i));
        return res;
      }
      module.exports = function(rows_, opts) {
        opts || (opts = {});
        var hsep = void 0 === opts.hsep ? "  " : opts.hsep, align = opts.align || [], stringLength = opts.stringLength || function(s) {
          return String(s).length;
        }, dotsizes = reduce(rows_, (function(acc, row) {
          return forEach(row, (function(c, ix) {
            var n = dotindex(c);
            (!acc[ix] || n > acc[ix]) && (acc[ix] = n);
          })), acc;
        }), []), rows = map(rows_, (function(row) {
          return map(row, (function(c_, ix) {
            var c = String(c_);
            if ("." === align[ix]) {
              var index = dotindex(c), size = dotsizes[ix] + (/\./.test(c) ? 1 : 2) - (stringLength(c) - index);
              return c + Array(size).join(" ");
            }
            return c;
          }));
        })), sizes = reduce(rows, (function(acc, row) {
          return forEach(row, (function(c, ix) {
            var n = stringLength(c);
            (!acc[ix] || n > acc[ix]) && (acc[ix] = n);
          })), acc;
        }), []);
        return map(rows, (function(row) {
          return map(row, (function(c, ix) {
            var n = sizes[ix] - stringLength(c) || 0, s = Array(Math.max(n + 1, 1)).join(" ");
            return "r" === align[ix] || "." === align[ix] ? s + c : "c" === align[ix] ? Array(Math.ceil(n / 2 + 1)).join(" ") + c + Array(Math.floor(n / 2 + 1)).join(" ") : c + s;
          })).join(hsep).replace(/\s+$/, "");
        })).join("\n");
      };
    },
    38100: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";
      __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
        default: () => src
      });
      const calculateDelta = (now, date) => Math.round(Math.abs(now - date) / 1e3);
      var en = __webpack_require__(27035);
      const src = (translations = __webpack_require__.n(en)(), function(date, now = new Date) {
        date instanceof Date || (date = new Date(date));
        let delta = null;
        const day = 86400;
        delta = calculateDelta(now, date), delta > day && delta < 604800 && (date = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0), 
        delta = calculateDelta(now, date));
        const translate = (translatePhrase, timeValue) => {
          let key;
          key = "justNow" === translatePhrase ? translatePhrase : now >= date ? `${translatePhrase}Ago` : `${translatePhrase}FromNow`;
          const translation = translations[key];
          return "function" == typeof translation ? translation(timeValue) : translation.replace("{{time}}", timeValue);
        };
        switch (!1) {
         case !(delta < 30):
          return translate("justNow");

         case !(delta < 60):
          return translate("seconds", delta);

         case !(delta < 120):
          return translate("aMinute");

         case !(delta < 3600):
          return translate("minutes", Math.floor(delta / 60));

         case 1 !== Math.floor(delta / 3600):
          return translate("anHour");

         case !(delta < day):
          return translate("hours", Math.floor(delta / 3600));

         case !(delta < 2 * day):
          return translate("aDay");

         case !(delta < 604800):
          return translate("days", Math.floor(delta / day));

         case 1 !== Math.floor(delta / 604800):
          return translate("aWeek");

         case !(delta < 2592e3):
          return translate("weeks", Math.floor(delta / 604800));

         case 1 !== Math.floor(delta / 2592e3):
          return translate("aMonth");

         case !(delta < 31536e3):
          return translate("months", Math.floor(delta / 2592e3));

         case 1 !== Math.floor(delta / 31536e3):
          return translate("aYear");

         default:
          return translate("overAYear");
        }
      });
      var translations;
    },
    27035: module => {
      module.exports = {
        justNow: "just now",
        secondsAgo: "{{time}} seconds ago",
        aMinuteAgo: "a minute ago",
        minutesAgo: "{{time}} minutes ago",
        anHourAgo: "an hour ago",
        hoursAgo: "{{time}} hours ago",
        aDayAgo: "yesterday",
        daysAgo: "{{time}} days ago",
        aWeekAgo: "a week ago",
        weeksAgo: "{{time}} weeks ago",
        aMonthAgo: "a month ago",
        monthsAgo: "{{time}} months ago",
        aYearAgo: "a year ago",
        yearsAgo: "{{time}} years ago",
        overAYearAgo: "over a year ago",
        secondsFromNow: "{{time}} seconds from now",
        aMinuteFromNow: "a minute from now",
        minutesFromNow: "{{time}} minutes from now",
        anHourFromNow: "an hour from now",
        hoursFromNow: "{{time}} hours from now",
        aDayFromNow: "tomorrow",
        daysFromNow: "{{time}} days from now",
        aWeekFromNow: "a week from now",
        weeksFromNow: "{{time}} weeks from now",
        aMonthFromNow: "a month from now",
        monthsFromNow: "{{time}} months from now",
        aYearFromNow: "a year from now",
        yearsFromNow: "{{time}} years from now",
        overAYearFromNow: "over a year from now"
      };
    },
    39499: module => {
      const isPromise = p => p && "function" == typeof p.then;
      module.exports = ({visit, filter = () => !0, getChildren, tree}) => {
        const queue = [], seen = new Map, next = () => {
          for (;queue.length; ) {
            const node = queue.shift(), res = visitNode(node);
            if (isPromise(res)) return res.then((() => next()));
          }
          return seen.get(tree);
        }, visitNode = visitTree => {
          if (seen.has(visitTree)) return seen.get(visitTree);
          seen.set(visitTree, null);
          const res = visit ? visit(visitTree) : visitTree;
          if (isPromise(res)) {
            const fullResult = res.then((resThen => (seen.set(visitTree, resThen), kidNodes(visitTree))));
            return seen.set(visitTree, fullResult), fullResult;
          }
          return seen.set(visitTree, res), kidNodes(visitTree);
        }, kidNodes = kidTree => {
          const kids = getChildren(kidTree, seen.get(kidTree));
          return isPromise(kids) ? kids.then(processKids) : processKids(kids);
        }, processKids = kids => {
          kids = (kids || []).filter(filter), queue.push(...kids);
        };
        return queue.push(tree), next();
      };
    },
    95267: module => {
      const isPromise = p => p && "function" == typeof p.then;
      module.exports = ({visit, filter, getChildren, tree}) => {
        const stack = [], seen = new Map, next = () => {
          for (;stack.length; ) {
            const node = stack.pop(), res = visitNode(node);
            if (isPromise(res)) return res.then((() => next()));
          }
          return seen.get(tree);
        }, visitNode = visitTree => {
          if (seen.has(visitTree)) return seen.get(visitTree);
          seen.set(visitTree, null);
          const res = visit ? visit(visitTree) : visitTree;
          if (isPromise(res)) {
            const fullResult = res.then((resThen => (seen.set(visitTree, resThen), kidNodes(visitTree))));
            return seen.set(visitTree, fullResult), fullResult;
          }
          return seen.set(visitTree, res), kidNodes(visitTree);
        }, kidNodes = kidTree => {
          const kids = getChildren(kidTree, seen.get(kidTree));
          return isPromise(kids) ? kids.then(processKids) : processKids(kids);
        }, processKids = kids => {
          kids = (kids || []).filter(filter), stack.push(...kids);
        };
        return stack.push(tree), next();
      };
    },
    3162: (module, __unused_webpack_exports, __webpack_require__) => {
      const depthDescent = __webpack_require__(95267), depth = ({visit, leave, filter = () => !0, seen = new Map, getChildren, tree}) => {
        if (!leave) return depthDescent({
          visit,
          filter,
          getChildren,
          tree
        });
        if (seen.has(tree)) return seen.get(tree);
        seen.set(tree, null);
        const kidNodes = () => {
          const kids = getChildren(tree, seen.get(tree));
          return isPromise(kids) ? kids.then(processKids) : processKids(kids);
        }, processKids = nodes => {
          const kids = (nodes || []).filter(filter).map((kid => depth({
            visit,
            leave,
            filter,
            seen,
            getChildren,
            tree: kid
          })));
          return kids.some(isPromise) ? Promise.all(kids).then(leaveNode) : leaveNode(kids);
        }, leaveNode = kids => {
          const res = leave(seen.get(tree), kids);
          return seen.set(tree, res), res;
        };
        return (() => {
          const res = visit ? visit(tree) : tree;
          if (isPromise(res)) {
            const fullResult = res.then((resThen => (seen.set(tree, resThen), kidNodes())));
            return seen.set(tree, fullResult), fullResult;
          }
          return seen.set(tree, res), kidNodes();
        })();
      }, isPromise = p => p && "function" == typeof p.then;
      module.exports = depth;
    },
    75476: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = {
        breadth: __webpack_require__(39499),
        depth: __webpack_require__(3162)
      };
    },
    97439: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = __webpack_require__(73837).deprecate;
    },
    74980: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var scopedPackagePattern = new RegExp("^(?:@([^/]+?)[/])?([^/]+?)$"), builtins = __webpack_require__(78874), blacklist = [ "node_modules", "favicon.ico" ];
      var done = function(warnings, errors) {
        var result = {
          validForNewPackages: 0 === errors.length && 0 === warnings.length,
          validForOldPackages: 0 === errors.length,
          warnings,
          errors
        };
        return result.warnings.length || delete result.warnings, result.errors.length || delete result.errors, 
        result;
      };
      module.exports = function(name) {
        var warnings = [], errors = [];
        if (null === name) return errors.push("name cannot be null"), done(warnings, errors);
        if (void 0 === name) return errors.push("name cannot be undefined"), done(warnings, errors);
        if ("string" != typeof name) return errors.push("name must be a string"), done(warnings, errors);
        if (name.length || errors.push("name length must be greater than zero"), name.match(/^\./) && errors.push("name cannot start with a period"), 
        name.match(/^_/) && errors.push("name cannot start with an underscore"), name.trim() !== name && errors.push("name cannot contain leading or trailing spaces"), 
        blacklist.forEach((function(blacklistedName) {
          name.toLowerCase() === blacklistedName && errors.push(blacklistedName + " is a blacklisted name");
        })), builtins({
          version: "*"
        }).forEach((function(builtin) {
          name.toLowerCase() === builtin && warnings.push(builtin + " is a core module name");
        })), name.length > 214 && warnings.push("name can no longer contain more than 214 characters"), 
        name.toLowerCase() !== name && warnings.push("name can no longer contain capital letters"), 
        /[~'!()*]/.test(name.split("/").slice(-1)[0]) && warnings.push('name can no longer contain special characters ("~\'!()*")'), 
        encodeURIComponent(name) !== name) {
          var nameMatch = name.match(scopedPackagePattern);
          if (nameMatch) {
            var user = nameMatch[1], pkg = nameMatch[2];
            if (encodeURIComponent(user) === user && encodeURIComponent(pkg) === pkg) return done(warnings, errors);
          }
          errors.push("name can only contain URL-friendly characters");
        }
        return done(warnings, errors);
      };
    },
    43967: (module, __unused_webpack_exports, __webpack_require__) => {
      const {dirname, resolve} = __webpack_require__(71017);
      module.exports = function*(path) {
        for (path = resolve(path); path; ) {
          yield path;
          const pp = dirname(path);
          path = pp === path ? null : pp;
        }
      };
    },
    96912: module => {
      module.exports = [ [ 768, 879 ], [ 1155, 1158 ], [ 1160, 1161 ], [ 1425, 1469 ], [ 1471, 1471 ], [ 1473, 1474 ], [ 1476, 1477 ], [ 1479, 1479 ], [ 1536, 1539 ], [ 1552, 1557 ], [ 1611, 1630 ], [ 1648, 1648 ], [ 1750, 1764 ], [ 1767, 1768 ], [ 1770, 1773 ], [ 1807, 1807 ], [ 1809, 1809 ], [ 1840, 1866 ], [ 1958, 1968 ], [ 2027, 2035 ], [ 2305, 2306 ], [ 2364, 2364 ], [ 2369, 2376 ], [ 2381, 2381 ], [ 2385, 2388 ], [ 2402, 2403 ], [ 2433, 2433 ], [ 2492, 2492 ], [ 2497, 2500 ], [ 2509, 2509 ], [ 2530, 2531 ], [ 2561, 2562 ], [ 2620, 2620 ], [ 2625, 2626 ], [ 2631, 2632 ], [ 2635, 2637 ], [ 2672, 2673 ], [ 2689, 2690 ], [ 2748, 2748 ], [ 2753, 2757 ], [ 2759, 2760 ], [ 2765, 2765 ], [ 2786, 2787 ], [ 2817, 2817 ], [ 2876, 2876 ], [ 2879, 2879 ], [ 2881, 2883 ], [ 2893, 2893 ], [ 2902, 2902 ], [ 2946, 2946 ], [ 3008, 3008 ], [ 3021, 3021 ], [ 3134, 3136 ], [ 3142, 3144 ], [ 3146, 3149 ], [ 3157, 3158 ], [ 3260, 3260 ], [ 3263, 3263 ], [ 3270, 3270 ], [ 3276, 3277 ], [ 3298, 3299 ], [ 3393, 3395 ], [ 3405, 3405 ], [ 3530, 3530 ], [ 3538, 3540 ], [ 3542, 3542 ], [ 3633, 3633 ], [ 3636, 3642 ], [ 3655, 3662 ], [ 3761, 3761 ], [ 3764, 3769 ], [ 3771, 3772 ], [ 3784, 3789 ], [ 3864, 3865 ], [ 3893, 3893 ], [ 3895, 3895 ], [ 3897, 3897 ], [ 3953, 3966 ], [ 3968, 3972 ], [ 3974, 3975 ], [ 3984, 3991 ], [ 3993, 4028 ], [ 4038, 4038 ], [ 4141, 4144 ], [ 4146, 4146 ], [ 4150, 4151 ], [ 4153, 4153 ], [ 4184, 4185 ], [ 4448, 4607 ], [ 4959, 4959 ], [ 5906, 5908 ], [ 5938, 5940 ], [ 5970, 5971 ], [ 6002, 6003 ], [ 6068, 6069 ], [ 6071, 6077 ], [ 6086, 6086 ], [ 6089, 6099 ], [ 6109, 6109 ], [ 6155, 6157 ], [ 6313, 6313 ], [ 6432, 6434 ], [ 6439, 6440 ], [ 6450, 6450 ], [ 6457, 6459 ], [ 6679, 6680 ], [ 6912, 6915 ], [ 6964, 6964 ], [ 6966, 6970 ], [ 6972, 6972 ], [ 6978, 6978 ], [ 7019, 7027 ], [ 7616, 7626 ], [ 7678, 7679 ], [ 8203, 8207 ], [ 8234, 8238 ], [ 8288, 8291 ], [ 8298, 8303 ], [ 8400, 8431 ], [ 12330, 12335 ], [ 12441, 12442 ], [ 43014, 43014 ], [ 43019, 43019 ], [ 43045, 43046 ], [ 64286, 64286 ], [ 65024, 65039 ], [ 65056, 65059 ], [ 65279, 65279 ], [ 65529, 65531 ], [ 68097, 68099 ], [ 68101, 68102 ], [ 68108, 68111 ], [ 68152, 68154 ], [ 68159, 68159 ], [ 119143, 119145 ], [ 119155, 119170 ], [ 119173, 119179 ], [ 119210, 119213 ], [ 119362, 119364 ], [ 917505, 917505 ], [ 917536, 917631 ], [ 917760, 917999 ] ];
    },
    7656: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var defaults = __webpack_require__(21338), combining = __webpack_require__(96912), DEFAULTS = {
        nul: 0,
        control: 0
      };
      function wcswidth(str, opts) {
        if ("string" != typeof str) return wcwidth(str, opts);
        for (var s = 0, i = 0; i < str.length; i++) {
          var n = wcwidth(str.charCodeAt(i), opts);
          if (n < 0) return -1;
          s += n;
        }
        return s;
      }
      function wcwidth(ucs, opts) {
        return 0 === ucs ? opts.nul : ucs < 32 || ucs >= 127 && ucs < 160 ? opts.control : function(ucs) {
          var mid, min = 0, max = combining.length - 1;
          if (ucs < combining[0][0] || ucs > combining[max][1]) return !1;
          for (;max >= min; ) if (mid = Math.floor((min + max) / 2), ucs > combining[mid][1]) min = mid + 1; else {
            if (!(ucs < combining[mid][0])) return !0;
            max = mid - 1;
          }
          return !1;
        }(ucs) ? 0 : 1 + (ucs >= 4352 && (ucs <= 4447 || 9001 == ucs || 9002 == ucs || ucs >= 11904 && ucs <= 42191 && 12351 != ucs || ucs >= 44032 && ucs <= 55203 || ucs >= 63744 && ucs <= 64255 || ucs >= 65040 && ucs <= 65049 || ucs >= 65072 && ucs <= 65135 || ucs >= 65280 && ucs <= 65376 || ucs >= 65504 && ucs <= 65510 || ucs >= 131072 && ucs <= 196605 || ucs >= 196608 && ucs <= 262141));
      }
      module.exports = function(str) {
        return wcswidth(str, DEFAULTS);
      }, module.exports.config = function(opts) {
        return opts = defaults(opts || {}, DEFAULTS), function(str) {
          return wcswidth(str, opts);
        };
      };
    },
    7017: (module, __unused_webpack_exports, __webpack_require__) => {
      const isWindows = "win32" === process.platform || "cygwin" === process.env.OSTYPE || "msys" === process.env.OSTYPE, path = __webpack_require__(71017), COLON = isWindows ? ";" : ":", isexe = __webpack_require__(23789), getNotFoundError = cmd => Object.assign(new Error(`not found: ${cmd}`), {
        code: "ENOENT"
      }), getPathInfo = (cmd, opt) => {
        const colon = opt.colon || COLON, pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [ "" ] : [ ...isWindows ? [ process.cwd() ] : [], ...(opt.path || process.env.PATH || "").split(colon) ], pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "", pathExt = isWindows ? pathExtExe.split(colon) : [ "" ];
        return isWindows && -1 !== cmd.indexOf(".") && "" !== pathExt[0] && pathExt.unshift(""), 
        {
          pathEnv,
          pathExt,
          pathExtExe
        };
      }, which = (cmd, opt, cb) => {
        "function" == typeof opt && (cb = opt, opt = {}), opt || (opt = {});
        const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt), found = [], step = i => new Promise(((resolve, reject) => {
          if (i === pathEnv.length) return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
          const ppRaw = pathEnv[i], pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw, pCmd = path.join(pathPart, cmd), p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
          resolve(subStep(p, i, 0));
        })), subStep = (p, i, ii) => new Promise(((resolve, reject) => {
          if (ii === pathExt.length) return resolve(step(i + 1));
          const ext = pathExt[ii];
          isexe(p + ext, {
            pathExt: pathExtExe
          }, ((er, is) => {
            if (!er && is) {
              if (!opt.all) return resolve(p + ext);
              found.push(p + ext);
            }
            return resolve(subStep(p, i, ii + 1));
          }));
        }));
        return cb ? step(0).then((res => cb(null, res)), cb) : step(0);
      };
      module.exports = which, which.sync = (cmd, opt) => {
        opt = opt || {};
        const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt), found = [];
        for (let i = 0; i < pathEnv.length; i++) {
          const ppRaw = pathEnv[i], pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw, pCmd = path.join(pathPart, cmd), p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
          for (let j = 0; j < pathExt.length; j++) {
            const cur = p + pathExt[j];
            try {
              if (isexe.sync(cur, {
                pathExt: pathExtExe
              })) {
                if (!opt.all) return cur;
                found.push(cur);
              }
            } catch (ex) {}
          }
        }
        if (opt.all && found.length) return found;
        if (opt.nothrow) return null;
        throw getNotFoundError(cmd);
      };
    },
    68839: module => {
      module.exports = function wrappy(fn, cb) {
        if (fn && cb) return wrappy(fn)(cb);
        if ("function" != typeof fn) throw new TypeError("need wrapper function");
        return Object.keys(fn).forEach((function(k) {
          wrapper[k] = fn[k];
        })), wrapper;
        function wrapper() {
          for (var args = new Array(arguments.length), i = 0; i < args.length; i++) args[i] = arguments[i];
          var ret = fn.apply(this, args), cb = args[args.length - 1];
          return "function" == typeof ret && ret !== cb && Object.keys(cb).forEach((function(k) {
            ret[k] = cb[k];
          })), ret;
        }
      };
    },
    27610: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = async function(filename, data, options, callback) {
        options instanceof Function && (callback = options, options = {});
        const promise = async function(filename, data, options = {}) {
          "string" == typeof options && (options = {
            encoding: options
          });
          let fd, tmpfile;
          const removeOnExitHandler = onExit(cleanupOnExit((() => tmpfile))), absoluteName = path.resolve(filename);
          try {
            await function(absoluteName) {
              return new Promise((resolve => {
                activeFiles[absoluteName] || (activeFiles[absoluteName] = []), activeFiles[absoluteName].push(resolve), 
                1 === activeFiles[absoluteName].length && resolve();
              }));
            }(absoluteName);
            const truename = await promisify(fs.realpath)(filename).catch((() => filename));
            if (tmpfile = getTmpname(truename), !options.mode || !options.chown) {
              const stats = await promisify(fs.stat)(truename).catch((() => {}));
              stats && (null == options.mode && (options.mode = stats.mode), null == options.chown && process.getuid && (options.chown = {
                uid: stats.uid,
                gid: stats.gid
              }));
            }
            fd = await promisify(fs.open)(tmpfile, "w", options.mode), options.tmpfileCreated && await options.tmpfileCreated(tmpfile), 
            ArrayBuffer.isView(data) ? await promisify(fs.write)(fd, data, 0, data.length, 0) : null != data && await promisify(fs.write)(fd, String(data), 0, String(options.encoding || "utf8")), 
            !1 !== options.fsync && await promisify(fs.fsync)(fd), await promisify(fs.close)(fd), 
            fd = null, options.chown && await promisify(fs.chown)(tmpfile, options.chown.uid, options.chown.gid).catch((err => {
              if (!isChownErrOk(err)) throw err;
            })), options.mode && await promisify(fs.chmod)(tmpfile, options.mode).catch((err => {
              if (!isChownErrOk(err)) throw err;
            })), await promisify(fs.rename)(tmpfile, truename);
          } finally {
            fd && await promisify(fs.close)(fd).catch((() => {})), removeOnExitHandler(), await promisify(fs.unlink)(tmpfile).catch((() => {})), 
            activeFiles[absoluteName].shift(), activeFiles[absoluteName].length > 0 ? activeFiles[absoluteName][0]() : delete activeFiles[absoluteName];
          }
        }(filename, data, options);
        if (callback) try {
          const result = await promise;
          return callback(result);
        } catch (err) {
          return callback(err);
        }
        return promise;
      }, module.exports.sync = function(filename, data, options) {
        "string" == typeof options ? options = {
          encoding: options
        } : options || (options = {});
        try {
          filename = fs.realpathSync(filename);
        } catch (ex) {}
        const tmpfile = getTmpname(filename);
        if (!options.mode || !options.chown) try {
          const stats = fs.statSync(filename);
          (options = Object.assign({}, options)).mode || (options.mode = stats.mode), !options.chown && process.getuid && (options.chown = {
            uid: stats.uid,
            gid: stats.gid
          });
        } catch (ex) {}
        let fd;
        const cleanup = cleanupOnExit(tmpfile), removeOnExitHandler = onExit(cleanup);
        let threw = !0;
        try {
          if (fd = fs.openSync(tmpfile, "w", options.mode || 438), options.tmpfileCreated && options.tmpfileCreated(tmpfile), 
          ArrayBuffer.isView(data) ? fs.writeSync(fd, data, 0, data.length, 0) : null != data && fs.writeSync(fd, String(data), 0, String(options.encoding || "utf8")), 
          !1 !== options.fsync && fs.fsyncSync(fd), fs.closeSync(fd), fd = null, options.chown) try {
            fs.chownSync(tmpfile, options.chown.uid, options.chown.gid);
          } catch (err) {
            if (!isChownErrOk(err)) throw err;
          }
          if (options.mode) try {
            fs.chmodSync(tmpfile, options.mode);
          } catch (err) {
            if (!isChownErrOk(err)) throw err;
          }
          fs.renameSync(tmpfile, filename), threw = !1;
        } finally {
          if (fd) try {
            fs.closeSync(fd);
          } catch (ex) {}
          removeOnExitHandler(), threw && cleanup();
        }
      }, module.exports._getTmpname = getTmpname, module.exports._cleanupOnExit = cleanupOnExit;
      const fs = __webpack_require__(57147), MurmurHash3 = __webpack_require__(287), onExit = __webpack_require__(20459), path = __webpack_require__(71017), {promisify} = __webpack_require__(73837), activeFiles = {}, threadId = function() {
        try {
          return __webpack_require__(71267).threadId;
        } catch (e) {
          return 0;
        }
      }();
      let invocations = 0;
      function getTmpname(filename) {
        return filename + "." + MurmurHash3(__filename).hash(String(process.pid)).hash(String(threadId)).hash(String(++invocations)).result();
      }
      function cleanupOnExit(tmpfile) {
        return () => {
          try {
            fs.unlinkSync("function" == typeof tmpfile ? tmpfile() : tmpfile);
          } catch {}
        };
      }
      function isChownErrOk(err) {
        if ("ENOSYS" === err.code) return !0;
        return !(process.getuid && 0 === process.getuid() || "EINVAL" !== err.code && "EPERM" !== err.code);
      }
    },
    1759: (module, __unused_webpack_exports, __webpack_require__) => {
      const {promisify} = __webpack_require__(73837), fs = __webpack_require__(57147), readFile = promisify(fs.readFile), lstat = promisify(fs.lstat), readdir = promisify(fs.readdir), parse = __webpack_require__(40295), {resolve, dirname, join, relative} = __webpack_require__(71017), rpj = path => readFile(path, "utf8").then((data => readBinDir(path, normalize(stripUnderscores(parse(data)))))).catch((er => {
        throw er.path = path, er;
      })), normalizePackageBin = __webpack_require__(63697), readBinDir = async (path, data) => {
        if (data.bin) return data;
        const m = data.directories && data.directories.bin;
        if (!m || "string" != typeof m) return data;
        const root = dirname(path), dir = join(".", join("/", m));
        return data.bin = await walkBinDir(root, dir, {}), data;
      }, walkBinDir = async (root, dir, obj) => {
        const entries = await readdir(resolve(root, dir)).catch((() => []));
        for (const entry of entries) {
          if ("." === entry.charAt(0)) continue;
          const f = resolve(root, dir, entry), st = await lstat(f).catch((() => null));
          st && (st.isFile() ? obj[entry] = relative(root, f) : st.isDirectory() && await walkBinDir(root, join(dir, entry), obj));
        }
        return obj;
      }, stripUnderscores = data => {
        for (const key of Object.keys(data).filter((k => /^_/.test(k)))) delete data[key];
        return data;
      }, normalize = data => (add_id(data), fixBundled(data), pruneRepeatedOptionals(data), 
      fixScripts(data), fixFunding(data), normalizePackageBin(data), data);
      rpj.normalize = normalize;
      const add_id = data => (data.name && data.version && (data._id = `${data.name}@${data.version}`), 
      data), pruneRepeatedOptionals = data => {
        const od = data.optionalDependencies, dd = data.dependencies || {};
        if (od && "object" == typeof od) for (const name of Object.keys(od)) delete dd[name];
        return 0 === Object.keys(dd).length && delete data.dependencies, data;
      }, fixBundled = data => {
        const bdd = data.bundledDependencies, bd = void 0 === data.bundleDependencies ? bdd : data.bundleDependencies;
        return !1 === bd ? data.bundleDependencies = [] : !0 === bd ? data.bundleDependencies = Object.keys(data.dependencies || {}) : bd && "object" == typeof bd ? Array.isArray(bd) ? data.bundleDependencies = bd : data.bundleDependencies = Object.keys(bd) : delete data.bundleDependencies, 
        delete data.bundledDependencies, data;
      }, fixScripts = data => {
        if (!data.scripts || "object" != typeof data.scripts) return delete data.scripts, 
        data;
        for (const [name, script] of Object.entries(data.scripts)) "string" != typeof script && delete data.scripts[name];
        return data;
      }, fixFunding = data => (data.funding && "string" == typeof data.funding && (data.funding = {
        url: data.funding
      }), data);
      module.exports = rpj;
    },
    62968: (module, __unused_webpack_exports, __webpack_require__) => {
      const {resolve, dirname, delimiter} = __webpack_require__(71017), nodeGypPath = resolve(__dirname, "../bin/node-gyp-bin");
      module.exports = (projectPath, binPaths, env) => {
        const PATH = Object.keys(env).filter((p => /^path$/i.test(p) && env[p])).map((p => env[p].split(delimiter))).reduce(((set, p) => set.concat(p.filter((concatted => !set.includes(concatted))))), []).join(delimiter), pathArr = [];
        binPaths && pathArr.push(...binPaths);
        let pp, p = projectPath;
        do {
          pathArr.push(resolve(p, "node_modules", ".bin")), pp = p, p = dirname(p);
        } while (p !== pp);
        pathArr.push(nodeGypPath, PATH);
        const pathVal = pathArr.join(delimiter);
        for (const key of Object.keys(env)) /^path$/i.test(key) && (env[key] = pathVal);
        return env;
      };
    },
    88760: (module, __unused_webpack_exports, __webpack_require__) => {
      const {dirname} = __webpack_require__(71017), {commands} = __webpack_require__(34456), localeCompare = __webpack_require__(51031)("en");
      module.exports = async npm => {
        const usesBrowser = "browser" === npm.config.get("viewer") ? " (in a browser)" : "";
        return `npm <command>\n\nUsage:\n\nnpm install        install all the dependencies in your project\nnpm install <foo>  add the <foo> dependency to your project\nnpm test           run this project's tests\nnpm run <foo>      run the script named <foo>\nnpm <command> -h   quick help on <command>\nnpm -l             display usage info for all commands\nnpm help <term>    search for help on <term>${usesBrowser}\nnpm help npm       more involved overview${usesBrowser}\n\nAll commands:\n${await allCommands(npm)}\n\nSpecify configs in the ini-formatted file:\n    ${npm.config.get("userconfig")}\nor on the command line via: npm <command> --key=value\n\nMore configuration info: npm help config\nConfiguration fields: npm help 7 config\n\nnpm@${npm.version} ${dirname(__dirname)}`;
      };
      const allCommands = async npm => npm.config.get("long") ? usages(npm) : "\n    " + wrap(commands), wrap = arr => {
        const out = [ "" ], line = process.stdout.columns ? Math.min(60, Math.max(process.stdout.columns - 16, 24)) : 60;
        let l = 0;
        for (const c of arr) out[l].length + c.length + 2 < line ? out[l] += ", " + c : (out[l++] += ",", 
        out[l] = c);
        return out.join("\n    ").slice(2);
      }, usages = async npm => {
        let maxLen = 0;
        const set = [];
        for (const c of commands) {
          const cmd = await npm.cmd(c);
          set.push([ c, cmd.usage ]), maxLen = Math.max(maxLen, c.length);
        }
        return set.sort((([a], [b]) => localeCompare(a, b))).map((([c, usage]) => `\n    ${c}${" ".repeat(maxLen - c.length + 1)}${usage.split("\n").join("\n" + " ".repeat(maxLen + 5))}`)).join("\n");
      };
    },
    24744: (module, __unused_webpack_exports, __webpack_require__) => {
      const fs = __webpack_require__(45264), nopt = __webpack_require__(69892), {definitions, shorthands} = __webpack_require__(70506), {aliases, commands, plumbing} = __webpack_require__(34456), aliasNames = Object.keys(aliases), fullList = commands.concat(aliasNames).filter((c => !plumbing.includes(c))), configNames = Object.keys(definitions), shorthandNames = Object.keys(shorthands), allConfs = configNames.concat(shorthandNames), {isWindowsShell} = __webpack_require__(52290), fileExists = async file => {
        try {
          return (await fs.stat(file)).isFile();
        } catch {
          return !1;
        }
      }, BaseCommand = __webpack_require__(26727);
      const dumpScript = async () => {
        const {resolve} = __webpack_require__(71017), p = resolve(__dirname, "utils", "completion.sh"), d = (await fs.readFile(p, "utf8")).replace(/^#!.*?\n/, "");
        await new Promise(((res, rej) => {
          let done = !1;
          process.stdout.on("error", (er => {
            done || (done = !0, "EPIPE" === er.errno ? res() : rej(er));
          })), process.stdout.write(d, (() => {
            done || (done = !0, res());
          }));
        }));
      }, unescape = w => "'" === w.charAt(0) ? w.replace(/^'|'$/g, "") : w.replace(/\\ /g, " "), configCompl = opts => {
        const split = opts.word.match(/^(-+)((?:no-)*)(.*)$/), dashes = split[1], no = split[2], flags = configNames.filter(isFlag);
        return allConfs.map((c => dashes + c)).concat(flags.map((f => dashes + (no || "no-") + f)));
      }, configValueCompl = opts => [], isFlag = word => {
        const split = word.match(/^(-*)((?:no-)+)?(.*)$/), no = split[2], conf = split[3], {type} = definitions[conf];
        return no || type === Boolean || Array.isArray(type) && type.includes(Boolean) || shorthands[conf];
      }, cmdCompl = (opts, npm) => {
        const matches = fullList.filter((c => c.startsWith(opts.partialWord)));
        if (!matches.length) return matches;
        const derefs = new Set([ ...matches.map((c => npm.deref(c))) ]);
        return 1 === derefs.size ? [ ...derefs ] : fullList;
      };
      module.exports = class extends BaseCommand {
        static description="Tab Completion for npm";
        static name="completion";
        static ignoreImplicitWorkspace=!1;
        async completion(opts) {
          if (opts.w > 2) return;
          const {resolve} = __webpack_require__(71017), [bashExists, zshExists] = await Promise.all([ fileExists(resolve(process.env.HOME, ".bashrc")), fileExists(resolve(process.env.HOME, ".zshrc")) ]), out = [];
          return zshExists && out.push([ ">>", "~/.zshrc" ]), bashExists && out.push([ ">>", "~/.bashrc" ]), 
          out;
        }
        async exec(args) {
          if (isWindowsShell) {
            const msg = "npm completion supported only in MINGW / Git bash on Windows";
            throw Object.assign(new Error(msg), {
              code: "ENOTSUP"
            });
          }
          const {COMP_CWORD, COMP_LINE, COMP_POINT} = process.env;
          if (void 0 === COMP_CWORD || void 0 === COMP_LINE || void 0 === COMP_POINT) return dumpScript();
          const w = +COMP_CWORD, words = args.map(unescape), word = words[w], line = COMP_LINE, point = +COMP_POINT, partialLine = line.slice(0, point), partialWords = words.slice(0, w), partialWordRaw = args[w];
          let i = partialWordRaw.length;
          for (;partialWordRaw.slice(0, i) !== partialLine.slice(-1 * i) && i > 0; ) i--;
          const partialWord = unescape(partialWordRaw.slice(0, i));
          partialWords.push(partialWord);
          const opts = {
            words,
            w,
            word,
            line,
            lineLength: line.length,
            point,
            partialLine,
            partialWords,
            partialWord,
            raw: args
          };
          if (-1 === partialWords.slice(0, -1).indexOf("--")) {
            if ("-" === word.charAt(0)) return this.wrap(opts, configCompl(opts));
            if (words[w - 1] && "-" === words[w - 1].charAt(0) && !isFlag(words[w - 1])) return this.wrap(opts, configValueCompl(opts));
          }
          const types = Object.entries(definitions).reduce(((types, [key, def]) => (types[key] = def.type, 
          types)), {}), parsed = opts.conf = nopt(types, shorthands, partialWords.slice(0, -1), 0), cmd = parsed.argv.remain[1];
          if (!cmd) return this.wrap(opts, cmdCompl(opts, this.npm));
          Object.keys(parsed).forEach((k => this.npm.config.set(k, parsed[k])));
          const impl = await this.npm.cmd(cmd);
          if (impl.completion) {
            const comps = await impl.completion(opts);
            return this.wrap(opts, comps);
          }
        }
        wrap(opts, compls) {
          opts.partialWord && (compls = compls.filter((c => c.startsWith(opts.partialWord)))), 
          compls.length > 0 && this.npm.output(compls.join("\n"));
        }
      };
    },
    61423: (module, __unused_webpack_exports, __webpack_require__) => {
      const fs = __webpack_require__(57147), path = __webpack_require__(71017), chalk = __webpack_require__(25433), {promisify} = __webpack_require__(73837), glob = promisify(__webpack_require__(34436)), readFile = promisify(fs.readFile), BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static description="Search npm help documentation";
        static name="help-search";
        static usage=[ "<text>" ];
        static params=[ "long" ];
        static ignoreImplicitWorkspace=!0;
        async exec(args) {
          if (!args.length) throw this.usageError();
          const docPath = path.resolve(__dirname, "..", "docs/content"), files = await glob(`${pattern = docPath, 
          pattern.split("\\").join("/")}/*/*.md`);
          var pattern;
          const data = await this.readFiles(files), results = await this.searchFiles(args, data, files), formatted = this.formatResults(args, results);
          formatted.trim() ? this.npm.output(formatted) : this.npm.output(`No matches in help for: ${args.join(" ")}\n`);
        }
        async readFiles(files) {
          const res = {};
          return await Promise.all(files.map((async file => {
            res[file] = (await readFile(file, "utf8")).replace(/^---\n(.*\n)*?---\n/, "").trim();
          }))), res;
        }
        async searchFiles(args, data, files) {
          const results = [];
          for (const [file, content] of Object.entries(data)) {
            const lowerCase = content.toLowerCase();
            if (!args.some((a => lowerCase.includes(a.toLowerCase())))) continue;
            const lines = content.split(/\n+/);
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i], nextLine = lines[i + 1];
              let match = !1;
              nextLine && (match = args.some((a => nextLine.toLowerCase().includes(a.toLowerCase()))), 
              match) ? i += 2 : (match = args.some((a => line.toLowerCase().includes(a.toLowerCase()))), 
              match ? i++ : lines[i] = null);
            }
            const pruned = lines.reduce(((l, r) => (null === r && null === l[l.length - 1] || l.push(r), 
            l)), []);
            null === pruned[pruned.length - 1] && pruned.pop(), null === pruned[0] && pruned.shift();
            const found = {};
            let totalHits = 0;
            for (const line of pruned) for (const arg of args) {
              const hit = (line || "").toLowerCase().split(arg.toLowerCase()).length - 1;
              hit > 0 && (found[arg] = (found[arg] || 0) + hit, totalHits += hit);
            }
            const cmd = "npm help " + path.basename(file, ".md").replace(/^npm-/, "");
            results.push({
              file,
              cmd,
              lines: pruned,
              found: Object.keys(found),
              hits: found,
              totalHits
            });
          }
          return results.sort(((a, b) => a.found.length > b.found.length ? -1 : a.found.length < b.found.length ? 1 : a.totalHits > b.totalHits ? -1 : a.totalHits < b.totalHits ? 1 : a.lines.length > b.lines.length ? -1 : a.lines.length < b.lines.length ? 1 : 0)).slice(0, 10);
        }
        formatResults(args, results) {
          const cols = Math.min(process.stdout.columns || 1 / 0, 80) + 1, out = results.map((res => {
            const out = [ res.cmd ], r = Object.keys(res.hits).map((k => `${k}:${res.hits[k]}`)).sort(((a, b) => a > b ? 1 : -1)).join(" ");
            return out.push(" ".repeat(Math.max(1, cols - out.join(" ").length - r.length - 1))), 
            out.push(r), this.npm.config.get("long") ? (out.unshift("\n\n"), out.push("\n"), 
            out.push("-".repeat(cols - 1) + "\n"), res.lines.forEach(((line, i) => {
              if (null === line || i > 3) return;
              if (!this.npm.color) return void out.push(line + "\n");
              const hilitLine = [];
              for (const arg of args) {
                const finder = line.toLowerCase().split(arg.toLowerCase());
                let p = 0;
                for (const f of finder) {
                  hilitLine.push(line.slice(p, p + f.length));
                  const word = line.slice(p + f.length, p + f.length + arg.length), hilit = chalk.bgBlack.red(word);
                  hilitLine.push(hilit), p += f.length + arg.length;
                }
              }
              out.push(hilitLine.join("") + "\n");
            })), out.join("")) : out.join("");
          })).join("\n");
          return (results.length && !this.npm.config.get("long") ? "Top hits for " + args.map(JSON.stringify).join(" ") + "\n" + "".repeat(cols - 1) + "\n" + out + "\n" + "".repeat(cols - 1) + "\n(run with -l or --long to see more context)" : out).trim();
        }
      };
    },
    17240: (module, __unused_webpack_exports, __webpack_require__) => {
      const {spawn} = __webpack_require__(32081), path = __webpack_require__(71017), openUrl = __webpack_require__(89562), {promisify} = __webpack_require__(73837), glob = promisify(__webpack_require__(34436)), localeCompare = __webpack_require__(51031)("en"), globify = pattern => pattern.split("\\").join("/"), BaseCommand = __webpack_require__(26727), manNumberRegex = /\.(\d+)(\.[^/\\]*)?$/, manNpmPrefixRegex = /\/npm-/;
      module.exports = class extends BaseCommand {
        static description="Get help on npm";
        static name="help";
        static usage=[ "<term> [<terms..>]" ];
        static params=[ "viewer" ];
        static ignoreImplicitWorkspace=!0;
        async completion(opts) {
          if (opts.conf.argv.remain.length > 2) return [];
          const g = path.resolve(__dirname, "../man/man[0-9]/*.[0-9]"), files = await glob(globify(g));
          return Object.keys(files.reduce((function(acc, file) {
            return acc[file = (file = path.basename(file).replace(/\.[0-9]+$/, "")).replace(/^npm-/, "")] = !0, 
            acc;
          }), {
            help: !0
          }));
        }
        async exec(args) {
          let manSearch = "man*";
          if (/^\d+$/.test(args[0]) && (manSearch = `man${args.shift()}`), !args.length) return this.npm.output(await this.npm.usage);
          if (args.length > 1) return this.helpSearch(args);
          let section = this.npm.deref(args[0]) || args[0];
          section = section.replace(".json", "-json");
          const f = `${path.resolve(__dirname, "..", "man")}/${manSearch}/?(npm-)${section}.[0-9]*`;
          let mans = await glob(globify(f));
          mans = mans.sort(((a, b) => {
            const aHasPrefix = manNpmPrefixRegex.test(a);
            if (aHasPrefix !== manNpmPrefixRegex.test(b)) return aHasPrefix ? -1 : 1;
            const aManNumberMatch = a.match(manNumberRegex), bManNumberMatch = b.match(manNumberRegex);
            if (aManNumberMatch) {
              if (!bManNumberMatch) return -1;
              if (aManNumberMatch[1] !== bManNumberMatch[1]) return aManNumberMatch[1] - bManNumberMatch[1];
            } else if (bManNumberMatch) return 1;
            return localeCompare(a, b);
          }));
          const man = mans[0];
          if (!man) return this.helpSearch(args);
          await this.viewMan(man);
        }
        helpSearch(args) {
          return this.npm.exec("help-search", args);
        }
        async viewMan(man) {
          const env = {};
          Object.keys(process.env).forEach((function(i) {
            env[i] = process.env[i];
          }));
          const viewer = this.npm.config.get("viewer"), opts = {
            env,
            stdio: "inherit"
          };
          let bin = "man";
          const args = [];
          switch (viewer) {
           case "woman":
            bin = "emacsclient", args.push("-e", `(woman-find-file '${man}')`);
            break;

           case "browser":
            return void await openUrl(this.npm, this.htmlMan(man), "help available at the following URL", !0);

           default:
            args.push(man);
          }
          const proc = spawn(bin, args, opts);
          return new Promise(((resolve, reject) => {
            proc.on("exit", (code => code ? reject(new Error(`help process exited with code: ${code}`)) : resolve()));
          }));
        }
        htmlMan(man) {
          let sect = man.match(manNumberRegex)[1];
          const f = path.basename(man).replace(manNumberRegex, "");
          switch (sect) {
           case "1":
            sect = "commands";
            break;

           case "5":
            sect = "configuring-npm";
            break;

           case "7":
            sect = "using-npm";
          }
          return "file:///" + path.resolve(__dirname, "..", "docs", "output", sect, f + ".html");
        }
      };
    },
    37477: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = function(dir, input, config, cb) {
        "function" == typeof config && (cb = config, config = {});
        if ("function" != typeof config.get) {
          var data = config;
          config = {
            get: function(k) {
              return data[k];
            },
            toJSON: function() {
              return data;
            }
          };
        }
        var pkg, packageFile = path.resolve(dir, "package.json");
        input = path.resolve(input);
        var ctx = {
          yes: yes(config)
        }, es = readJson.extraSet;
        readJson.extraSet = es.filter((function(fn) {
          return "authors" !== fn.name && "mans" !== fn.name;
        })), readJson(packageFile, (function(er, d) {
          readJson.extraSet = es, pkg = er ? {} : d, ctx.filename = packageFile, ctx.dirname = path.dirname(packageFile), 
          ctx.basename = path.basename(ctx.dirname), pkg.version && semver.valid(pkg.version) || delete pkg.version, 
          ctx.package = pkg, ctx.config = config || {};
          var pz = new PZ(input, ctx);
          pz.backupFile = def, pz.on("error", cb), pz.on("data", (function(pzData) {
            Object.keys(pzData).forEach((function(k) {
              void 0 !== pzData[k] && null !== pzData[k] && (pkg[k] = pzData[k]);
            })), es = readJson.extraSet, readJson.extraSet = es.filter((function(fn) {
              return "authors" !== fn.name && "mans" !== fn.name;
            })), readJson.extras(packageFile, pkg, (function(extrasErr, pkgWithExtras) {
              if (extrasErr) return cb(extrasErr, pkgWithExtras);
              readJson.extraSet = es, pkgWithExtras = function(data) {
                data.author && (data.author = unParsePerson(data.author));
                return [ "maintainers", "contributors" ].forEach((function(set) {
                  Array.isArray(data[set]) && (data[set] = data[set].map(unParsePerson));
                })), data;
              }(pkgWithExtras), delete pkgWithExtras.readme, delete pkgWithExtras.readmeFilename, 
              delete pkgWithExtras._id, delete pkgWithExtras.gitHead, pkgWithExtras.repository || delete pkgWithExtras.repository, 
              pkgWithExtras.description || (pkgWithExtras.description = pzData.description);
              var stringified = JSON.stringify(function(depsData) {
                if (depsData.dependencies) {
                  if (depsData.optionalDependencies) for (const name of Object.keys(depsData.optionalDependencies)) delete depsData.dependencies[name];
                  0 === Object.keys(depsData.dependencies).length && delete depsData.dependencies;
                }
                return depsData;
              }(pkgWithExtras), null, 2) + "\n";
              function write(writeYes) {
                fs.writeFile(packageFile, stringified, "utf8", (function(writeFileErr) {
                  return writeFileErr || !writeYes || config.get("silent") || console.log("Wrote to %s:\n\n%s\n", packageFile, stringified), 
                  cb(writeFileErr, pkgWithExtras);
                }));
              }
              if (ctx.yes) return write(!0);
              console.log("About to write to %s:\n\n%s\n", packageFile, stringified), read({
                prompt: "Is this OK? ",
                default: "yes"
              }, (function(promptErr, ok) {
                return promptErr ? cb(promptErr) : ok && "y" === ok.toLowerCase().charAt(0) ? write() : void console.log("Aborted.");
              }));
            }));
          }));
        }));
      }, module.exports.yes = yes;
      var PZ = __webpack_require__(854).PromZard, path = __webpack_require__(71017), def = path.join(__dirname, "init-package-json.js"), fs = __webpack_require__(57147), semver = __webpack_require__(5870), read = __webpack_require__(9547), readJson = __webpack_require__(62965);
      function yes(conf) {
        return !!(conf.get("yes") || conf.get("y") || conf.get("force") || conf.get("f"));
      }
      function unParsePerson(person) {
        if ("string" == typeof person) return person;
        var name = person.name || "", u = person.url || person.web, url = u ? " (" + u + ")" : "", e = person.email || person.mail;
        return name + (e ? " <" + e + ">" : "") + url;
      }
    },
    18700: (module, __unused_webpack_exports, __webpack_require__) => {
      const definitions = {};
      module.exports = definitions;
      const Definition = __webpack_require__(1726), log = __webpack_require__(86883), npmVersion = __webpack_require__(2401).i8, ciName = __webpack_require__(21811)(), querystring = __webpack_require__(63477), {isWindows} = __webpack_require__(52290), {join} = __webpack_require__(71017), fs = __webpack_require__(57147), editor = process.env.EDITOR || process.env.VISUAL || (isWindows ? "notepad.exe" : "vi"), shell = isWindows ? process.env.ComSpec || "cmd" : process.env.SHELL || "sh", {tmpdir, networkInterfaces} = __webpack_require__(22037), unicode = /UTF-?8$/i.test(process.env.LC_ALL || process.env.LC_CTYPE || process.env.LANG), cache = `${isWindows && process.env.LOCALAPPDATA || "~"}/${isWindows ? "npm-cache" : ".npm"}`, Config = __webpack_require__(18919), {typeDefs: {semver: {type: semver}, Umask: {type: Umask}, url: {type: url}, path: {type: path}}} = Config, define = (key, def) => {
        if (definitions[key]) throw new Error(`defining key more than once: ${key}`);
        definitions[key] = new Definition(key, def);
      }, flatten = (key, obj, flatOptions) => {
        flatOptions[key.replace(/-([a-z])/g, ((_0, _1) => _1.toUpperCase()))] = obj[key];
      };
      define("_auth", {
        default: null,
        type: [ null, String ],
        description: '\n    A basic-auth string to use when authenticating against the npm registry.\n    This will ONLY be used to authenticate against the npm registry.  For other\n    registries you will need to scope it like "//other-registry.tld/:_auth"\n\n    Warning: This should generally not be set via a command-line option.  It\n    is safer to use a registry-provided authentication bearer token stored in\n    the ~/.npmrc file by running `npm login`.\n  ',
        flatten
      }), define("access", {
        default: null,
        defaultDescription: "\n    'restricted' for scoped packages, 'public' for unscoped packages\n  ",
        type: [ null, "restricted", "public" ],
        description: "\n    When publishing scoped packages, the access level defaults to\n    `restricted`.  If you want your scoped package to be publicly viewable\n    (and installable) set `--access=public`. The only valid values for\n    `access` are `public` and `restricted`. Unscoped packages _always_\n    have an access level of `public`.\n\n    Note: Using the `--access` flag on the `npm publish` command will only\n    set the package access level on the initial publish of the package. Any\n    subsequent `npm publish` commands using the `--access` flag will not\n    have an effect to the access level.  To make changes to the access level\n    after the initial publish use `npm access`.\n  ",
        flatten
      }), define("all", {
        default: !1,
        type: Boolean,
        short: "a",
        description: "\n    When running `npm outdated` and `npm ls`, setting `--all` will show\n    all outdated or installed packages, rather than only those directly\n    depended upon by the current project.\n  ",
        flatten
      }), define("allow-same-version", {
        default: !1,
        type: Boolean,
        description: "\n    Prevents throwing an error when `npm version` is used to set the new\n    version to the same value as the current version.\n  ",
        flatten
      }), define("also", {
        default: null,
        type: [ null, "dev", "development" ],
        description: "\n    When set to `dev` or `development`, this is an alias for\n    `--include=dev`.\n  ",
        deprecated: "Please use --include=dev instead.",
        flatten(key, obj, flatOptions) {
          definitions.omit.flatten("omit", obj, flatOptions);
        }
      }), define("audit", {
        default: !0,
        type: Boolean,
        description: '\n    When "true" submit audit reports alongside the current npm command to the\n    default registry and all registries configured for scopes.  See the\n    documentation for [`npm audit`](/commands/npm-audit) for details on what\n    is submitted.\n  ',
        flatten
      }), define("audit-level", {
        default: null,
        type: [ null, "info", "low", "moderate", "high", "critical", "none" ],
        description: "\n    The minimum level of vulnerability for `npm audit` to exit with\n    a non-zero exit code.\n  ",
        flatten
      }), define("auth-type", {
        default: "legacy",
        type: [ "legacy", "web", "sso", "saml", "oauth", "webauthn" ],
        description: '\n    NOTE: auth-type values "sso", "saml", "oauth", and "webauthn" will be\n    removed in a future version.\n\n    What authentication strategy to use with `login`.\n  ',
        flatten(key, obj, flatOptions) {
          flatOptions.authType = obj[key], "sso" === obj[key] && log.warn("config", "--auth-type=sso is will be removed in a future version.");
        }
      }), define("before", {
        default: null,
        type: [ null, Date ],
        description: "\n    If passed to `npm install`, will rebuild the npm tree such that only\n    versions that were available **on or before** the `--before` time get\n    installed.  If there's no versions available for the current set of\n    direct dependencies, the command will error.\n\n    If the requested version is a `dist-tag` and the given tag does not\n    pass the `--before` filter, the most recent version less than or equal\n    to that tag will be used. For example, `foo@latest` might install\n    `foo@1.2` even though `latest` is `2.0`.\n  ",
        flatten
      }), define("bin-links", {
        default: !0,
        type: Boolean,
        description: "\n    Tells npm to create symlinks (or `.cmd` shims on Windows) for package\n    executables.\n\n    Set to false to have it not do this.  This can be used to work around the\n    fact that some file systems don't support symlinks, even on ostensibly\n    Unix systems.\n  ",
        flatten
      }), define("browser", {
        default: null,
        defaultDescription: '\n    OS X: `"open"`, Windows: `"start"`, Others: `"xdg-open"`\n  ',
        type: [ null, Boolean, String ],
        description: "\n    The browser that is called by npm commands to open websites.\n\n    Set to `false` to suppress browser behavior and instead print urls to\n    terminal.\n\n    Set to `true` to use default system URL opener.\n  ",
        flatten
      }), define("ca", {
        default: null,
        type: [ null, String, Array ],
        description: '\n    The Certificate Authority signing certificate that is trusted for SSL\n    connections to the registry. Values should be in PEM format (Windows\n    calls it "Base-64 encoded X.509 (.CER)") with newlines replaced by the\n    string "\\n". For example:\n\n    ```ini\n    ca="-----BEGIN CERTIFICATE-----\\nXXXX\\nXXXX\\n-----END CERTIFICATE-----"\n    ```\n\n    Set to `null` to only allow "known" registrars, or to a specific CA\n    cert to trust only that specific signing authority.\n\n    Multiple CAs can be trusted by specifying an array of certificates:\n\n    ```ini\n    ca[]="..."\n    ca[]="..."\n    ```\n\n    See also the `strict-ssl` config.\n  ',
        flatten
      }), define("cache", {
        default: cache,
        defaultDescription: "\n    Windows: `%LocalAppData%\\npm-cache`, Posix: `~/.npm`\n  ",
        type: path,
        description: "\n    The location of npm's cache directory.  See [`npm\n    cache`](/commands/npm-cache)\n  ",
        flatten(key, obj, flatOptions) {
          flatOptions.cache = join(obj.cache, "_cacache"), flatOptions.npxCache = join(obj.cache, "_npx");
        }
      }), define("cache-max", {
        default: 1 / 0,
        type: Number,
        description: "\n    `--cache-max=0` is an alias for `--prefer-online`\n  ",
        deprecated: "\n    This option has been deprecated in favor of `--prefer-online`\n  ",
        flatten(key, obj, flatOptions) {
          obj[key] <= 0 && (flatOptions.preferOnline = !0);
        }
      }), define("cache-min", {
        default: 0,
        type: Number,
        description: "\n    `--cache-min=9999 (or bigger)` is an alias for `--prefer-offline`.\n  ",
        deprecated: "\n    This option has been deprecated in favor of `--prefer-offline`.\n  ",
        flatten(key, obj, flatOptions) {
          obj[key] >= 9999 && (flatOptions.preferOffline = !0);
        }
      }), define("cafile", {
        default: null,
        type: path,
        description: "\n    A path to a file containing one or multiple Certificate Authority signing\n    certificates. Similar to the `ca` setting, but allows for multiple\n    CA's, as well as for the CA information to be stored in a file on disk.\n  ",
        flatten(key, obj, flatOptions) {
          if (!obj.cafile) return;
          const raw = (file => {
            try {
              return fs.readFileSync(file, "utf8");
            } catch (er) {
              if ("ENOENT" !== er.code) throw er;
              return null;
            }
          })(obj.cafile);
          if (!raw) return;
          const delim = "-----END CERTIFICATE-----";
          flatOptions.ca = raw.replace(/\r\n/g, "\n").split(delim).filter((section => section.trim())).map((section => section.trimLeft() + delim));
        }
      }), define("call", {
        default: "",
        type: String,
        short: "c",
        description: '\n    Optional companion option for `npm exec`, `npx` that allows for\n    specifying a custom command to be run along with the installed packages.\n\n    ```bash\n    npm exec --package yo --package generator-node --call "yo node"\n    ```\n  ',
        flatten
      }), define("cert", {
        default: null,
        type: [ null, String ],
        description: '\n    A client certificate to pass when accessing the registry.  Values should\n    be in PEM format (Windows calls it "Base-64 encoded X.509 (.CER)") with\n    newlines replaced by the string "\\n". For example:\n\n    ```ini\n    cert="-----BEGIN CERTIFICATE-----\\nXXXX\\nXXXX\\n-----END CERTIFICATE-----"\n    ```\n\n    It is _not_ the path to a certificate file, though you can set a registry-scoped\n    "certfile" path like "//other-registry.tld/:certfile=/path/to/cert.pem".\n  ',
        flatten
      }), define("ci-name", {
        default: ciName || null,
        defaultDescription: "\n    The name of the current CI system, or `null` when not on a known CI\n    platform.\n  ",
        type: [ null, String ],
        description: "\n    The name of a continuous integration system.  If not set explicitly, npm\n    will detect the current CI environment using the\n    [`@npmcli/ci-detect`](http://npm.im/@npmcli/ci-detect) module.\n  ",
        flatten
      }), define("cidr", {
        default: null,
        type: [ null, String, Array ],
        description: "\n    This is a list of CIDR address to be used when configuring limited access\n    tokens with the `npm token create` command.\n  ",
        flatten
      }), define("color", {
        default: !process.env.NO_COLOR || "0" === process.env.NO_COLOR,
        usage: "--color|--no-color|--color always",
        defaultDescription: "\n    true unless the NO_COLOR environ is set to something other than '0'\n  ",
        type: [ "always", Boolean ],
        description: '\n    If false, never shows colors.  If `"always"` then always shows colors.\n    If true, then only prints color codes for tty file descriptors.\n  ',
        flatten(key, obj, flatOptions) {
          flatOptions.color = !!obj.color && ("always" === obj.color || !!process.stdout.isTTY), 
          flatOptions.logColor = !!obj.color && ("always" === obj.color || !!process.stderr.isTTY);
        }
      }), define("commit-hooks", {
        default: !0,
        type: Boolean,
        description: "\n    Run git commit hooks when using the `npm version` command.\n  ",
        flatten
      }), define("depth", {
        default: null,
        defaultDescription: "\n    `Infinity` if `--all` is set, otherwise `1`\n  ",
        type: [ null, Number ],
        description: "\n    The depth to go when recursing packages for `npm ls`.\n\n    If not set, `npm ls` will show only the immediate dependencies of the\n    root project.  If `--all` is set, then npm will show all dependencies\n    by default.\n  ",
        flatten
      }), define("description", {
        default: !0,
        type: Boolean,
        usage: "--no-description",
        description: "\n    Show the description in `npm search`\n  ",
        flatten(key, obj, flatOptions) {
          flatOptions.search = flatOptions.search || {
            limit: 20
          }, flatOptions.search[key] = obj[key];
        }
      }), define("dev", {
        default: !1,
        type: Boolean,
        description: "\n    Alias for `--include=dev`.\n  ",
        deprecated: "Please use --include=dev instead.",
        flatten(key, obj, flatOptions) {
          definitions.omit.flatten("omit", obj, flatOptions);
        }
      }), define("diff", {
        default: [],
        hint: "<package-spec>",
        type: [ String, Array ],
        description: "\n    Define arguments to compare in `npm diff`.\n  ",
        flatten
      }), define("diff-ignore-all-space", {
        default: !1,
        type: Boolean,
        description: "\n    Ignore whitespace when comparing lines in `npm diff`.\n  ",
        flatten
      }), define("diff-name-only", {
        default: !1,
        type: Boolean,
        description: "\n    Prints only filenames when using `npm diff`.\n  ",
        flatten
      }), define("diff-no-prefix", {
        default: !1,
        type: Boolean,
        description: "\n    Do not show any source or destination prefix in `npm diff` output.\n\n    Note: this causes `npm diff` to ignore the `--diff-src-prefix` and\n    `--diff-dst-prefix` configs.\n  ",
        flatten
      }), define("diff-dst-prefix", {
        default: "b/",
        hint: "<path>",
        type: String,
        description: "\n    Destination prefix to be used in `npm diff` output.\n  ",
        flatten
      }), define("diff-src-prefix", {
        default: "a/",
        hint: "<path>",
        type: String,
        description: "\n    Source prefix to be used in `npm diff` output.\n  ",
        flatten
      }), define("diff-text", {
        default: !1,
        type: Boolean,
        description: "\n    Treat all files as text in `npm diff`.\n  ",
        flatten
      }), define("diff-unified", {
        default: 3,
        type: Number,
        description: "\n    The number of lines of context to print in `npm diff`.\n  ",
        flatten
      }), define("dry-run", {
        default: !1,
        type: Boolean,
        description: "\n    Indicates that you don't want npm to make any changes and that it should\n    only report what it would have done.  This can be passed into any of the\n    commands that modify your local installation, eg, `install`,\n    `update`, `dedupe`, `uninstall`, as well as `pack` and\n    `publish`.\n\n    Note: This is NOT honored by other network related commands, eg\n    `dist-tags`, `owner`, etc.\n  ",
        flatten
      }), define("editor", {
        default: editor,
        defaultDescription: "\n    The EDITOR or VISUAL environment variables, or 'notepad.exe' on Windows,\n    or 'vim' on Unix systems\n  ",
        type: String,
        description: "\n    The command to run for `npm edit` and `npm config edit`.\n  ",
        flatten
      }), define("engine-strict", {
        default: !1,
        type: Boolean,
        description: "\n    If set to true, then npm will stubbornly refuse to install (or even\n    consider installing) any package that claims to not be compatible with\n    the current Node.js version.\n\n    This can be overridden by setting the `--force` flag.\n  ",
        flatten
      }), define("fetch-retries", {
        default: 2,
        type: Number,
        description: '\n    The "retries" config for the `retry` module to use when fetching\n    packages from the registry.\n\n    npm will retry idempotent read requests to the registry in the case\n    of network failures or 5xx HTTP errors.\n  ',
        flatten(key, obj, flatOptions) {
          flatOptions.retry = flatOptions.retry || {}, flatOptions.retry.retries = obj[key];
        }
      }), define("fetch-retry-factor", {
        default: 10,
        type: Number,
        description: '\n    The "factor" config for the `retry` module to use when fetching\n    packages.\n  ',
        flatten(key, obj, flatOptions) {
          flatOptions.retry = flatOptions.retry || {}, flatOptions.retry.factor = obj[key];
        }
      }), define("fetch-retry-maxtimeout", {
        default: 6e4,
        defaultDescription: "60000 (1 minute)",
        type: Number,
        description: '\n    The "maxTimeout" config for the `retry` module to use when fetching\n    packages.\n  ',
        flatten(key, obj, flatOptions) {
          flatOptions.retry = flatOptions.retry || {}, flatOptions.retry.maxTimeout = obj[key];
        }
      }), define("fetch-retry-mintimeout", {
        default: 1e4,
        defaultDescription: "10000 (10 seconds)",
        type: Number,
        description: '\n    The "minTimeout" config for the `retry` module to use when fetching\n    packages.\n  ',
        flatten(key, obj, flatOptions) {
          flatOptions.retry = flatOptions.retry || {}, flatOptions.retry.minTimeout = obj[key];
        }
      }), define("fetch-timeout", {
        default: 3e5,
        defaultDescription: "300000 (5 minutes)",
        type: Number,
        description: "\n    The maximum amount of time to wait for HTTP requests to complete.\n  ",
        flatten(key, obj, flatOptions) {
          flatOptions.timeout = obj[key];
        }
      }), define("force", {
        default: !1,
        type: Boolean,
        short: "f",
        description: "\n    Removes various protections against unfortunate side effects, common\n    mistakes, unnecessary performance degradation, and malicious input.\n\n    * Allow clobbering non-npm files in global installs.\n    * Allow the `npm version` command to work on an unclean git repository.\n    * Allow deleting the cache folder with `npm cache clean`.\n    * Allow installing packages that have an `engines` declaration\n      requiring a different version of npm.\n    * Allow installing packages that have an `engines` declaration\n      requiring a different version of `node`, even if `--engine-strict`\n      is enabled.\n    * Allow `npm audit fix` to install modules outside your stated\n      dependency range (including SemVer-major changes).\n    * Allow unpublishing all versions of a published package.\n    * Allow conflicting peerDependencies to be installed in the root project.\n    * Implicitly set `--yes` during `npm init`.\n    * Allow clobbering existing values in `npm pkg`\n    * Allow unpublishing of entire packages (not just a single version).\n\n    If you don't have a clear idea of what you want to do, it is strongly\n    recommended that you do not use this option!\n  ",
        flatten
      }), define("foreground-scripts", {
        default: !1,
        type: Boolean,
        description: "\n    Run all build scripts (ie, `preinstall`, `install`, and\n    `postinstall`) scripts for installed packages in the foreground\n    process, sharing standard input, output, and error with the main npm\n    process.\n\n    Note that this will generally make installs run slower, and be much\n    noisier, but can be useful for debugging.\n  ",
        flatten
      }), define("format-package-lock", {
        default: !0,
        type: Boolean,
        description: "\n    Format `package-lock.json` or `npm-shrinkwrap.json` as a human\n    readable file.\n  ",
        flatten
      }), define("fund", {
        default: !0,
        type: Boolean,
        description: '\n    When "true" displays the message at the end of each `npm install`\n    acknowledging the number of dependencies looking for funding.\n    See [`npm fund`](/commands/npm-fund) for details.\n  ',
        flatten
      }), define("git", {
        default: "git",
        type: String,
        description: "\n    The command to use for git commands.  If git is installed on the\n    computer, but is not in the `PATH`, then set this to the full path to\n    the git binary.\n  ",
        flatten
      }), define("git-tag-version", {
        default: !0,
        type: Boolean,
        description: "\n    Tag the commit when using the `npm version` command.  Setting this to\n    false results in no commit being made at all.\n  ",
        flatten
      }), define("global", {
        default: !1,
        type: Boolean,
        short: "g",
        description: '\n    Operates in "global" mode, so that packages are installed into the\n    `prefix` folder instead of the current working directory.  See\n    [folders](/configuring-npm/folders) for more on the differences in\n    behavior.\n\n    * packages are installed into the `{prefix}/lib/node_modules` folder,\n      instead of the current working directory.\n    * bin files are linked to `{prefix}/bin`\n    * man pages are linked to `{prefix}/share/man`\n  ',
        flatten: (key, obj, flatOptions) => {
          flatten(key, obj, flatOptions), flatOptions.global && (flatOptions.location = "global");
        }
      }), define("global-style", {
        default: !1,
        type: Boolean,
        description: "\n    Causes npm to install the package into your local `node_modules` folder\n    with the same layout it uses with the global `node_modules` folder.\n    Only your direct dependencies will show in `node_modules` and\n    everything they depend on will be flattened in their `node_modules`\n    folders.  This obviously will eliminate some deduping. If used with\n    `legacy-bundling`, `legacy-bundling` will be preferred.\n  ",
        flatten
      }), define("globalconfig", {
        type: path,
        default: "",
        defaultDescription: "\n    The global --prefix setting plus 'etc/npmrc'. For example,\n    '/usr/local/etc/npmrc'\n  ",
        description: "\n    The config file to read for global config options.\n  ",
        flatten
      }), define("heading", {
        default: "npm",
        type: String,
        description: "\n    The string that starts all the debugging log output.\n  ",
        flatten
      }), define("https-proxy", {
        default: null,
        type: [ null, url ],
        description: "\n    A proxy to use for outgoing https requests. If the `HTTPS_PROXY` or\n    `https_proxy` or `HTTP_PROXY` or `http_proxy` environment variables\n    are set, proxy settings will be honored by the underlying\n    `make-fetch-happen` library.\n  ",
        flatten
      }), define("if-present", {
        default: !1,
        type: Boolean,
        envExport: !1,
        description: "\n    If true, npm will not exit with an error code when `run-script` is\n    invoked for a script that isn't defined in the `scripts` section of\n    `package.json`. This option can be used when it's desirable to\n    optionally run a script when it's present and fail if the script fails.\n    This is useful, for example, when running scripts that may only apply for\n    some builds in an otherwise generic CI setup.\n  ",
        flatten
      }), define("ignore-scripts", {
        default: !1,
        type: Boolean,
        description: "\n    If true, npm does not run scripts specified in package.json files.\n\n    Note that commands explicitly intended to run a particular script, such\n    as `npm start`, `npm stop`, `npm restart`, `npm test`, and `npm\n    run-script` will still run their intended script if `ignore-scripts` is\n    set, but they will *not* run any pre- or post-scripts.\n  ",
        flatten
      }), define("include", {
        default: [],
        type: [ Array, "prod", "dev", "optional", "peer" ],
        description: "\n    Option that allows for defining which types of dependencies to install.\n\n    This is the inverse of `--omit=<type>`.\n\n    Dependency types specified in `--include` will not be omitted,\n    regardless of the order in which omit/include are specified on the\n    command-line.\n  ",
        flatten(key, obj, flatOptions) {
          definitions.omit.flatten("omit", obj, flatOptions);
        }
      }), define("include-staged", {
        default: !1,
        type: Boolean,
        description: '\n    Allow installing "staged" published packages, as defined by [npm RFC PR\n    #92](https://github.com/npm/rfcs/pull/92).\n\n    This is experimental, and not implemented by the npm public registry.\n  ',
        flatten
      }), define("include-workspace-root", {
        default: !1,
        type: Boolean,
        envExport: !1,
        description: "\n    Include the workspace root when workspaces are enabled for a command.\n\n    When false, specifying individual workspaces via the `workspace` config,\n    or all workspaces via the `workspaces` flag, will cause npm to operate only\n    on the specified workspaces, and not on the root project.\n  ",
        flatten
      }), define("init-author-email", {
        default: "",
        type: String,
        description: "\n    The value `npm init` should use by default for the package author's\n    email.\n  "
      }), define("init-author-name", {
        default: "",
        type: String,
        description: "\n    The value `npm init` should use by default for the package author's name.\n  "
      }), define("init-author-url", {
        default: "",
        type: [ "", url ],
        description: "\n    The value `npm init` should use by default for the package author's homepage.\n  "
      }), define("init-license", {
        default: "ISC",
        type: String,
        description: "\n    The value `npm init` should use by default for the package license.\n  "
      }), define("init-module", {
        default: "~/.npm-init.js",
        type: path,
        description: "\n    A module that will be loaded by the `npm init` command.  See the\n    documentation for the\n    [init-package-json](https://github.com/npm/init-package-json) module for\n    more information, or [npm init](/commands/npm-init).\n  "
      }), define("init-version", {
        default: "1.0.0",
        type: semver,
        description: "\n    The value that `npm init` should use by default for the package\n    version number, if not already set in package.json.\n  "
      }), define("init.author.email", {
        default: "",
        type: String,
        deprecated: "\n    Use `--init-author-email` instead.",
        description: "\n    Alias for `--init-author-email`\n  "
      }), define("init.author.name", {
        default: "",
        type: String,
        deprecated: "\n    Use `--init-author-name` instead.\n  ",
        description: "\n    Alias for `--init-author-name`\n  "
      }), define("init.author.url", {
        default: "",
        type: [ "", url ],
        deprecated: "\n    Use `--init-author-url` instead.\n  ",
        description: "\n    Alias for `--init-author-url`\n  "
      }), define("init.license", {
        default: "ISC",
        type: String,
        deprecated: "\n    Use `--init-license` instead.\n  ",
        description: "\n    Alias for `--init-license`\n  "
      }), define("init.module", {
        default: "~/.npm-init.js",
        type: path,
        deprecated: "\n    Use `--init-module` instead.\n  ",
        description: "\n    Alias for `--init-module`\n  "
      }), define("init.version", {
        default: "1.0.0",
        type: semver,
        deprecated: "\n    Use `--init-version` instead.\n  ",
        description: "\n    Alias for `--init-version`\n  "
      }), define("install-links", {
        default: !1,
        type: Boolean,
        description: "\n    When set file: protocol dependencies that exist outside of the project root\n    will be packed and installed as regular dependencies instead of creating a\n    symlink. This option has no effect on workspaces.\n  ",
        flatten
      }), define("json", {
        default: !1,
        type: Boolean,
        description: "\n    Whether or not to output JSON data, rather than the normal output.\n\n    * In `npm pkg set` it enables parsing set values with JSON.parse()\n    before saving them to your `package.json`.\n\n    Not supported by all npm commands.\n  ",
        flatten
      }), define("key", {
        default: null,
        type: [ null, String ],
        description: '\n    A client key to pass when accessing the registry.  Values should be in\n    PEM format with newlines replaced by the string "\\n". For example:\n\n    ```ini\n    key="-----BEGIN PRIVATE KEY-----\\nXXXX\\nXXXX\\n-----END PRIVATE KEY-----"\n    ```\n\n    It is _not_ the path to a key file, though you can set a registry-scoped\n    "keyfile" path like "//other-registry.tld/:keyfile=/path/to/key.pem".\n  ',
        flatten
      }), define("legacy-bundling", {
        default: !1,
        type: Boolean,
        description: "\n    Causes npm to install the package such that versions of npm prior to 1.4,\n    such as the one included with node 0.8, can install the package.  This\n    eliminates all automatic deduping. If used with `global-style` this\n    option will be preferred.\n  ",
        flatten
      }), define("legacy-peer-deps", {
        default: !1,
        type: Boolean,
        description: "\n    Causes npm to completely ignore `peerDependencies` when building a\n    package tree, as in npm versions 3 through 6.\n\n    If a package cannot be installed because of overly strict\n    `peerDependencies` that collide, it provides a way to move forward\n    resolving the situation.\n\n    This differs from `--omit=peer`, in that `--omit=peer` will avoid\n    unpacking `peerDependencies` on disk, but will still design a tree such\n    that `peerDependencies` _could_ be unpacked in a correct place.\n\n    Use of `legacy-peer-deps` is not recommended, as it will not enforce\n    the `peerDependencies` contract that meta-dependencies may rely on.\n  ",
        flatten
      }), define("link", {
        default: !1,
        type: Boolean,
        description: "\n    Used with `npm ls`, limiting output to only those packages that are\n    linked.\n  "
      }), define("local-address", {
        default: null,
        type: (() => {
          try {
            return Object.values(networkInterfaces()).map((int => int.map((({address}) => address)))).reduce(((set, addrs) => set.concat(addrs)), [ null ]);
          } catch (e) {
            return [ null ];
          }
        })(),
        typeDescription: "IP Address",
        description: "\n    The IP address of the local interface to use when making connections to\n    the npm registry.  Must be IPv4 in versions of Node prior to 0.12.\n  ",
        flatten
      }), define("location", {
        default: "user",
        short: "L",
        type: [ "global", "user", "project" ],
        defaultDescription: '\n    "user" unless `--global` is passed, which will also set this value to "global"\n  ',
        description: '\n    When passed to `npm config` this refers to which config file to use.\n\n    When set to "global" mode, packages are installed into the `prefix` folder\n    instead of the current working directory. See\n    [folders](/configuring-npm/folders) for more on the differences in behavior.\n\n    * packages are installed into the `{prefix}/lib/node_modules` folder,\n      instead of the current working directory.\n    * bin files are linked to `{prefix}/bin`\n    * man pages are linked to `{prefix}/share/man`\n  ',
        flatten: (key, obj, flatOptions) => {
          flatten(key, obj, flatOptions), flatOptions.global && (flatOptions.location = "global"), 
          "global" === obj.location && (flatOptions.global = !0);
        }
      }), define("lockfile-version", {
        default: null,
        type: [ null, 1, 2, 3, "1", "2", "3" ],
        defaultDescription: "\n    Version 2 if no lockfile or current lockfile version less than or equal to\n    2, otherwise maintain current lockfile version\n  ",
        description: "\n    Set the lockfile format version to be used in package-lock.json and\n    npm-shrinkwrap-json files.  Possible options are:\n\n    1: The lockfile version used by npm versions 5 and 6.  Lacks some data that\n    is used during the install, resulting in slower and possibly less\n    deterministic installs.  Prevents lockfile churn when interoperating with\n    older npm versions.\n\n    2: The default lockfile version used by npm version 7.  Includes both the\n    version 1 lockfile data and version 3 lockfile data, for maximum\n    determinism and interoperability, at the expense of more bytes on disk.\n\n    3: Only the new lockfile information introduced in npm version 7.  Smaller\n    on disk than lockfile version 2, but not interoperable with older npm\n    versions.  Ideal if all users are on npm version 7 and higher.\n  ",
        flatten: (key, obj, flatOptions) => {
          flatOptions.lockfileVersion = obj[key] && parseInt(obj[key], 10);
        }
      }), define("loglevel", {
        default: "notice",
        type: [ "silent", "error", "warn", "notice", "http", "timing", "info", "verbose", "silly" ],
        description: '\n    What level of logs to report.  All logs are written to a debug log,\n    with the path to that file printed if the execution of a command fails.\n\n    Any logs of a higher level than the setting are shown. The default is\n    "notice".\n\n    See also the `foreground-scripts` config.\n  ',
        flatten(key, obj, flatOptions) {
          flatOptions.silent = "silent" === obj[key];
        }
      }), define("logs-dir", {
        default: null,
        type: [ null, path ],
        defaultDescription: "\n    A directory named `_logs` inside the cache\n",
        description: "\n    The location of npm's log directory.  See [`npm\n    logging`](/using-npm/logging) for more information.\n  "
      }), define("logs-max", {
        default: 10,
        type: Number,
        description: "\n    The maximum number of log files to store.\n\n    If set to 0, no log files will be written for the current run.\n  "
      }), define("long", {
        default: !1,
        type: Boolean,
        short: "l",
        description: "\n    Show extended information in `ls`, `search`, and `help-search`.\n  "
      }), define("maxsockets", {
        default: 15,
        type: Number,
        description: "\n    The maximum number of connections to use per origin (protocol/host/port\n    combination).\n  ",
        flatten(key, obj, flatOptions) {
          flatOptions.maxSockets = obj[key];
        }
      }), define("message", {
        default: "%s",
        type: String,
        short: "m",
        description: '\n    Commit message which is used by `npm version` when creating version commit.\n\n    Any "%s" in the message will be replaced with the version number.\n  ',
        flatten
      }), define("node-options", {
        default: null,
        type: [ null, String ],
        description: "\n    Options to pass through to Node.js via the `NODE_OPTIONS` environment\n    variable.  This does not impact how npm itself is executed but it does\n    impact how lifecycle scripts are called.\n  "
      }), define("node-version", {
        default: process.version,
        defaultDescription: "Node.js `process.version` value",
        type: semver,
        description: "\n    The node version to use when checking a package's `engines` setting.\n  ",
        flatten
      }), define("noproxy", {
        default: "",
        defaultDescription: "\n    The value of the NO_PROXY environment variable\n  ",
        type: [ String, Array ],
        description: "\n    Domain extensions that should bypass any proxies.\n\n    Also accepts a comma-delimited string.\n  ",
        flatten(key, obj, flatOptions) {
          Array.isArray(obj[key]) ? flatOptions.noProxy = obj[key].join(",") : flatOptions.noProxy = obj[key];
        }
      }), define("npm-version", {
        default: npmVersion,
        defaultDescription: "Output of `npm --version`",
        type: semver,
        description: "\n    The npm version to use when checking a package's `engines` setting.\n  ",
        flatten
      }), define("offline", {
        default: !1,
        type: Boolean,
        description: "\n    Force offline mode: no network requests will be done during install. To allow\n    the CLI to fill in missing cache data, see `--prefer-offline`.\n  ",
        flatten
      }), define("omit", {
        default: "production" === process.env.NODE_ENV ? [ "dev" ] : [],
        defaultDescription: "\n    'dev' if the `NODE_ENV` environment variable is set to 'production',\n    otherwise empty.\n  ",
        type: [ Array, "dev", "optional", "peer" ],
        description: "\n    Dependency types to omit from the installation tree on disk.\n\n    Note that these dependencies _are_ still resolved and added to the\n    `package-lock.json` or `npm-shrinkwrap.json` file.  They are just\n    not physically installed on disk.\n\n    If a package type appears in both the `--include` and `--omit`\n    lists, then it will be included.\n\n    If the resulting omit list includes `'dev'`, then the `NODE_ENV`\n    environment variable will be set to `'production'` for all lifecycle\n    scripts.\n  ",
        flatten(key, obj, flatOptions) {
          flatOptions.omit = (obj => {
            const include = obj.include || [], omit = obj.omit || [], only = obj.only;
            return /^prod(uction)?$/.test(only) || obj.production ? omit.push("dev") : !1 === obj.production && include.push("dev"), 
            /^dev/.test(obj.also) && include.push("dev"), obj.dev && include.push("dev"), !1 === obj.optional ? omit.push("optional") : !0 === obj.optional && include.push("optional"), 
            obj.omit = [ ...new Set(omit) ].filter((type => !include.includes(type))), obj.include = [ ...new Set(include) ], 
            obj.omit.includes("dev") && (process.env.NODE_ENV = "production"), obj.omit;
          })(obj);
        }
      }), define("omit-lockfile-registry-resolved", {
        default: !1,
        type: Boolean,
        description: "\n    This option causes npm to create lock files without a `resolved` key for\n    registry dependencies. Subsequent installs will need to resolve tarball\n    endpoints with the configured registry, likely resulting in a longer install\n    time.\n  ",
        flatten
      }), define("only", {
        default: null,
        type: [ null, "prod", "production" ],
        deprecated: "\n    Use `--omit=dev` to omit dev dependencies from the install.\n  ",
        description: "\n    When set to `prod` or `production`, this is an alias for\n    `--omit=dev`.\n  ",
        flatten(key, obj, flatOptions) {
          definitions.omit.flatten("omit", obj, flatOptions);
        }
      }), define("optional", {
        default: null,
        type: [ null, Boolean ],
        deprecated: "\n    Use `--omit=optional` to exclude optional dependencies, or\n    `--include=optional` to include them.\n\n    Default value does install optional deps unless otherwise omitted.\n  ",
        description: "\n    Alias for --include=optional or --omit=optional\n  ",
        flatten(key, obj, flatOptions) {
          definitions.omit.flatten("omit", obj, flatOptions);
        }
      }), define("otp", {
        default: null,
        type: [ null, String ],
        description: "\n    This is a one-time password from a two-factor authenticator.  It's needed\n    when publishing or changing package permissions with `npm access`.\n\n    If not set, and a registry response fails with a challenge for a one-time\n    password, npm will prompt on the command line for one.\n  ",
        flatten
      }), define("package", {
        default: [],
        hint: "<package-spec>",
        type: [ String, Array ],
        description: "\n    The package or packages to install for [`npm exec`](/commands/npm-exec)\n  ",
        flatten
      }), define("package-lock", {
        default: !0,
        type: Boolean,
        description: "\n    If set to false, then ignore `package-lock.json` files when installing.\n    This will also prevent _writing_ `package-lock.json` if `save` is\n    true.\n\n    This configuration does not affect `npm ci`.\n  ",
        flatten: (key, obj, flatOptions) => {
          flatten(key, obj, flatOptions), flatOptions.packageLockOnly && (flatOptions.packageLock = !0);
        }
      }), define("package-lock-only", {
        default: !1,
        type: Boolean,
        description: "\n    If set to true, the current operation will only use the `package-lock.json`,\n    ignoring `node_modules`.\n\n    For `update` this means only the `package-lock.json` will be updated,\n    instead of checking `node_modules` and downloading dependencies.\n\n    For `list` this means the output will be based on the tree described by the\n    `package-lock.json`, rather than the contents of `node_modules`.\n  ",
        flatten: (key, obj, flatOptions) => {
          flatten(key, obj, flatOptions), flatOptions.packageLockOnly && (flatOptions.packageLock = !0);
        }
      }), define("pack-destination", {
        default: ".",
        type: String,
        description: "\n    Directory in which `npm pack` will save tarballs.\n  ",
        flatten
      }), define("parseable", {
        default: !1,
        type: Boolean,
        short: "p",
        description: "\n    Output parseable results from commands that write to standard output. For\n    `npm search`, this will be tab-separated table format.\n  ",
        flatten
      }), define("prefer-offline", {
        default: !1,
        type: Boolean,
        description: "\n    If true, staleness checks for cached data will be bypassed, but missing\n    data will be requested from the server. To force full offline mode, use\n    `--offline`.\n  ",
        flatten
      }), define("prefer-online", {
        default: !1,
        type: Boolean,
        description: "\n    If true, staleness checks for cached data will be forced, making the CLI\n    look for updates immediately even for fresh package data.\n  ",
        flatten
      }), define("prefix", {
        type: path,
        short: "C",
        default: "",
        defaultDescription: "\n    In global mode, the folder where the node executable is installed. In\n    local mode, the nearest parent folder containing either a package.json\n    file or a node_modules folder.\n  ",
        description: "\n    The location to install global items.  If set on the command line, then\n    it forces non-global commands to run in the specified folder.\n  "
      }), define("preid", {
        default: "",
        hint: "prerelease-id",
        type: String,
        description: '\n    The "prerelease identifier" to use as a prefix for the "prerelease" part\n    of a semver. Like the `rc` in `1.2.0-rc.8`.\n  ',
        flatten
      }), define("production", {
        default: null,
        type: [ null, Boolean ],
        deprecated: "Use `--omit=dev` instead.",
        description: "Alias for `--omit=dev`",
        flatten(key, obj, flatOptions) {
          definitions.omit.flatten("omit", obj, flatOptions);
        }
      }), define("progress", {
        default: !ciName,
        defaultDescription: "\n    `true` unless running in a known CI system\n  ",
        type: Boolean,
        description: "\n    When set to `true`, npm will display a progress bar during time\n    intensive operations, if `process.stderr` is a TTY.\n\n    Set to `false` to suppress the progress bar.\n  ",
        flatten(key, obj, flatOptions) {
          flatOptions.progress = !!obj.progress && (!!process.stderr.isTTY && "dumb" !== process.env.TERM);
        }
      }), define("proxy", {
        default: null,
        type: [ null, !1, url ],
        description: "\n    A proxy to use for outgoing http requests. If the `HTTP_PROXY` or\n    `http_proxy` environment variables are set, proxy settings will be\n    honored by the underlying `request` library.\n  ",
        flatten
      }), define("read-only", {
        default: !1,
        type: Boolean,
        description: "\n    This is used to mark a token as unable to publish when configuring\n    limited access tokens with the `npm token create` command.\n  ",
        flatten
      }), define("rebuild-bundle", {
        default: !0,
        type: Boolean,
        description: "\n    Rebuild bundled dependencies after installation.\n  ",
        flatten
      }), define("registry", {
        default: "https://registry.npmjs.org/",
        type: url,
        description: "\n    The base URL of the npm registry.\n  ",
        flatten
      }), define("replace-registry-host", {
        default: "npmjs",
        hint: "<npmjs|never|always> | hostname",
        type: [ "npmjs", "never", "always", String ],
        description: '\n    Defines behavior for replacing the registry host in a lockfile with the\n    configured registry.\n\n    The default behavior is to replace package dist URLs from the default\n    registry (https://registry.npmjs.org) to the configured registry. If set to\n    "never", then use the registry value. If set to "always", then replace the\n    registry host with the configured host every time.\n\n    You may also specify a bare hostname (e.g., "registry.npmjs.org").\n  ',
        flatten
      }), define("save", {
        default: !0,
        defaultDescription: "`true` unless when using `npm update` where it\n  defaults to `false`",
        usage: "-S|--save|--no-save|--save-prod|--save-dev|--save-optional|--save-peer|--save-bundle",
        type: Boolean,
        short: "S",
        description: "\n    Save installed packages to a `package.json` file as dependencies.\n\n    When used with the `npm rm` command, removes the dependency from\n    `package.json`.\n\n    Will also prevent writing to `package-lock.json` if set to `false`.\n  ",
        flatten
      }), define("save-bundle", {
        default: !1,
        type: Boolean,
        short: "B",
        description: "\n    If a package would be saved at install time by the use of `--save`,\n    `--save-dev`, or `--save-optional`, then also put it in the\n    `bundleDependencies` list.\n\n    Ignored if `--save-peer` is set, since peerDependencies cannot be bundled.\n  ",
        flatten(key, obj, flatOptions) {
          flatOptions.saveBundle = obj["save-bundle"] && !obj["save-peer"];
        }
      }), define("save-dev", {
        default: !1,
        type: Boolean,
        short: "D",
        description: "\n    Save installed packages to a package.json file as `devDependencies`.\n  ",
        flatten(key, obj, flatOptions) {
          obj[key] ? flatOptions.saveType = "dev" : "dev" === flatOptions.saveType && delete flatOptions.saveType;
        }
      }), define("save-exact", {
        default: !1,
        type: Boolean,
        short: "E",
        description: "\n    Dependencies saved to package.json will be configured with an exact\n    version rather than using npm's default semver range operator.\n  ",
        flatten(key, obj, flatOptions) {
          definitions["save-prefix"].flatten("save-prefix", obj, flatOptions);
        }
      }), define("save-optional", {
        default: !1,
        type: Boolean,
        short: "O",
        description: "\n    Save installed packages to a package.json file as\n    `optionalDependencies`.\n  ",
        flatten(key, obj, flatOptions) {
          obj[key] ? "peerOptional" !== flatOptions.saveType && ("peer" === flatOptions.saveType ? flatOptions.saveType = "peerOptional" : flatOptions.saveType = "optional") : "optional" === flatOptions.saveType ? delete flatOptions.saveType : "peerOptional" === flatOptions.saveType && (flatOptions.saveType = "peer");
        }
      }), define("save-peer", {
        default: !1,
        type: Boolean,
        description: "\n    Save installed packages to a package.json file as `peerDependencies`\n  ",
        flatten(key, obj, flatOptions) {
          obj[key] ? "peerOptional" !== flatOptions.saveType && ("optional" === flatOptions.saveType ? flatOptions.saveType = "peerOptional" : flatOptions.saveType = "peer") : "peer" === flatOptions.saveType ? delete flatOptions.saveType : "peerOptional" === flatOptions.saveType && (flatOptions.saveType = "optional");
        }
      }), define("save-prefix", {
        default: "^",
        type: String,
        description: "\n    Configure how versions of packages installed to a package.json file via\n    `--save` or `--save-dev` get prefixed.\n\n    For example if a package has version `1.2.3`, by default its version is\n    set to `^1.2.3` which allows minor upgrades for that package, but after\n    `npm config set save-prefix='~'` it would be set to `~1.2.3` which\n    only allows patch upgrades.\n  ",
        flatten(key, obj, flatOptions) {
          flatOptions.savePrefix = obj["save-exact"] ? "" : obj["save-prefix"], obj["save-prefix"] = flatOptions.savePrefix;
        }
      }), define("save-prod", {
        default: !1,
        type: Boolean,
        short: "P",
        description: "\n    Save installed packages into `dependencies` specifically. This is\n    useful if a package already exists in `devDependencies` or\n    `optionalDependencies`, but you want to move it to be a non-optional\n    production dependency.\n\n    This is the default behavior if `--save` is true, and neither\n    `--save-dev` or `--save-optional` are true.\n  ",
        flatten(key, obj, flatOptions) {
          obj[key] ? flatOptions.saveType = "prod" : "prod" === flatOptions.saveType && delete flatOptions.saveType;
        }
      }), define("scope", {
        default: "",
        defaultDescription: '\n    the scope of the current project, if any, or ""\n  ',
        type: String,
        hint: "<@scope>",
        description: '\n    Associate an operation with a scope for a scoped registry.\n\n    Useful when logging in to or out of a private registry:\n\n    ```\n    # log in, linking the scope to the custom registry\n    npm login --scope=@mycorp --registry=https://registry.mycorp.com\n\n    # log out, removing the link and the auth token\n    npm logout --scope=@mycorp\n    ```\n\n    This will cause `@mycorp` to be mapped to the registry for future\n    installation of packages specified according to the pattern\n    `@mycorp/package`.\n\n    This will also cause `npm init` to create a scoped package.\n\n    ```\n    # accept all defaults, and create a package named "@foo/whatever",\n    # instead of just named "whatever"\n    npm init --scope=@foo --yes\n    ```\n  ',
        flatten(key, obj, flatOptions) {
          const value = obj[key], scope = value && !/^@/.test(value) ? `@${value}` : value;
          flatOptions.scope = scope, flatOptions.projectScope = scope;
        }
      }), define("script-shell", {
        default: null,
        defaultDescription: "\n    '/bin/sh' on POSIX systems, 'cmd.exe' on Windows\n  ",
        type: [ null, String ],
        description: "\n    The shell to use for scripts run with the `npm exec`,\n    `npm run` and `npm init <package-spec>` commands.\n  ",
        flatten(key, obj, flatOptions) {
          flatOptions.scriptShell = obj[key] || void 0;
        }
      }), define("searchexclude", {
        default: "",
        type: String,
        description: "\n    Space-separated options that limit the results from search.\n  ",
        flatten(key, obj, flatOptions) {
          flatOptions.search = flatOptions.search || {
            limit: 20
          }, flatOptions.search.exclude = obj[key].toLowerCase();
        }
      }), define("searchlimit", {
        default: 20,
        type: Number,
        description: "\n    Number of items to limit search results to. Will not apply at all to\n    legacy searches.\n  ",
        flatten(key, obj, flatOptions) {
          flatOptions.search = flatOptions.search || {}, flatOptions.search.limit = obj[key];
        }
      }), define("searchopts", {
        default: "",
        type: String,
        description: "\n    Space-separated options that are always passed to search.\n  ",
        flatten(key, obj, flatOptions) {
          flatOptions.search = flatOptions.search || {
            limit: 20
          }, flatOptions.search.opts = querystring.parse(obj[key]);
        }
      }), define("searchstaleness", {
        default: 900,
        type: Number,
        description: "\n    The age of the cache, in seconds, before another registry request is made\n    if using legacy search endpoint.\n  ",
        flatten(key, obj, flatOptions) {
          flatOptions.search = flatOptions.search || {
            limit: 20
          }, flatOptions.search.staleness = obj[key];
        }
      }), define("shell", {
        default: shell,
        defaultDescription: '\n    SHELL environment variable, or "bash" on Posix, or "cmd.exe" on Windows\n  ',
        type: String,
        description: "\n    The shell to run for the `npm explore` command.\n  ",
        flatten
      }), define("shrinkwrap", {
        default: !0,
        type: Boolean,
        deprecated: "\n    Use the --package-lock setting instead.\n  ",
        description: "\n    Alias for --package-lock\n  ",
        flatten(key, obj, flatOptions) {
          obj["package-lock"] = obj.shrinkwrap, definitions["package-lock"].flatten("package-lock", obj, flatOptions);
        }
      }), define("sign-git-commit", {
        default: !1,
        type: Boolean,
        description: "\n    If set to true, then the `npm version` command will commit the new\n    package version using `-S` to add a signature.\n\n    Note that git requires you to have set up GPG keys in your git configs\n    for this to work properly.\n  ",
        flatten
      }), define("sign-git-tag", {
        default: !1,
        type: Boolean,
        description: "\n    If set to true, then the `npm version` command will tag the version\n    using `-s` to add a signature.\n\n    Note that git requires you to have set up GPG keys in your git configs\n    for this to work properly.\n  ",
        flatten
      }), define("sso-poll-frequency", {
        default: 500,
        type: Number,
        deprecated: "\n    The --auth-type method of SSO/SAML/OAuth will be removed in a future\n    version of npm in favor of web-based login.\n  ",
        description: "\n    When used with SSO-enabled `auth-type`s, configures how regularly the\n    registry should be polled while the user is completing authentication.\n  ",
        flatten
      }), define("sso-type", {
        default: "oauth",
        type: [ null, "oauth", "saml" ],
        deprecated: "\n    The --auth-type method of SSO/SAML/OAuth will be removed in a future\n    version of npm in favor of web-based login.\n  ",
        description: "\n    If `--auth-type=sso`, the type of SSO type to use.\n  ",
        flatten
      }), define("strict-peer-deps", {
        default: !1,
        type: Boolean,
        description: "\n    If set to `true`, and `--legacy-peer-deps` is not set, then _any_\n    conflicting `peerDependencies` will be treated as an install failure,\n    even if npm could reasonably guess the appropriate resolution based on\n    non-peer dependency relationships.\n\n    By default, conflicting `peerDependencies` deep in the dependency graph\n    will be resolved using the nearest non-peer dependency specification,\n    even if doing so will result in some packages receiving a peer dependency\n    outside the range set in their package's `peerDependencies` object.\n\n    When such and override is performed, a warning is printed, explaining the\n    conflict and the packages involved.  If `--strict-peer-deps` is set,\n    then this warning is treated as a failure.\n  ",
        flatten
      }), define("strict-ssl", {
        default: !0,
        type: Boolean,
        description: "\n    Whether or not to do SSL key validation when making requests to the\n    registry via https.\n\n    See also the `ca` config.\n  ",
        flatten(key, obj, flatOptions) {
          flatOptions.strictSSL = obj[key];
        }
      }), define("tag", {
        default: "latest",
        type: String,
        description: "\n    If you ask npm to install a package and don't tell it a specific version,\n    then it will install the specified tag.\n\n    Also the tag that is added to the package@version specified by the `npm\n    tag` command, if no explicit tag is given.\n\n    When used by the `npm diff` command, this is the tag used to fetch the\n    tarball that will be compared with the local files by default.\n  ",
        flatten(key, obj, flatOptions) {
          flatOptions.defaultTag = obj[key];
        }
      }), define("tag-version-prefix", {
        default: "v",
        type: String,
        description: '\n    If set, alters the prefix used when tagging a new version when performing\n    a version increment using  `npm-version`. To remove the prefix\n    altogether, set it to the empty string: `""`.\n\n    Because other tools may rely on the convention that npm version tags look\n    like `v1.0.0`, _only use this property if it is absolutely necessary_.\n    In particular, use care when overriding this setting for public packages.\n  ',
        flatten
      }), define("timing", {
        default: !1,
        type: Boolean,
        description: "\n    If true, writes a debug log to `logs-dir` and timing information\n    to `_timing.json` in the cache, even if the command completes\n    successfully.  `_timing.json` is a newline delimited list of JSON\n    objects.\n\n    You can quickly view it with this [json](https://npm.im/json) command\n    line: `npm exec -- json -g < ~/.npm/_timing.json`.\n  "
      }), define("tmp", {
        default: tmpdir(),
        defaultDescription: "\n    The value returned by the Node.js `os.tmpdir()` method\n    <https://nodejs.org/api/os.html#os_os_tmpdir>\n  ",
        type: path,
        deprecated: "\n    This setting is no longer used.  npm stores temporary files in a special\n    location in the cache, and they are managed by\n    [`cacache`](http://npm.im/cacache).\n  ",
        description: "\n    Historically, the location where temporary files were stored.  No longer\n    relevant.\n  "
      }), define("umask", {
        default: 0,
        type: Umask,
        description: '\n    The "umask" value to use when setting the file creation mode on files and\n    folders.\n\n    Folders and executables are given a mode which is `0o777` masked\n    against this value.  Other files are given a mode which is `0o666`\n    masked against this value.\n\n    Note that the underlying system will _also_ apply its own umask value to\n    files and folders that are created, and npm does not circumvent this, but\n    rather adds the `--umask` config to it.\n\n    Thus, the effective default umask value on most POSIX systems is 0o22,\n    meaning that folders and executables are created with a mode of 0o755 and\n    other files are created with a mode of 0o644.\n  ',
        flatten
      }), define("unicode", {
        default: unicode,
        defaultDescription: "\n    false on windows, true on mac/unix systems with a unicode locale, as\n    defined by the `LC_ALL`, `LC_CTYPE`, or `LANG` environment variables.\n  ",
        type: Boolean,
        description: "\n    When set to true, npm uses unicode characters in the tree output.  When\n    false, it uses ascii characters instead of unicode glyphs.\n  "
      }), define("update-notifier", {
        default: !0,
        type: Boolean,
        description: "\n    Set to false to suppress the update notification when using an older\n    version of npm than the latest.\n  "
      }), define("usage", {
        default: !1,
        type: Boolean,
        short: [ "?", "H", "h" ],
        description: "\n    Show short usage output about the command specified.\n  "
      }), define("user-agent", {
        default: "npm/{npm-version} node/{node-version} {platform} {arch} workspaces/{workspaces} {ci}",
        type: String,
        description: "\n    Sets the User-Agent request header.  The following fields are replaced\n    with their actual counterparts:\n\n    * `{npm-version}` - The npm version in use\n    * `{node-version}` - The Node.js version in use\n    * `{platform}` - The value of `process.platform`\n    * `{arch}` - The value of `process.arch`\n    * `{workspaces}` - Set to `true` if the `workspaces` or `workspace`\n      options are set.\n    * `{ci}` - The value of the `ci-name` config, if set, prefixed with\n      `ci/`, or an empty string if `ci-name` is empty.\n  ",
        flatten(key, obj, flatOptions) {
          const value = obj[key], ciName = obj["ci-name"];
          let inWorkspaces = !1;
          (obj.workspaces || obj.workspace && obj.workspace.length) && (inWorkspaces = !0), 
          flatOptions.userAgent = value.replace(/\{node-version\}/gi, obj["node-version"]).replace(/\{npm-version\}/gi, obj["npm-version"]).replace(/\{platform\}/gi, process.platform).replace(/\{arch\}/gi, process.arch).replace(/\{workspaces\}/gi, inWorkspaces).replace(/\{ci\}/gi, ciName ? `ci/${ciName}` : "").trim(), 
          process.env.npm_config_user_agent = flatOptions.userAgent;
        }
      }), define("userconfig", {
        default: "~/.npmrc",
        type: path,
        description: "\n    The location of user-level configuration settings.\n\n    This may be overridden by the `npm_config_userconfig` environment\n    variable or the `--userconfig` command line option, but may _not_\n    be overridden by settings in the `globalconfig` file.\n  "
      }), define("version", {
        default: !1,
        type: Boolean,
        short: "v",
        description: "\n    If true, output the npm version and exit successfully.\n\n    Only relevant when specified explicitly on the command line.\n  "
      }), define("versions", {
        default: !1,
        type: Boolean,
        description: "\n    If true, output the npm version as well as node's `process.versions`\n    map and the version in the current working directory's `package.json`\n    file if one exists, and exit successfully.\n\n    Only relevant when specified explicitly on the command line.\n  "
      }), define("viewer", {
        default: isWindows ? "browser" : "man",
        defaultDescription: '\n    "man" on Posix, "browser" on Windows\n  ',
        type: String,
        description: '\n    The program to use to view help content.\n\n    Set to `"browser"` to view html help content in the default web browser.\n  '
      }), define("which", {
        default: null,
        hint: "<fundingSourceNumber>",
        type: [ null, Number ],
        description: "\n    If there are multiple funding sources, which 1-indexed source URL to open.\n  "
      }), define("workspace", {
        default: [],
        type: [ String, Array ],
        hint: "<workspace-name>",
        short: "w",
        envExport: !1,
        description: "\n    Enable running a command in the context of the configured workspaces of the\n    current project while filtering by running only the workspaces defined by\n    this configuration option.\n\n    Valid values for the `workspace` config are either:\n\n    * Workspace names\n    * Path to a workspace directory\n    * Path to a parent workspace directory (will result in selecting all\n      workspaces within that folder)\n\n    When set for the `npm init` command, this may be set to the folder of\n    a workspace which does not yet exist, to create the folder and set it\n    up as a brand new workspace within the project.\n  ",
        flatten: (key, obj, flatOptions) => {
          definitions["user-agent"].flatten("user-agent", obj, flatOptions);
        }
      }), define("workspaces", {
        default: null,
        type: [ null, Boolean ],
        short: "ws",
        envExport: !1,
        description: "\n    Set to true to run the command in the context of **all** configured\n    workspaces.\n\n    Explicitly setting this to false will cause commands like `install` to\n    ignore workspaces altogether.\n    When not set explicitly:\n\n    - Commands that operate on the `node_modules` tree (install, update,\n      etc.) will link workspaces into the `node_modules` folder.\n    - Commands that do other things (test, exec, publish, etc.) will operate\n      on the root project, _unless_ one or more workspaces are specified in\n      the `workspace` config.\n  ",
        flatten: (key, obj, flatOptions) => {
          definitions["user-agent"].flatten("user-agent", obj, flatOptions), flatOptions.workspacesEnabled = !1 !== obj[key];
        }
      }), define("workspaces-update", {
        default: !0,
        type: Boolean,
        description: "\n    If set to true, the npm cli will run an update after operations that may\n    possibly change the workspaces installed to the `node_modules` folder.\n  ",
        flatten
      }), define("yes", {
        default: null,
        type: [ null, Boolean ],
        short: "y",
        description: '\n    Automatically answer "yes" to any prompts that npm might print on\n    the command line.\n  '
      });
    },
    41727: (module, __unused_webpack_exports, __webpack_require__) => {
      const EventEmitter = __webpack_require__(82361), {resolve, dirname, join} = __webpack_require__(71017), Config = __webpack_require__(18919), chalk = __webpack_require__(25433), which = __webpack_require__(7017), fs = __webpack_require__(45264);
      __webpack_require__(49809).gracefulify(__webpack_require__(57147));
      const {definitions, flatten, shorthands} = __webpack_require__(70506), usage = __webpack_require__(88760), LogFile = __webpack_require__(7341), Timers = __webpack_require__(61682), Display = __webpack_require__(55969), log = __webpack_require__(86883), replaceInfo = __webpack_require__(45042), updateNotifier = __webpack_require__(36533), pkg = {
        version: __webpack_require__(2401).i8
      }, cmdList = __webpack_require__(34456);
      let warnedNonDashArg = !1;
      const _load = Symbol("_load");
      class Npm extends EventEmitter {
        static get version() {
          return pkg.version;
        }
        command=null;
        updateNotification=null;
        loadErr=null;
        argv=[];
        #loadPromise=null;
        #tmpFolder=null;
        #title="npm";
        #argvClean=[];
        #chalk=null;
        #logFile=new LogFile;
        #display=new Display;
        #timers=new Timers({
          start: "npm",
          listener: (name, ms) => {
            const args = [ "timing", name, `Completed in ${ms}ms` ];
            this.#logFile.log(...args), this.#display.log(...args);
          }
        });
        config=new Config({
          npmPath: dirname(__dirname),
          definitions,
          flatten,
          shorthands
        });
        get version() {
          return this.constructor.version;
        }
        deref(c) {
          if (!c) return;
          if (c.match(/[A-Z]/) && (c = c.replace(/([A-Z])/g, (m => "-" + m.toLowerCase()))), 
          -1 !== cmdList.plumbing.indexOf(c)) return c;
          let a = cmdList.abbrevs[c];
          for (;cmdList.aliases[a]; ) a = cmdList.aliases[a];
          return a;
        }
        async cmd(cmd) {
          await this.load();
          const command = this.deref(cmd);
          if (!command) throw Object.assign(new Error(`Unknown command ${cmd}`), {
            code: "EUNKNOWNCOMMAND"
          });
          return new (__webpack_require__(25879)(`./${command}.js`))(this);
        }
        async exec(cmd, args) {
          const command = await this.cmd(cmd), timeEnd = this.time(`command:${cmd}`);
          this.command || (process.env.npm_command = command.name, this.command = command.name, 
          this.commandInstance = command), updateNotifier(this).then((msg => this.updateNotification = msg)), 
          warnedNonDashArg || args.filter((arg => /^[\u2010-\u2015\u2212\uFE58\uFE63\uFF0D]/.test(arg))).forEach((arg => {
            warnedNonDashArg = !0, log.error("arg", "Argument starts with non-ascii dash, this is probably invalid:", arg);
          }));
          const workspacesEnabled = this.config.get("workspaces"), implicitWorkspace = this.config.get("workspace", "default").length > 0, workspacesFilters = this.config.get("workspace"), includeWorkspaceRoot = this.config.get("include-workspace-root"), hasWorkspaceFilters = workspacesFilters.length > 0, invalidWorkspaceConfig = !1 === workspacesEnabled && hasWorkspaceFilters, filterByWorkspaces = (workspacesEnabled || hasWorkspaceFilters) && (!implicitWorkspace || !command.ignoreImplicitWorkspace);
          command.workspaces = workspacesEnabled, command.workspacePaths = null, command.includeWorkspaceRoot = includeWorkspaceRoot;
          let execPromise = Promise.resolve();
          return this.config.get("usage") ? this.output(command.usage) : execPromise = invalidWorkspaceConfig ? Promise.reject(new Error("Can not use --no-workspaces and --workspace at the same time")) : filterByWorkspaces ? this.global ? Promise.reject(new Error("Workspaces not supported for global packages")) : command.execWorkspaces(args, workspacesFilters) : command.exec(args), 
          execPromise.finally(timeEnd);
        }
        async load() {
          return this.#loadPromise || (this.#loadPromise = this.time("npm:load", (async () => {
            await this[_load]().catch((er => {
              throw this.loadErr = er, er;
            })), this.config.get("force") && log.warn("using --force", "Recommended protections disabled.");
          }))), this.#loadPromise;
        }
        get loaded() {
          return this.config.loaded;
        }
        unload() {
          this.#timers.off(), this.#display.off(), this.#logFile.off();
        }
        time(name, fn) {
          return this.#timers.time(name, fn);
        }
        writeTimingFile() {
          this.#timers.writeFile({
            command: this.#argvClean,
            logfile: this.logFiles[this.logFiles.length - 1],
            logfiles: this.logFiles,
            version: this.version
          });
        }
        get title() {
          return this.#title;
        }
        set title(t) {
          process.title = t, this.#title = t;
        }
        async [_load]() {
          const node = this.time("npm:load:whichnode", (() => {
            try {
              return which.sync(process.argv[0]);
            } catch {}
          }));
          node && node.toUpperCase() !== process.execPath.toUpperCase() && (log.verbose("node symlink", node), 
          process.execPath = node, this.config.execPath = node), await this.time("npm:load:configload", (() => this.config.load())), 
          await this.time("npm:load:mkdirpcache", (() => fs.mkdir(this.cache, {
            recursive: !0,
            owner: "inherit"
          }).catch((e => log.verbose("cache", `could not create cache: ${e}`))))), await this.time("npm:load:mkdirplogs", (() => fs.mkdir(this.logsDir, {
            recursive: !0,
            owner: "inherit"
          }).catch((e => log.verbose("logfile", `could not create logs-dir: ${e}`))))), this.time("npm:load:setTitle", (() => {
            const {parsedArgv: {cooked, remain}} = this.config;
            this.argv = remain, this.title = [ "npm" ].concat(replaceInfo(remain)).join(" ").trim(), 
            this.#argvClean = replaceInfo(cooked), log.verbose("title", this.title), log.verbose("argv", this.#argvClean.map(JSON.stringify).join(" "));
          })), this.time("npm:load:display", (() => {
            this.#display.load({
              color: this.logColor,
              progress: this.flatOptions.progress,
              silent: this.silent,
              timing: this.config.get("timing"),
              loglevel: this.config.get("loglevel"),
              unicode: this.config.get("unicode"),
              heading: this.config.get("heading")
            }), process.env.COLOR = this.color ? "1" : "0";
          })), this.time("npm:load:logFile", (() => {
            this.#logFile.load({
              dir: this.logsDir,
              logsMax: this.config.get("logs-max")
            }), log.verbose("logfile", this.#logFile.files[0] || "no logfile created");
          })), this.time("npm:load:timers", (() => this.#timers.load({
            dir: this.config.get("timing") ? this.timingDir : null
          }))), this.time("npm:load:configScope", (() => {
            const configScope = this.config.get("scope");
            configScope && !/^@/.test(configScope) && this.config.set("scope", `@${configScope}`, this.config.find("scope"));
          }));
        }
        get flatOptions() {
          const {flat} = this.config;
          return this.command && (flat.npmCommand = this.command), flat;
        }
        get color() {
          return this.flatOptions.color;
        }
        get chalk() {
          if (!this.#chalk) {
            let level = chalk.level;
            this.color || (level = 0), this.#chalk = new chalk.Instance({
              level
            });
          }
          return this.#chalk;
        }
        get global() {
          return this.config.get("global") || "global" === this.config.get("location");
        }
        get logColor() {
          return this.flatOptions.logColor;
        }
        get silent() {
          return this.flatOptions.silent;
        }
        get lockfileVersion() {
          return 2;
        }
        get unfinishedTimers() {
          return this.#timers.unfinished;
        }
        get finishedTimers() {
          return this.#timers.finished;
        }
        get started() {
          return this.#timers.started;
        }
        get logFiles() {
          return this.#logFile.files;
        }
        get logsDir() {
          return this.config.get("logs-dir") || join(this.cache, "_logs");
        }
        get timingFile() {
          return this.#timers.file;
        }
        get timingDir() {
          return this.config.get("logs-dir") || this.cache;
        }
        get cache() {
          return this.config.get("cache");
        }
        set cache(r) {
          this.config.set("cache", r);
        }
        get globalPrefix() {
          return this.config.globalPrefix;
        }
        set globalPrefix(r) {
          this.config.globalPrefix = r;
        }
        get localPrefix() {
          return this.config.localPrefix;
        }
        set localPrefix(r) {
          this.config.localPrefix = r;
        }
        get globalDir() {
          return "win32" !== process.platform ? resolve(this.globalPrefix, "lib", "node_modules") : resolve(this.globalPrefix, "node_modules");
        }
        get localDir() {
          return resolve(this.localPrefix, "node_modules");
        }
        get dir() {
          return this.global ? this.globalDir : this.localDir;
        }
        get globalBin() {
          const b = this.globalPrefix;
          return "win32" !== process.platform ? resolve(b, "bin") : b;
        }
        get localBin() {
          return resolve(this.dir, ".bin");
        }
        get bin() {
          return this.global ? this.globalBin : this.localBin;
        }
        get prefix() {
          return this.global ? this.globalPrefix : this.localPrefix;
        }
        set prefix(r) {
          this[this.global ? "globalPrefix" : "localPrefix"] = r;
        }
        get usage() {
          return usage(this);
        }
        get tmp() {
          if (!this.#tmpFolder) {
            const rand = __webpack_require__(6113).randomBytes(4).toString("hex");
            this.#tmpFolder = `npm-${process.pid}-${rand}`;
          }
          return resolve(this.config.get("tmp"), this.#tmpFolder);
        }
        output(...msg) {
          log.clearProgress(), console.log(...msg), log.showProgress();
        }
        outputError(...msg) {
          log.clearProgress(), console.error(...msg), log.showProgress();
        }
      }
      module.exports = Npm, Npm._config = {
        definitions,
        shorthands
      }, Npm._log = log, Npm._didYouMean = __webpack_require__(90594), Npm._exitHandler = __webpack_require__(28685);
    },
    85917: (module, __unused_webpack_exports, __webpack_require__) => {
      const colorizeDiff = __webpack_require__(71657), jsDiff = {
        createTwoFilesPatch: __webpack_require__(23083).ym
      }, shouldPrintPatch = __webpack_require__(241);
      module.exports = ({files, opts = {}, refs, versions}) => {
        let res = "";
        const srcPrefix = opts.diffNoPrefix ? "" : opts.diffSrcPrefix || "a/", dstPrefix = opts.diffNoPrefix ? "" : opts.diffDstPrefix || "b/";
        for (const filename of files.values()) {
          const names = {
            a: `${srcPrefix}${filename}`,
            b: `${dstPrefix}${filename}`
          };
          let fileMode = "";
          const filenames = {
            a: refs.get(`a/${filename}`),
            b: refs.get(`b/${filename}`)
          }, contents = {
            a: filenames.a && filenames.a.content,
            b: filenames.b && filenames.b.content
          }, modes = {
            a: filenames.a && filenames.a.mode,
            b: filenames.b && filenames.b.mode
          };
          if (contents.a === contents.b && modes.a === modes.b) continue;
          if (opts.diffNameOnly) {
            res += `${filename}\n`;
            continue;
          }
          let patch = "", headerLength = 0;
          const header = str => {
            headerLength++, patch += `${str}\n`;
          };
          header(`diff --git ${names.a} ${names.b}`), modes.a === modes.b ? fileMode = filenames.a.mode : modes.a && !modes.b ? header(`deleted file mode ${modes.a}`) : !modes.a && modes.b ? header(`new file mode ${modes.b}`) : (header(`old mode ${modes.a}`), 
          header(`new mode ${modes.b}`)), header(`index ${opts.tagVersionPrefix || "v"}${versions.a}..${opts.tagVersionPrefix || "v"}${versions.b} ${fileMode}`), 
          shouldPrintPatch(filename) ? (patch += jsDiff.createTwoFilesPatch(names.a, names.b, contents.a || "", contents.b || "", "", "", {
            context: 0 === opts.diffUnified ? 0 : opts.diffUnified || 3,
            ignoreWhitespace: opts.diffIgnoreAllSpace
          }).replace("===================================================================\n", "").replace(/\t\n/g, "\n"), 
          headerLength += 2) : (header(`--- ${names.a}`), header(`+++ ${names.b}`)), res += opts.color ? colorizeDiff(patch, {
            headerLength
          }) : patch;
        }
        return res.trim();
      };
    },
    67697: (module, __unused_webpack_exports, __webpack_require__) => {
      const parseJSON = __webpack_require__(40295), diff = __webpack_require__(16719).H, diffApply = __webpack_require__(78162).t, globalObjectProperties = Object.getOwnPropertyNames(Object.prototype), PARENT_RE = /\|{7,}/g, OURS_RE = /<{7,}/g, THEIRS_RE = /={7,}/g, END_RE = />{7,}/g, isDiff = str => str.match(OURS_RE) && str.match(THEIRS_RE) && str.match(END_RE), isObj = obj => obj && "object" == typeof obj, copyPath = (to, from, path, i) => {
        const p = path[i];
        if (isObj(to[p]) && isObj(from[p]) && Array.isArray(to[p]) === Array.isArray(from[p])) return copyPath(to[p], from[p], path, i + 1);
        to[p] = from[p];
      }, resolve = (parent, ours, theirs) => {
        const dours = diff(parent, ours);
        for (let i = 0; i < dours.length; i++) if (!globalObjectProperties.find((prop => dours[i].path.includes(prop)))) try {
          diffApply(theirs, [ dours[i] ]);
        } catch (e) {
          copyPath(theirs, ours, dours[i].path, 0);
        }
        return theirs;
      };
      module.exports = Object.assign(((str, reviver, prefer) => {
        if ("theirs" !== (prefer = prefer || "ours") && "ours" !== prefer) throw new TypeError('prefer param must be "ours" or "theirs" if set');
        var content;
        if (65279 === (content = (content = str).toString()).charCodeAt(0) && (content = content.slice(1)), 
        !isDiff(str = content)) return parseJSON(str);
        const pieces = str.split(/[\n\r]+/g).reduce(((acc, line) => (line.match(PARENT_RE) ? acc.state = "parent" : line.match(OURS_RE) ? acc.state = "ours" : line.match(THEIRS_RE) ? acc.state = "theirs" : line.match(END_RE) ? acc.state = "top" : ("top" !== acc.state && "ours" !== acc.state || (acc.ours += line), 
        "top" !== acc.state && "theirs" !== acc.state || (acc.theirs += line), "top" !== acc.state && "parent" !== acc.state || (acc.parent += line)), 
        acc)), {
          state: "top",
          ours: "",
          theirs: "",
          parent: ""
        }), parent = parseJSON(pieces.parent, reviver), ours = parseJSON(pieces.ours, reviver), theirs = parseJSON(pieces.theirs, reviver);
        return "ours" === prefer ? resolve(parent, ours, theirs) : resolve(parent, theirs, ours);
      }), {
        isDiff
      });
    },
    40064: (module, __unused_webpack_exports, __webpack_require__) => {
      const pacote = __webpack_require__(86585), hostedGitInfo = __webpack_require__(19932)._hostedGit, openUrl = __webpack_require__(89562), log = __webpack_require__(86883), BaseCommand = __webpack_require__(26727);
      module.exports = class extends BaseCommand {
        static ignoreImplicitWorkspace=!1;
        static params=[ "browser", "registry", "workspace", "workspaces", "include-workspace-root" ];
        static usage=[ "[<pkgname> [<pkgname> ...]]" ];
        async exec(args) {
          args && args.length || (args = [ "." ]);
          for (const arg of args) {
            const opts = {
              ...this.npm.flatOptions,
              where: this.npm.localPrefix,
              fullMetadata: !0
            }, mani = await pacote.manifest(arg, opts), url = this.getUrl(arg, mani);
            log.silly(this.name, "url", url), await openUrl(this.npm, url, `${mani.name} ${this.name} available at the following URL`);
          }
        }
        async execWorkspaces(args, filters) {
          return args && args.length ? this.exec(args) : (await this.setWorkspaces(filters), 
          this.exec(this.workspacePaths));
        }
        hostedFromMani(mani) {
          const r = mani.repository, rurl = r ? "string" == typeof r ? r : "object" == typeof r && "string" == typeof r.url ? r.url : null : null;
          return rurl && hostedGitInfo.fromUrl(rurl.replace(/^git\+/, "")) || null;
        }
      };
    },
    10181: (module, __unused_webpack_exports, __webpack_require__) => {
      const onExit = __webpack_require__(52478), pacote = __webpack_require__(86585), AuditReport = __webpack_require__(88917), {subset, intersects} = __webpack_require__(5870), npa = __webpack_require__(19932), semver = __webpack_require__(5870), debug = __webpack_require__(63120), walkUp = __webpack_require__(43967), log = __webpack_require__(46521), hgi = npa._hostedGit, {dirname, resolve, relative} = __webpack_require__(71017), {depth: dfwalk} = __webpack_require__(75476), fs = __webpack_require__(57147), {promisify} = __webpack_require__(73837), lstat = promisify(fs.lstat), symlink = promisify(fs.symlink), mkdirp = __webpack_require__(87700), justMkdirp = __webpack_require__(41718), moveFile = __webpack_require__(24052), rimraf = promisify(__webpack_require__(11567)), PackageJson = __webpack_require__(66096), packageContents = __webpack_require__(20590), runScript = __webpack_require__(63036), {checkEngine, checkPlatform} = __webpack_require__(91126), _force = Symbol.for("force"), treeCheck = __webpack_require__(56912), relpath = __webpack_require__(52452), Diff = __webpack_require__(63636), retirePath = __webpack_require__(46826), promiseAllRejectLate = __webpack_require__(40639), optionalSet = __webpack_require__(9702), calcDepFlags = __webpack_require__(52667), {saveTypeMap, hasSubKey} = __webpack_require__(50089), _retiredPaths = Symbol("retiredPaths"), _retiredUnchanged = Symbol("retiredUnchanged"), _sparseTreeDirs = Symbol("sparseTreeDirs"), _sparseTreeRoots = Symbol("sparseTreeRoots"), _savePrefix = Symbol("savePrefix"), _retireShallowNodes = Symbol.for("retireShallowNodes"), _getBundlesByDepth = Symbol("getBundlesByDepth"), _registryResolved = Symbol("registryResolved"), _addNodeToTrashList = Symbol.for("addNodeToTrashList"), _workspaces = Symbol.for("workspaces"), _workspacesEnabled = Symbol.for("workspacesEnabled"), _trashList = Symbol.for("trashList"), _handleOptionalFailure = Symbol.for("handleOptionalFailure"), _loadTrees = Symbol.for("loadTrees"), _diffTrees = Symbol.for("diffTrees"), _createSparseTree = Symbol.for("createSparseTree"), _loadShrinkwrapsAndUpdateTrees = Symbol.for("loadShrinkwrapsAndUpdateTrees"), _shrinkwrapInflated = Symbol("shrinkwrapInflated"), _bundleUnpacked = Symbol("bundleUnpacked"), _bundleMissing = Symbol("bundleMissing"), _reifyNode = Symbol.for("reifyNode"), _extractOrLink = Symbol("extractOrLink"), _updateAll = Symbol.for("updateAll"), _updateNames = Symbol.for("updateNames"), _checkBins = Symbol.for("checkBins"), _symlink = Symbol("symlink"), _warnDeprecated = Symbol("warnDeprecated"), _loadBundlesAndUpdateTrees = Symbol.for("loadBundlesAndUpdateTrees"), _submitQuickAudit = Symbol("submitQuickAudit"), _unpackNewModules = Symbol.for("unpackNewModules"), _moveContents = Symbol.for("moveContents"), _moveBackRetiredUnchanged = Symbol.for("moveBackRetiredUnchanged"), _build = Symbol.for("build"), _removeTrash = Symbol.for("removeTrash"), _renamePath = Symbol.for("renamePath"), _rollbackRetireShallowNodes = Symbol.for("rollbackRetireShallowNodes"), _rollbackCreateSparseTree = Symbol.for("rollbackCreateSparseTree"), _rollbackMoveBackRetiredUnchanged = Symbol.for("rollbackMoveBackRetiredUnchanged"), _saveIdealTree = Symbol.for("saveIdealTree"), _saveLockFile = Symbol("saveLockFile"), _copyIdealToActual = Symbol("copyIdealToActual"), _addOmitsToTrashList = Symbol("addOmitsToTrashList"), _packageLockOnly = Symbol("packageLockOnly"), _dryRun = Symbol("dryRun"), _validateNodeModules = Symbol("validateNodeModules"), _nmValidated = Symbol("nmValidated"), _validatePath = Symbol("validatePath"), _reifyPackages = Symbol.for("reifyPackages"), _includeWorkspaceRoot = Symbol.for("includeWorkspaceRoot"), _omitDev = Symbol("omitDev"), _omitOptional = Symbol("omitOptional"), _omitPeer = Symbol("omitPeer"), _global = Symbol.for("global"), _pruneBundledMetadeps = Symbol("pruneBundledMetadeps"), _resolvedAdd = Symbol.for("resolvedAdd"), _usePackageLock = Symbol.for("usePackageLock"), _formatPackageLock = Symbol.for("formatPackageLock");
      module.exports = cls => class extends cls {
        constructor(options) {
          super(options);
          const {savePrefix = "^", packageLockOnly = !1, dryRun = !1, formatPackageLock = !0} = options;
          this[_dryRun] = !!dryRun, this[_packageLockOnly] = !!packageLockOnly, this[_savePrefix] = savePrefix, 
          this[_formatPackageLock] = !!formatPackageLock, this.diff = null, this[_retiredPaths] = {}, 
          this[_shrinkwrapInflated] = new Set, this[_retiredUnchanged] = {}, this[_sparseTreeDirs] = new Set, 
          this[_sparseTreeRoots] = new Set, this[_trashList] = new Set, this[_bundleUnpacked] = new Set, 
          this[_bundleMissing] = new Set, this[_nmValidated] = new Set;
        }
        async reify(options = {}) {
          if (this[_packageLockOnly] && this[_global]) {
            const er = new Error("cannot generate lockfile for global packages");
            throw er.code = "ESHRINKWRAPGLOBAL", er;
          }
          const omit = new Set(options.omit || []);
          return this[_omitDev] = omit.has("dev"), this[_omitOptional] = omit.has("optional"), 
          this[_omitPeer] = omit.has("peer"), this.addTracker("reify"), process.emit("time", "reify"), 
          await this[_validatePath](), await this[_loadTrees](options), await this[_diffTrees](), 
          await this[_reifyPackages](), await this[_saveIdealTree](options), await this[_copyIdealToActual](), 
          this.auditReport = await this.auditReport, this.finishTracker("reify"), process.emit("timeEnd", "reify"), 
          treeCheck(this.actualTree);
        }
        async [_validatePath]() {
          this[_packageLockOnly] || this[_dryRun] || (await justMkdirp(resolve(this.path)), 
          await this[_validateNodeModules](resolve(this.path, "node_modules")));
        }
        async [_reifyPackages]() {
          if (this[_dryRun]) return;
          if (this[_packageLockOnly]) return this[_submitQuickAudit]();
          let reifyTerminated = null;
          const removeHandler = onExit((({signal}) => (removeHandler(), reifyTerminated = Object.assign(new Error("process terminated"), {
            signal
          }), !1))), steps = [ [ _rollbackRetireShallowNodes, [ _retireShallowNodes ] ], [ _rollbackCreateSparseTree, [ _createSparseTree, _addOmitsToTrashList, _loadShrinkwrapsAndUpdateTrees, _loadBundlesAndUpdateTrees, _submitQuickAudit, _unpackNewModules ] ], [ _rollbackMoveBackRetiredUnchanged, [ _moveBackRetiredUnchanged, _build ] ] ];
          for (const [rollback, actions] of steps) for (const action of actions) try {
            if (await this[action](), reifyTerminated) throw reifyTerminated;
          } catch (er) {
            throw await this[rollback](er), er;
          }
          if (await this[_removeTrash](), reifyTerminated) throw reifyTerminated;
          removeHandler();
        }
        [_loadTrees](options) {
          process.emit("time", "reify:loadTrees");
          const bitOpt = {
            ...options,
            complete: this[_packageLockOnly] || this[_dryRun]
          };
          if (this[_packageLockOnly]) return this.buildIdealTree(bitOpt).then((() => process.emit("timeEnd", "reify:loadTrees")));
          const actualOpt = this[_global] ? {
            ignoreMissing: !0,
            global: !0,
            filter: (node, kid) => {
              if (0 === this.explicitRequests.size || !node.isProjectRoot) return !0;
              if (this.idealTree.edgesOut.has(kid)) return !0;
              return !![ ...this.explicitRequests ].some((edge => edge.name === kid));
            }
          } : {
            ignoreMissing: !0
          };
          return this[_global] ? this.buildIdealTree(bitOpt).then((() => this.loadActual(actualOpt))).then((() => process.emit("timeEnd", "reify:loadTrees"))) : Promise.all([ this.loadActual(actualOpt), this.buildIdealTree(bitOpt) ]).then((() => process.emit("timeEnd", "reify:loadTrees")));
        }
        [_diffTrees]() {
          if (this[_packageLockOnly]) return;
          process.emit("time", "reify:diffTrees");
          const includeWorkspaces = this[_workspacesEnabled], includeRootDeps = !this[_workspacesEnabled] || this[_includeWorkspaceRoot] && this[_workspaces].length > 0, filterNodes = [];
          if (this[_global] && this.explicitRequests.size) {
            const idealTree = this.idealTree.target, actualTree = this.actualTree.target;
            for (const {name} of this.explicitRequests) {
              const ideal = idealTree.children.get(name);
              ideal && filterNodes.push(ideal);
              const actual = actualTree.children.get(name);
              actual && filterNodes.push(actual);
            }
          } else {
            if (includeWorkspaces) for (const ws of this[_workspaces]) {
              const ideal = this.idealTree.children.get(ws);
              ideal && filterNodes.push(ideal);
              const actual = this.actualTree.children.get(ws);
              actual && filterNodes.push(actual);
            }
            if (includeRootDeps) for (const tree of [ this.idealTree, this.actualTree ]) for (const {type, to} of tree.edgesOut.values()) "workspace" !== type && to && filterNodes.push(to);
          }
          this.diff = Diff.calculate({
            shrinkwrapInflated: this[_shrinkwrapInflated],
            filterNodes,
            actual: this.actualTree,
            ideal: this.idealTree
          }), process.emit("timeEnd", "reify:diffTrees");
        }
        [_addNodeToTrashList](node, retire = !1) {
          const paths = [ node.path, ...node.binPaths ], moves = this[_retiredPaths];
          log.silly("reify", "mark", retire ? "retired" : "deleted", paths);
          for (const path of paths) if (retire) {
            const retired = retirePath(path);
            moves[path] = retired, this[_trashList].add(retired);
          } else this[_trashList].add(path);
        }
        [_retireShallowNodes]() {
          process.emit("time", "reify:retireShallow");
          const moves = this[_retiredPaths] = {};
          for (const diff of this.diff.children) "CHANGE" !== diff.action && "REMOVE" !== diff.action || this[_addNodeToTrashList](diff.actual, !0);
          log.silly("reify", "moves", moves);
          const movePromises = Object.entries(moves).map((([from, to]) => this[_renamePath](from, to)));
          return promiseAllRejectLate(movePromises).then((() => process.emit("timeEnd", "reify:retireShallow")));
        }
        [_renamePath](from, to, didMkdirp = !1) {
          return moveFile(from, to).catch((er => {
            if ("ENOENT" === er.code) return didMkdirp ? null : mkdirp(dirname(to)).then((() => this[_renamePath](from, to, !0)));
            if ("EEXIST" === er.code) return rimraf(to).then((() => moveFile(from, to)));
            throw er;
          }));
        }
        [_rollbackRetireShallowNodes](er) {
          process.emit("time", "reify:rollback:retireShallow");
          const moves = this[_retiredPaths], movePromises = Object.entries(moves).map((([from, to]) => this[_renamePath](to, from)));
          return promiseAllRejectLate(movePromises).catch((er => {})).then((() => process.emit("timeEnd", "reify:rollback:retireShallow"))).then((() => {
            throw er;
          }));
        }
        [_addOmitsToTrashList]() {
          if (!this[_omitDev] && !this[_omitOptional] && !this[_omitPeer]) return;
          process.emit("time", "reify:trashOmits");
          const filter = node => node.top.isProjectRoot && (node.peer && this[_omitPeer] || node.dev && this[_omitDev] || node.optional && this[_omitOptional] || node.devOptional && this[_omitOptional] && this[_omitDev]);
          for (const node of this.idealTree.inventory.filter(filter)) this[_addNodeToTrashList](node);
          process.emit("timeEnd", "reify:trashOmits");
        }
        [_createSparseTree]() {
          process.emit("time", "reify:createSparse");
          const leaves = this.diff.leaves.filter((diff => !("ADD" !== diff.action && "CHANGE" !== diff.action || this[_sparseTreeDirs].has(diff.ideal.path) || diff.ideal.isLink))).map((diff => diff.ideal)), dirsChecked = new Set;
          return promiseAllRejectLate(leaves.map((async node => {
            for (const d of walkUp(node.path)) {
              if (d === node.top.path) break;
              if (dirsChecked.has(d)) continue;
              dirsChecked.add(d);
              const st = await lstat(d).catch((er => null));
              if (st && !st.isDirectory()) {
                const retired = retirePath(d);
                this[_retiredPaths][d] = retired, this[_trashList].add(retired), await this[_renamePath](d, retired);
              }
            }
            const made = await mkdirp(node.path);
            this[_sparseTreeDirs].add(node.path), this[_sparseTreeRoots].add(made);
          }))).then((() => process.emit("timeEnd", "reify:createSparse")));
        }
        [_rollbackCreateSparseTree](er) {
          process.emit("time", "reify:rollback:createSparse");
          const roots = this[_sparseTreeRoots], failures = [], unlinks = [ ...roots, ...Object.keys(this[_retiredPaths]) ].map((path => rimraf(path).catch((er => failures.push([ path, er ])))));
          return promiseAllRejectLate(unlinks).then((() => {
            failures.length && log.warn("cleanup", "Failed to remove some directories", failures);
          })).then((() => process.emit("timeEnd", "reify:rollback:createSparse"))).then((() => this[_rollbackRetireShallowNodes](er)));
        }
        [_loadShrinkwrapsAndUpdateTrees]() {
          const seen = this[_shrinkwrapInflated], shrinkwraps = this.diff.leaves.filter((d => ("CHANGE" === d.action || "ADD" === d.action || !d.action) && d.ideal.hasShrinkwrap && !seen.has(d.ideal) && !this[_trashList].has(d.ideal.path)));
          if (!shrinkwraps.length) return;
          process.emit("time", "reify:loadShrinkwraps");
          const Arborist = this.constructor;
          return promiseAllRejectLate(shrinkwraps.map((diff => {
            const node = diff.ideal;
            return seen.add(node), diff.action ? this[_reifyNode](node) : node;
          }))).then((nodes => promiseAllRejectLate(nodes.map((node => new Arborist({
            ...this.options,
            path: node.path
          }).loadVirtual({
            root: node
          })))))).then((() => this[_diffTrees]())).then((() => this[_createSparseTree]())).then((() => this[_addOmitsToTrashList]())).then((() => this[_loadShrinkwrapsAndUpdateTrees]())).then((() => process.emit("timeEnd", "reify:loadShrinkwraps")));
        }
        [_reifyNode](node) {
          if (this[_trashList].has(node.path)) return node;
          const timer = `reifyNode:${node.location}`;
          process.emit("time", timer), this.addTracker("reify", node.name, node.location);
          const {npmVersion, nodeVersion} = this.options, p = Promise.resolve().then((async () => {
            node.optional && (checkEngine(node.package, npmVersion, nodeVersion, !1), checkPlatform(node.package, !1)), 
            await this[_checkBins](node), await this[_extractOrLink](node), await this[_warnDeprecated](node);
          }));
          return this[_handleOptionalFailure](node, p).then((() => (this.finishTracker("reify", node.name, node.location), 
          process.emit("timeEnd", timer), node)));
        }
        async [_validateNodeModules](nm) {
          if (this[_force] || this[_nmValidated].has(nm)) return;
          const st = await lstat(nm).catch((() => null));
          st && !st.isDirectory() ? (log.warn("reify", "Removing non-directory", nm), await rimraf(nm)) : this[_nmValidated].add(nm);
        }
        async [_extractOrLink](node) {
          let res = null;
          if (node.resolved) {
            const registryResolved = this[_registryResolved](node.resolved);
            registryResolved && (res = `${node.name}@${registryResolved}`);
          } else node.packageName && node.version && (res = `${node.packageName}@${node.version}`);
          if (!res) {
            const warning = "invalid or damaged lockfile detected\nplease re-try this operation once it completes\nso that the damage can be corrected, or perform\na fresh install with no lockfile if the problem persists.";
            return log.warn("reify", warning), log.verbose("reify", "unrecognized node in tree", node.path), 
            node.parent = null, node.fsParent = null, void this[_addNodeToTrashList](node);
          }
          const nm = resolve(node.parent.path, "node_modules");
          await this[_validateNodeModules](nm), node.isLink ? (await rimraf(node.path), await this[_symlink](node)) : (await debug((async () => {
            const st = await lstat(node.path).catch((e => null));
            if (st && !st.isDirectory()) throw debug.log("unpacking into a non-directory", node), 
            Object.assign(new Error("ENOTDIR: not a directory"), {
              code: "ENOTDIR",
              path: node.path
            });
          })), await pacote.extract(res, node.path, {
            ...this.options,
            resolved: node.resolved,
            integrity: node.integrity
          }));
        }
        async [_symlink](node) {
          const dir = dirname(node.path), target = node.realpath, rel = relative(dir, target);
          return await mkdirp(dir), symlink(rel, node.path, "junction");
        }
        [_warnDeprecated](node) {
          const {_id, deprecated} = node.package;
          deprecated && log.warn("deprecated", `${_id}: ${deprecated}`);
        }
        [_handleOptionalFailure](node, p) {
          return (node.optional ? p.catch((er => {
            const set = optionalSet(node);
            for (node of set) log.verbose("reify", "failed optional dependency", node.path), 
            this[_addNodeToTrashList](node);
          })) : p).then((() => node));
        }
        [_registryResolved](resolved) {
          const resolvedURL = hgi.parseUrl(resolved);
          if (resolvedURL) return this.options.replaceRegistryHost === resolvedURL.hostname || "always" === this.options.replaceRegistryHost ? `${this.registry.slice(0, -1)}${resolvedURL.pathname}${resolvedURL.searchParams}` : resolved;
        }
        [_loadBundlesAndUpdateTrees](depth = 0, bundlesByDepth = this[_getBundlesByDepth]()) {
          0 === depth && process.emit("time", "reify:loadBundles");
          const maxBundleDepth = bundlesByDepth.get("maxBundleDepth");
          if (depth > maxBundleDepth) return -1 !== maxBundleDepth && (this[_pruneBundledMetadeps](bundlesByDepth), 
          this[_diffTrees]()), void process.emit("timeEnd", "reify:loadBundles");
          const set = (bundlesByDepth.get(depth) || []).filter((node => node.root === this.idealTree && node.target !== node.root && !this[_trashList].has(node.path)));
          return set.length ? promiseAllRejectLate(set.map((node => (this[_bundleUnpacked].add(node), 
          this[_reifyNode](node))))).then((nodes => promiseAllRejectLate(nodes.map((async node => {
            const arb = new this.constructor({
              ...this.options,
              path: node.path
            }), notTransplanted = new Set(node.children.keys());
            await arb.loadActual({
              root: node,
              transplantFilter: node => !!node.package._id && (notTransplanted.delete(node.name), 
              !0)
            });
            for (const name of notTransplanted) this[_bundleMissing].add(node.children.get(name));
          }))))).then((() => this[_loadBundlesAndUpdateTrees](depth + 1, bundlesByDepth))) : this[_loadBundlesAndUpdateTrees](depth + 1, bundlesByDepth);
        }
        [_getBundlesByDepth]() {
          const bundlesByDepth = new Map;
          let maxBundleDepth = -1;
          return dfwalk({
            tree: this.diff,
            visit: diff => {
              const node = diff.ideal;
              if (!node) return;
              if (node.isProjectRoot) return;
              const {bundleDependencies} = node.package;
              bundleDependencies && bundleDependencies.length && (maxBundleDepth = Math.max(maxBundleDepth, node.depth), 
              bundlesByDepth.has(node.depth) ? bundlesByDepth.get(node.depth).push(node) : bundlesByDepth.set(node.depth, [ node ]));
            },
            getChildren: diff => diff.children
          }), bundlesByDepth.set("maxBundleDepth", maxBundleDepth), bundlesByDepth;
        }
        [_pruneBundledMetadeps](bundlesByDepth) {
          const bundleShadowed = new Set;
          for (const bundles of bundlesByDepth.values()) if (Array.isArray(bundles)) for (const node of bundles) for (const name of node.children.keys()) {
            const shadow = node.parent.resolve(name);
            shadow && (bundleShadowed.add(shadow), shadow.extraneous = !0);
          }
          for (const shadow of bundleShadowed) for (const shadDep of shadow.edgesOut.values()) shadDep.to && (bundleShadowed.add(shadDep.to), 
          shadDep.to.extraneous = !0);
          let changed;
          do {
            changed = !1;
            for (const shadow of bundleShadowed) for (const edge of shadow.edgesIn) if (!bundleShadowed.has(edge.from)) {
              shadow.extraneous = !1, bundleShadowed.delete(shadow), changed = !0;
              break;
            }
          } while (changed);
          for (const shadow of bundleShadowed) this[_addNodeToTrashList](shadow), shadow.root = null;
        }
        async [_submitQuickAudit]() {
          if (!1 === this.options.audit) return void (this.auditReport = null);
          process.emit("time", "reify:audit");
          const options = {
            ...this.options
          }, tree = this.idealTree;
          this[_workspaces] && this[_workspaces].length && (options.filterSet = this.workspaceDependencySet(tree, this[_workspaces], this[_includeWorkspaceRoot])), 
          this.auditReport = AuditReport.load(tree, options).then((res => (process.emit("timeEnd", "reify:audit"), 
          res)));
        }
        [_unpackNewModules]() {
          process.emit("time", "reify:unpack");
          const unpacks = [];
          return dfwalk({
            tree: this.diff,
            visit: diff => {
              if ("CHANGE" !== diff.action && "ADD" !== diff.action) return;
              const node = diff.ideal, bd = this[_bundleUnpacked].has(node), sw = this[_shrinkwrapInflated].has(node), bundleMissing = this[_bundleMissing].has(node);
              node && !node.isRoot && !bd && !sw && (bundleMissing || !node.inDepBundle) && unpacks.push(this[_reifyNode](node));
            },
            getChildren: diff => diff.children
          }), promiseAllRejectLate(unpacks).then((() => process.emit("timeEnd", "reify:unpack")));
        }
        [_moveBackRetiredUnchanged]() {
          process.emit("time", "reify:unretire");
          const moves = this[_retiredPaths];
          return this[_retiredUnchanged] = {}, promiseAllRejectLate(this.diff.children.map((diff => {
            if ("CHANGE" !== diff.action && "REMOVE" !== diff.action) return;
            const {path: realFolder} = diff.actual, retireFolder = moves[realFolder];
            return debug((() => {
              if (!retireFolder) {
                const er = new Error("trying to un-retire but not retired");
                throw Object.assign(er, {
                  realFolder,
                  retireFolder,
                  actual: diff.actual,
                  ideal: diff.ideal,
                  action: diff.action
                });
              }
            })), this[_retiredUnchanged][retireFolder] = [], promiseAllRejectLate(diff.unchanged.map((node => {
              if (node.isLink) return mkdirp(dirname(node.path)).then((() => this[_reifyNode](node)));
              if (node.inDepBundle && !this[_bundleMissing].has(node)) return;
              this[_retiredUnchanged][retireFolder].push(node);
              const rel = relative(realFolder, node.path), fromPath = resolve(retireFolder, rel), bd = node.package.bundleDependencies, dir = bd && bd.length ? node.path + "/node_modules" : node.path;
              return mkdirp(dir).then((() => this[_moveContents](node, fromPath)));
            })));
          }))).then((() => process.emit("timeEnd", "reify:unretire")));
        }
        [_moveContents](node, fromPath) {
          return packageContents({
            path: fromPath,
            depth: 1,
            packageJsonCache: new Map([ [ fromPath + "/package.json", node.package ] ])
          }).then((res => promiseAllRejectLate(res.map((path => {
            const rel = relative(fromPath, path), to = resolve(node.path, rel);
            return this[_renamePath](path, to);
          })))));
        }
        [_rollbackMoveBackRetiredUnchanged](er) {
          const moves = this[_retiredPaths], realFolders = new Map(Object.entries(moves).map((([k, v]) => [ v, k ]))), promises = Object.entries(this[_retiredUnchanged]).map((([retireFolder, nodes]) => promiseAllRejectLate(nodes.map((node => {
            const realFolder = realFolders.get(retireFolder), rel = relative(realFolder, node.path), fromPath = resolve(retireFolder, rel);
            return this[_moveContents]({
              ...node,
              path: fromPath
            }, node.path);
          })))));
          return promiseAllRejectLate(promises).then((() => this[_rollbackCreateSparseTree](er)));
        }
        [_build]() {
          process.emit("time", "reify:build");
          const nodes = [];
          dfwalk({
            tree: this.diff,
            leave: diff => {
              diff.ideal.isProjectRoot || nodes.push(diff.ideal);
            },
            getChildren: diff => diff && diff.children,
            filter: diff => "ADD" === diff.action || "CHANGE" === diff.action
          });
          for (const node of this.diff.unchanged) {
            const tree = node.root.target, linkedFromRoot = node.parent === tree || node.target.fsTop === tree;
            node.isLink && linkedFromRoot && nodes.push(node);
          }
          return this.rebuild({
            nodes,
            handleOptionalFailure: !0
          }).then((() => process.emit("timeEnd", "reify:build")));
        }
        async [_removeTrash]() {
          process.emit("time", "reify:trash");
          const promises = [], failures = [], rm = path => rimraf(path).catch((er => failures.push([ path, er ])));
          for (const path of this[_trashList]) promises.push(rm(path));
          await promiseAllRejectLate(promises), failures.length && log.warn("cleanup", "Failed to remove some directories", failures), 
          process.emit("timeEnd", "reify:trash");
        }
        async [_saveIdealTree](options) {
          const save = !(!1 === options.save), hasUpdates = this[_updateAll] || this[_updateNames].length;
          if (!!(!save && !hasUpdates || this[_global] || this[_dryRun])) return !1;
          process.emit("time", "reify:save");
          const updatedTrees = new Set, updateNodes = nodes => {
            for (const {name, tree: addTree} of nodes) {
              const edge = addTree.edgesOut.get(name), pkg = addTree.package, req = npa.resolve(name, edge.spec, addTree.realpath), {rawSpec, subSpec} = req, spec = subSpec ? subSpec.rawSpec : rawSpec, child = edge.to;
              if (!child || !addTree.isTop) continue;
              let newSpec;
              const isLocalDep = "directory" === req.type || "file" === req.type;
              if (req.registry) {
                const version = child.version, prefixRange = version ? this[_savePrefix] + version : "*";
                let range = spec;
                "range" === (subSpec || req).type && "*" !== spec && !subset(prefixRange, spec, {
                  loose: !0
                }) || (range = prefixRange);
                const pname = child.packageName;
                newSpec = name !== pname ? `npm:${pname}@${range}` : range;
              } else if (req.hosted) {
                const h = req.hosted, opt = {
                  noCommittish: !1
                };
                newSpec = h.https && h.auth ? `git+${h.https(opt)}` : h.shortcut(opt);
              } else if (isLocalDep) if ("workspace" === edge.type) {
                const {version} = edge.to.target;
                newSpec = version ? this[_savePrefix] + version : "*";
              } else {
                const p = req.fetchSpec.replace(/^file:/, "");
                newSpec = `file:${relpath(addTree.realpath, p).replace(/#/g, "%23")}`;
              } else newSpec = req.saveSpec;
              if (options.saveType) {
                pkg[saveTypeMap.get(options.saveType)][name] = newSpec, "prod" === options.saveType && pkg.optionalDependencies && delete pkg.optionalDependencies[name];
              } else hasSubKey(pkg, "dependencies", name) && (pkg.dependencies[name] = newSpec), 
              hasSubKey(pkg, "devDependencies", name) ? (pkg.devDependencies[name] = newSpec, 
              !hasSubKey(pkg, "peerDependencies", name) || !isLocalDep && intersects(newSpec, pkg.peerDependencies[name]) || (pkg.peerDependencies[name] = newSpec), 
              !hasSubKey(pkg, "optionalDependencies", name) || !isLocalDep && intersects(newSpec, pkg.optionalDependencies[name]) || (pkg.optionalDependencies[name] = newSpec)) : (hasSubKey(pkg, "peerDependencies", name) && (pkg.peerDependencies[name] = newSpec), 
              hasSubKey(pkg, "optionalDependencies", name) && (pkg.optionalDependencies[name] = newSpec));
              updatedTrees.add(addTree);
            }
          }, retrieveUpdatedNodes = names => {
            const directDeps = this.idealTree.inventory.filter((node => !node.isRoot && node.resolveParent && node.resolveParent.isRoot && (!names || names.includes(node.name)) && (node => {
              for (const edge of node.edgesIn) try {
                if (semver.subset(edge.spec, node.version)) return !1;
              } catch {}
              return !0;
            })(node))), nodes = [];
            for (const node of directDeps) for (const edgeIn of node.edgesIn) nodes.push({
              name: node.name,
              tree: edgeIn.from.target
            });
            return nodes;
          };
          if (save) if (this[_updateAll]) {
            updateNodes(retrieveUpdatedNodes());
          } else {
            if (this[_resolvedAdd].length && updateNodes(this[_resolvedAdd]), this[_updateNames].length) {
              updateNodes(retrieveUpdatedNodes(this[_updateNames]));
            }
            for (const {from: tree} of this.explicitRequests) updatedTrees.add(tree);
          }
          const {[Symbol.for("indent")]: indent} = this.idealTree.package, format = void 0 === indent ? "  " : indent, saveOpt = {
            format: this[_formatPackageLock] && format ? format : this[_formatPackageLock]
          }, promises = [ this[_saveLockFile](saveOpt) ], updatePackageJson = async tree => {
            const pkgJson = await PackageJson.load(tree.path).catch((() => new PackageJson(tree.path))), {dependencies = {}, devDependencies = {}, optionalDependencies = {}, peerDependencies = {}, bundleDependencies} = tree.package;
            pkgJson.update({
              dependencies,
              devDependencies,
              optionalDependencies,
              peerDependencies,
              bundleDependencies
            }), await pkgJson.save();
          };
          if (save) for (const tree of updatedTrees) tree.package = tree.package, promises.push(updatePackageJson(tree));
          return await Promise.all(promises), process.emit("timeEnd", "reify:save"), !0;
        }
        async [_saveLockFile](saveOpt) {
          if (!this[_usePackageLock]) return;
          const {meta} = this.idealTree;
          return meta.save(saveOpt);
        }
        async [_copyIdealToActual]() {
          for (const path of this[_trashList]) {
            const loc = relpath(this.idealTree.realpath, path), node = this.idealTree.inventory.get(loc);
            node && node.root === this.idealTree && (node.parent = null);
          }
          if (this.diff && this.diff.filterSet.size) {
            const reroot = new Set, {filterSet} = this.diff, seen = new Set;
            for (const [loc, ideal] of this.idealTree.inventory.entries()) {
              if (seen.add(loc), filterSet.has(ideal)) continue;
              const actual = this.actualTree.inventory.get(loc);
              if (actual) {
                if ([ ...actual.linksIn ].some((link => filterSet.has(link)))) {
                  seen.add(actual.location);
                  continue;
                }
                const {realpath, isLink} = actual;
                if (isLink && ideal.isLink && ideal.realpath === realpath) continue;
                reroot.add(actual);
              } else ideal.root = null;
            }
            for (const [loc, actual] of this.actualTree.inventory.entries()) seen.has(loc) || (seen.add(loc), 
            filterSet.has(actual) || reroot.add(actual));
            for (const actual of reroot) actual.root = this.idealTree;
            for (const top of this.idealTree.tops) 0 === top.linksIn.size && (top.root = null);
            calcDepFlags(this.idealTree);
          }
          if (this.idealTree.meta.filename = this.idealTree.realpath + "/node_modules/.package-lock.json", 
          this.idealTree.meta.hiddenLockfile = !0, this.actualTree = this.idealTree, this.idealTree = null, 
          !this[_global]) {
            await this.actualTree.meta.save();
            const ignoreScripts = !!this.options.ignoreScripts;
            if (!this[_dryRun] && !ignoreScripts && this.diff && this.diff.children.length) {
              const {path, package: pkg} = this.actualTree.target, stdio = this.options.foregroundScripts ? "inherit" : "pipe", {scripts = {}} = pkg;
              for (const event of [ "predependencies", "dependencies", "postdependencies" ]) if (Object.prototype.hasOwnProperty.call(scripts, event)) {
                const timer = `reify:run:${event}`;
                process.emit("time", timer), log.info("run", pkg._id, event, scripts[event]), await runScript({
                  event,
                  path,
                  pkg,
                  stdioString: !0,
                  stdio,
                  scriptShell: this.options.scriptShell
                }), process.emit("timeEnd", timer);
              }
            }
          }
        }
      };
    },
    84173: (module, __unused_webpack_exports, __webpack_require__) => {
      const isWindows = __webpack_require__(6669), setPATH = __webpack_require__(62968), {resolve} = __webpack_require__(71017), which = __webpack_require__(7017), npm_config_node_gyp = resolve(__dirname, "../bin/node-gyp.js"), escape = __webpack_require__(86527);
      module.exports = options => {
        const {event, path, scriptShell = isWindows ? process.env.ComSpec || "cmd" : "sh", binPaths, env = {}, stdio, cmd, args = [], stdioString = !1} = options, spawnEnv = setPATH(path, binPaths, {
          ...process.env,
          ...env,
          npm_package_json: resolve(path, "package.json"),
          npm_lifecycle_event: event,
          npm_lifecycle_script: cmd,
          npm_config_node_gyp
        });
        let doubleEscape = !1;
        const isCmd = /(?:^|\\)cmd(?:\.exe)?$/i.test(scriptShell);
        if (isCmd) {
          let pathToInitial, initialCmd = "", insideQuotes = !1;
          for (let i = 0; i < cmd.length; ++i) {
            const char = cmd.charAt(i);
            if (" " === char && !insideQuotes) break;
            initialCmd += char, '"' !== char && "'" !== char || (insideQuotes = !insideQuotes);
          }
          try {
            pathToInitial = which.sync(initialCmd, {
              path: spawnEnv.path,
              pathext: spawnEnv.pathext
            }).toLowerCase();
          } catch (err) {
            pathToInitial = initialCmd.toLowerCase();
          }
          doubleEscape = pathToInitial.endsWith(".cmd") || pathToInitial.endsWith(".bat");
        }
        let script = cmd;
        for (const arg of args) script += isCmd ? ` ${escape.cmd(arg, doubleEscape)}` : ` ${escape.sh(arg)}`;
        return [ scriptShell, isCmd ? [ "/d", "/s", "/c", script ] : [ "-c", "--", script ], {
          env: spawnEnv,
          stdioString,
          stdio,
          cwd: path,
          ...isCmd ? {
            windowsVerbatimArguments: !0
          } : {}
        } ];
      };
    },
    39148: module => {
      "use strict";
      module.exports = require("./tar");
    },
    99269: module => {
      "use strict";
      module.exports = require("./cacache");
    },
    14936: module => {
      "use strict";
      module.exports = require("./make-fetch-happen");
    },
    67105: module => {
      "use strict";
      module.exports = require("./minipass-fetch");
    },
    17770: module => {
      "use strict";
      module.exports = require("./normalize-package-data");
    },
    19932: module => {
      "use strict";
      module.exports = require("./npm-package-arg");
    },
    19334: module => {
      "use strict";
      module.exports = require("./npmlog");
    },
    5870: module => {
      "use strict";
      module.exports = require("./semver");
    },
    60440: module => {
      "use strict";
      module.exports = require("./ssri");
    },
    34436: module => {
      "use strict";
      module.exports = require("../vendor/glob");
    },
    71752: module => {
      "use strict";
      module.exports = require("../vendor/lru-cache");
    },
    51191: module => {
      "use strict";
      module.exports = require("../vendor/minimatch");
    },
    45018: module => {
      "use strict";
      module.exports = require("../vendor/minipass");
    },
    11567: module => {
      "use strict";
      module.exports = require("../vendor/rimraf");
    },
    29270: module => {
      "use strict";
      module.exports = require("bluebird");
    },
    39491: module => {
      "use strict";
      module.exports = require("assert");
    },
    14300: module => {
      "use strict";
      module.exports = require("buffer");
    },
    32081: module => {
      "use strict";
      module.exports = require("child_process");
    },
    22057: module => {
      "use strict";
      module.exports = require("constants");
    },
    6113: module => {
      "use strict";
      module.exports = require("crypto");
    },
    13639: module => {
      "use strict";
      module.exports = require("domain");
    },
    82361: module => {
      "use strict";
      module.exports = require("events");
    },
    57147: module => {
      "use strict";
      module.exports = require("fs");
    },
    98188: module => {
      "use strict";
      module.exports = require("module");
    },
    22037: module => {
      "use strict";
      module.exports = require("os");
    },
    71017: module => {
      "use strict";
      module.exports = require("path");
    },
    63477: module => {
      "use strict";
      module.exports = require("querystring");
    },
    14521: module => {
      "use strict";
      module.exports = require("readline");
    },
    12781: module => {
      "use strict";
      module.exports = require("stream");
    },
    76224: module => {
      "use strict";
      module.exports = require("tty");
    },
    57310: module => {
      "use strict";
      module.exports = require("url");
    },
    73837: module => {
      "use strict";
      module.exports = require("util");
    },
    26144: module => {
      "use strict";
      module.exports = require("vm");
    },
    71267: module => {
      "use strict";
      module.exports = require("worker_threads");
    },
    59796: module => {
      "use strict";
      module.exports = require("zlib");
    },
    78162: (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
      "use strict";
      __webpack_require__.d(__webpack_exports__, {
        t: () => diffApply
      });
      function diffApply(obj, diff, pathConverter) {
        if (!obj || "object" != typeof obj) throw new Error("base object must be an object or an array");
        if (!Array.isArray(diff)) throw new Error("diff must be an array");
        for (var diffLength = diff.length, i = 0; i < diffLength; i++) {
          var toPath, toPathCopy, lastToProp, subToObject, valueToMove, thisDiff = diff[i], subObject = obj, thisOp = thisDiff.op, thisPath = transformPath(pathConverter, thisDiff.path), thisFromPath = thisDiff.from && transformPath(pathConverter, thisDiff.from);
          if (thisFromPath) {
            if (toPath = thisPath, thisPath = thisFromPath, prototypeCheck(lastToProp = (toPathCopy = toPath.slice()).pop()), 
            null == lastToProp) return !1;
            for (var thisToProp; null != (thisToProp = toPathCopy.shift()); ) prototypeCheck(thisToProp), 
            thisToProp in subToObject || (subToObject[thisToProp] = {}), subToObject = subToObject[thisToProp];
          }
          var thisProp, pathCopy = thisPath.slice(), lastProp = pathCopy.pop();
          if (prototypeCheck(lastProp), null == lastProp) return !1;
          for (;null != (thisProp = pathCopy.shift()); ) prototypeCheck(thisProp), thisProp in subObject || (subObject[thisProp] = {}), 
          subObject = subObject[thisProp];
          if ("remove" === thisOp || "replace" === thisOp || "move" === thisOp) {
            var path = "move" === thisOp ? thisDiff.from : thisDiff.path;
            if (!subObject.hasOwnProperty(lastProp)) throw new Error([ "expected to find property", path, "in object", obj ].join(" "));
          }
          "remove" !== thisOp && "move" !== thisOp || ("move" === thisOp && (valueToMove = subObject[lastProp]), 
          Array.isArray(subObject) ? subObject.splice(lastProp, 1) : delete subObject[lastProp]), 
          "replace" !== thisOp && "add" !== thisOp || (subObject[lastProp] = thisDiff.value), 
          "move" === thisOp && (subObject[lastToProp] = valueToMove);
        }
        return subObject;
      }
      function transformPath(pathConverter, thisPath) {
        if (pathConverter) {
          if (thisPath = pathConverter(thisPath), !Array.isArray(thisPath)) throw new Error([ "pathConverter must return an array, returned:", thisPath ].join(" "));
        } else if (!Array.isArray(thisPath)) throw new Error([ "diff path", thisPath, "must be an array, consider supplying a path converter" ].join(" "));
        return thisPath;
      }
      function prototypeCheck(prop) {
        if ("__proto__" == prop || "constructor" == prop || "prototype" == prop) throw new Error("setting of prototype values not supported");
      }
    },
    16719: (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
      "use strict";
      function diff(obj1, obj2, pathConverter) {
        if (!obj1 || "object" != typeof obj1 || !obj2 || "object" != typeof obj2) throw new Error("both arguments must be objects or arrays");
        pathConverter || (pathConverter = function(arr) {
          return arr;
        });
        const finalDiffs = function getDiff(obj1, obj2, basePath, diffs) {
          for (var path, obj1Keys = Object.keys(obj1), obj1KeysLength = obj1Keys.length, obj2Keys = Object.keys(obj2), obj2KeysLength = obj2Keys.length, i = 0; i < obj1KeysLength; i++) {
            (key = Array.isArray(obj1) ? Number(obj1Keys[i]) : obj1Keys[i]) in obj2 || (path = basePath.concat(key), 
            diffs.remove.push({
              op: "remove",
              path: pathConverter(path)
            }));
          }
          for (i = 0; i < obj2KeysLength; i++) {
            var key, obj1AtKey = obj1[key = Array.isArray(obj2) ? Number(obj2Keys[i]) : obj2Keys[i]], obj2AtKey = obj2[key];
            if (key in obj1) obj1AtKey !== obj2AtKey && (Object(obj1AtKey) !== obj1AtKey || Object(obj2AtKey) !== obj2AtKey ? path = pushReplace(path, basePath, key, diffs, pathConverter, obj2) : Object.keys(obj1AtKey).length || Object.keys(obj2AtKey).length || String(obj1AtKey) == String(obj2AtKey) ? getDiff(obj1[key], obj2[key], basePath.concat(key), diffs) : path = pushReplace(path, basePath, key, diffs, pathConverter, obj2)); else {
              path = basePath.concat(key);
              var obj2Value = obj2[key];
              diffs.add.push({
                op: "add",
                path: pathConverter(path),
                value: obj2Value
              });
            }
          }
          return diffs;
        }(obj1, obj2, [], {
          remove: [],
          replace: [],
          add: []
        });
        return finalDiffs.remove.reverse().concat(finalDiffs.replace).concat(finalDiffs.add);
      }
      function pushReplace(path, basePath, key, diffs, pathConverter, obj2) {
        return path = basePath.concat(key), diffs.replace.push({
          op: "replace",
          path: pathConverter(path),
          value: obj2[key]
        }), path;
      }
      __webpack_require__.d(__webpack_exports__, {
        H: () => diff
      });
    },
    23083: (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
      "use strict";
      function Diff() {}
      function buildValues(diff, components, newString, oldString, useLongestToken) {
        for (var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0; componentPos < componentLen; componentPos++) {
          var component = components[componentPos];
          if (component.removed) {
            if (component.value = diff.join(oldString.slice(oldPos, oldPos + component.count)), 
            oldPos += component.count, componentPos && components[componentPos - 1].added) {
              var tmp = components[componentPos - 1];
              components[componentPos - 1] = components[componentPos], components[componentPos] = tmp;
            }
          } else {
            if (!component.added && useLongestToken) {
              var value = newString.slice(newPos, newPos + component.count);
              value = value.map((function(value, i) {
                var oldValue = oldString[oldPos + i];
                return oldValue.length > value.length ? oldValue : value;
              })), component.value = diff.join(value);
            } else component.value = diff.join(newString.slice(newPos, newPos + component.count));
            newPos += component.count, component.added || (oldPos += component.count);
          }
        }
        var lastComponent = components[componentLen - 1];
        return componentLen > 1 && "string" == typeof lastComponent.value && (lastComponent.added || lastComponent.removed) && diff.equals("", lastComponent.value) && (components[componentLen - 2].value += lastComponent.value, 
        components.pop()), components;
      }
      function clonePath(path) {
        return {
          newPos: path.newPos,
          components: path.components.slice(0)
        };
      }
      __webpack_require__.d(__webpack_exports__, {
        ym: () => createTwoFilesPatch
      }), Diff.prototype = {
        diff: function(oldString, newString) {
          var options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, callback = options.callback;
          "function" == typeof options && (callback = options, options = {}), this.options = options;
          var self = this;
          function done(value) {
            return callback ? (setTimeout((function() {
              callback(void 0, value);
            }), 0), !0) : value;
          }
          oldString = this.castInput(oldString), newString = this.castInput(newString), oldString = this.removeEmpty(this.tokenize(oldString));
          var newLen = (newString = this.removeEmpty(this.tokenize(newString))).length, oldLen = oldString.length, editLength = 1, maxEditLength = newLen + oldLen;
          options.maxEditLength && (maxEditLength = Math.min(maxEditLength, options.maxEditLength));
          var bestPath = [ {
            newPos: -1,
            components: []
          } ], oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
          if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) return done([ {
            value: this.join(newString),
            count: newString.length
          } ]);
          function execEditLength() {
            for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
              var basePath = void 0, addPath = bestPath[diagonalPath - 1], removePath = bestPath[diagonalPath + 1], _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
              addPath && (bestPath[diagonalPath - 1] = void 0);
              var canAdd = addPath && addPath.newPos + 1 < newLen, canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
              if (canAdd || canRemove) {
                if (!canAdd || canRemove && addPath.newPos < removePath.newPos ? (basePath = clonePath(removePath), 
                self.pushComponent(basePath.components, void 0, !0)) : ((basePath = addPath).newPos++, 
                self.pushComponent(basePath.components, !0, void 0)), _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath), 
                basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
                bestPath[diagonalPath] = basePath;
              } else bestPath[diagonalPath] = void 0;
            }
            editLength++;
          }
          if (callback) !function exec() {
            setTimeout((function() {
              if (editLength > maxEditLength) return callback();
              execEditLength() || exec();
            }), 0);
          }(); else for (;editLength <= maxEditLength; ) {
            var ret = execEditLength();
            if (ret) return ret;
          }
        },
        pushComponent: function(components, added, removed) {
          var last = components[components.length - 1];
          last && last.added === added && last.removed === removed ? components[components.length - 1] = {
            count: last.count + 1,
            added,
            removed
          } : components.push({
            count: 1,
            added,
            removed
          });
        },
        extractCommon: function(basePath, newString, oldString, diagonalPath) {
          for (var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = 0; newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1]); ) newPos++, 
          oldPos++, commonCount++;
          return commonCount && basePath.components.push({
            count: commonCount
          }), basePath.newPos = newPos, oldPos;
        },
        equals: function(left, right) {
          return this.options.comparator ? this.options.comparator(left, right) : left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
        },
        removeEmpty: function(array) {
          for (var ret = [], i = 0; i < array.length; i++) array[i] && ret.push(array[i]);
          return ret;
        },
        castInput: function(value) {
          return value;
        },
        tokenize: function(value) {
          return value.split("");
        },
        join: function(chars) {
          return chars.join("");
        }
      };
      var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, reWhitespace = /\S/, wordDiff = new Diff;
      wordDiff.equals = function(left, right) {
        return this.options.ignoreCase && (left = left.toLowerCase(), right = right.toLowerCase()), 
        left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
      }, wordDiff.tokenize = function(value) {
        for (var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), i = 0; i < tokens.length - 1; i++) !tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2]) && (tokens[i] += tokens[i + 2], 
        tokens.splice(i + 1, 2), i--);
        return tokens;
      };
      var lineDiff = new Diff;
      lineDiff.tokenize = function(value) {
        var retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
        linesAndNewlines[linesAndNewlines.length - 1] || linesAndNewlines.pop();
        for (var i = 0; i < linesAndNewlines.length; i++) {
          var line = linesAndNewlines[i];
          i % 2 && !this.options.newlineIsToken ? retLines[retLines.length - 1] += line : (this.options.ignoreWhitespace && (line = line.trim()), 
          retLines.push(line));
        }
        return retLines;
      };
      var sentenceDiff = new Diff;
      sentenceDiff.tokenize = function(value) {
        return value.split(/(\S.+?[.!?])(?=\s+|$)/);
      };
      var cssDiff = new Diff;
      function _typeof(obj) {
        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
          return typeof obj;
        } : function(obj) {
          return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, _typeof(obj);
      }
      function _toConsumableArray(arr) {
        return function(arr) {
          if (Array.isArray(arr)) return _arrayLikeToArray(arr);
        }(arr) || function(iter) {
          if ("undefined" != typeof Symbol && Symbol.iterator in Object(iter)) return Array.from(iter);
        }(arr) || function(o, minLen) {
          if (!o) return;
          if ("string" == typeof o) return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          "Object" === n && o.constructor && (n = o.constructor.name);
          if ("Map" === n || "Set" === n) return Array.from(o);
          if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }(arr) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function _arrayLikeToArray(arr, len) {
        (null == len || len > arr.length) && (len = arr.length);
        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
        return arr2;
      }
      cssDiff.tokenize = function(value) {
        return value.split(/([{}:;,]|\s+)/);
      };
      var objectPrototypeToString = Object.prototype.toString, jsonDiff = new Diff;
      function canonicalize(obj, stack, replacementStack, replacer, key) {
        var i, canonicalizedObj;
        for (stack = stack || [], replacementStack = replacementStack || [], replacer && (obj = replacer(key, obj)), 
        i = 0; i < stack.length; i += 1) if (stack[i] === obj) return replacementStack[i];
        if ("[object Array]" === objectPrototypeToString.call(obj)) {
          for (stack.push(obj), canonicalizedObj = new Array(obj.length), replacementStack.push(canonicalizedObj), 
          i = 0; i < obj.length; i += 1) canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
          return stack.pop(), replacementStack.pop(), canonicalizedObj;
        }
        if (obj && obj.toJSON && (obj = obj.toJSON()), "object" === _typeof(obj) && null !== obj) {
          stack.push(obj), canonicalizedObj = {}, replacementStack.push(canonicalizedObj);
          var _key, sortedKeys = [];
          for (_key in obj) obj.hasOwnProperty(_key) && sortedKeys.push(_key);
          for (sortedKeys.sort(), i = 0; i < sortedKeys.length; i += 1) canonicalizedObj[_key = sortedKeys[i]] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
          stack.pop(), replacementStack.pop();
        } else canonicalizedObj = obj;
        return canonicalizedObj;
      }
      jsonDiff.useLongestToken = !0, jsonDiff.tokenize = lineDiff.tokenize, jsonDiff.castInput = function(value) {
        var _this$options = this.options, undefinedReplacement = _this$options.undefinedReplacement, _this$options$stringi = _this$options.stringifyReplacer, stringifyReplacer = void 0 === _this$options$stringi ? function(k, v) {
          return void 0 === v ? undefinedReplacement : v;
        } : _this$options$stringi;
        return "string" == typeof value ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
      }, jsonDiff.equals = function(left, right) {
        return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"));
      };
      var arrayDiff = new Diff;
      function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
        options || (options = {}), void 0 === options.context && (options.context = 4);
        var diff = function(oldStr, newStr, callback) {
          return lineDiff.diff(oldStr, newStr, callback);
        }(oldStr, newStr, options);
        if (diff) {
          diff.push({
            value: "",
            lines: []
          });
          for (var hunks = [], oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1, _loop = function(i) {
            var current = diff[i], lines = current.lines || current.value.replace(/\n$/, "").split("\n");
            if (current.lines = lines, current.added || current.removed) {
              var _curRange;
              if (!oldRangeStart) {
                var prev = diff[i - 1];
                oldRangeStart = oldLine, newRangeStart = newLine, prev && (curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [], 
                oldRangeStart -= curRange.length, newRangeStart -= curRange.length);
              }
              (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map((function(entry) {
                return (current.added ? "+" : "-") + entry;
              })))), current.added ? newLine += lines.length : oldLine += lines.length;
            } else {
              if (oldRangeStart) if (lines.length <= 2 * options.context && i < diff.length - 2) {
                var _curRange2;
                (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
              } else {
                var _curRange3, contextSize = Math.min(lines.length, options.context);
                (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));
                var hunk = {
                  oldStart: oldRangeStart,
                  oldLines: oldLine - oldRangeStart + contextSize,
                  newStart: newRangeStart,
                  newLines: newLine - newRangeStart + contextSize,
                  lines: curRange
                };
                if (i >= diff.length - 2 && lines.length <= options.context) {
                  var oldEOFNewline = /\n$/.test(oldStr), newEOFNewline = /\n$/.test(newStr), noNlBeforeAdds = 0 == lines.length && curRange.length > hunk.oldLines;
                  !oldEOFNewline && noNlBeforeAdds && oldStr.length > 0 && curRange.splice(hunk.oldLines, 0, "\\ No newline at end of file"), 
                  (oldEOFNewline || noNlBeforeAdds) && newEOFNewline || curRange.push("\\ No newline at end of file");
                }
                hunks.push(hunk), oldRangeStart = 0, newRangeStart = 0, curRange = [];
              }
              oldLine += lines.length, newLine += lines.length;
            }
          }, i = 0; i < diff.length; i++) _loop(i);
          return {
            oldFileName,
            newFileName,
            oldHeader,
            newHeader,
            hunks
          };
        }
        function contextLines(lines) {
          return lines.map((function(entry) {
            return " " + entry;
          }));
        }
      }
      function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
        return function(diff) {
          var ret = [];
          diff.oldFileName == diff.newFileName && ret.push("Index: " + diff.oldFileName), 
          ret.push("==================================================================="), 
          ret.push("--- " + diff.oldFileName + (void 0 === diff.oldHeader ? "" : "\t" + diff.oldHeader)), 
          ret.push("+++ " + diff.newFileName + (void 0 === diff.newHeader ? "" : "\t" + diff.newHeader));
          for (var i = 0; i < diff.hunks.length; i++) {
            var hunk = diff.hunks[i];
            0 === hunk.oldLines && (hunk.oldStart -= 1), 0 === hunk.newLines && (hunk.newStart -= 1), 
            ret.push("@@ -" + hunk.oldStart + "," + hunk.oldLines + " +" + hunk.newStart + "," + hunk.newLines + " @@"), 
            ret.push.apply(ret, hunk.lines);
          }
          return ret.join("\n") + "\n";
        }(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));
      }
      arrayDiff.tokenize = function(value) {
        return value.slice();
      }, arrayDiff.join = arrayDiff.removeEmpty = function(value) {
        return value;
      };
    },
    62631: module => {
      "use strict";
      module.exports = JSON.parse('["3dm","3ds","3g2","3gp","7z","a","aac","adp","ai","aif","aiff","alz","ape","apk","appimage","ar","arj","asf","au","avi","bak","baml","bh","bin","bk","bmp","btif","bz2","bzip2","cab","caf","cgm","class","cmx","cpio","cr2","cur","dat","dcm","deb","dex","djvu","dll","dmg","dng","doc","docm","docx","dot","dotm","dra","DS_Store","dsk","dts","dtshd","dvb","dwg","dxf","ecelp4800","ecelp7470","ecelp9600","egg","eol","eot","epub","exe","f4v","fbs","fh","fla","flac","flatpak","fli","flv","fpx","fst","fvt","g3","gh","gif","graffle","gz","gzip","h261","h263","h264","icns","ico","ief","img","ipa","iso","jar","jpeg","jpg","jpgv","jpm","jxr","key","ktx","lha","lib","lvp","lz","lzh","lzma","lzo","m3u","m4a","m4v","mar","mdi","mht","mid","midi","mj2","mka","mkv","mmr","mng","mobi","mov","movie","mp3","mp4","mp4a","mpeg","mpg","mpga","mxu","nef","npx","numbers","nupkg","o","odp","ods","odt","oga","ogg","ogv","otf","ott","pages","pbm","pcx","pdb","pdf","pea","pgm","pic","png","pnm","pot","potm","potx","ppa","ppam","ppm","pps","ppsm","ppsx","ppt","pptm","pptx","psd","pya","pyc","pyo","pyv","qt","rar","ras","raw","resources","rgb","rip","rlc","rmf","rmvb","rpm","rtf","rz","s3m","s7z","scpt","sgi","shar","snap","sil","sketch","slk","smv","snk","so","stl","suo","sub","swf","tar","tbz","tbz2","tga","tgz","thmx","tif","tiff","tlz","ttc","ttf","txz","udf","uvh","uvi","uvm","uvp","uvs","uvu","viv","vob","war","wav","wax","wbmp","wdp","weba","webm","webp","whl","wim","wm","wma","wmv","wmx","woff","woff2","wrm","wvx","xbm","xif","xla","xlam","xls","xlsb","xlsm","xlsx","xlt","xltm","xltx","xm","xmind","xpi","xpm","xwd","xz","z","zip","zipx"]');
    },
    19194: module => {
      "use strict";
      module.exports = {
        i8: "13.6.2"
      };
    },
    2401: module => {
      "use strict";
      module.exports = {
        i8: "8.19.4-2"
      };
    },
    82803: module => {
      "use strict";
      module.exports = JSON.parse('{"name":"npm-registry-fetch","version":"13.3.1","description":"Fetch-based http client for use with npm registry APIs"}');
    }
  }, __webpack_module_cache__ = {};
  function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (void 0 !== cachedModule) return cachedModule.exports;
    var module = __webpack_module_cache__[moduleId] = {
      id: moduleId,
      loaded: !1,
      exports: {}
    };
    return __webpack_modules__[moduleId](module, module.exports, __webpack_require__), 
    module.loaded = !0, module.exports;
  }
  __webpack_require__.c = __webpack_module_cache__, __webpack_require__.n = module => {
    var getter = module && module.__esModule ? () => module.default : () => module;
    return __webpack_require__.d(getter, {
      a: getter
    }), getter;
  }, __webpack_require__.d = (exports, definition) => {
    for (var key in definition) __webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key) && Object.defineProperty(exports, key, {
      enumerable: !0,
      get: definition[key]
    });
  }, __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop), 
  __webpack_require__.r = exports => {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(exports, "__esModule", {
      value: !0
    });
  }, __webpack_require__.nmd = module => (module.paths = [], module.children || (module.children = []), 
  module);
  var __webpack_exports__ = __webpack_require__(__webpack_require__.s = 41727);
  module.exports = __webpack_exports__;
})();