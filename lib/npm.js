(() => {
  var __webpack_modules__ = {
    24844: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const BB = __webpack_require__(41142), figgyPudding = __webpack_require__(55212), libaccess = __webpack_require__(87878), npmConfig = __webpack_require__(23300), output = __webpack_require__(1015), otplease = __webpack_require__(83304), path = __webpack_require__(71017), prefix = __webpack_require__(44874).prefix, readPackageJson = BB.promisify(__webpack_require__(92200)), usage = __webpack_require__(29320), whoami = __webpack_require__(9364);
      module.exports = access, access.usage = usage("npm access", "npm access public [<package>]\nnpm access restricted [<package>]\nnpm access grant <read-only|read-write> <scope:team> [<package>]\nnpm access revoke <scope:team> [<package>]\nnpm access 2fa-required [<package>]\nnpm access 2fa-not-required [<package>]\nnpm access ls-packages [<user>|<scope>|<scope:team>]\nnpm access ls-collaborators [<package> [<user>]]\nnpm access edit [<package>]"), 
      access.subcommands = [ "public", "restricted", "grant", "revoke", "ls-packages", "ls-collaborators", "edit", "2fa-required", "2fa-not-required" ];
      const AccessConfig = figgyPudding({
        json: {}
      });
      function UsageError(msg = "") {
        throw Object.assign(new Error((msg ? `\nUsage: ${msg}\n\n` : "") + access.usage), {
          code: "EUSAGE"
        });
      }
      function access([cmd, ...args], cb) {
        return BB.try((() => {
          const fn = access.subcommands.includes(cmd) && access[cmd];
          return cmd || UsageError("Subcommand is required."), fn || UsageError(`${cmd} is not a recognized subcommand.`), 
          fn(args, AccessConfig(npmConfig()));
        })).then((x => cb(null, x)), (err => "EUSAGE" === err.code ? cb(err.message) : cb(err)));
      }
      function modifyPackage(pkg, opts, fn, requireScope = !0) {
        return getPackage(pkg, requireScope).then((pkgName => otplease(opts, (opts => fn(pkgName, opts)))));
      }
      function getPackage(name, requireScope = !0) {
        return BB.try((() => name && name.trim() ? name.trim() : readPackageJson(path.resolve(prefix, "package.json")).then((data => data.name), (err => {
          throw "ENOENT" === err.code ? new Error("no package name passed to command and no package.json found") : err;
        })))).then((name => {
          if (!requireScope || name.match(/^@[^/]+\/.*$/)) return name;
          UsageError("This command is only available for scoped packages.");
        }));
      }
      access.completion = function(opts, cb) {
        var argv = opts.conf.argv.remain;
        if (2 === argv.length) return cb(null, access.subcommands);
        switch (argv[2]) {
         case "grant":
          return 3 === argv.length ? cb(null, [ "read-only", "read-write" ]) : cb(null, []);

         case "public":
         case "restricted":
         case "ls-packages":
         case "ls-collaborators":
         case "edit":
         case "2fa-required":
         case "2fa-not-required":
         case "revoke":
          return cb(null, []);

         default:
          return cb(new Error(argv[2] + " not recognized"));
        }
      }, access.public = ([pkg], opts) => modifyPackage(pkg, opts, libaccess.public), 
      access.restricted = ([pkg], opts) => modifyPackage(pkg, opts, libaccess.restricted), 
      access.grant = ([perms, scopeteam, pkg], opts) => BB.try((() => {
        (!perms || "read-only" !== perms && "read-write" !== perms) && UsageError("First argument must be either `read-only` or `read-write.`"), 
        scopeteam || UsageError("`<scope:team>` argument is required.");
        const [, scope, team] = scopeteam.match(/^@?([^:]+):(.*)$/) || [];
        return scope || team || UsageError("Second argument used incorrect format.\nExample: @example:developers"), 
        modifyPackage(pkg, opts, ((pkgName, opts) => libaccess.grant(pkgName, scopeteam, perms, opts)), !1);
      })), access.revoke = ([scopeteam, pkg], opts) => BB.try((() => {
        scopeteam || UsageError("`<scope:team>` argument is required.");
        const [, scope, team] = scopeteam.match(/^@?([^:]+):(.*)$/) || [];
        return scope && team || UsageError("First argument used incorrect format.\nExample: @example:developers"), 
        modifyPackage(pkg, opts, ((pkgName, opts) => libaccess.revoke(pkgName, scopeteam, opts)));
      })), access["2fa-required"] = access.tfaRequired = ([pkg], opts) => modifyPackage(pkg, opts, libaccess.tfaRequired, !1), 
      access["2fa-not-required"] = access.tfaNotRequired = ([pkg], opts) => modifyPackage(pkg, opts, libaccess.tfaNotRequired, !1), 
      access["ls-packages"] = access.lsPackages = ([owner], opts) => (owner ? BB.resolve(owner) : BB.fromNode((cb => whoami([], !0, cb)))).then((owner => libaccess.lsPackages(owner, opts))).then((pkgs => {
        output(JSON.stringify(pkgs, null, 2));
      })), access["ls-collaborators"] = access.lsCollaborators = ([pkg, usr], opts) => getPackage(pkg, !1).then((pkgName => libaccess.lsCollaborators(pkgName, usr, opts))).then((collabs => {
        output(JSON.stringify(collabs, null, 2));
      })), access.edit = () => BB.reject(new Error("edit subcommand is not implemented yet"));
    },
    59117: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = adduser;
      const log = __webpack_require__(19334), npm = __webpack_require__(44874), usage = __webpack_require__(29320);
      let crypto;
      try {
        crypto = __webpack_require__(6113);
      } catch (ex) {}
      function adduser(args, cb) {
        if (!crypto) return cb(new Error("You must compile node with ssl support to use the adduser feature"));
        let registry = npm.config.get("registry");
        const scope = npm.config.get("scope"), creds = npm.config.getCredentialsByURI(npm.config.get("registry"));
        if (scope) {
          const scopedRegistry = npm.config.get(scope + ":registry"), cliRegistry = npm.config.get("registry", "cli");
          scopedRegistry && !cliRegistry && (registry = scopedRegistry);
        }
        let auth;
        log.disableProgress();
        try {
          auth = __webpack_require__(60488)("./" + npm.config.get("auth-type"));
        } catch (e) {
          return cb(new Error("no such auth module"));
        }
        auth.login(creds, registry, scope, (function(err, newCreds) {
          if (err) return cb(err);
          npm.config.del("_token", "user"), scope && npm.config.set(scope + ":registry", registry, "user"), 
          npm.config.setCredentialsByURI(registry, newCreds), npm.config.save("user", cb);
        }));
      }
      adduser.usage = usage("adduser", "npm adduser [--registry=url] [--scope=@orgname] [--auth-type=legacy] [--always-auth]");
    },
    20609: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const Bluebird = __webpack_require__(41142), audit = __webpack_require__(64795), figgyPudding = __webpack_require__(55212), fs = __webpack_require__(59799), Installer = __webpack_require__(70913).Installer, lockVerify = __webpack_require__(92263), log = __webpack_require__(19334), npa = __webpack_require__(4422), npm = __webpack_require__(44874), npmConfig = __webpack_require__(23300), output = __webpack_require__(1015), parseJson = __webpack_require__(15071), readFile = Bluebird.promisify(fs.readFile), AuditConfig = figgyPudding({
        also: {},
        "audit-level": {},
        deepArgs: "deep-args",
        "deep-args": {},
        dev: {},
        force: {},
        "dry-run": {},
        global: {},
        json: {},
        only: {},
        parseable: {},
        prod: {},
        production: {},
        registry: {},
        runId: {}
      });
      module.exports = auditCmd;
      const usage = __webpack_require__(29320);
      auditCmd.usage = usage("audit", "\nnpm audit [--json] [--production]\nnpm audit fix [--force|--package-lock-only|--dry-run|--production|--only=(dev|prod)]"), 
      auditCmd.completion = function(opts, cb) {
        const argv = opts.conf.argv.remain;
        return "audit" === argv[2] ? cb(null, []) : cb(new Error(argv[2] + " not recognized"));
      };
      class Auditor extends Installer {
        constructor(where, dryrun, args, opts) {
          super(where, dryrun, args, opts), this.deepArgs = opts && opts.deepArgs || [], this.runId = opts.runId || "", 
          this.audit = !1;
        }
        loadAllDepsIntoIdealTree(cb) {
          Bluebird.fromNode((cb => super.loadAllDepsIntoIdealTree(cb))).then((() => {
            if (this.deepArgs && this.deepArgs.length) return this.deepArgs.forEach((arg => {
              arg.reduce(((acc, child, ii) => {
                if (!acc) return;
                const spec = npa(child), target = acc.requires.find((n => n.package.name === spec.name)) || acc.requires.find((n => audit.scrub(n.package.name, this.runId) === spec.name));
                if (target && ii === arg.length - 1) {
                  target.loaded = !1, target.package = {
                    name: spec.name,
                    version: spec.fetchSpec,
                    _requested: target.package._requested
                  }, delete target.fakeChild;
                  let parent = target.parent;
                  for (;parent; ) parent.loaded = !1, parent = parent.parent;
                  target.requiredBy.forEach((par => {
                    par.loaded = !1, delete par.fakeChild;
                  }));
                }
                return target;
              }), this.idealTree);
            })), Bluebird.fromNode((cb => super.loadAllDepsIntoIdealTree(cb)));
          })).nodeify(cb);
        }
        runPreinstallTopLevelLifecycles(cb) {
          cb();
        }
        runPostinstallTopLevelLifecycles(cb) {
          cb();
        }
      }
      function maybeReadFile(name) {
        const file = `${npm.prefix}/${name}`;
        return readFile(file).then((data => {
          try {
            return parseJson(data);
          } catch (ex) {
            throw ex.code = "EJSONPARSE", ex;
          }
        })).catch({
          code: "ENOENT"
        }, (() => null)).catch((ex => {
          throw ex.file = file, ex;
        }));
      }
      function auditCmd(args, cb) {
        const opts = AuditConfig(npmConfig());
        if (opts.global) {
          const err = new Error("`npm audit` does not support testing globals");
          throw err.code = "EAUDITGLOBAL", err;
        }
        return args.length && "fix" !== args[0] ? cb(new Error("Invalid audit subcommand: `" + args[0] + "`\n\nUsage:\n" + auditCmd.usage)) : Bluebird.all([ maybeReadFile("npm-shrinkwrap.json"), maybeReadFile("package-lock.json"), maybeReadFile("package.json") ]).spread(((shrinkwrap, lockfile, pkgJson) => {
          const sw = shrinkwrap || lockfile;
          if (!pkgJson) {
            const err = new Error("No package.json found: Cannot audit a project without a package.json");
            throw err.code = "EAUDITNOPJSON", err;
          }
          if (!sw) {
            const err = new Error("Neither npm-shrinkwrap.json nor package-lock.json found: Cannot audit a project without a lockfile");
            throw err.code = "EAUDITNOLOCK", err;
          }
          shrinkwrap && lockfile && log.warn("audit", "Both npm-shrinkwrap.json and package-lock.json exist, using npm-shrinkwrap.json.");
          const requires = Object.assign({}, pkgJson && pkgJson.dependencies || {}, !opts.production && pkgJson && pkgJson.devDependencies || {});
          return lockVerify(npm.prefix).then((result => {
            if (result.status) return audit.generate(sw, requires);
            const err = new Error(`Errors were found in your ${shrinkwrap ? "npm-shrinkwrap.json" : "package-lock.json"}, run  npm install  to fix them.\n    ` + result.errors.join("\n    "));
            throw err.code = "ELOCKVERIFY", err;
          }));
        })).then((auditReport => audit.submitForFullReport(auditReport))).catch((err => {
          if (err.statusCode >= 400) {
            let msg;
            msg = 401 === err.statusCode ? `Either your login credentials are invalid or your registry (${opts.registry}) does not support audit.` : 404 === err.statusCode ? `Your configured registry (${opts.registry}) does not support audit requests.` : `Your configured registry (${opts.registry}) may not support audit requests, or the audit endpoint may be temporarily unavailable.`, 
            err.body.length && (msg += "\nThe server said: " + err.body);
            const ne = new Error(msg);
            throw ne.code = "ENOAUDIT", ne.wrapped = err, ne;
          }
          throw err;
        })).then((auditResult => {
          if ("fix" === args[0]) {
            const actions = (auditResult.actions || []).reduce(((acc, action) => {
              if (action = function(action, opts) {
                const includeDev = opts.dev || !/^prod(uction)?$/.test(opts.only) && !opts.production || /^dev(elopment)?$/.test(opts.only) || /^dev(elopment)?$/.test(opts.also), includeProd = !/^dev(elopment)?$/.test(opts.only), resolves = action.resolves.filter((({dev}) => dev && includeDev || !dev && includeProd));
                if (resolves.length) return Object.assign({}, action, {
                  resolves
                });
              }(action, opts), !action) return acc;
              if (action.isMajor) acc.major.add(`${action.module}@${action.target}`), action.resolves.forEach((({id, path}) => acc.majorFixes.add(`${id}::${path}`))); else if ("install" === action.action) acc.install.add(`${action.module}@${action.target}`), 
              action.resolves.forEach((({id, path}) => acc.installFixes.add(`${id}::${path}`))); else if ("update" === action.action) {
                const name = action.module, version = action.target;
                action.resolves.forEach((vuln => {
                  acc.updateFixes.add(`${vuln.id}::${vuln.path}`);
                  const modPath = vuln.path.split(">"), newPath = modPath.slice(0, modPath.indexOf(name)).concat(`${name}@${version}`);
                  1 === newPath.length ? acc.install.add(newPath[0]) : acc.update.add(newPath.join(">"));
                }));
              } else "review" === action.action && action.resolves.forEach((({id, path}) => acc.review.add(`${id}::${path}`)));
              return acc;
            }), {
              install: new Set,
              installFixes: new Set,
              update: new Set,
              updateFixes: new Set,
              major: new Set,
              majorFixes: new Set,
              review: new Set
            });
            return Bluebird.try((() => {
              const installMajor = opts.force, installCount = actions.install.size + (installMajor ? actions.major.size : 0) + actions.update.size, vulnFixCount = new Set([ ...actions.installFixes, ...actions.updateFixes, ...installMajor ? actions.majorFixes : [] ]).size, metavuln = auditResult.metadata.vulnerabilities, total = Object.keys(metavuln).reduce(((acc, key) => acc + metavuln[key]), 0);
              return installCount && log.verbose("audit", "installing", [ ...actions.install, ...installMajor ? actions.major : [], ...actions.update ]), 
              Bluebird.fromNode((cb => {
                new Auditor(npm.prefix, !!opts["dry-run"], [ ...actions.install, ...installMajor ? actions.major : [] ], opts.concat({
                  runId: auditResult.runId,
                  deepArgs: [ ...actions.update ].map((u => u.split(">")))
                }).toJSON()).run(cb);
              })).then((() => {
                const numScanned = auditResult.metadata.totalDependencies;
                opts.json || opts.parseable || (output(`fixed ${vulnFixCount} of ${total} vulnerabilit${1 === total ? "y" : "ies"} in ${numScanned} scanned package${1 === numScanned ? "" : "s"}`), 
                actions.review.size && output(`  ${actions.review.size} vulnerabilit${1 === actions.review.size ? "y" : "ies"} required manual review and could not be updated`), 
                actions.major.size && (output(`  ${actions.major.size} package update${1 === actions.major.size ? "" : "s"} for ${actions.majorFixes.size} vulnerabilit${1 === actions.majorFixes.size ? "y" : "ies"} involved breaking changes`), 
                output(installMajor ? "  (installed due to `--force` option)" : "  (use `npm audit fix --force` to install breaking changes; or refer to `npm audit` for steps to fix these manually)")));
              }));
            }));
          }
          {
            const levels = [ "low", "moderate", "high", "critical" ], minLevel = levels.indexOf(opts["audit-level"]);
            return levels.reduce(((count, level, i) => i < minLevel ? count : count + (auditResult.metadata.vulnerabilities[level] || 0)), 0) > 0 && (process.exitCode = 1), 
            opts.parseable ? audit.printParseableReport(auditResult) : audit.printFullReport(auditResult);
          }
        })).asCallback(cb);
      }
    },
    2126: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const read = __webpack_require__(87121), profile = __webpack_require__(29668), log = __webpack_require__(19334), figgyPudding = __webpack_require__(55212), npmConfig = __webpack_require__(23300), output = __webpack_require__(1015), openUrl = __webpack_require__(89562), openerPromise = url => new Promise(((resolve, reject) => {
        openUrl(url, "to complete your login please visit", (er => er ? reject(er) : resolve()));
      })), loginPrompter = creds => {
        const opts = {
          log
        };
        return read.username("Username:", creds.username, opts).then((u => (creds.username = u, 
        read.password("Password:", creds.password)))).then((p => (creds.password = p, read.email("Email: (this IS public) ", creds.email, opts)))).then((e => (creds.email = e, 
        creds)));
      }, LoginOpts = figgyPudding({
        "always-auth": {},
        creds: {},
        log: {
          default: () => log
        },
        registry: {},
        scope: {}
      });
      module.exports.login = (creds = {}, registry, scope, cb) => {
        (function(opts) {
          return profile.login(openerPromise, loginPrompter, opts).catch((err => {
            if ("EOTP" === err.code) throw err;
            const u = opts.creds.username, p = opts.creds.password, e = opts.creds.email;
            if (!(u && p && e)) throw err;
            return profile.adduserCouch(u, e, p, opts);
          })).catch((err => {
            if ("EOTP" !== err.code) throw err;
            return read.otp("Enter one-time password: ").then((otp => {
              const u = opts.creds.username, p = opts.creds.password;
              return profile.loginCouch(u, p, opts.concat({
                otp
              }));
            }));
          })).then((result => {
            const newCreds = {};
            result && result.token ? newCreds.token = result.token : (newCreds.username = opts.creds.username, 
            newCreds.password = opts.creds.password, newCreds.email = opts.creds.email, newCreds.alwaysAuth = opts["always-auth"]);
            const usermsg = opts.creds.username ? " user " + opts.creds.username : "";
            opts.log.info("login", "Authorized" + usermsg);
            const scopeMessage = opts.scope ? " to scope " + opts.scope : "", userout = opts.creds.username ? " as " + opts.creds.username : "";
            return output("Logged in%s%s on %s.", userout, scopeMessage, opts.registry), newCreds;
          }));
        })(LoginOpts(npmConfig()).concat({
          scope,
          registry,
          creds
        })).then((newCreds => cb(null, newCreds))).catch(cb);
      };
    },
    4620: (module, __unused_webpack_exports, __webpack_require__) => {
      var ssoAuth = __webpack_require__(14956), npm = __webpack_require__(44874);
      module.exports.login = function() {
        npm.config.set("sso-type", "oauth"), ssoAuth.login.apply(this, arguments);
      };
    },
    7474: (module, __unused_webpack_exports, __webpack_require__) => {
      var ssoAuth = __webpack_require__(14956), npm = __webpack_require__(44874);
      module.exports.login = function() {
        npm.config.set("sso-type", "saml"), ssoAuth.login.apply(this, arguments);
      };
    },
    14956: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const BB = __webpack_require__(41142), figgyPudding = __webpack_require__(55212), log = __webpack_require__(19334), npmConfig = __webpack_require__(23300), npmFetch = __webpack_require__(11527), output = __webpack_require__(1015), openUrl = BB.promisify(__webpack_require__(89562)), otplease = __webpack_require__(83304), profile = __webpack_require__(29668), SsoOpts = figgyPudding({
        ssoType: "sso-type",
        "sso-type": {},
        ssoPollFrequency: "sso-poll-frequency",
        "sso-poll-frequency": {}
      });
      function pollForSession(registry, token, opts) {
        return log.info("adduser", "Polling for validated SSO session"), npmFetch.json("/-/whoami", opts.concat({
          registry,
          forceAuth: {
            token
          }
        })).then((({username}) => username), (err => {
          if ("E401" === err.code) return (time = opts["sso-poll-frequency"], new BB((resolve => {
            setTimeout(resolve, time);
          }))).then((() => pollForSession(registry, token, opts)));
          throw err;
          var time;
        }));
      }
      module.exports.login = function(creds, registry, scope, cb) {
        const opts = SsoOpts(npmConfig()).concat({
          creds,
          registry,
          scope
        }), ssoType = opts.ssoType;
        if (!ssoType) return cb(new Error("Missing option: sso-type"));
        const auth = {
          username: "npm_" + ssoType + "_auth_dummy_user",
          password: "placeholder",
          email: "support@npmjs.com",
          authType: ssoType
        };
        otplease(opts, (opts => profile.loginCouch(auth.username, auth.password, opts))).then((({token, sso}) => {
          if (!token) throw new Error("no SSO token returned");
          if (!sso) throw new Error("no SSO URL returned by services");
          return openUrl(sso, "to complete your login please visit").then((() => pollForSession(registry, token, opts))).then((username => (log.info("adduser", "Authorized user %s", username), 
          output("Logged in as %s%s on %s.", username, scope ? " to scope " + scope : "", registry), 
          {
            token
          })));
        })).nodeify(cb);
      };
    },
    60488: (module, __unused_webpack_exports, __webpack_require__) => {
      var map = {
        "./legacy": 2126,
        "./legacy.js": 2126,
        "./oauth": 4620,
        "./oauth.js": 4620,
        "./saml": 7474,
        "./saml.js": 7474,
        "./sso": 14956,
        "./sso.js": 14956
      };
      function webpackContext(req) {
        var id = webpackContextResolve(req);
        return __webpack_require__(id);
      }
      function webpackContextResolve(req) {
        if (!__webpack_require__.o(map, req)) {
          var e = new Error("Cannot find module '" + req + "'");
          throw e.code = "MODULE_NOT_FOUND", e;
        }
        return map[req];
      }
      webpackContext.keys = function() {
        return Object.keys(map);
      }, webpackContext.resolve = webpackContextResolve, module.exports = webpackContext, 
      webpackContext.id = 60488;
    },
    51791: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = bin;
      var npm = __webpack_require__(44874), osenv = __webpack_require__(20396), output = __webpack_require__(1015);
      function bin(args, silent, cb) {
        "function" != typeof cb && (cb = silent, silent = !1);
        var b = npm.bin, PATH = osenv.path();
        silent || output(b), process.nextTick(cb.bind(this, null, b)), npm.config.get("global") && -1 === PATH.indexOf(b) && npm.config.get("logstream").write("(not in PATH env variable)\n");
      }
      bin.usage = "npm bin [--global]";
    },
    73741: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = bugs;
      var log = __webpack_require__(19334), openUrl = __webpack_require__(89562), fetchPackageMetadata = __webpack_require__(3138), usage = __webpack_require__(29320);
      function bugs(args, cb) {
        var n = args.length ? args[0] : ".";
        fetchPackageMetadata(n, ".", {
          fullMetadata: !0
        }, (function(er, d) {
          if (er) return cb(er);
          var url = d.bugs && ("string" == typeof d.bugs ? d.bugs : d.bugs.url);
          url || (url = "https://www.npmjs.org/package/" + d.name), log.silly("bugs", "url", url), 
          openUrl(url, "bug list available at the following URL", cb);
        }));
      }
      bugs.usage = usage("bugs", "npm bugs [<pkgname>]"), bugs.completion = function(opts, cb) {
        cb();
      };
    },
    34674: (module, __unused_webpack_exports, __webpack_require__) => {
      var npm = __webpack_require__(44874), log = __webpack_require__(19334), chain = __webpack_require__(89009).chain, path = __webpack_require__(71017), fs = __webpack_require__(59799), lifecycle = __webpack_require__(4705), readJson = __webpack_require__(92200), binLinks = __webpack_require__(82503), binLinksConfig = __webpack_require__(96228), ini = __webpack_require__(8477), writeFile = __webpack_require__(19804);
      function build(args, global, didPre, didRB, cb) {
        if ("function" != typeof cb && (cb = didRB, didRB = !1), "function" != typeof cb && (cb = didPre, 
        didPre = !1), "function" != typeof cb && (cb = global, global = npm.config.get("global")), 
        args.length) {
          var builder = build_(global, didPre, didRB);
          chain(args.map((function(arg) {
            return function(cb) {
              builder(arg, cb);
            };
          })), cb);
        } else readJson(path.resolve(npm.localPrefix, "package.json"), (function(er, pkg) {
          !args.length && pkg && pkg.scripts && pkg.scripts.build && log.warn("build", "`npm build` called with no arguments. Did you mean to `npm run-script build`?"), 
          cb();
        }));
      }
      function build_(global, didPre, didRB) {
        return function(folder, cb) {
          folder = path.resolve(folder), build._didBuild[folder] && log.info("build", "already built", folder), 
          build._didBuild[folder] = !0, log.info("build", folder), readJson(path.resolve(folder, "package.json"), (function(er, pkg) {
            if (er) return cb(er);
            chain([ !didPre && [ lifecycle, pkg, "preinstall", folder ], [ linkStuff, pkg, folder, global ], !didRB && [ rebuildBundles, pkg, folder ], [ writeBuiltinConf, pkg, folder ], didPre !== build._noLC && [ lifecycle, pkg, "install", folder ], didPre !== build._noLC && [ lifecycle, pkg, "postinstall", folder ] ], cb);
          }));
        };
      }
      module.exports = build, build.usage = "npm build [<folder>]", build._didBuild = {}, 
      build._noLC = {};
      var writeBuiltinConf = build.writeBuiltinConf = function(pkg, folder, cb) {
        var parent = path.dirname(folder), dir = npm.globalDir;
        if ("npm" !== pkg.name && "npmc" !== pkg.name || !npm.config.get("global") || !npm.config.usingBuiltin || dir !== parent) return cb();
        var data = ini.stringify(npm.config.sources.builtin.data);
        writeFile(path.resolve(folder, "npmrc"), data, cb);
      }, linkStuff = build.linkStuff = function(pkg, folder, global, cb) {
        return !1 === npm.config.get("bin-links") ? cb() : binLinks(pkg, folder, global, binLinksConfig(pkg), cb);
      };
      function rebuildBundles(pkg, folder, cb) {
        if (!npm.config.get("rebuild-bundle")) return cb();
        var deps = Object.keys(pkg.dependencies || {}).concat(Object.keys(pkg.devDependencies || {})), bundles = pkg.bundleDependencies || pkg.bundledDependencies || [];
        fs.readdir(path.resolve(folder, "node_modules"), (function(er, files) {
          if (er) return cb();
          log.verbose("rebuildBundles", files), chain(files.filter((function(file) {
            return !file.match(/^[._-]/) && -1 === file.indexOf("@") && (-1 === deps.indexOf(file) || -1 !== bundles.indexOf(file));
          })).map((function(file) {
            return file = path.resolve(folder, "node_modules", file), function(cb) {
              if (build._didBuild[file]) return cb();
              log.verbose("rebuild bundle", file), fs.lstat(path.resolve(file, "package.json"), (function(er) {
                if (er) return cb();
                build_(!1)(file, cb);
              }));
            };
          })), cb);
        }));
      }
    },
    15285: (module, exports, __webpack_require__) => {
      "use strict";
      const BB = __webpack_require__(41142), assert = __webpack_require__(39491), cacache = __webpack_require__(99269), finished = BB.promisify(__webpack_require__(30498).finished), log = __webpack_require__(19334), npa = __webpack_require__(19932), npm = __webpack_require__(44874), npmConfig = __webpack_require__(23300), output = __webpack_require__(1015), pacote = __webpack_require__(96770), path = __webpack_require__(71017), rm = BB.promisify(__webpack_require__(8638)), unbuild = BB.promisify(npm.commands.unbuild);
      function cache(args, cb) {
        const cmd = args.shift();
        let result;
        switch (cmd) {
         case "rm":
         case "clear":
         case "clean":
          result = clean(args);
          break;

         case "add":
          result = add(args, npm.prefix);
          break;

         case "verify":
         case "check":
          result = verify();
          break;

         default:
          return cb("Usage: " + cache.usage);
        }
        if (!result || !result.then) throw new Error(`npm cache ${cmd} handler did not return a Promise`);
        result.then((() => cb()), cb);
      }
      function clean(args) {
        if (args || (args = []), args.length) return BB.reject(new Error("npm cache clear does not accept arguments"));
        const cachePath = path.join(npm.cache, "_cacache");
        return npm.config.get("force") ? rm(cachePath) : BB.reject(new Error("As of npm@5, the npm cache self-heals from corruption issues and data extracted from the cache is guaranteed to be valid. If you want to make sure everything is consistent, use 'npm cache verify' instead. On the other hand, if you're debugging an issue with the installer, you can use `npm install --cache /tmp/empty-cache` to use a temporary cache instead of nuking the actual one.\n\nIf you're sure you want to delete the entire cache, rerun this command with --force."));
      }
      function add(args, where) {
        var spec;
        return log.silly("cache add", "args", args), void 0 === args[1] && (args[1] = null), 
        null !== args[1] ? spec = args[0] + "@" + args[1] : 2 === args.length && (spec = args[0]), 
        log.verbose("cache add", "spec", spec), spec ? (log.silly("cache add", "parsed spec", spec), 
        finished(pacote.tarball.stream(spec, npmConfig({
          where
        })).resume())) : BB.reject(new Error("Usage:\n    npm cache add <tarball-url>\n    npm cache add <pkg>@<ver>\n    npm cache add <tarball>\n    npm cache add <folder>\n"));
      }
      function verify() {
        const cache = path.join(npm.config.get("cache"), "_cacache");
        let prefix = cache;
        return 0 === prefix.indexOf(process.env.HOME) && (prefix = "~" + prefix.substr(process.env.HOME.length)), 
        cacache.verify(cache).then((stats => {
          output(`Cache verified and compressed (${prefix}):`), output(`Content verified: ${stats.verifiedContent} (${stats.keptSize} bytes)`), 
          stats.badContentCount && output(`Corrupted content removed: ${stats.badContentCount}`), 
          stats.reclaimedCount && output(`Content garbage-collected: ${stats.reclaimedCount} (${stats.reclaimedSize} bytes)`), 
          stats.missingContent && output(`Missing content: ${stats.missingContent}`), output(`Index entries: ${stats.totalEntries}`), 
          output(`Finished in ${stats.runTime.total / 1e3}s`);
        }));
      }
      cache.usage = "npm cache add <tarball file>\nnpm cache add <folder>\nnpm cache add <tarball url>\nnpm cache add <git url>\nnpm cache add <name>@<version>\nnpm cache clean\nnpm cache verify", 
      cache.completion = function(opts, cb) {
        var argv = opts.conf.argv.remain;
        if (2 === argv.length) return cb(null, [ "add", "clean" ]);
        switch (argv[2]) {
         case "clean":
         case "add":
          return cb(null, []);
        }
      }, module.exports = cache, cache.clean = clean, cache.add = function(pkg, ver, where, scrub) {
        return assert("string" == typeof pkg, "must include name of package to install"), 
        scrub ? clean([]).then((() => add([ pkg, ver ], where))) : add([ pkg, ver ], where);
      }, cache.verify = verify, cache.unpack = function(pkg, ver, unpackTarget, dmode, fmode, uid, gid) {
        return unbuild([ unpackTarget ], !0).then((() => {
          const opts = npmConfig({
            dmode,
            fmode,
            uid,
            gid,
            offline: !0
          });
          return pacote.extract(npa.resolve(pkg, ver), unpackTarget, opts);
        }));
      };
    },
    35200: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const npm = __webpack_require__(44874), Installer = __webpack_require__(33890), log = __webpack_require__(19334), path = __webpack_require__(71017), pack = __webpack_require__(69797);
      function ci(args, cb) {
        const opts = {
          cache: path.join(npm.config.get("cache"), "_cacache"),
          color: !!npm.color,
          hashAlgorithm: "sha1",
          includeDeprecated: !1,
          log,
          "npm-session": npm.session,
          "project-scope": npm.projectScope,
          refer: npm.referer,
          dmode: npm.modes.exec,
          fmode: npm.modes.file,
          umask: npm.modes.umask,
          npmVersion: npm.version,
          tmp: npm.tmp,
          dirPacker: pack.packGitDep
        };
        npm.config.get("dev") && log.warn("ci", "Usage of the `--dev` option is deprecated. Use `--also=dev` instead.");
        for (const key in npm.config.list[0]) [ "log", "cache" ].includes(key) || (opts[key] = npm.config.list[0][key]);
        return new Installer(opts).run().then((details => {
          log.disableProgress(), console.log(`added ${details.pkgCount} packages in ${details.runTime / 1e3}s`);
        })).then((() => cb()), cb);
      }
      ci.usage = "npm ci", ci.completion = cb => cb(null, []), module.exports = ci;
    },
    41121: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = completion, completion.usage = "source <(npm completion)";
      var npm = __webpack_require__(44874), configDefs = __webpack_require__(25560).defs, configTypes = configDefs.types, shorthands = configDefs.shorthands, nopt = __webpack_require__(60166), configNames = Object.keys(configTypes).filter((function(e) {
        return "_" !== e.charAt(0);
      })), shorthandNames = Object.keys(shorthands), allConfs = configNames.concat(shorthandNames), once = __webpack_require__(38412), isWindowsShell = __webpack_require__(98892), output = __webpack_require__(1015);
      function completion(args, cb) {
        if (isWindowsShell) {
          var e = new Error("npm completion supported only in MINGW / Git bash on Windows");
          return e.code = "ENOTSUP", e.errno = __webpack_require__(22057).ENOTSUP, cb(e);
        }
        if (void 0 === process.env.COMP_CWORD || void 0 === process.env.COMP_LINE || void 0 === process.env.COMP_POINT) return function(cb) {
          var fs = __webpack_require__(59799), p = __webpack_require__(71017).resolve(__dirname, "utils/completion.sh");
          cb = once(cb), fs.readFile(p, "utf8", (function(er, d) {
            if (er) return cb(er);
            d = d.replace(/^#!.*?\n/, ""), process.stdout.write(d, (function() {
              cb();
            })), process.stdout.on("error", (function(er) {
              "EPIPE" === er.errno && (er = null), cb(er);
            }));
          }));
        }(cb);
        console.error(process.env.COMP_CWORD), console.error(process.env.COMP_LINE), console.error(process.env.COMP_POINT);
        for (var w = +process.env.COMP_CWORD, words = args.map(unescape), word = words[w], line = process.env.COMP_LINE, point = +process.env.COMP_POINT, partialLine = line.substr(0, point), partialWords = words.slice(0, w), partialWord = args[w], i = partialWord.length; partialWord.substr(0, i) !== partialLine.substr(-1 * i) && i > 0; ) i--;
        partialWord = unescape(partialWord.substr(0, i)), partialWords.push(partialWord);
        var opts = {
          words,
          w,
          word,
          line,
          lineLength: line.length,
          point,
          partialLine,
          partialWords,
          partialWord,
          raw: args
        };
        if (cb = function(cb, opts) {
          return function(er, compls) {
            if (Array.isArray(compls) || (compls = compls ? [ compls ] : []), compls = compls.map((function(c) {
              return c = Array.isArray(c) ? c.map(escape).join(" ") : escape(c);
            })), opts.partialWord && (compls = compls.filter((function(c) {
              return 0 === c.indexOf(opts.partialWord);
            }))), console.error([ er && er.stack, compls, opts.partialWord ]), er || 0 === compls.length) return cb(er);
            output(compls.join("\n")), cb();
          };
        }(cb, opts), console.error(opts), -1 === partialWords.slice(0, -1).indexOf("--")) {
          if ("-" === word.charAt(0)) return function(opts, cb) {
            var split = opts.word.match(/^(-+)((?:no-)*)(.*)$/), dashes = split[1], no = split[2], flags = configNames.filter(isFlag);
            return console.error(flags), cb(null, allConfs.map((function(c) {
              return dashes + c;
            })).concat(flags.map((function(f) {
              return dashes + (no || "no-") + f;
            }))));
          }(opts, cb);
          if (words[w - 1] && "-" === words[w - 1].charAt(0) && !isFlag(words[w - 1])) return console.error("configValueCompl"), 
          function(opts, cb) {
            return console.error("configValue", opts), cb(null, []);
          }(opts, cb);
        }
        var parsed = opts.conf = nopt(configTypes, shorthands, partialWords.slice(0, -1), 0);
        console.error(parsed);
        var cmd = parsed.argv.remain[1];
        return cmd ? (Object.keys(parsed).forEach((function(k) {
          npm.config.set(k, parsed[k]);
        })), (cmd = npm.commands[cmd]) && cmd.completion ? cmd.completion(opts, cb) : void cb()) : function(opts, cb) {
          return cb(null, npm.fullList);
        }(0, cb);
      }
      function unescape(w) {
        return "'" === w.charAt(0) ? w.replace(/^'|'$/g, "") : w.replace(/\\ /g, " ");
      }
      function escape(w) {
        return w.match(/\s+/) ? "'" + w + "'" : w;
      }
      function isFlag(word) {
        var split = word.match(/^(-*)((?:no-)+)?(.*)$/), no = split[2], conf = split[3];
        return no || configTypes[conf] === Boolean || shorthands[conf];
      }
      completion.completion = function(opts, cb) {
        if (opts.w > 3) return cb();
        var fs = __webpack_require__(59799), path = __webpack_require__(71017), bashExists = null, zshExists = null;
        function next() {
          if (null !== zshExists && null !== bashExists) {
            var out = [];
            zshExists && out.push("~/.zshrc"), bashExists && out.push("~/.bashrc"), 2 === opts.w && (out = out.map((function(m) {
              return [ ">>", m ];
            }))), cb(null, out);
          }
        }
        fs.stat(path.resolve(process.env.HOME, ".bashrc"), (function(er) {
          bashExists = !er, next();
        })), fs.stat(path.resolve(process.env.HOME, ".zshrc"), (function(er) {
          zshExists = !er, next();
        }));
      };
    },
    80214: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = config;
      var log = __webpack_require__(19334), npm = __webpack_require__(44874), npmconf = __webpack_require__(25560), fs = __webpack_require__(59799), writeFileAtomic = __webpack_require__(19804), types = npmconf.defs.types, ini = __webpack_require__(8477), editor = __webpack_require__(59550), os = __webpack_require__(22037), path = __webpack_require__(71017), mkdirp = __webpack_require__(33169).mkdir, umask = __webpack_require__(84175), usage = __webpack_require__(29320), output = __webpack_require__(1015), noProgressTillDone = __webpack_require__(39474).tillDone;
      function config(args, cb) {
        var action = args.shift();
        switch (action) {
         case "set":
          return function(key, val, cb) {
            if (void 0 === key) return unknown("", cb);
            if (void 0 === val) if (-1 !== key.indexOf("=")) {
              var k = key.split("=");
              key = k.shift(), val = k.join("=");
            } else val = "";
            key = key.trim(), val = val.trim(), log.info("config", "set %j %j", key, val);
            var where = npm.config.get("global") ? "global" : "user";
            key.match(/umask/) && (val = umask.fromString(val));
            npm.config.set(key, val, where), npm.config.save(where, cb);
          }(args[0], args[1], cb);

         case "get":
          return function(key, cb) {
            if (!key) return list(cb);
            if (!publicVar(key)) return cb(new Error("---sekretz---"));
            var val = npm.config.get(key);
            key.match(/umask/) && (val = umask.toString(val));
            output(val), cb();
          }(args[0], cb);

         case "delete":
         case "rm":
         case "del":
          return function(key, cb) {
            if (!key) return cb(new Error("no key provided"));
            var where = npm.config.get("global") ? "global" : "user";
            npm.config.del(key, where), npm.config.save(where, cb);
          }(args[0], cb);

         case "list":
         case "ls":
          return npm.config.get("json") ? function(cb) {
            const publicConf = npm.config.keys.reduce(((publicConf, k) => {
              var value = npm.config.get(k);
              return publicVar(k) && "argv" !== k && "logstream" !== k && (publicConf[k] = value), 
              publicConf;
            }), {});
            return output(JSON.stringify(publicConf, null, 2)), cb();
          }(cb) : list(cb);

         case "edit":
          return function(cb) {
            var e = npm.config.get("editor"), which = npm.config.get("global") ? "global" : "user", f = npm.config.get(which + "config");
            if (!e) return cb(new Error("No EDITOR config or environ set."));
            npm.config.save(which, (function(er) {
              if (er) return cb(er);
              fs.readFile(f, "utf8", (function(er, data) {
                er && (data = ""), data = [ ";;;;", "; npm " + (npm.config.get("global") ? "globalconfig" : "userconfig") + " file", "; this is a simple ini-formatted file", "; lines that start with semi-colons are comments.", "; read `npm help config` for help on the various options", ";;;;", "", data ].concat([ ";;;;", "; all options with default values", ";;;;" ]).concat(Object.keys(npmconf.defaults).reduce((function(arr, key) {
                  var obj = {};
                  return obj[key] = npmconf.defaults[key], "logstream" === key ? arr : arr.concat(ini.stringify(obj).replace(/\n$/m, "").replace(/^/g, "; ").replace(/\n/g, "\n; ").split("\n"));
                }), [])).concat([ "" ]).join(os.EOL), mkdirp(path.dirname(f), (function(er) {
                  if (er) return cb(er);
                  writeFileAtomic(f, data, (function(er) {
                    if (er) return cb(er);
                    editor(f, {
                      editor: e
                    }, noProgressTillDone(cb));
                  }));
                }));
              }));
            }));
          }(cb);

         default:
          return unknown(action, cb);
        }
      }
      function sort(a, b) {
        return a > b ? 1 : -1;
      }
      function publicVar(k) {
        return !("_" === k.charAt(0) || -1 !== k.indexOf(":_"));
      }
      function getKeys(data) {
        return Object.keys(data).filter(publicVar).sort(sort);
      }
      function listFromSource(title, conf, long) {
        var confKeys = getKeys(conf), msg = "";
        return confKeys.length && (msg += "; " + title + "\n", confKeys.forEach((function(k) {
          var val = JSON.stringify(conf[k]);
          if (conf[k] !== npm.config.get(k)) {
            if (!long) return;
            msg += "; " + k + " = " + val + " (overridden)\n";
          } else msg += k + " = " + val + "\n";
        })), msg += "\n"), msg;
      }
      function list(cb) {
        var msg = "", long = npm.config.get("long"), cli = npm.config.sources.cli.data, cliKeys = getKeys(cli);
        cliKeys.length && (msg += "; cli configs\n", cliKeys.forEach((function(k) {
          cli[k] && "object" == typeof cli[k] || "argv" !== k && (msg += k + " = " + JSON.stringify(cli[k]) + "\n");
        })), msg += "\n"), msg += listFromSource("environment configs", npm.config.sources.env.data, long);
        var project = npm.config.sources.project;
        msg += listFromSource("project config " + project.path, project.data, long), msg += listFromSource("userconfig " + npm.config.get("userconfig"), npm.config.sources.user.data, long), 
        msg += listFromSource("globalconfig " + npm.config.get("globalconfig"), npm.config.sources.global.data, long);
        var builtin = npm.config.sources.builtin || {};
        if (builtin && builtin.data && (msg += listFromSource("builtin config " + builtin.path, builtin.data, long)), 
        !long) return msg += "; node bin location = " + process.execPath + "\n; cwd = " + process.cwd() + "\n; HOME = " + process.env.HOME + '\n; "npm config ls -l" to show all defaults.\n', 
        output(msg), cb();
        var defaults = npmconf.defaults, defKeys = getKeys(defaults);
        return msg += "; default values\n", defKeys.forEach((function(k) {
          if (!defaults[k] || "object" != typeof defaults[k]) {
            var val = JSON.stringify(defaults[k]);
            defaults[k] !== npm.config.get(k) ? msg += "; " + k + " = " + val + " (overridden)\n" : msg += k + " = " + val + "\n";
          }
        })), output(msg += "\n"), cb();
      }
      function unknown(action, cb) {
        cb("Usage:\n" + config.usage);
      }
      config.usage = usage("config", "npm config set <key> <value>\nnpm config get [<key>]\nnpm config delete <key>\nnpm config list [--json]\nnpm config edit\nnpm set <key> <value>\nnpm get [<key>]"), 
      config.completion = function(opts, cb) {
        var argv = opts.conf.argv.remain;
        if ("config" !== argv[1] && argv.unshift("config"), 2 === argv.length) {
          var cmds = [ "get", "set", "delete", "ls", "rm", "edit" ];
          return "l" !== opts.partialWord && cmds.push("list"), cb(null, cmds);
        }
        switch (argv[2]) {
         case "set":
          if (argv.length > 3) return cb(null, []);

         case "get":
         case "delete":
         case "rm":
          return cb(null, Object.keys(types));

         default:
          return cb(null, []);
        }
      };
    },
    96228: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const npm = __webpack_require__(44874);
      var packageId = __webpack_require__(73531);
      const log = __webpack_require__(19334);
      module.exports = function(pkg) {
        return {
          ignoreScripts: npm.config.get("ignore-scripts"),
          force: npm.config.get("force"),
          globalBin: npm.globalBin,
          globalDir: npm.globalDir,
          json: npm.config.get("json"),
          log,
          name: "npm",
          parseable: npm.config.get("parseable"),
          pkgId: packageId(pkg),
          prefix: npm.config.get("prefix"),
          prefixes: [ npm.prefix, npm.globalPrefix, npm.dir, npm.root, npm.globalDir, npm.bin, npm.globalBin ],
          umask: npm.config.get("umask")
        };
      };
    },
    95959: (module, __unused_webpack_exports, __webpack_require__) => {
      var assert = __webpack_require__(39491), toNerfDart = __webpack_require__(43444);
      module.exports = function(uri) {
        assert(uri && "string" == typeof uri, "registry URL is required");
        var nerfed = toNerfDart(uri);
        this.del(nerfed + ":_authToken", "user"), this.del(nerfed + ":_password", "user"), 
        this.del(nerfed + ":username", "user"), this.del(nerfed + ":email", "user");
      };
    },
    27572: module => {
      var shorthands = {
        un: "uninstall",
        rb: "rebuild",
        list: "ls",
        ln: "link",
        create: "init",
        i: "install",
        it: "install-test",
        cit: "install-ci-test",
        up: "update",
        c: "config",
        s: "search",
        se: "search",
        unstar: "star",
        tst: "test",
        t: "test",
        ddp: "dedupe",
        v: "view",
        run: "run-script",
        "clean-install": "ci",
        "clean-install-test": "cit"
      }, affordances = {
        la: "ls",
        ll: "ls",
        verison: "version",
        ic: "ci",
        innit: "init",
        isntall: "install",
        "install-clean": "ci",
        "isntall-clean": "ci",
        "dist-tags": "dist-tag",
        apihelp: "help",
        "find-dupes": "dedupe",
        upgrade: "update",
        udpate: "update",
        login: "adduser",
        "add-user": "adduser",
        author: "owner",
        home: "docs",
        issues: "bugs",
        info: "view",
        show: "view",
        find: "search",
        add: "install",
        unlink: "uninstall",
        remove: "uninstall",
        rm: "uninstall",
        r: "uninstall",
        rum: "run-script",
        sit: "cit",
        urn: "run-script",
        ogr: "org"
      };
      module.exports.aliases = Object.assign({}, shorthands, affordances), module.exports.shorthands = shorthands, 
      module.exports.affordances = affordances, module.exports.cmdList = [ "ci", "install-ci-test", "install", "install-test", "uninstall", "cache", "config", "set", "get", "update", "outdated", "prune", "pack", "dedupe", "hook", "rebuild", "link", "publish", "star", "stars", "adduser", "login", "logout", "unpublish", "owner", "access", "team", "deprecate", "shrinkwrap", "token", "profile", "audit", "fund", "org", "help", "help-search", "ls", "search", "view", "init", "version", "edit", "explore", "docs", "repo", "bugs", "root", "prefix", "bin", "whoami", "dist-tag", "ping", "test", "stop", "start", "restart", "run-script", "completion", "doctor" ], 
      module.exports.plumbing = [ "build", "unbuild", "xmas", "substack", "visnup" ];
    },
    25560: (__unused_webpack_module, exports, __webpack_require__) => {
      var CC = __webpack_require__(23671).ConfigChain, inherits = __webpack_require__(90741), configDefs = __webpack_require__(25476), types = configDefs.types, once = __webpack_require__(38412), fs = __webpack_require__(57147), path = __webpack_require__(71017), nopt = __webpack_require__(60166), ini = __webpack_require__(8477), Umask = configDefs.Umask, mkdirp = __webpack_require__(33169).mkdir, umask = __webpack_require__(84175), isWindows = __webpack_require__(52290);
      exports.load = function() {
        for (var cli, builtin, cb, i = 0; i < arguments.length; i++) switch (typeof arguments[i]) {
         case "string":
          builtin = arguments[i];
          break;

         case "object":
          cli = arguments[i];
          break;

         case "function":
          cb = arguments[i];
        }
        cb || (cb = function() {});
        if (exports.loaded) {
          var ret = exports.loaded;
          return cli && (ret = new Conf(ret)).unshift(cli), process.nextTick(cb.bind(null, null, ret));
        }
        cli = cli ? Object.keys(cli).reduce((function(c, k) {
          return c[k] = cli[k], c;
        }), {}) : {};
        if (loadCbs.push(cb), loading) return;
        loading = !0, cb = once((function(er, conf) {
          er || (exports.loaded = conf, loading = !1), loadCbs.forEach((function(fn) {
            fn(er, conf);
          })), loadCbs.length = 0;
        })), exports.usingBuiltin = !!builtin;
        var rc = exports.rootConf = new Conf;
        builtin ? rc.addFile(builtin, "builtin") : rc.add({}, "builtin");
        rc.on("load", (function() {
          load_(builtin, rc, cli, cb);
        })), rc.on("error", cb);
      }, exports.Conf = Conf, exports.loaded = !1, exports.rootConf = null, exports.usingBuiltin = !1, 
      exports.defs = configDefs, Object.defineProperty(exports, "defaults", {
        get: function() {
          return configDefs.defaults;
        },
        enumerable: !0
      }), Object.defineProperty(exports, "types", {
        get: function() {
          return configDefs.types;
        },
        enumerable: !0
      }), exports.validate = validate;
      var myUid = process.getuid && process.getuid(), myGid = process.getgid && process.getgid(), loading = !1, loadCbs = [];
      function load_(builtin, rc, cli, cb) {
        var defaults = configDefs.defaults, conf = new Conf(rc);
        function afterPrefix() {
          conf.addFile(conf.get("userconfig"), "user"), conf.once("error", cb), conf.once("load", afterUser);
        }
        function afterUser() {
          if (conf.get("prefix")) {
            var etc = path.resolve(conf.get("prefix"), "etc");
            defaults.globalconfig = path.resolve(etc, "npmrc"), defaults.globalignorefile = path.resolve(etc, "npmignore");
          }
          conf.addFile(conf.get("globalconfig"), "global"), conf.root = defaults, conf.add(rc.shift(), "builtin"), 
          conf.once("load", (function() {
            conf.loadExtras(afterExtras);
          }));
        }
        function afterExtras(er) {
          if (er) return cb(er);
          validate(conf);
          var cafile = conf.get("cafile");
          if (cafile) return conf.loadCAFile(cafile, finalize);
          finalize();
        }
        function finalize(er) {
          if (er) return cb(er);
          exports.loaded = conf, cb(er, conf);
        }
        conf.usingBuiltin = !!builtin, conf.add(cli, "cli"), conf.addEnv(), conf.loadPrefix((function(er) {
          if (er) return cb(er);
          var projectConf = path.resolve(conf.localPrefix, ".npmrc"), defaultUserConfig = rc.get("userconfig"), resolvedUserConfig = conf.get("userconfig");
          conf.get("global") || projectConf === defaultUserConfig || projectConf === resolvedUserConfig ? (conf.add({}, "project"), 
          afterPrefix()) : (conf.addFile(projectConf, "project"), conf.once("load", afterPrefix));
        }));
      }
      function Conf(base) {
        if (!(this instanceof Conf)) return new Conf(base);
        CC.call(this), this.root = base ? base instanceof Conf ? base.list[0] || base.root : base : configDefs.defaults;
      }
      function envReplace(f) {
        if ("string" != typeof f || !f) return f;
        return f.replace(/(\\*)\$\{([^}]+)\}/g, (function(orig, esc, name) {
          if (esc = esc.length && esc.length % 2) return orig;
          if (void 0 === process.env[name]) throw new Error("Failed to replace env in config: " + orig);
          return process.env[name];
        }));
      }
      function validate(cl) {
        cl.list.forEach((function(conf) {
          nopt.clean(conf, configDefs.types);
        })), nopt.clean(cl.root, configDefs.types);
      }
      inherits(Conf, CC), Conf.prototype.loadPrefix = __webpack_require__(24226), Conf.prototype.loadCAFile = __webpack_require__(8033), 
      Conf.prototype.setUser = __webpack_require__(14871), Conf.prototype.getCredentialsByURI = __webpack_require__(43932), 
      Conf.prototype.setCredentialsByURI = __webpack_require__(58089), Conf.prototype.clearCredentialsByURI = __webpack_require__(95959), 
      Conf.prototype.loadExtras = function(cb) {
        this.setUser(function(er) {
          if (er) return cb(er);
          mkdirp(this.prefix, cb);
        }.bind(this));
      }, Conf.prototype.save = function(where, cb) {
        var er, target = this.sources[where];
        if (!target || !target.path && !target.source || !target.data) return "builtin" !== where && (er = new Error("bad save target: " + where)), 
        cb ? (process.nextTick(cb.bind(null, er)), this) : this.emit("error", er);
        if (target.source) {
          var pref = target.prefix || "";
          return Object.keys(target.data).forEach((function(k) {
            target.source[pref + k] = target.data[k];
          })), cb && process.nextTick(cb), this;
        }
        var data = ini.stringify(target.data), then = function(er) {
          if (er) return done(er);
          fs.chmod(target.path, mode, done);
        }, done = function(er) {
          if (er) return cb ? cb(er) : this.emit("error", er);
          this._saving--, 0 === this._saving && (cb && cb(), this.emit("save"));
        };
        then = then.bind(this), done = done.bind(this), this._saving++;
        var mode = "user" === where ? "0600" : "0666";
        if (data.trim()) {
          const dir = path.dirname(target.path);
          mkdirp(dir, (function(er) {
            if (er) return then(er);
            fs.stat(dir, ((er, st) => {
              if (er) return then(er);
              fs.writeFile(target.path, data, "utf8", (function(er) {
                if (er) return then(er);
                0 !== myUid || myUid === st.uid && myGid === st.gid ? then() : fs.chown(target.path, st.uid, st.gid, then);
              }));
            }));
          }));
        } else fs.unlink(target.path, (function() {
          done(null);
        }));
        return this;
      }, Conf.prototype.addFile = function(file, name) {
        var marker = {
          __source__: name = name || file
        };
        return this.sources[name] = {
          path: file,
          type: "ini"
        }, this.push(marker), this._await(), fs.readFile(file, "utf8", function(er, data) {
          if (er) return this.add({}, marker);
          this.addString(data, file, "ini", marker);
        }.bind(this)), this;
      }, Conf.prototype.parse = function(content, file) {
        return CC.prototype.parse.call(this, content, file, "ini");
      }, Conf.prototype.add = function(data, marker) {
        try {
          Object.keys(data).forEach((function(k) {
            const newKey = envReplace(k), newField = function(f, k) {
              if ("string" != typeof f && !(f instanceof String)) return f;
              var typeList = [].concat(types[k]), isPath = -1 !== typeList.indexOf(path), isBool = -1 !== typeList.indexOf(Boolean), isString = -1 !== typeList.indexOf(String), isUmask = -1 !== typeList.indexOf(Umask), isNumber = -1 !== typeList.indexOf(Number);
              if ((f = ("" + f).trim()).match(/^".*"$/)) try {
                f = JSON.parse(f);
              } catch (e) {
                throw new Error("Failed parsing JSON config key " + k + ": " + f);
              }
              if (isBool && !isString && "" === f) return !0;
              switch (f) {
               case "true":
                return !0;

               case "false":
                return !1;

               case "null":
                return null;

               case "undefined":
                return;
              }
              if (f = envReplace(f), isPath) {
                var homePattern = isWindows ? /^~(\/|\\)/ : /^~\//;
                f.match(homePattern) && process.env.HOME && (f = path.resolve(process.env.HOME, f.substr(2))), 
                f = path.resolve(f);
              }
              isUmask && (f = umask.fromString(f));
              isNumber && !isNaN(f) && (f = +f);
              return f;
            }(data[k], newKey);
            delete data[k], data[newKey] = newField;
          }));
        } catch (e) {
          return this.emit("error", e), this;
        }
        return CC.prototype.add.call(this, data, marker);
      }, Conf.prototype.addEnv = function(env) {
        env = env || process.env;
        var conf = {};
        return Object.keys(env).filter((function(k) {
          return k.match(/^npm_config_/i);
        })).forEach((function(k) {
          if (env[k]) {
            var p = k.toLowerCase().replace(/^npm_config_/, "").replace(/(?!^)_/g, "-");
            conf[p] = env[k];
          }
        })), CC.prototype.addEnv.call(this, "", conf, "env");
      };
    },
    25476: (__unused_webpack_module, exports, __webpack_require__) => {
      var log, defaults, path = __webpack_require__(71017), url = __webpack_require__(57310), Stream = __webpack_require__(12781).Stream, semver = __webpack_require__(73107), stableFamily = semver.parse(process.version), nopt = __webpack_require__(60166), os = __webpack_require__(22037), osenv = __webpack_require__(20396), umask = __webpack_require__(84175), hasUnicode = __webpack_require__(65534);
      try {
        log = __webpack_require__(19334);
      } catch (er) {
        var util = __webpack_require__(73837);
        log = {
          warn: function(m) {
            console.warn(m + " " + util.format.apply(util, [].slice.call(arguments, 1)));
          }
        };
      }
      function Umask() {}
      exports.Umask = Umask, nopt.typeDefs.semver = {
        type: semver,
        validate: function(data, k, val) {
          if (!semver.valid(val)) return !1;
          data[k] = semver.valid(val);
        }
      }, nopt.typeDefs.Stream = {
        type: Stream,
        validate: function(data, k, val) {
          if (!(val instanceof Stream)) return !1;
          data[k] = val;
        }
      }, nopt.typeDefs.Umask = {
        type: Umask,
        validate: function(data, k, val) {
          return umask.validate(data, k, val);
        }
      }, nopt.invalidHandler = function(k, val, type) {
        switch (log.warn("invalid config", k + "=" + JSON.stringify(val)), Array.isArray(type) && (-1 !== type.indexOf(url) ? type = url : -1 !== type.indexOf(path) && (type = path)), 
        type) {
         case Umask:
          log.warn("invalid config", "Must be umask, octal number in range 0000..0777");
          break;

         case url:
          log.warn("invalid config", "Must be a full url with 'http://'");
          break;

         case path:
          log.warn("invalid config", "Must be a valid filesystem path");
          break;

         case Number:
          log.warn("invalid config", "Must be a numeric value");
          break;

         case Stream:
          log.warn("invalid config", "Must be an instance of the Stream class");
        }
      }, stableFamily = !stableFamily || +stableFamily.minor % 2 ? null : stableFamily.major + "." + stableFamily.minor;
      var temp = osenv.tmpdir(), home = osenv.home(), uidOrPid = process.getuid ? process.getuid() : process.pid;
      home ? process.env.HOME = home : home = path.resolve(temp, "npm-" + uidOrPid);
      var globalPrefix, cacheExtra = "win32" === process.platform ? "npm-cache" : ".npm", cacheRoot = "win32" === process.platform && process.env.APPDATA || home, cache = path.resolve(cacheRoot, cacheExtra);
      Object.defineProperty(exports, "defaults", {
        get: function() {
          return defaults || (process.env.PREFIX ? globalPrefix = process.env.PREFIX : "win32" === process.platform ? globalPrefix = path.dirname(process.execPath) : (globalPrefix = path.dirname(path.dirname(process.execPath)), 
          process.env.DESTDIR && (globalPrefix = path.join(process.env.DESTDIR, globalPrefix))), 
          defaults = {
            access: null,
            "allow-same-version": !1,
            "always-auth": !1,
            also: null,
            audit: !0,
            "audit-level": "low",
            "auth-type": "legacy",
            before: null,
            "bin-links": !0,
            browser: null,
            ca: null,
            cafile: null,
            cache,
            "cache-lock-stale": 6e4,
            "cache-lock-retries": 10,
            "cache-lock-wait": 1e4,
            "cache-max": 1 / 0,
            "cache-min": 10,
            cert: null,
            cidr: null,
            color: null == process.env.NO_COLOR,
            depth: 1 / 0,
            description: !0,
            dev: !1,
            "dry-run": !1,
            editor: osenv.editor(),
            "engine-strict": !1,
            force: !1,
            "format-package-lock": !0,
            fund: !0,
            "fetch-retries": 2,
            "fetch-retry-factor": 10,
            "fetch-retry-mintimeout": 1e4,
            "fetch-retry-maxtimeout": 6e4,
            git: "git",
            "git-tag-version": !0,
            "commit-hooks": !0,
            global: !1,
            globalconfig: path.resolve(globalPrefix, "etc", "npmrc"),
            "global-style": !1,
            group: "win32" === process.platform ? 0 : process.env.SUDO_GID || process.getgid && process.getgid(),
            "ham-it-up": !1,
            heading: "npm",
            "if-present": !1,
            "ignore-prepublish": !1,
            "ignore-scripts": !1,
            "init-module": path.resolve(home, ".npm-init.js"),
            "init-author-name": "",
            "init-author-email": "",
            "init-author-url": "",
            "init-version": "1.0.0",
            "init-license": "ISC",
            json: !1,
            key: null,
            "legacy-bundling": !1,
            link: !1,
            "local-address": void 0,
            loglevel: "notice",
            logstream: process.stderr,
            "logs-max": 10,
            long: !1,
            maxsockets: 50,
            message: "%s",
            "metrics-registry": null,
            "node-options": null,
            "node-version": process.version,
            offline: !1,
            "onload-script": !1,
            only: null,
            optional: !0,
            otp: null,
            "package-lock": !0,
            "package-lock-only": !1,
            parseable: !1,
            "prefer-offline": !1,
            "prefer-online": !1,
            prefix: globalPrefix,
            preid: "",
            production: "production" === process.env.NODE_ENV,
            progress: !process.env.TRAVIS && !process.env.CI,
            proxy: null,
            "https-proxy": null,
            noproxy: null,
            "user-agent": "npm/{npm-version} node/{node-version} {platform} {arch} {ci}",
            "read-only": !1,
            "rebuild-bundle": !0,
            registry: "https://registry.npmjs.org/",
            rollback: !0,
            save: !0,
            "save-bundle": !1,
            "save-dev": !1,
            "save-exact": !1,
            "save-optional": !1,
            "save-prefix": "^",
            "save-prod": !1,
            scope: "",
            "script-shell": null,
            "scripts-prepend-node-path": "warn-only",
            searchopts: "",
            searchexclude: null,
            searchlimit: 20,
            searchstaleness: 900,
            "send-metrics": !1,
            shell: osenv.shell(),
            shrinkwrap: !0,
            "sign-git-commit": !1,
            "sign-git-tag": !1,
            "sso-poll-frequency": 500,
            "sso-type": "oauth",
            "strict-ssl": !0,
            tag: "latest",
            "tag-version-prefix": "v",
            timing: !1,
            tmp: temp,
            unicode: hasUnicode(),
            "unsafe-perm": "win32" === process.platform || "cygwin" === process.platform || !(process.getuid && process.setuid && process.getgid && process.setgid) || 0 !== process.getuid(),
            "update-notifier": !0,
            usage: !1,
            user: "win32" === process.platform || "OS400" === os.type() ? 0 : "nobody",
            userconfig: path.resolve(home, ".npmrc"),
            umask: process.umask ? process.umask() : umask.fromString("022"),
            version: !1,
            versions: !1,
            viewer: "win32" === process.platform ? "browser" : "man",
            _exit: !0
          });
        }
      }), exports.types = {
        access: [ null, "restricted", "public" ],
        "allow-same-version": Boolean,
        "always-auth": Boolean,
        also: [ null, "dev", "development" ],
        audit: Boolean,
        "audit-level": [ "low", "moderate", "high", "critical" ],
        "auth-type": [ "legacy", "sso", "saml", "oauth" ],
        before: [ null, Date ],
        "bin-links": Boolean,
        browser: [ null, String ],
        ca: [ null, String, Array ],
        cafile: path,
        cache: path,
        "cache-lock-stale": Number,
        "cache-lock-retries": Number,
        "cache-lock-wait": Number,
        "cache-max": Number,
        "cache-min": Number,
        cert: [ null, String ],
        cidr: [ null, String, Array ],
        color: [ "always", Boolean ],
        depth: Number,
        description: Boolean,
        dev: Boolean,
        "dry-run": Boolean,
        editor: String,
        "engine-strict": Boolean,
        force: Boolean,
        fund: Boolean,
        "format-package-lock": Boolean,
        "fetch-retries": Number,
        "fetch-retry-factor": Number,
        "fetch-retry-mintimeout": Number,
        "fetch-retry-maxtimeout": Number,
        git: String,
        "git-tag-version": Boolean,
        "commit-hooks": Boolean,
        global: Boolean,
        globalconfig: path,
        "global-style": Boolean,
        group: [ Number, String ],
        "https-proxy": [ null, url ],
        "user-agent": String,
        "ham-it-up": Boolean,
        heading: String,
        "if-present": Boolean,
        "ignore-prepublish": Boolean,
        "ignore-scripts": Boolean,
        "init-module": path,
        "init-author-name": String,
        "init-author-email": String,
        "init-author-url": [ "", url ],
        "init-license": String,
        "init-version": semver,
        json: Boolean,
        key: [ null, String ],
        "legacy-bundling": Boolean,
        link: Boolean,
        "local-address": function() {
          var interfaces;
          try {
            interfaces = os.networkInterfaces();
          } catch (e) {
            interfaces = {};
          }
          return Object.keys(interfaces).map((nic => interfaces[nic].map((({address}) => address)))).reduce(((curr, next) => curr.concat(next)), []).concat(void 0);
        }(),
        loglevel: [ "silent", "error", "warn", "notice", "http", "timing", "info", "verbose", "silly" ],
        logstream: Stream,
        "logs-max": Number,
        long: Boolean,
        maxsockets: Number,
        message: String,
        "metrics-registry": [ null, String ],
        "node-options": [ null, String ],
        "node-version": [ null, semver ],
        noproxy: [ null, String, Array ],
        offline: Boolean,
        "onload-script": [ null, String ],
        only: [ null, "dev", "development", "prod", "production" ],
        optional: Boolean,
        "package-lock": Boolean,
        otp: [ null, String ],
        "package-lock-only": Boolean,
        parseable: Boolean,
        "prefer-offline": Boolean,
        "prefer-online": Boolean,
        prefix: path,
        preid: String,
        production: Boolean,
        progress: Boolean,
        proxy: [ null, !1, url ],
        "read-only": Boolean,
        "rebuild-bundle": Boolean,
        registry: [ null, url ],
        rollback: Boolean,
        save: Boolean,
        "save-bundle": Boolean,
        "save-dev": Boolean,
        "save-exact": Boolean,
        "save-optional": Boolean,
        "save-prefix": String,
        "save-prod": Boolean,
        scope: String,
        "script-shell": [ null, String ],
        "scripts-prepend-node-path": [ !1, !0, "auto", "warn-only" ],
        searchopts: String,
        searchexclude: [ null, String ],
        searchlimit: Number,
        searchstaleness: Number,
        "send-metrics": Boolean,
        shell: String,
        shrinkwrap: Boolean,
        "sign-git-commit": Boolean,
        "sign-git-tag": Boolean,
        "sso-poll-frequency": Number,
        "sso-type": [ null, "oauth", "saml" ],
        "strict-ssl": Boolean,
        tag: String,
        timing: Boolean,
        tmp: path,
        unicode: Boolean,
        "unsafe-perm": Boolean,
        "update-notifier": Boolean,
        usage: Boolean,
        user: [ Number, String ],
        userconfig: path,
        umask: Umask,
        version: Boolean,
        "tag-version-prefix": String,
        versions: Boolean,
        viewer: String,
        _exit: Boolean
      }, exports.shorthands = {
        before: [ "--enjoy-by" ],
        s: [ "--loglevel", "silent" ],
        d: [ "--loglevel", "info" ],
        dd: [ "--loglevel", "verbose" ],
        ddd: [ "--loglevel", "silly" ],
        noreg: [ "--no-registry" ],
        N: [ "--no-registry" ],
        reg: [ "--registry" ],
        "no-reg": [ "--no-registry" ],
        silent: [ "--loglevel", "silent" ],
        verbose: [ "--loglevel", "verbose" ],
        quiet: [ "--loglevel", "warn" ],
        q: [ "--loglevel", "warn" ],
        h: [ "--usage" ],
        H: [ "--usage" ],
        "?": [ "--usage" ],
        help: [ "--usage" ],
        v: [ "--version" ],
        f: [ "--force" ],
        desc: [ "--description" ],
        "no-desc": [ "--no-description" ],
        local: [ "--no-global" ],
        l: [ "--long" ],
        m: [ "--message" ],
        p: [ "--parseable" ],
        porcelain: [ "--parseable" ],
        readonly: [ "--read-only" ],
        g: [ "--global" ],
        S: [ "--save" ],
        D: [ "--save-dev" ],
        E: [ "--save-exact" ],
        O: [ "--save-optional" ],
        P: [ "--save-prod" ],
        y: [ "--yes" ],
        n: [ "--no-yes" ],
        B: [ "--save-bundle" ],
        C: [ "--prefix" ]
      };
    },
    23300: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const BB = __webpack_require__(41142), crypto = __webpack_require__(6113), figgyPudding = __webpack_require__(55212), log = __webpack_require__(19334), npm = __webpack_require__(44874), pack = __webpack_require__(69797), path = __webpack_require__(71017), npmSession = npm.session = crypto.randomBytes(8).toString("hex");
      log.verbose("npm-session", npmSession);
      const SCOPE_REGISTRY_REGEX = /@.*:registry$/gi, NpmConfig = figgyPudding({}, {
        other: key => key.match(SCOPE_REGISTRY_REGEX)
      });
      let baseConfig, effectiveOwner;
      module.exports = function(...providers) {
        if (!baseConfig) {
          baseConfig = NpmConfig(npm.config, {
            cache: path.join(npm.config.get("cache"), "_cacache"),
            color: !!npm.color,
            dirPacker: pack.packGitDep,
            hashAlgorithm: "sha1",
            includeDeprecated: !1,
            log,
            "npm-session": npmSession,
            "project-scope": npm.projectScope,
            refer: npm.referer,
            dmode: npm.modes.exec,
            fmode: npm.modes.file,
            umask: npm.modes.umask,
            npmVersion: npm.version,
            tmp: npm.tmp,
            Promise: BB
          });
          const ownerStats = function() {
            if (!effectiveOwner) {
              if (effectiveOwner = {
                uid: 0,
                gid: 0
              }, !process.getuid) return effectiveOwner;
              effectiveOwner.uid = +process.getuid(), effectiveOwner.gid = +process.getgid(), 
              0 === effectiveOwner.uid && (process.env.SUDO_UID && (effectiveOwner.uid = +process.env.SUDO_UID), 
              process.env.SUDO_GID && (effectiveOwner.gid = +process.env.SUDO_GID));
            }
            return effectiveOwner;
          }();
          null == ownerStats.uid && null == ownerStats.gid || (baseConfig = baseConfig.concat(ownerStats));
        }
        let conf = baseConfig.concat(...providers);
        void 0 === npm.config.get("prefer-online") && (conf = conf.concat({
          "prefer-online": npm.config.get("cache-max") <= 0
        }));
        void 0 === npm.config.get("prefer-online") && (conf = conf.concat({
          "prefer-online": npm.config.get("cache-min") >= 9999
        }));
        return conf;
      };
    },
    64565: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const npm = __webpack_require__(44874), log = __webpack_require__(19334);
      module.exports = function(gently, base, abs) {
        return {
          prefixes: [ npm.prefix, npm.globalPrefix, npm.dir, npm.root, npm.globalDir, npm.bin, npm.globalBin ],
          absolute: abs,
          log,
          prefix: npm.prefix,
          force: npm.config.get("force"),
          gently,
          base,
          name: "npm"
        };
      };
    },
    43932: (module, __unused_webpack_exports, __webpack_require__) => {
      var assert = __webpack_require__(39491), toNerfDart = __webpack_require__(43444);
      module.exports = function(uri) {
        assert(uri && "string" == typeof uri, "registry URL is required");
        var nerfed = toNerfDart(uri), defnerf = toNerfDart(this.get("registry")), c = {
          scope: nerfed,
          token: void 0,
          password: void 0,
          username: void 0,
          email: void 0,
          auth: void 0,
          alwaysAuth: void 0
        };
        if (void 0 !== this.get(nerfed + ":always-auth")) {
          var val = this.get(nerfed + ":always-auth");
          c.alwaysAuth = "false" !== val && !!val;
        } else void 0 !== this.get("always-auth") && (c.alwaysAuth = this.get("always-auth"));
        if (this.get(nerfed + ":_authToken")) return c.token = this.get(nerfed + ":_authToken"), 
        c;
        if (this.get(nerfed + ":-authtoken")) return c.token = this.get(nerfed + ":-authtoken"), 
        c;
        var authDef = this.get("_auth"), userDef = this.get("username"), passDef = this.get("_password");
        !authDef || userDef && passDef || (authDef = (authDef = Buffer.from(authDef, "base64").toString()).split(":"), 
        userDef = authDef.shift(), passDef = authDef.join(":"));
        this.get(nerfed + ":_password") ? c.password = Buffer.from(this.get(nerfed + ":_password"), "base64").toString("utf8") : nerfed === defnerf && passDef && (c.password = passDef);
        this.get(nerfed + ":username") ? c.username = this.get(nerfed + ":username") : nerfed === defnerf && userDef && (c.username = userDef);
        this.get(nerfed + ":email") ? c.email = this.get(nerfed + ":email") : this.get("email") && (c.email = this.get("email"));
        c.username && c.password && (c.auth = Buffer.from(c.username + ":" + c.password).toString("base64"));
        return c;
      };
    },
    96058: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const npm = __webpack_require__(44874), log = __webpack_require__(19334);
      let opts;
      module.exports = function(moreOpts) {
        opts || (opts = {
          config: npm.config.snapshot,
          dir: npm.dir,
          failOk: !1,
          force: npm.config.get("force"),
          group: npm.config.get("group"),
          ignorePrepublish: npm.config.get("ignore-prepublish"),
          ignoreScripts: npm.config.get("ignore-scripts"),
          log,
          nodeOptions: npm.config.get("node-options"),
          production: npm.config.get("production"),
          scriptShell: npm.config.get("script-shell"),
          scriptsPrependNodePath: npm.config.get("scripts-prepend-node-path"),
          unsafePerm: npm.config.get("unsafe-perm"),
          user: npm.config.get("user")
        });
        return moreOpts ? Object.assign({}, opts, moreOpts) : opts;
      };
    },
    8033: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = function(cafilePath, cb) {
        if (!cafilePath) return process.nextTick(cb);
        fs.readFile(cafilePath, "utf8", function(er, cadata) {
          if (er) return "ENOENT" === er.code ? cb() : cb(er);
          var output, delim = "-----END CERTIFICATE-----";
          output = cadata.split(delim).filter((function(xs) {
            return !!xs.trim();
          })).map((function(xs) {
            return xs.trimLeft() + delim;
          })), this.set("ca", output), cb(null);
        }.bind(this));
      };
      var fs = __webpack_require__(57147);
    },
    24226: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = function(cb) {
        var p, cli = this.list[0];
        Object.defineProperty(this, "prefix", {
          set: function(prefix) {
            this[this.get("global") ? "globalPrefix" : "localPrefix"] = prefix;
          }.bind(this),
          get: function() {
            return this.get("global") ? this.globalPrefix : this.localPrefix;
          }.bind(this),
          enumerable: !0
        }), Object.defineProperty(this, "globalPrefix", {
          set: function(prefix) {
            this.set("prefix", prefix);
          }.bind(this),
          get: function() {
            return path.resolve(this.get("prefix"));
          }.bind(this),
          enumerable: !0
        }), Object.defineProperty(this, "localPrefix", {
          set: function(prefix) {
            p = prefix;
          },
          get: function() {
            return p;
          },
          enumerable: !0
        }), Object.prototype.hasOwnProperty.call(cli, "prefix") ? (p = path.resolve(cli.prefix), 
        process.nextTick(cb)) : findPrefix(process.cwd()).then((found => {
          p = found, cb();
        }), cb);
      };
      var findPrefix = __webpack_require__(81048), path = __webpack_require__(71017);
    },
    43444: (module, __unused_webpack_exports, __webpack_require__) => {
      var url = __webpack_require__(57310);
      module.exports = function(uri) {
        var parsed = url.parse(uri);
        return delete parsed.protocol, delete parsed.auth, delete parsed.query, delete parsed.search, 
        delete parsed.hash, url.resolve(url.format(parsed), ".");
      };
    },
    58089: (module, __unused_webpack_exports, __webpack_require__) => {
      var assert = __webpack_require__(39491), toNerfDart = __webpack_require__(43444);
      module.exports = function(uri, c) {
        assert(uri && "string" == typeof uri, "registry URL is required"), assert(c && "object" == typeof c, "credentials are required");
        var nerfed = toNerfDart(uri);
        if (c.token) this.set(nerfed + ":_authToken", c.token, "user"), this.del(nerfed + ":_password", "user"), 
        this.del(nerfed + ":username", "user"), this.del(nerfed + ":email", "user"), this.del(nerfed + ":always-auth", "user"); else {
          if (!(c.username || c.password || c.email)) throw new Error("No credentials to set.");
          assert(c.username, "must include username"), assert(c.password, "must include password"), 
          assert(c.email, "must include email address"), this.del(nerfed + ":_authToken", "user");
          var encoded = Buffer.from(c.password, "utf8").toString("base64");
          this.set(nerfed + ":_password", encoded, "user"), this.set(nerfed + ":username", c.username, "user"), 
          this.set(nerfed + ":email", c.email, "user"), void 0 !== c.alwaysAuth ? this.set(nerfed + ":always-auth", c.alwaysAuth, "user") : this.del(nerfed + ":always-auth", "user");
        }
      };
    },
    14871: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = function(cb) {
        var defaultConf = this.root;
        if (assert(defaultConf !== Object.prototype), this.get("global")) return cb();
        if (process.env.SUDO_UID) return defaultConf.user = +process.env.SUDO_UID, cb();
        var prefix = path.resolve(this.get("prefix"));
        mkdirp(prefix, (function(er) {
          if (er) return cb(er);
          fs.stat(prefix, (function(er, st) {
            return defaultConf.user = st && st.uid, cb(er);
          }));
        }));
      };
      var assert = __webpack_require__(39491), path = __webpack_require__(71017), fs = __webpack_require__(57147), mkdirp = __webpack_require__(33169).mkdir;
    },
    84495: (module, __unused_webpack_exports, __webpack_require__) => {
      var util = __webpack_require__(73837), path = __webpack_require__(71017), validate = __webpack_require__(95073), without = __webpack_require__(78400), asyncMap = __webpack_require__(89009).asyncMap, chain = __webpack_require__(89009).chain, npa = __webpack_require__(19932), log = __webpack_require__(19334), npm = __webpack_require__(44874), Installer = __webpack_require__(70913).Installer, findRequirement = __webpack_require__(48045).findRequirement, earliestInstallable = __webpack_require__(48045).earliestInstallable, checkPermissions = __webpack_require__(129), decomposeActions = __webpack_require__(67485), loadExtraneous = __webpack_require__(48045).loadExtraneous, computeMetadata = __webpack_require__(48045).computeMetadata, sortActions = __webpack_require__(30855).sortActions, moduleName = __webpack_require__(7802), packageId = __webpack_require__(73531), childPath = __webpack_require__(37013), usage = __webpack_require__(29320), getRequested = __webpack_require__(87517);
      function dedupe(args, cb) {
        validate("AF", arguments);
        var where = path.resolve(npm.dir, ".."), dryrun = !1;
        npm.command.match(/^find/) && (dryrun = !0), npm.config.get("dry-run") && (dryrun = !0), 
        dryrun && !npm.config.get("json") && npm.config.set("parseable", !0), new Deduper(where, dryrun).run(cb);
      }
      function Deduper(where, dryrun) {
        validate("SB", arguments), Installer.call(this, where, dryrun, []), this.noPackageJsonOk = !0, 
        this.topLevelLifecycles = !1;
      }
      function andComputeMetadata(tree) {
        return function(next) {
          next(null, computeMetadata(tree));
        };
      }
      function move(node, hoistTo, diff) {
        node.parent.children = without(node.parent.children, node), hoistTo.children.push(node), 
        node.fromPath = node.path, node.path = childPath(hoistTo.path, node), node.parent = hoistTo, 
        diff.filter((function(action) {
          return "move" === action[0] && action[1] === node;
        })).length || diff.push([ "move", node ]);
      }
      function moveRemainingChildren(node, diff) {
        node.children.forEach((function(child) {
          move(child, node, diff), moveRemainingChildren(child, diff);
        }));
      }
      function remove(child, diff, done) {
        remove_(child, diff, new Set, done);
      }
      function remove_(child, diff, seen, done) {
        if (seen.has(child)) return done();
        seen.add(child), diff.push([ "remove", child ]), child.parent.children = without(child.parent.children, child), 
        asyncMap(child.children, (function(child, next) {
          remove_(child, diff, seen, next);
        }), done);
      }
      function hoistChildren(tree, diff, next) {
        hoistChildren_(tree, diff, new Set, next);
      }
      function hoistChildren_(tree, diff, seen, next) {
        if (validate("OAOF", arguments), seen.has(tree)) return next();
        seen.add(tree), asyncMap(tree.children, (function(child, done) {
          if (!tree.parent || child.fromBundle || child.package._inBundle) return hoistChildren_(child, diff, seen, done);
          if (findRequirement(tree.parent, moduleName(child), getRequested(child) || npa(packageId(child)))) return chain([ [ remove, child, diff ], [ andComputeMetadata(tree) ] ], done);
          var hoistTo = earliestInstallable(tree, tree.parent, child.package, log);
          hoistTo ? (move(child, hoistTo, diff), chain([ [ andComputeMetadata(hoistTo) ], [ hoistChildren_, child, diff, seen ], [ function(next) {
            moveRemainingChildren(child, diff), next();
          } ] ], done)) : done();
        }), next);
      }
      module.exports = dedupe, module.exports.Deduper = Deduper, dedupe.usage = usage("dedupe", "npm dedupe"), 
      util.inherits(Deduper, Installer), Deduper.prototype.loadIdealTree = function(cb) {
        validate("F", arguments), log.silly("install", "loadIdealTree");
        var self = this;
        chain([ [ this.newTracker(this.progress.loadIdealTree, "cloneCurrentTree") ], [ this, this.cloneCurrentTreeToIdealTree ], [ this, this.finishTracker, "cloneCurrentTree" ], [ this.newTracker(this.progress.loadIdealTree, "loadAllDepsIntoIdealTree", 10) ], [ function(next) {
          loadExtraneous(self.idealTree, self.progress.loadAllDepsIntoIdealTree, next);
        } ], [ this, this.finishTracker, "loadAllDepsIntoIdealTree" ], [ this, andComputeMetadata(this.idealTree) ] ], cb);
      }, Deduper.prototype.generateActionsToTake = function(cb) {
        validate("F", arguments), log.silly("dedupe", "generateActionsToTake"), chain([ [ this.newTracker(log, "hoist", 1) ], [ hoistChildren, this.idealTree, this.differences ], [ this, this.finishTracker, "hoist" ], [ this.newTracker(log, "sort-actions", 1) ], [ this, function(next) {
          this.differences = sortActions(this.differences), next();
        } ], [ this, this.finishTracker, "sort-actions" ], [ checkPermissions, this.differences ], [ decomposeActions, this.differences, this.todo ] ], cb);
      };
    },
    68037: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const BB = __webpack_require__(41142), npmConfig = __webpack_require__(23300), fetch = __webpack_require__(27382), figgyPudding = __webpack_require__(55212), otplease = __webpack_require__(83304), npa = __webpack_require__(4422), semver = __webpack_require__(73107), whoami = __webpack_require__(9364), DeprecateConfig = figgyPudding({});
      function deprecate([pkg, msg], opts, cb) {
        return "function" != typeof cb && (cb = opts, opts = null), opts = DeprecateConfig(opts || npmConfig()), 
        BB.try((() => {
          if (null == msg) throw new Error(`Usage: ${deprecate.usage}`);
          const p = npa(pkg), spec = "" === p.rawSpec ? "*" : p.fetchSpec;
          if (null === semver.validRange(spec, !0)) throw new Error("invalid version range: " + spec);
          const uri = "/" + p.escapedName;
          return fetch.json(uri, opts.concat({
            spec: p,
            query: {
              write: !0
            }
          })).then((packument => (Object.keys(packument.versions).filter((v => semver.satisfies(v, spec))).forEach((v => {
            packument.versions[v].deprecated = msg;
          })), otplease(opts, (opts => fetch(uri, opts.concat({
            spec: p,
            method: "PUT",
            body: packument,
            ignoreBody: !0
          })))))));
        })).nodeify(cb);
      }
      module.exports = deprecate, deprecate.usage = "npm deprecate <pkg>[@<version>] <message>", 
      deprecate.completion = function(opts, cb) {
        return BB.try((() => {
          if (!(opts.conf.argv.remain.length > 2)) return whoami([], !0, (() => {})).then((username => {
            if (username) return fetch(`/-/by-user/${encodeURIComponent(username)}`, DeprecateConfig()).then((list => list[username]));
          }));
        })).nodeify(cb);
      };
    },
    64112: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = distTag;
      const BB = __webpack_require__(41142), figgyPudding = __webpack_require__(55212), log = __webpack_require__(19334), npa = __webpack_require__(4422), npmConfig = __webpack_require__(23300), output = __webpack_require__(1015), otplease = __webpack_require__(83304), readLocalPkg = BB.promisify(__webpack_require__(6236)), regFetch = __webpack_require__(27382), semver = __webpack_require__(73107), usage = __webpack_require__(29320), DistTagOpts = figgyPudding({
        tag: {}
      });
      function UsageError() {
        throw Object.assign(new Error("Usage:\n" + distTag.usage), {
          code: "EUSAGE"
        });
      }
      function distTag([cmd, pkg, tag], cb) {
        const opts = DistTagOpts(npmConfig());
        return BB.try((() => {
          switch (cmd) {
           case "add":
           case "a":
           case "set":
           case "s":
            return function(spec, tag, opts) {
              const version = (spec = npa(spec || "")).rawSpec, t = (tag || opts.tag).trim();
              log.verbose("dist-tag add", t, "to", spec.name + "@" + version), spec && version && t || UsageError();
              if (semver.validRange(t)) throw new Error("Tag name must not be a valid SemVer range: " + t);
              return fetchTags(spec, opts).then((tags => {
                if (tags[t] === version) return void log.warn("dist-tag add", t, "is already set to version", version);
                tags[t] = version;
                const url = `/-/package/${spec.escapedName}/dist-tags/${encodeURIComponent(t)}`, reqOpts = opts.concat({
                  method: "PUT",
                  body: JSON.stringify(version),
                  headers: {
                    "content-type": "application/json"
                  },
                  spec
                });
                return otplease(reqOpts, (reqOpts => regFetch(url, reqOpts))).then((() => {
                  output(`+${t}: ${spec.name}@${version}`);
                }));
              }));
            }(pkg, tag, opts);

           case "rm":
           case "r":
           case "del":
           case "d":
           case "remove":
            return function(spec, tag, opts) {
              return spec = npa(spec || ""), log.verbose("dist-tag del", tag, "from", spec.name), 
              fetchTags(spec, opts).then((tags => {
                if (!tags[tag]) throw log.info("dist-tag del", tag, "is not a dist-tag on", spec.name), 
                new Error(tag + " is not a dist-tag on " + spec.name);
                const version = tags[tag];
                delete tags[tag];
                const url = `/-/package/${spec.escapedName}/dist-tags/${encodeURIComponent(tag)}`, reqOpts = opts.concat({
                  method: "DELETE",
                  spec
                });
                return otplease(reqOpts, (reqOpts => regFetch(url, reqOpts))).then((() => {
                  output(`-${tag}: ${spec.name}@${version}`);
                }));
              }));
            }(pkg, tag, opts);

           case "ls":
           case "l":
           case "sl":
           case "list":
            return list(pkg, opts);

           default:
            if (!pkg) return list(cmd, opts);
            UsageError();
          }
        })).then((x => cb(null, x)), (err => {
          "EUSAGE" === err.code ? cb(err.message) : cb(err);
        }));
      }
      function list(spec, opts) {
        return spec ? fetchTags(spec = npa(spec), opts).then((tags => {
          var msg = Object.keys(tags).map((k => `${k}: ${tags[k]}`)).sort().join("\n");
          return output(msg), tags;
        }), (err => {
          throw log.error("dist-tag ls", "Couldn't get dist-tag data for", spec), err;
        })) : readLocalPkg().then((pkg => (pkg || UsageError(), list(pkg, opts))));
      }
      function fetchTags(spec, opts) {
        return regFetch.json(`/-/package/${spec.escapedName}/dist-tags`, opts.concat({
          "prefer-online": !0,
          spec
        })).then((data => {
          if (data && "object" == typeof data && delete data._etag, !data || !Object.keys(data).length) throw new Error("No dist-tags found for " + spec.name);
          return data;
        }));
      }
      distTag.usage = usage("dist-tag", "npm dist-tag add <pkg>@<version> [<tag>]\nnpm dist-tag rm <pkg> <tag>\nnpm dist-tag ls [<pkg>]"), 
      distTag.completion = function(opts, cb) {
        var argv = opts.conf.argv.remain;
        return 2 === argv.length ? cb(null, [ "add", "rm", "ls" ]) : (argv[2], cb());
      };
    },
    97702: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = docs;
      var openUrl = __webpack_require__(89562), log = __webpack_require__(19334), fetchPackageMetadata = __webpack_require__(3138), usage = __webpack_require__(29320);
      function docs(args, cb) {
        args && args.length || (args = [ "." ]);
        var pending = args.length;
        log.silly("docs", args), args.forEach((function(proj) {
          !function(project, cb) {
            log.silly("getDoc", project), fetchPackageMetadata(project, ".", {
              fullMetadata: !0
            }, (function(er, d) {
              if (er) return cb(er);
              var url = d.homepage;
              return url || (url = "https://www.npmjs.org/package/" + d.name), openUrl(url, "docs available at the following URL", cb);
            }));
          }(proj, (function(err) {
            if (err) return cb(err);
            --pending || cb();
          }));
        }));
      }
      docs.usage = usage("docs", "npm docs <pkgname>\nnpm docs ."), docs.completion = function(opts, cb) {
        cb();
      };
    },
    24240: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const ansiTrim = __webpack_require__(82576), chain = __webpack_require__(89009).chain, color = __webpack_require__(53987), defaultRegistry = __webpack_require__(25476).defaults.registry, log = __webpack_require__(19334), npm = __webpack_require__(44874), output = __webpack_require__(1015), path = __webpack_require__(71017), semver = __webpack_require__(73107), styles = __webpack_require__(65308), table = __webpack_require__(5371), checkFilesPermission = __webpack_require__(99420), checkPing = __webpack_require__(59634), getGitPath = __webpack_require__(67008), getLatestNodejsVersion = __webpack_require__(9583), getLatestNpmVersion = __webpack_require__(10305), verifyCachedFiles = __webpack_require__(59125), globalNodeModules = path.join(npm.config.globalPrefix, "lib", "node_modules"), localNodeModules = path.join(npm.config.localPrefix, "node_modules");
      function doctor(args, silent, cb) {
        "function" != typeof cb && (cb = silent, silent = !1);
        const actionsToRun = [ [ checkPing ], [ getLatestNpmVersion ], [ getLatestNodejsVersion, (args = args || {})["node-url"] ], [ getGitPath ], [ checkFilesPermission, npm.cache, 4, 6 ], [ checkFilesPermission, globalNodeModules, 4, 4 ], [ checkFilesPermission, localNodeModules, 6, 6 ], [ verifyCachedFiles, path.join(npm.cache, "_cacache") ] ];
        log.info("doctor", "Running checkup"), chain(actionsToRun, (function(stderr, stdout) {
          if (stderr && "not found: git" !== stderr.message) return cb(stderr);
          const list = function(p) {
            const ping = p[1], npmLTS = p[2], nodeLTS = p[3].replace("v", ""), whichGit = p[4] || "not installed", readbleCaches = p[5] ? "ok" : "notOk", executableGlobalModules = p[6] ? "ok" : "notOk", executableLocalModules = p[7] ? "ok" : "notOk", cacheStatus = p[8] ? `verified ${p[8].verifiedContent} tarballs` : "notOk", npmV = npm.version, nodeV = process.version.replace("v", ""), registry = npm.config.get("registry") || "", list = [ [ "npm ping", ping ], [ "npm -v", "v" + npmV ], [ "node -v", "v" + nodeV ], [ "npm config get registry", registry ], [ "which git", whichGit ], [ "Perms check on cached files", readbleCaches ], [ "Perms check on global node_modules", executableGlobalModules ], [ "Perms check on local node_modules", executableLocalModules ], [ "Verify cache contents", cacheStatus ] ];
            200 !== p[0] && (list[0][2] = "Check your internet connection");
            semver.satisfies(npmV, ">=" + npmLTS) || (list[1][2] = "Use npm v" + npmLTS);
            semver.satisfies(nodeV, ">=" + nodeLTS) || (list[2][2] = "Use node v" + nodeLTS);
            registry !== defaultRegistry && (list[3][2] = "Try `npm config set registry " + defaultRegistry + "`");
            "not installed" === whichGit && (list[4][2] = "Install git and ensure it's in your PATH.");
            "ok" !== readbleCaches && (list[5][2] = "Check the permissions of your files in " + npm.config.get("cache"));
            "ok" !== executableGlobalModules && (list[6][2] = globalNodeModules + " must be readable and writable by the current user.");
            "ok" !== executableLocalModules && (list[7][2] = localNodeModules + " must be readable and writable by the current user.");
            return list;
          }(stdout);
          let outHead = [ "Check", "Value", "Recommendation" ], outBody = list;
          npm.color && (outHead = outHead.map((function(item) {
            return styles.underline(item);
          })), outBody = outBody.map((function(item) {
            return item[2] && (item[0] = color.red(item[0]), item[2] = color.magenta(item[2])), 
            item;
          })));
          const outTable = [ outHead ].concat(outBody);
          silent || output(table(outTable, {
            stringLength: function(s) {
              return ansiTrim(s).length;
            }
          })), cb(null, list);
        }));
      }
      module.exports = doctor, doctor.usage = "npm doctor";
    },
    99420: (module, __unused_webpack_exports, __webpack_require__) => {
      var fs = __webpack_require__(57147), path = __webpack_require__(71017), getUid = __webpack_require__(7971), chain = __webpack_require__(89009).chain, log = __webpack_require__(19334), npm = __webpack_require__(44874), fileCompletion = __webpack_require__(82463);
      module.exports = function(root, fmask, dmask, cb) {
        if ("win32" === process.platform) return cb(null, !0);
        getUid(npm.config.get("user"), npm.config.get("group"), (function(e, uid, gid) {
          var tracker = log.newItem("checkFilePermissions", 1);
          if (e) return tracker.finish(), tracker.warn("checkFilePermissions", "Error looking up user and group:", e), 
          cb(e);
          tracker.info("checkFilePermissions", "Building file list of " + root), fileCompletion(root, ".", 1 / 0, (function(e, files) {
            if (e) return tracker.warn("checkFilePermissions", "Error building file list:", e), 
            tracker.finish(), cb(e);
            function checkFile(f, next) {
              var file = path.join(root, f);
              tracker.silly("checkFilePermissions", f), fs.lstat(file, (function(e, stat) {
                return tracker.completeWork(1), e ? next(e) : stat.isDirectory() || stat.isFile() ? void fs.access(file, stat.isFile() ? fmask : dmask, (err => err ? (tracker.error("checkFilePermissions", `Missing permissions on ${file}`), 
                next(new Error("Missing permissions for " + file))) : next())) : next();
              }));
            }
            tracker.addWork(files.length), tracker.completeWork(1), chain(files.map((function(f) {
              return [ checkFile, f ];
            })), (function(er) {
              tracker.finish(), cb(null, !er);
            }));
          }));
        }));
      };
    },
    59634: (module, __unused_webpack_exports, __webpack_require__) => {
      var log = __webpack_require__(19334), ping = __webpack_require__(23447);
      module.exports = function(cb) {
        log.newItem("checkPing", 1).info("checkPing", "Pinging registry"), ping({}, !0, ((err, pong) => {
          if (err && err.code && err.code.match(/^E\d{3}$/)) return cb(null, [ err.code.substr(1), "failed" ]);
          cb(null, [ 200, "ok" ]);
        }));
      };
    },
    67008: (module, __unused_webpack_exports, __webpack_require__) => {
      var log = __webpack_require__(19334), which = __webpack_require__(7017);
      module.exports = function(cb) {
        var tracker = log.newItem("getGitPath", 1);
        tracker.info("getGitPath", "Finding git in your PATH"), which("git", (function(err, path) {
          tracker.finish(), cb(err, path);
        }));
      };
    },
    9583: (module, __unused_webpack_exports, __webpack_require__) => {
      var log = __webpack_require__(19334), request = __webpack_require__(34712), semver = __webpack_require__(73107);
      module.exports = function(url, cb) {
        var tracker = log.newItem("getLatestNodejsVersion", 1);
        tracker.info("getLatestNodejsVersion", "Getting Node.js release information");
        var version = "v0.0.0";
        request(url = url || "https://nodejs.org/dist/index.json", (function(e, res, index) {
          if (tracker.finish(), e) return cb(e);
          if (200 !== res.statusCode) return cb(new Error("Status not 200, " + res.statusCode));
          try {
            JSON.parse(index).forEach((function(item) {
              item.lts && semver.gt(item.version, version) && (version = item.version);
            })), cb(null, version);
          } catch (e) {
            cb(e);
          }
        }));
      };
    },
    10305: (module, __unused_webpack_exports, __webpack_require__) => {
      var log = __webpack_require__(19334), fetchPackageMetadata = __webpack_require__(3138);
      module.exports = function(cb) {
        var tracker = log.newItem("getLatestNpmVersion", 1);
        tracker.info("getLatestNpmVersion", "Getting npm package information"), fetchPackageMetadata("npm@latest", ".", {}, (function(err, d) {
          if (tracker.finish(), err) return cb(err);
          cb(null, d.version);
        }));
      };
    },
    59125: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const cacache = __webpack_require__(99269), log = __webpack_require__(19334);
      module.exports = function(cache, cb) {
        log.info("verifyCachedFiles", `Verifying cache at ${cache}`), cacache.verify(cache).then((stats => (log.info("verifyCachedFiles", `Verification complete. Stats: ${JSON.stringify(stats, 2)}`), 
        (stats.reclaimedCount || stats.badContentCount || stats.missingContent) && (stats.badContentCount && log.warn("verifyCachedFiles", `Corrupted content removed: ${stats.badContentCount}`), 
        stats.reclaimedCount && log.warn("verifyCachedFiles", `Content garbage-collected: ${stats.reclaimedCount} (${stats.reclaimedSize} bytes)`), 
        stats.missingContent && log.warn("verifyCachedFiles", `Missing content: ${stats.missingContent}`), 
        log.warn("verifyCachedFiles", "Cache issues have been fixed")), stats))).then((s => cb(null, s)), cb);
      };
    },
    25758: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = edit, edit.usage = "npm edit <pkg>[/<subpkg>...]", edit.completion = __webpack_require__(73486);
      var npm = __webpack_require__(44874), path = __webpack_require__(71017), fs = __webpack_require__(59799), editor = __webpack_require__(59550), noProgressTillDone = __webpack_require__(39474).tillDone;
      function edit(args, cb) {
        var p = args[0];
        if (1 !== args.length || !p) return cb(edit.usage);
        var e = npm.config.get("editor");
        if (!e) return cb(new Error("No editor set.  Set the 'editor' config, or $EDITOR environ."));
        p = p.split("/").reduce((function(parts, part) {
          if (0 === parts.length) return [ part ];
          var lastPart = parts[parts.length - 1];
          return "@" !== lastPart[0] || lastPart.includes("/") ? parts.push(part) : parts[parts.length - 1] += "/" + part, 
          parts;
        }), []).join("/node_modules/").replace(/(\/node_modules)+/, "/node_modules");
        var f = path.resolve(npm.dir, p);
        fs.lstat(f, (function(er) {
          if (er) return cb(er);
          editor(f, {
            editor: e
          }, noProgressTillDone((function(er) {
            if (er) return cb(er);
            npm.commands.rebuild(args, cb);
          })));
        }));
      }
    },
    19434: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = explore, explore.usage = "npm explore <pkg> [ -- <command>]", explore.completion = __webpack_require__(73486);
      var npm = __webpack_require__(44874), spawn = __webpack_require__(34998), path = __webpack_require__(71017), fs = __webpack_require__(59799), isWindows = __webpack_require__(52290), escapeExecPath = __webpack_require__(19787), escapeArg = __webpack_require__(43795), output = __webpack_require__(1015), log = __webpack_require__(19334);
      function explore(args, cb) {
        if (args.length < 1 || !args[0]) return cb(explore.usage);
        var p = args.shift(), cwd = path.resolve(npm.dir, p), opts = {
          cwd,
          stdio: "inherit"
        }, shellArgs = [];
        if (args.length) if (isWindows) {
          var execArgs = [ escapeExecPath(args.shift()) ].concat(args.map(escapeArg));
          opts.windowsVerbatimArguments = !0, shellArgs = [ "/d", "/s", "/c" ].concat(execArgs);
        } else shellArgs = [ "-c", args.map(escapeArg).join(" ").trim() ];
        var sh = npm.config.get("shell");
        fs.stat(cwd, (function(er, s) {
          if (er || !s.isDirectory()) return cb(new Error("It doesn't look like " + p + " is installed."));
          shellArgs.length || output("\nExploring " + cwd + "\nType 'exit' or ^D when finished\n"), 
          log.silly("explore", {
            sh,
            shellArgs,
            opts
          }), spawn(sh, shellArgs, opts).on("close", (function(er) {
            if (!shellArgs.length) return cb();
            cb(er);
          }));
        }));
      }
    },
    3138: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const deprCheck = __webpack_require__(8956), path = __webpack_require__(71017), log = __webpack_require__(19334), pacote = __webpack_require__(96770), readPackageTree = __webpack_require__(7338), rimraf = __webpack_require__(68259), validate = __webpack_require__(95073), npa = __webpack_require__(19932), npm = __webpack_require__(44874);
      let npmConfig;
      const npmlog = __webpack_require__(19334), limit = __webpack_require__(71247), tempFilename = __webpack_require__(10081), replaceInfo = __webpack_require__(45042), isWindows = __webpack_require__(52290);
      const CACHE = new (__webpack_require__(36941))({
        max: 314572800,
        length: p => p._contentLength
      });
      module.exports = limit((function(spec, where, opts, done) {
        validate("SSOF|SSFZ|OSOF|OSFZ", [ spec, where, opts, done ]), done || (done = opts, 
        opts = {});
        var tracker = opts.tracker;
        const logAndFinish = function(spec, tracker, done) {
          return validate("SOF|SZF|OOF|OZF", [ spec, tracker, done ]), (er, pkg) => {
            if (er) {
              er.message = replaceInfo(er.message);
              var spc = replaceInfo(String(spec));
              log.silly("fetchPackageMetaData", "error for " + spc, er.message), tracker && tracker.finish();
            }
            return done(er, pkg);
          };
        }(spec, tracker, done);
        if ("object" == typeof spec) var dep = spec; else dep = npa(spec);
        if (!isWindows && "directory" === dep.type && /^[a-zA-Z]:/.test(dep.fetchSpec)) {
          var err = new Error(`Can't install from windows path on a non-windows system: ${dep.fetchSpec.replace(/[/]/g, "\\")}`);
          return err.code = "EWINDOWSPATH", logAndFinish(err);
        }
        npmConfig || (npmConfig = __webpack_require__(23300));
        pacote.manifest(dep, npmConfig({
          annotate: !0,
          fullMetadata: opts.fullMetadata,
          log: tracker || npmlog,
          memoize: CACHE,
          where
        })).then((pkg => logAndFinish(null, deprCheck(pkg))), (err => {
          if ("directory" !== dep.type) return logAndFinish(err);
          if ("ENOTDIR" === err.code) {
            var enolocal = new Error(`Could not install "${path.relative(process.cwd(), dep.fetchSpec)}" as it is not a directory and is not a file with a name ending in .tgz, .tar.gz or .tar`);
            return enolocal.code = "ENOLOCAL", err.stack && (enolocal.stack = err.stack), logAndFinish(enolocal);
          }
          if ("ENOPACKAGEJSON" === err.code) {
            var enopackage = new Error(`Could not install from "${path.relative(process.cwd(), dep.fetchSpec)}" as it does not contain a package.json file.`);
            return enopackage.code = "ENOLOCAL", err.stack && (enopackage.stack = err.stack), 
            logAndFinish(enopackage);
          }
          return logAndFinish(err);
        }));
      }), npm.limit.fetch), module.exports.addBundled = function(pkg, next) {
        if (validate("OF", arguments), void 0 !== pkg._bundled) return next(null, pkg);
        if (!pkg.bundleDependencies && "directory" !== pkg._requested.type) return next(null, pkg);
        const requested = pkg._requested || npa(pkg._from);
        if ("directory" === requested.type) return pkg._bundled = null, readPackageTree(pkg._requested.fetchSpec, (function(er, tree) {
          return tree && (pkg._bundled = tree.children), next(null, pkg);
        }));
        pkg._bundled = null;
        const target = tempFilename("unpack");
        npmConfig || (npmConfig = __webpack_require__(23300));
        const opts = npmConfig({
          integrity: pkg._integrity
        });
        pacote.extract(pkg._resolved || pkg._requested || npa.resolve(pkg.name, pkg.version), target, opts).then((() => {
          log.silly("addBundled", "read tarball"), readPackageTree(target, ((err, tree) => {
            if (err) return next(err);
            log.silly("cleanup", "remove extracted module"), rimraf(target, (function() {
              tree && (pkg._bundled = tree.children), next(null, pkg);
            }));
          }));
        }), next);
      };
    },
    35094: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const path = __webpack_require__(71017), archy = __webpack_require__(84032), figgyPudding = __webpack_require__(55212), readPackageTree = __webpack_require__(7338), npm = __webpack_require__(44874), npmConfig = __webpack_require__(23300), fetchPackageMetadata = __webpack_require__(3138), computeMetadata = __webpack_require__(48045).computeMetadata, readShrinkwrap = __webpack_require__(34160), mutateIntoLogicalTree = __webpack_require__(60867), output = __webpack_require__(1015), openUrl = __webpack_require__(89562), {getFundingInfo, retrieveFunding, validFundingField, flatCacheSymbol} = __webpack_require__(41539), FundConfig = figgyPudding({
        browser: {},
        global: {},
        json: {},
        unicode: {},
        which: {}
      });
      module.exports = fundCmd;
      const usage = __webpack_require__(29320);
      function printJSON(fundingInfo) {
        return JSON.stringify(fundingInfo, null, 2);
      }
      function printHuman(fundingInfo, opts) {
        const flatCache = fundingInfo[flatCacheSymbol], {name, version} = fundingInfo, printableVersion = version ? `@${version}` : "", items = Object.keys(flatCache).map((url => {
          const packages = flatCache[url].map((dep => {
            const {name, version} = dep;
            return `${name}${version ? `@${version}` : ""}`;
          }));
          return {
            label: url,
            nodes: [ packages.join(", ") ]
          };
        }));
        return archy({
          label: `${name}${printableVersion}`,
          nodes: items
        }, "", {
          unicode: opts.unicode
        });
      }
      function openFundingUrl(packageName, fundingSourceNumber, cb) {
        fetchPackageMetadata(packageName, ".", {
          fullMetadata: !0
        }, (function(err, packageMetadata) {
          if (err) return cb(err);
          !function(packageMetadata) {
            const {funding} = packageMetadata, validSources = [].concat(retrieveFunding(funding)).filter(validFundingField);
            if (1 === validSources.length || fundingSourceNumber > 0 && fundingSourceNumber <= validSources.length) {
              const {type, url} = validSources[fundingSourceNumber ? fundingSourceNumber - 1 : 0];
              openUrl(url, (type ? `${type} funding` : "Funding") + " available at the following URL", cb);
            } else {
              if (fundingSourceNumber >= 1) {
                const noFundingError = new Error(`No valid funding method available for: ${packageName}`);
                throw noFundingError.code = "ENOFUND", noFundingError;
              }
              validSources.forEach((({type, url}, i) => {
                const msg = (type ? `${type} funding` : "Funding") + " available at the following URL";
                console.log(`${i + 1}: ${msg}: ${url}`);
              })), console.log("Run `npm fund [<@scope>/]<pkg> --which=1`, for example, to open the first funding URL listed in that package"), 
              cb();
            }
          }(packageMetadata);
        }));
      }
      function fundCmd(args, cb) {
        const opts = FundConfig(npmConfig()), dir = path.resolve(npm.dir, ".."), packageName = args[0], numberArg = opts.which, fundingSourceNumber = numberArg && parseInt(numberArg, 10);
        if (void 0 !== numberArg && (String(fundingSourceNumber) !== numberArg || fundingSourceNumber < 1)) {
          const err = new Error("`npm fund [<@scope>/]<pkg> [--which=fundingSourceNumber]` must be given a positive integer");
          throw err.code = "EFUNDNUMBER", err;
        }
        if (opts.global) {
          const err = new Error("`npm fund` does not support global packages");
          throw err.code = "EFUNDGLOBAL", err;
        }
        packageName ? openFundingUrl(packageName, fundingSourceNumber, cb) : readPackageTree(dir, (function(err, tree) {
          if (err) return process.exitCode = 1, cb(err);
          readShrinkwrap.andInflate(tree, (function() {
            const fundingInfo = getFundingInfo(mutateIntoLogicalTree.asReadInstalled(computeMetadata(tree))), print = opts.json ? printJSON : printHuman;
            output(print(fundingInfo, opts)), cb(err, tree);
          }));
        }));
      }
      fundCmd.usage = usage("fund", "npm fund [--json]", "npm fund [--browser] [[<@scope>/]<pkg> [--which=<fundingSourceNumber>]"), 
      fundCmd.completion = function(opts, cb) {
        const argv = opts.conf.argv.remain;
        return "fund" === argv[2] ? cb(null, []) : cb(new Error(argv[2] + " not recognized"));
      };
    },
    67870: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = get, get.usage = "npm get <key> <value> (See `npm config`)";
      var npm = __webpack_require__(44874);
      function get(args, cb) {
        npm.commands.config([ "get" ].concat(args), cb);
      }
      get.completion = npm.commands.config.completion;
    },
    89982: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = helpSearch;
      var fs = __webpack_require__(59799), path = __webpack_require__(71017), asyncMap = __webpack_require__(89009).asyncMap, npm = __webpack_require__(44874), glob = __webpack_require__(34436), color = __webpack_require__(53987), output = __webpack_require__(1015);
      function helpSearch(args, silent, cb) {
        if ("function" != typeof cb && (cb = silent, silent = !1), !args.length) return cb(helpSearch.usage);
        var docPath = path.resolve(__dirname, "..", "docs");
        return glob(docPath + "/content/*/*.md", (function(er, files) {
          if (er) return cb(er);
          !function(files, cb) {
            var res = {};
            asyncMap(files, (function(file, cb) {
              fs.readFile(file, "utf8", (function(er, data) {
                return res[file] = data, cb(er);
              }));
            }), (function(er) {
              return cb(er, res);
            }));
          }(files, (function(er, data) {
            if (er) return cb(er);
            !function(args, files, cb) {
              var results = [];
              if (Object.keys(files).forEach((function(file) {
                for (var match, data = files[file], a = 0, l = args.length; a < l && !match; a++) match = -1 !== data.toLowerCase().indexOf(args[a].toLowerCase());
                if (match) {
                  var lines = data.split(/\n+/);
                  l = lines.length;
                  for (var i = 0; i < l; i++) {
                    var ll, line = lines[i], nextLine = lines[i + 1];
                    if (match = !1, nextLine) {
                      for (a = 0, ll = args.length; a < ll && !match; a++) match = -1 !== nextLine.toLowerCase().indexOf(args[a].toLowerCase());
                      if (match) {
                        i += 2;
                        continue;
                      }
                    }
                    for (match = !1, a = 0, ll = args.length; a < ll && !match; a++) match = -1 !== line.toLowerCase().indexOf(args[a].toLowerCase());
                    match ? i++ : lines[i] = null;
                  }
                  lines = lines.reduce((function(l, r) {
                    return null === r && null === l[l.length - 1] || l.push(r), l;
                  }), []), null === lines[lines.length - 1] && lines.pop(), null === lines[0] && lines.shift();
                  var found = {}, totalHits = 0;
                  lines.forEach((function(line) {
                    args.forEach((function(arg) {
                      var hit = (line || "").toLowerCase().split(arg.toLowerCase()).length - 1;
                      hit > 0 && (found[arg] = (found[arg] || 0) + hit, totalHits += hit);
                    }));
                  }));
                  var cmd = "npm help ";
                  "api" === path.basename(path.dirname(file)) && (cmd = "npm apihelp "), cmd += path.basename(file, ".md").replace(/^npm-/, ""), 
                  results.push({
                    file,
                    cmd,
                    lines,
                    found: Object.keys(found),
                    hits: found,
                    totalHits
                  });
                }
              })), 1 === results.length) return npm.commands.help([ results[0].file.replace(/\.md$/, "") ], cb);
              if (0 === results.length) return output("No results for " + args.map(JSON.stringify).join(" ")), 
              cb();
              results = results.sort((function(a, b) {
                return a.found.length > b.found.length ? -1 : a.found.length < b.found.length ? 1 : a.totalHits > b.totalHits ? -1 : a.totalHits < b.totalHits ? 1 : a.lines.length > b.lines.length ? -1 : a.lines.length < b.lines.length ? 1 : 0;
              })), cb(null, results);
            }(args, data, (function(er, results) {
              if (er) return cb(er);
              !function(args, results, cb) {
                if (!results) return cb(null);
                var cols = Math.min(process.stdout.columns || 1 / 0, 80) + 1, out = results.map((function(res) {
                  var out = res.cmd, r = Object.keys(res.hits).map((function(k) {
                    return k + ":" + res.hits[k];
                  })).sort((function(a, b) {
                    return a > b ? 1 : -1;
                  })).join(" ");
                  return out += new Array(Math.max(1, cols - out.length - r.length)).join(" ") + r, 
                  npm.config.get("long") ? out = "\n\n" + out + "\n" + new Array(cols).join("") + "\n" + res.lines.map((function(line, i) {
                    if (null === line || i > 3) return "";
                    for (var out = line, a = 0, l = args.length; a < l; a++) {
                      var finder = out.toLowerCase().split(args[a].toLowerCase()), newOut = "", p = 0;
                      finder.forEach((function(f) {
                        newOut += out.substr(p, f.length);
                        var hilit = out.substr(p + f.length, args[a].length);
                        npm.color && (hilit = color.bgBlack(color.red(hilit))), newOut += hilit, p += f.length + args[a].length;
                      }));
                    }
                    return newOut;
                  })).join("\n").trim() : out;
                })).join("\n");
                results.length && !npm.config.get("long") && (out = "Top hits for " + args.map(JSON.stringify).join(" ") + "\n" + new Array(cols).join("") + "\n" + out + "\n" + new Array(cols).join("") + "\n(run with -l or --long to see more context)");
                output(out.trim()), cb(null, results);
              }(args, results, cb);
            }));
          }));
        }));
      }
      helpSearch.usage = "npm help-search <text>";
    },
    53210: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = help, help.completion = function(opts, cb) {
        if (opts.conf.argv.remain.length > 2) return cb(null, []);
        !function(cb) {
          var g = path.resolve(__dirname, "../man/man[0-9]/*.[0-9]");
          glob(g, (function(er, files) {
            if (er) return cb(er);
            cb(null, Object.keys(files.reduce((function(acc, file) {
              return acc[file = (file = path.basename(file).replace(/\.[0-9]+$/, "")).replace(/^npm-/, "")] = !0, 
              acc;
            }), {
              help: !0
            })));
          }));
        }(cb);
      };
      var path = __webpack_require__(71017), spawn = __webpack_require__(34998), npm = __webpack_require__(44874), log = __webpack_require__(19334), openUrl = __webpack_require__(89562), glob = __webpack_require__(34436), didYouMean = __webpack_require__(90594), cmdList = __webpack_require__(27572).cmdList, shorthands = __webpack_require__(27572).shorthands, commands = cmdList.concat(Object.keys(shorthands)), output = __webpack_require__(1015);
      function help(args, cb) {
        var argv = npm.config.get("argv").cooked, argnum = 0;
        if (2 === args.length && ~~args[0] && (argnum = ~~args.shift()), args.length > 1 && args[0]) return npm.commands["help-search"](args, argnum, cb);
        var section = npm.deref(args[0]) || args[0];
        if (!section) return function(valid, cb) {
          npm.config.set("loglevel", "silent"), log.level = "silent", output([ "\nUsage: npm <command>", "", "where <command> is one of:", npm.config.get("long") ? usages() : "    " + wrap(commands), "", "npm <command> -h  quick help on <command>", "npm -l            display full usage info", "npm help <term>   search for help on <term>", "npm help npm      involved overview", "", "Specify configs in the ini-formatted file:", "    " + npm.config.get("userconfig"), "or on the command line via: npm <command> --key value", "Config info can be viewed via: npm help config", "", "npm@" + npm.version + " " + path.dirname(__dirname) ].join("\n")), 
          npm.argv.length > 1 && output(didYouMean(npm.argv[1], commands));
          cb(valid);
        }("help" === argv[0] ? 0 : 1, cb);
        if (npm.config.get("usage") && npm.commands[section] && npm.commands[section].usage) return npm.config.set("loglevel", "silent"), 
        log.level = "silent", output(npm.commands[section].usage), cb();
        var pref = argv.length && -1 !== argv[0].indexOf("api") ? [ 3, 1, 5, 7 ] : [ 1, 3, 5, 7 ];
        argnum && (pref = [ argnum ].concat(pref.filter((function(n) {
          return n !== argnum;
        }))));
        var manroot = path.resolve(__dirname, "..", "man");
        "global" === section ? section = "folders" : section.match(/.*json/) && (section = section.replace(".json", "-json"));
        return glob(manroot + "/*/" + ("+(npm-" + section + "|" + section + ").[0-9]?(.+(gz|bz2|lzma|[FYzZ]|xz))"), (function(er, mans) {
          return er ? cb(er) : mans.length ? void function(man, cb) {
            var nre = /([0-9]+)$/, num = man.match(nre)[1], section = path.basename(man, "." + num), manpath = path.join(__dirname, "..", "man"), env = {};
            switch (Object.keys(process.env).forEach((function(i) {
              env[i] = process.env[i];
            })), env.MANPATH = manpath, npm.config.get("viewer")) {
             case "woman":
              spawn("emacsclient", [ "-e", "(woman-find-file '" + man + "')" ], {
                env,
                stdio: "inherit"
              }).on("close", cb);
              break;

             case "browser":
              openUrl(function(man) {
                var sect = +man.match(/([0-9]+)$/)[1], f = path.basename(man).replace(/[.]([0-9]+)$/, "");
                switch (sect) {
                 case 1:
                  sect = "commands";
                  break;

                 case 5:
                  sect = "configuring-npm";
                  break;

                 case 7:
                  sect = "using-npm";
                  break;

                 default:
                  throw new Error("invalid man section: " + sect);
                }
                return path.resolve(__dirname, "..", "docs", "output", sect, f + ".html");
              }(man), "help available at the following URL", cb);
              break;

             default:
              spawn("man", [ num, section ], {
                env,
                stdio: "inherit"
              }).on("close", cb);
            }
          }(function(mans, pref_) {
            var nre = /([0-9]+)$/, pref = {};
            return pref_.forEach((function(sect, i) {
              pref[sect] = i;
            })), (mans = mans.sort((function(a, b) {
              var an = a.match(nre)[1], bn = b.match(nre)[1];
              return an === bn ? a > b ? -1 : 1 : pref[an] < pref[bn] ? -1 : 1;
            })))[0];
          }(mans = mans.map((function(man) {
            var ext = path.extname(man);
            return man.match(new RegExp("\\.(gz|bz2|lzma|[FYzZ]|xz)$")) && (man = path.basename(man, ext)), 
            man;
          })), pref), cb) : npm.commands["help-search"](args, cb);
        }));
      }
      function usages() {
        var maxLen = 0;
        return Object.keys(npm.commands).filter((function(c) {
          return c === npm.deref(c);
        })).reduce((function(set, c) {
          return set.push([ c, npm.commands[c].usage || "" ]), maxLen = Math.max(maxLen, c.length), 
          set;
        }), []).map((function(item) {
          var c = item[0], usage = item[1];
          return "\n    " + c + new Array(maxLen - c.length + 2).join(" ") + usage.split("\n").join("\n" + new Array(maxLen + 6).join(" "));
        })).join("\n");
      }
      function wrap(arr) {
        var line, out = [ "" ], l = 0;
        return line = (line = process.stdout.columns) ? Math.min(60, Math.max(line - 16, 24)) : 60, 
        arr.sort((function(a, b) {
          return a < b ? -1 : 1;
        })).forEach((function(c) {
          out[l].length + c.length + 2 < line ? out[l] += ", " + c : (out[l++] += ",", out[l] = c);
        })), out.join("\n    ").substr(2);
      }
    },
    95503: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const BB = __webpack_require__(41142), hookApi = __webpack_require__(67879), npmConfig = __webpack_require__(23300), output = __webpack_require__(1015), otplease = __webpack_require__(83304), pudding = __webpack_require__(55212), relativeDate = __webpack_require__(38100), Table = __webpack_require__(27275), validate = __webpack_require__(95073), npm = __webpack_require__(44874);
      hook.usage = [ "npm hook add <pkg> <url> <secret> [--type=<type>]", "npm hook ls [pkg]", "npm hook rm <id>", "npm hook update <id> <url> <secret>" ].join("\n"), 
      hook.completion = (opts, cb) => (validate("OF", [ opts, cb ]), cb(null, []));
      const HookConfig = pudding({
        json: {},
        loglevel: {},
        parseable: {},
        silent: {},
        unicode: {}
      });
      function hook(args) {
        return 4 === args.length && function() {
          const referer = npm.referer;
          if (!referer) return;
          const splittedReferer = referer.split(" ");
          splittedReferer[4] = "[REDACTED]", npm.referer = splittedReferer.join(" ");
        }(), otplease(npmConfig(), (opts => {
          switch (opts = HookConfig(opts), args[0]) {
           case "add":
            return function(pkg, uri, secret, opts) {
              return hookApi.add(pkg, uri, secret, opts).then((hook => {
                opts.json ? output(JSON.stringify(hook, null, 2)) : opts.parseable ? (output(Object.keys(hook).join("\t")), 
                output(Object.keys(hook).map((k => hook[k])).join("\t"))) : opts.silent || "silent" === opts.loglevel || output(`+ ${hookName(hook)} ${opts.unicode ? "  " : " -> "} ${hook.endpoint}`);
              }));
            }(args[1], args[2], args[3], opts);

           case "ls":
            return function(pkg, opts) {
              return hookApi.ls(opts.concat({
                package: pkg
              })).then((hooks => {
                if (opts.json) output(JSON.stringify(hooks, null, 2)); else if (opts.parseable) output(Object.keys(hooks[0]).join("\t")), 
                hooks.forEach((hook => {
                  output(Object.keys(hook).map((k => hook[k])).join("\t"));
                })); else if (hooks.length) {
                  if (!opts.silent && "silent" !== opts.loglevel) {
                    1 === hooks.length ? output("You have one hook configured.") : output(`You have ${hooks.length} hooks configured.`);
                    const table = new Table({
                      head: [ "id", "target", "endpoint" ]
                    });
                    hooks.forEach((hook => {
                      table.push([ {
                        rowSpan: 2,
                        content: hook.id
                      }, hookName(hook), hook.endpoint ]), hook.last_delivery ? table.push([ {
                        colSpan: 1,
                        content: `triggered ${relativeDate(hook.last_delivery)}`
                      }, hook.response_code ]) : table.push([ {
                        colSpan: 2,
                        content: "never triggered"
                      } ]);
                    })), output(table.toString());
                  }
                } else output("You don't have any hooks configured yet.");
              }));
            }(args[1], opts);

           case "rm":
            return function(id, opts) {
              return hookApi.rm(id, opts).then((hook => {
                opts.json ? output(JSON.stringify(hook, null, 2)) : opts.parseable ? (output(Object.keys(hook).join("\t")), 
                output(Object.keys(hook).map((k => hook[k])).join("\t"))) : opts.silent || "silent" === opts.loglevel || output(`- ${hookName(hook)} ${opts.unicode ? "  " : " X "} ${hook.endpoint}`);
              }));
            }(args[1], opts);

           case "update":
           case "up":
            return function(id, uri, secret, opts) {
              return hookApi.update(id, uri, secret, opts).then((hook => {
                opts.json ? output(JSON.stringify(hook, null, 2)) : opts.parseable ? (output(Object.keys(hook).join("\t")), 
                output(Object.keys(hook).map((k => hook[k])).join("\t"))) : opts.silent || "silent" === opts.loglevel || output(`+ ${hookName(hook)} ${opts.unicode ? "  " : " -> "} ${hook.endpoint}`);
              }));
            }(args[1], args[2], args[3], opts);

           default:
            !function() {
              throw Object.assign(new Error(hook.usage), {
                code: "EUSAGE"
              });
            }();
          }
        }));
      }
      function hookName(hook) {
        let target = hook.name;
        return "scope" === hook.type && (target = "@" + target), "owner" === hook.type && (target = "~" + target), 
        target;
      }
      module.exports = (args, cb) => BB.try((() => hook(args))).then((val => cb(null, val)), (err => "EUSAGE" === err.code ? cb(err.message) : cb(err)));
    },
    35153: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = init;
      var path = __webpack_require__(71017), log = __webpack_require__(19334), npa = __webpack_require__(19932), npm = __webpack_require__(44874), npx = __webpack_require__(2985), initJson = __webpack_require__(35975), isRegistry = __webpack_require__(80127), output = __webpack_require__(1015), noProgressTillDone = __webpack_require__(39474).tillDone, usage = __webpack_require__(29320);
      function init(args, cb) {
        if (args.length) {
          var NPM_PATH = path.resolve(__dirname, "../bin/npm-cli.js"), initerName = args[0], packageName = initerName;
          if (/^@[^/]+$/.test(initerName)) packageName = initerName + "/create"; else {
            var req = npa(initerName);
            if ("git" === req.type && req.hosted) {
              var {user, project} = req.hosted;
              packageName = initerName.replace(user + "/" + project, user + "/create-" + project);
            } else {
              if (!isRegistry(req)) {
                var err = new Error("Unrecognized initializer: " + initerName + "\nFor more package binary executing power check out `npx`:\nhttps://www.npmjs.com/package/npx");
                throw err.code = "EUNSUPPORTED", err;
              }
              packageName = req.name.replace(/^(@[^/]+\/)?/, "$1create-"), req.rawSpec && (packageName += "@" + req.rawSpec);
            }
          }
          var npxArgs = [ process.argv0, "[fake arg]", "--always-spawn", packageName, ...process.argv.slice(4) ], parsed = npx.parseArgs(npxArgs, NPM_PATH);
          return npx(parsed).then((() => cb())).catch(cb);
        }
        var dir = process.cwd();
        log.pause();
        var initFile = npm.config.get("init-module");
        initJson.yes(npm.config) || output([ "This utility will walk you through creating a package.json file.", "It only covers the most common items, and tries to guess sensible defaults.", "", "See `npm help init` for definitive documentation on these fields", "and exactly what they do.", "", "Use `npm install <pkg>` afterwards to install a package and", "save it as a dependency in the package.json file.", "", "Press ^C at any time to quit." ].join("\n")), 
        initJson(dir, initFile, npm.config, noProgressTillDone((function(er, data) {
          if (log.resume(), log.silly("package data", data), er && "canceled" === er.message) return log.warn("init", "canceled"), 
          cb(null, data);
          log.info("init", "written successfully"), cb(er, data);
        })));
      }
      init.usage = usage("init", "\nnpm init [--force|-f|--yes|-y|--scope]\nnpm init <@scope> (same as `npx <@scope>/create`)\nnpm init [<@scope>/]<name> (same as `npx [<@scope>/]create-<name>`)");
    },
    17577: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = installTest;
      var ci = __webpack_require__(35200), test = __webpack_require__(75842), usage = __webpack_require__(29320);
      function installTest(args, cb) {
        ci(args, (function(er) {
          if (er) return cb(er);
          test([], cb);
        }));
      }
      installTest.usage = usage("install-ci-test", "\nnpm install-ci-test [args]\nSame args as `npm ci`"), 
      installTest.completion = ci.completion;
    },
    59330: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = installTest;
      var install = __webpack_require__(70913), test = __webpack_require__(75842), usage = __webpack_require__(29320);
      function installTest(args, cb) {
        install(args, (function(er) {
          if (er) return cb(er);
          test([], cb);
        }));
      }
      installTest.usage = usage("install-test", "\nnpm install-test [args]\nSame args as `npm install`"), 
      installTest.completion = install.completion;
    },
    70913: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = install, module.exports.Installer = Installer;
      var usage = __webpack_require__(29320);
      install.usage = usage("install", "\nnpm install (with no args, in package dir)\nnpm install [<@scope>/]<pkg>\nnpm install [<@scope>/]<pkg>@<tag>\nnpm install [<@scope>/]<pkg>@<version>\nnpm install [<@scope>/]<pkg>@<version range>\nnpm install <alias>@npm:<name>\nnpm install <folder>\nnpm install <tarball file>\nnpm install <tarball url>\nnpm install <git:// url>\nnpm install <github username>/<github project>", "[--save-prod|--save-dev|--save-optional] [--save-exact] [--no-save]"), 
      install.completion = function(opts, cb) {
        if (validate("OF", arguments), /^https?:\/\//.test(opts.partialWord)) return cb(null, []);
        if (/\//.test(opts.partialWord)) {
          var lastSlashIdx = opts.partialWord.lastIndexOf("/"), partialName = opts.partialWord.slice(lastSlashIdx + 1), partialPath = opts.partialWord.slice(0, lastSlashIdx);
          "" === partialPath && (partialPath = "/");
          var annotatePackageDirMatch = function(sibling, cb) {
            var fullPath = path.join(partialPath, sibling);
            if (sibling.slice(0, partialName.length) !== partialName) return cb(null, null);
            fs.readdir(fullPath, (function(err, contents) {
              if (err) return cb(null, {
                isPackage: !1
              });
              cb(null, {
                fullPath,
                isPackage: -1 !== contents.indexOf("package.json")
              });
            }));
          };
          return fs.readdir(partialPath, (function(err, siblings) {
            if (err) return cb(null, []);
            asyncMap(siblings, annotatePackageDirMatch, (function(err, matches) {
              if (err) return cb(err);
              var cleaned = matches.filter((function(x) {
                return null !== x;
              }));
              return 1 !== cleaned.length ? cb(null, []) : cleaned[0].isPackage ? cb(null, [ cleaned[0].fullPath ]) : cb(null, []);
            }));
          }));
        }
        cb();
      };
      var fs = __webpack_require__(57147), path = __webpack_require__(71017), log = __webpack_require__(19334), readPackageTree = __webpack_require__(7338), readPackageJson = __webpack_require__(92200), chain = __webpack_require__(89009).chain, asyncMap = __webpack_require__(89009).asyncMap, archy = __webpack_require__(84032), mkdirp = __webpack_require__(33169).mkdir, rimraf = __webpack_require__(68259), iferr = __webpack_require__(17367), validate = __webpack_require__(95073), uniq = __webpack_require__(67900), Bluebird = __webpack_require__(41142), npm = __webpack_require__(44874), locker = __webpack_require__(67797), lock = locker.lock, unlock = locker.unlock, parseJSON = __webpack_require__(51686), output = __webpack_require__(1015), saveMetrics = __webpack_require__(21694).save, copyTree = __webpack_require__(9528), readShrinkwrap = __webpack_require__(34160), computeMetadata = __webpack_require__(48045).computeMetadata, prefetchDeps = __webpack_require__(48045).prefetchDeps, loadDeps = __webpack_require__(48045).loadDeps, loadDevDeps = __webpack_require__(48045).loadDevDeps, getAllMetadata = __webpack_require__(48045).getAllMetadata, loadRequestedDeps = __webpack_require__(48045).loadRequestedDeps, loadExtraneous = __webpack_require__(48045).loadExtraneous, diffTrees = __webpack_require__(30855), checkPermissions = __webpack_require__(129), decomposeActions = __webpack_require__(67485), validateTree = __webpack_require__(49310), validateArgs = __webpack_require__(11674), saveRequested = __webpack_require__(29705).saveRequested, saveShrinkwrap = __webpack_require__(29705).saveShrinkwrap, audit = __webpack_require__(64795), {getPrintFundingReport, getPrintFundingReportJSON} = __webpack_require__(12992), getSaveType = __webpack_require__(29705).getSaveType, doSerialActions = __webpack_require__(80631).doSerial, doReverseSerialActions = __webpack_require__(80631).doReverseSerial, doParallelActions = __webpack_require__(80631).doParallel, doOneAction = __webpack_require__(80631).doOne, removeObsoleteDep = __webpack_require__(48045).removeObsoleteDep, removeExtraneous = __webpack_require__(48045).removeExtraneous, computeVersionSpec = __webpack_require__(48045).computeVersionSpec, packageId = __webpack_require__(73531), moduleName = __webpack_require__(7802), errorMessage = __webpack_require__(78611), isExtraneous = __webpack_require__(66305);
      function unlockCB(lockPath, name, cb) {
        return validate("SSF", arguments), function(installEr) {
          var args = arguments;
          try {
            unlock(lockPath, name, reportErrorAndReturn);
          } catch (unlockEx) {
            process.nextTick((function() {
              reportErrorAndReturn(unlockEx);
            }));
          }
          function reportErrorAndReturn(unlockEr) {
            return installEr ? (unlockEr && "ENOTLOCKED" !== unlockEr.code && log.warn("unlock" + name, unlockEr), 
            cb.apply(null, args)) : unlockEr ? cb(unlockEr) : cb.apply(null, args);
          }
        };
      }
      function install(where, args, cb) {
        cb || (cb = args, args = where, where = null);
        var globalTop = path.resolve(npm.globalDir, "..");
        where || (where = npm.config.get("global") ? globalTop : npm.prefix), validate("SAF", [ where, args, cb ]);
        var dryrun = !!npm.config.get("dry-run");
        npm.config.get("dev") && log.warn("install", "Usage of the `--dev` option is deprecated. Use `--also=dev` instead."), 
        where !== globalTop || args.length || (args = [ "." ]), new Installer(where, dryrun, args = args.filter((function(a) {
          return path.resolve(a) !== npm.prefix;
        }))).run(cb);
      }
      function Installer(where, dryrun, args, opts) {
        validate("SBA|SBAO", arguments), opts || (opts = {}), this.where = where, this.dryrun = dryrun, 
        this.args = args, this.currentTree = null, this.idealTree = null, this.differences = [], 
        this.todo = [], this.progress = {}, this.noPackageJsonOk = !!args.length, this.topLevelLifecycles = !args.length, 
        this.autoPrune = npm.config.get("package-lock");
        const dev = npm.config.get("dev"), only = npm.config.get("only"), onlyProd = /^prod(uction)?$/.test(only), onlyDev = /^dev(elopment)?$/.test(only), prod = npm.config.get("production");
        this.dev = null != opts.dev ? opts.dev : dev || !onlyProd && !prod || onlyDev, this.prod = null != opts.prod ? opts.prod : !onlyDev, 
        this.packageLockOnly = null != opts.packageLockOnly ? opts.packageLockOnly : npm.config.get("package-lock-only"), 
        this.rollback = null != opts.rollback ? opts.rollback : npm.config.get("rollback"), 
        this.link = null != opts.link ? opts.link : npm.config.get("link"), this.saveOnlyLock = opts.saveOnlyLock, 
        this.global = null != opts.global ? opts.global : this.where === path.resolve(npm.globalDir, ".."), 
        this.audit = npm.config.get("audit") && !this.global, this.fund = npm.config.get("fund") && !this.global, 
        this.started = Date.now();
      }
      Installer.prototype = {}, Installer.prototype.run = function(_cb) {
        var result, cb;
        if (validate("F|", arguments), _cb ? cb = function(err) {
          return saveMetrics(!err), _cb.apply(this, arguments);
        } : result = new Promise(((resolve, reject) => {
          cb = (err, value) => err ? reject(err) : resolve(value);
        })), this.global) {
          var prevGlobal = npm.config.get("global");
          npm.config.set("global", !0);
          var next = cb;
          cb = function() {
            npm.config.set("global", prevGlobal), next.apply(null, arguments);
          };
        }
        var installSteps = [], postInstallSteps = [];
        if (this.dryrun || installSteps.push([ this.newTracker(log, "runTopLevelLifecycles", 2) ], [ this, this.runPreinstallTopLevelLifecycles ]), 
        installSteps.push([ this.newTracker(log, "loadCurrentTree", 4) ], [ this, this.loadCurrentTree ], [ this, this.finishTracker, "loadCurrentTree" ], [ this.newTracker(log, "loadIdealTree", 12) ], [ this, this.loadIdealTree ], [ this, this.finishTracker, "loadIdealTree" ], [ this, this.debugTree, "currentTree", "currentTree" ], [ this, this.debugTree, "idealTree", "idealTree" ], [ this.newTracker(log, "generateActionsToTake") ], [ this, this.generateActionsToTake ], [ this, this.finishTracker, "generateActionsToTake" ], [ this, this.debugActions, "diffTrees", "differences" ], [ this, this.debugActions, "decomposeActions", "todo" ], [ this, this.startAudit ]), 
        this.packageLockOnly) postInstallSteps.push([ this, this.saveToDependencies ]); else if (!this.dryrun) {
          installSteps.push([ this.newTracker(log, "executeActions", 8) ], [ this, this.executeActions ], [ this, this.finishTracker, "executeActions" ]);
          var node_modules = path.resolve(this.where, "node_modules"), staging = path.resolve(node_modules, ".staging");
          postInstallSteps.push([ this.newTracker(log, "rollbackFailedOptional", 1) ], [ this, this.rollbackFailedOptional, staging, this.todo ], [ this, this.finishTracker, "rollbackFailedOptional" ], [ this, this.commit, staging, this.todo ], [ this, this.runPostinstallTopLevelLifecycles ], [ this, this.finishTracker, "runTopLevelLifecycles" ]), 
          getSaveType() && postInstallSteps.push([ this, next => {
            computeMetadata(this.idealTree), next();
          } ], [ this, this.pruneIdealTree ], [ this, this.debugLogicalTree, "saveTree", "idealTree" ], [ this, this.saveToDependencies ]);
        }
        postInstallSteps.push([ this, this.printWarnings ], [ this, this.printInstalled ]);
        var self = this;
        return chain(installSteps, (function(installEr) {
          installEr && (self.failing = !0), chain(postInstallSteps, (function(postInstallEr) {
            if (installEr && postInstallEr) {
              var msg = errorMessage(postInstallEr);
              msg.summary.forEach((function(logline) {
                log.warn.apply(log, logline);
              })), msg.detail.forEach((function(logline) {
                log.verbose.apply(log, logline);
              }));
            }
            cb(installEr || postInstallEr, self.getInstalledModules(), self.idealTree);
          }));
        })), result;
      }, Installer.prototype.loadArgMetadata = function(next) {
        getAllMetadata(this.args, this.currentTree, process.cwd(), iferr(next, (args => {
          this.args = args, next();
        })));
      }, Installer.prototype.newTracker = function(tracker, name, size) {
        return validate("OS", [ tracker, name ]), size && validate("N", [ size ]), this.progress[name] = tracker.newGroup(name, size), 
        function(next) {
          process.emit("time", "stage:" + name), next();
        };
      }, Installer.prototype.finishTracker = function(name, cb) {
        validate("SF", arguments), process.emit("timeEnd", "stage:" + name), cb();
      }, Installer.prototype.loadCurrentTree = function(cb) {
        validate("F", arguments), log.silly("install", "loadCurrentTree");
        var todo = [];
        this.global ? todo.push([ this, this.readGlobalPackageData ]) : todo.push([ this, this.readLocalPackageData ]), 
        todo.push([ this, this.normalizeCurrentTree ]), chain(todo, cb);
      };
      var createNode = __webpack_require__(65061).create, flatNameFromTree = __webpack_require__(36140).flatNameFromTree;
      function isLinkable(pkg, cb) {
        var globalPackage = path.resolve(npm.globalPrefix, "lib", "node_modules", moduleName(pkg)), globalPackageJson = path.resolve(globalPackage, "package.json");
        fs.stat(globalPackage, (function(er) {
          if (er) return cb(!0, !0);
          fs.readFile(globalPackageJson, (function(er, data) {
            var json = parseJSON.noExceptions(data);
            cb(!1, json && json.version === pkg.package.version);
          }));
        }));
      }
      Installer.prototype.normalizeCurrentTree = function(cb) {
        if (this.currentTree.isTop = !0, function normalizeTree(tree, seen) {
          seen || (seen = new Set);
          if (seen.has(tree)) return;
          seen.add(tree), createNode(tree), tree.location = flatNameFromTree(tree), tree.children.forEach((child => normalizeTree(child, seen)));
        }(this.currentTree), this.currentTree.error) for (let child of this.currentTree.children) !child.fakeChild && isExtraneous(child) && (this.currentTree.package.dependencies[moduleName(child)] = computeVersionSpec(this.currentTree, child));
        return computeMetadata(this.currentTree), cb();
      }, Installer.prototype.loadIdealTree = function(cb) {
        validate("F", arguments), log.silly("install", "loadIdealTree"), chain([ [ this.newTracker(this.progress.loadIdealTree, "loadIdealTree:cloneCurrentTree") ], [ this, this.cloneCurrentTreeToIdealTree ], [ this, this.finishTracker, "loadIdealTree:cloneCurrentTree" ], [ this.newTracker(this.progress.loadIdealTree, "loadIdealTree:loadShrinkwrap") ], [ this, this.loadShrinkwrap ], [ this, this.finishTracker, "loadIdealTree:loadShrinkwrap" ], [ this.newTracker(this.progress.loadIdealTree, "loadIdealTree:loadAllDepsIntoIdealTree", 10) ], [ this, this.loadAllDepsIntoIdealTree ], [ this, this.finishTracker, "loadIdealTree:loadAllDepsIntoIdealTree" ], [ this, function(next) {
          computeMetadata(this.idealTree), next();
        } ], [ this, this.pruneIdealTree ] ], cb);
      }, Installer.prototype.pruneIdealTree = function(cb) {
        if (!this.idealTree) return cb();
        if (!this.idealTree.hasRequiresFromLock && this.idealTree.children.some((n => n.fakeChild))) return cb();
        const toPrune = this.idealTree.children.filter((child => isExtraneous(child) && (this.autoPrune || child.removing))).map((n => ({
          name: moduleName(n)
        })));
        return removeExtraneous(toPrune, this.idealTree, cb);
      }, Installer.prototype.loadAllDepsIntoIdealTree = function(cb) {
        validate("F", arguments), log.silly("install", "loadAllDepsIntoIdealTree");
        var saveDeps = getSaveType(), cg = this.progress["loadIdealTree:loadAllDepsIntoIdealTree"], installNewModules = !!this.args.length, steps = [];
        if (installNewModules) steps.push([ validateArgs, this.idealTree, this.args ]), 
        steps.push([ loadRequestedDeps, this.args, this.idealTree, saveDeps, cg.newGroup("loadRequestedDeps") ]); else {
          const depsToPreload = Object.assign({}, this.idealTree.package.devDependencies, this.idealTree.package.dependencies);
          steps.push([ prefetchDeps, this.idealTree, depsToPreload, cg.newGroup("prefetchDeps") ], [ loadDeps, this.idealTree, cg.newGroup("loadDeps") ], [ loadDevDeps, this.idealTree, cg.newGroup("loadDevDeps") ]);
        }
        steps.push([ loadExtraneous.andResolveDeps, this.idealTree, cg.newGroup("loadExtraneous") ]), 
        chain(steps, cb);
      }, Installer.prototype.generateActionsToTake = function(cb) {
        validate("F", arguments), log.silly("install", "generateActionsToTake");
        var cg = this.progress.generateActionsToTake;
        chain([ [ validateTree, this.idealTree, cg.newGroup("validateTree") ], [ diffTrees, this.currentTree, this.idealTree, this.differences, cg.newGroup("diffTrees") ], [ this, this.computeLinked ], [ checkPermissions, this.differences ], [ decomposeActions, this.differences, this.todo ] ], cb);
      }, Installer.prototype.computeLinked = function(cb) {
        if (validate("F", arguments), !this.link || this.global) return cb();
        var linkTodoList = [], self = this;
        asyncMap(this.differences, (function(action, next) {
          var cmd = action[0], pkg = action[1];
          if ("add" !== cmd && "update" !== cmd) return next();
          var isReqByTop = pkg.requiredBy.filter((function(mod) {
            return mod.isTop;
          })).length, isReqByUser = pkg.userRequired, isExtraneous = 0 === pkg.requiredBy.length;
          if (!isReqByTop && !isReqByUser && !isExtraneous) return next();
          isLinkable(pkg, (function(install, link) {
            install && linkTodoList.push([ "global-install", pkg ]), link && linkTodoList.push([ "global-link", pkg ]), 
            (install || link) && removeObsoleteDep(pkg), next();
          }));
        }), (function() {
          if (0 === linkTodoList.length) return cb();
          self.differences.length = 0, Array.prototype.push.apply(self.differences, linkTodoList), 
          diffTrees(self.currentTree, self.idealTree, self.differences, log.newGroup("d2"), cb);
        }));
      }, Installer.prototype.executeActions = function(cb) {
        validate("F", arguments), log.silly("install", "executeActions");
        var todo = this.todo, cg = this.progress.executeActions, node_modules = path.resolve(this.where, "node_modules"), staging = path.resolve(node_modules, ".staging"), steps = [], trackLifecycle = cg.newGroup("lifecycle");
        cb = unlockCB(node_modules, ".staging", cb), steps.push([ doSerialActions, "global-install", staging, todo, trackLifecycle.newGroup("global-install") ], [ lock, node_modules, ".staging" ], [ rimraf, staging ], [ doParallelActions, "extract", staging, todo, cg.newGroup("extract", 100) ], [ doReverseSerialActions, "unbuild", staging, todo, cg.newGroup("unbuild") ], [ doSerialActions, "remove", staging, todo, cg.newGroup("remove") ], [ doSerialActions, "move", staging, todo, cg.newGroup("move") ], [ doSerialActions, "finalize", staging, todo, cg.newGroup("finalize") ], [ doParallelActions, "refresh-package-json", staging, todo, cg.newGroup("refresh-package-json") ], [ doParallelActions, "preinstall", staging, todo, trackLifecycle.newGroup("preinstall") ], [ doSerialActions, "build", staging, todo, trackLifecycle.newGroup("build") ], [ doSerialActions, "global-link", staging, todo, trackLifecycle.newGroup("global-link") ], [ doParallelActions, "update-linked", staging, todo, trackLifecycle.newGroup("update-linked") ], [ doSerialActions, "install", staging, todo, trackLifecycle.newGroup("install") ], [ doSerialActions, "postinstall", staging, todo, trackLifecycle.newGroup("postinstall") ]);
        var self = this;
        chain(steps, (function(er) {
          !er || self.rollback ? rimraf(staging, (function() {
            cb(er);
          })) : cb(er);
        }));
      }, Installer.prototype.rollbackFailedOptional = function(staging, actionsToRun, cb) {
        if (!this.rollback) return cb();
        var failed = uniq(actionsToRun.map((function(action) {
          return action[1];
        })).filter((function(pkg) {
          return pkg.failed && pkg.rollback;
        }))), top = this.currentTree && this.currentTree.path;
        Bluebird.map(failed, (pkg => Bluebird.map(pkg.rollback, (rollback => rollback(top, staging, pkg))))).asCallback(cb);
      }, Installer.prototype.commit = function(staging, actionsToRun, cb) {
        var toCommit = actionsToRun.map((function(action) {
          return action[1];
        })).filter((function(pkg) {
          return !pkg.failed && pkg.commit;
        }));
        asyncMap(toCommit, (function(pkg, next) {
          asyncMap(pkg.commit, (function(commit, done) {
            commit(staging, pkg, done);
          }), (function() {
            pkg.commit = [], next.apply(null, arguments);
          }));
        }), cb);
      }, Installer.prototype.runPreinstallTopLevelLifecycles = function(cb) {
        return validate("F", arguments), this.failing ? cb() : this.topLevelLifecycles ? (log.silly("install", "runPreinstallTopLevelLifecycles"), 
        void readPackageJson(path.join(this.where, "package.json"), log, !1, ((err, data) => {
          if (err) return cb();
          this.currentTree = createNode({
            isTop: !0,
            package: data,
            path: this.where
          }), doOneAction("preinstall", this.where, this.currentTree, log.newGroup("preinstall:."), cb);
        }))) : cb();
      }, Installer.prototype.runPostinstallTopLevelLifecycles = function(cb) {
        if (validate("F", arguments), this.failing) return cb();
        if (!this.topLevelLifecycles) return cb();
        log.silly("install", "runPostinstallTopLevelLifecycles");
        var steps = [], trackLifecycle = this.progress.runTopLevelLifecycles;
        steps.push([ doOneAction, "build", this.idealTree.path, this.idealTree, trackLifecycle.newGroup("build:.") ], [ doOneAction, "install", this.idealTree.path, this.idealTree, trackLifecycle.newGroup("install:.") ], [ doOneAction, "postinstall", this.idealTree.path, this.idealTree, trackLifecycle.newGroup("postinstall:.") ]), 
        this.dev && steps.push([ doOneAction, "prepare", this.idealTree.path, this.idealTree, trackLifecycle.newGroup("prepare") ]), 
        chain(steps, cb);
      }, Installer.prototype.startAudit = function(cb) {
        if (!this.audit) return cb();
        this.auditSubmission = Bluebird.try((() => audit.generateFromInstall(this.idealTree, this.differences, this.args, this.remove))).then((auditData => audit.submitForInstallReport(auditData))).catch((_ => {})), 
        cb();
      }, Installer.prototype.saveToDependencies = function(cb) {
        if (validate("F", arguments), this.failing) return cb();
        log.silly("install", "saveToDependencies"), this.saveOnlyLock ? saveShrinkwrap(this.idealTree, cb) : saveRequested(this.idealTree, cb);
      }, Installer.prototype.readGlobalPackageData = function(cb) {
        validate("F", arguments), log.silly("install", "readGlobalPackageData");
        var self = this;
        this.loadArgMetadata(iferr(cb, (function() {
          mkdirp(self.where, iferr(cb, (function() {
            var pkgs = {};
            self.args.forEach((function(pkg) {
              pkgs[pkg.name] = !0;
            })), readPackageTree(self.where, (function(ctx, kid) {
              return ctx.parent || pkgs[kid];
            }), iferr(cb, (function(currentTree) {
              return self.currentTree = currentTree, cb();
            })));
          })));
        })));
      }, Installer.prototype.readLocalPackageData = function(cb) {
        validate("F", arguments), log.silly("install", "readLocalPackageData");
        var self = this;
        mkdirp(this.where, iferr(cb, (function() {
          readPackageTree(self.where, iferr(cb, (function(currentTree) {
            if (self.currentTree = currentTree, self.currentTree.warnings = [], currentTree.error && "EJSONPARSE" === currentTree.error.code) return cb(currentTree.error);
            if (!self.noPackageJsonOk && !currentTree.package) {
              log.error("install", "Couldn't read dependencies");
              var er = new Error("ENOENT, open '" + path.join(self.where, "package.json") + "'");
              return er.code = "ENOPACKAGEJSON", er.errno = 34, cb(er);
            }
            currentTree.package || (currentTree.package = {}), readShrinkwrap(currentTree, (function(err) {
              err ? cb(err) : self.loadArgMetadata(cb);
            }));
          })));
        })));
      }, Installer.prototype.cloneCurrentTreeToIdealTree = function(cb) {
        validate("F", arguments), log.silly("install", "cloneCurrentTreeToIdealTree"), npm.config.get("before") ? this.idealTree = {
          package: this.currentTree.package,
          path: this.currentTree.path,
          realpath: this.currentTree.realpath,
          children: [],
          requires: [],
          missingDeps: {},
          missingDevDeps: {},
          requiredBy: [],
          error: this.currentTree.error,
          warnings: [],
          isTop: !0
        } : (this.idealTree = copyTree(this.currentTree), this.idealTree.warnings = []), 
        cb();
      }, Installer.prototype.loadShrinkwrap = function(cb) {
        validate("F", arguments), log.silly("install", "loadShrinkwrap"), readShrinkwrap.andInflate(this.idealTree, iferr(cb, (() => {
          computeMetadata(this.idealTree), cb();
        })));
      }, Installer.prototype.getInstalledModules = function() {
        return this.differences.filter((function(action) {
          var mutation = action[0];
          return "add" === mutation || "update" === mutation;
        })).map((function(action) {
          var child = action[1];
          return [ child.package._id, child.path ];
        }));
      }, Installer.prototype.printWarnings = function(cb) {
        if (!this.idealTree) return cb();
        var self = this, warned = !1;
        this.idealTree.warnings.forEach((function(warning) {
          if (("EPACKAGEJSON" !== warning.code || !self.global) && "ENOTDIR" !== warning.code) {
            warned = !0;
            var msg = errorMessage(warning);
            msg.summary.forEach((function(logline) {
              log.warn.apply(log, logline);
            })), msg.detail.forEach((function(logline) {
              log.verbose.apply(log, logline);
            }));
          }
        })), warned && log.levels[npm.config.get("loglevel")] <= log.levels.warn && console.error(), 
        cb();
      }, Installer.prototype.printInstalled = function(cb) {
        if (validate("F", arguments), this.failing) return cb();
        log.silly("install", "printInstalled");
        const diffs = this.differences;
        if (!this.idealTree.error && this.idealTree.removedChildren) {
          const deps = this.currentTree.package.dependencies || {}, dev = this.currentTree.package.devDependencies || {};
          this.idealTree.removedChildren.forEach((r => {
            diffs.some((d => "remove" === d[0] && d[1].path === r.path)) || (deps[moduleName(r)] || dev[moduleName(r)]) && diffs.push([ "remove", r ]);
          }));
        }
        return Bluebird.try((() => {
          if (this.auditSubmission) return Bluebird.resolve(this.auditSubmission).timeout(1e4).catch((() => null));
        })).then((auditResult => (auditResult && !auditResult.metadata && log.warn("audit", "Audit result from registry missing metadata. This is probably an issue with the registry."), 
        npm.config.get("json") ? this.printInstalledForJSON(diffs, auditResult) : npm.config.get("parseable") ? this.printInstalledForParseable(diffs, auditResult) : this.printInstalledForHuman(diffs, auditResult)))).asCallback(cb);
      }, Installer.prototype.printInstalledForHuman = function(diffs, auditResult) {
        var removed = 0, added = 0, updated = 0, moved = 0, contributors = new Set;
        diffs.forEach((function(action) {
          var mutation = action[0], pkg = action[1];
          if (!pkg.failed) if ("remove" === mutation) ++removed; else if ("move" === mutation) ++moved; else if ("add" === mutation) {
            ++added;
            var people = [], meta = pkg.package;
            meta.author && people.push(meta.author), meta.contributors && Array.isArray(meta.contributors) && (people = people.concat(meta.contributors)), 
            people.forEach((function(person) {
              try {
                var normalized = function(argument) {
                  if ("string" == typeof argument) return argument;
                  var returned = "";
                  argument.name && (returned += argument.name);
                  argument.email && (returned += " <" + argument.email + ">");
                  argument.url && (returned += " (" + argument.email + ")");
                  return returned;
                }(person);
              } catch (error) {
                return;
              }
              contributors.has(normalized) || contributors.add(normalized);
            }));
          } else "update" !== mutation && "update-linked" !== mutation || ++updated;
        }));
        var report = "";
        this.args.length && (added || updated) && (report += this.args.map((p => `+ ${p.name}@${p.version}${p._requested.name && p._requested.name !== p.name ? ` (as ${p._requested.name})` : ""}`)).join("\n") + "\n");
        var num, actions = [];
        if (added) {
          var action = "added " + packages(added);
          contributors.size && (action += " from " + (num = contributors.size) + " contributor" + (num > 1 ? "s" : "")), 
          actions.push(action);
        }
        if (removed && actions.push("removed " + packages(removed)), updated && actions.push("updated " + packages(updated)), 
        moved && actions.push("moved " + packages(moved)), auditResult && auditResult.metadata && auditResult.metadata.totalDependencies && actions.push("audited " + packages(auditResult.metadata.totalDependencies)), 
        0 === actions.length) report += "up to date"; else if (1 === actions.length) report += actions[0]; else {
          var lastAction = actions.pop();
          report += actions.join(", ") + " and " + lastAction;
        }
        function packages(num) {
          return num + " package" + (num > 1 ? "s" : "");
        }
        report += " in " + (Date.now() - this.started) / 1e3 + "s", output(report);
        const {fund, idealTree} = this, printFundingReport = getPrintFundingReport({
          fund,
          idealTree
        });
        if (printFundingReport.length && output(printFundingReport), auditResult) return audit.printInstallReport(auditResult);
      }, Installer.prototype.printInstalledForJSON = function(diffs, auditResult) {
        const {fund, idealTree} = this;
        var result = {
          added: [],
          removed: [],
          updated: [],
          moved: [],
          failed: [],
          warnings: [],
          audit: auditResult,
          funding: getPrintFundingReportJSON({
            fund,
            idealTree
          }),
          elapsed: Date.now() - this.started
        }, self = this;
        function flattenMessage(msg) {
          return msg.map((function(logline) {
            return logline.slice(1).join(" ");
          })).join("\n");
        }
        this.idealTree.warnings.forEach((function(warning) {
          if (("EPACKAGEJSON" !== warning.code || !self.global) && "ENOTDIR" !== warning.code) {
            var output = errorMessage(warning), message = flattenMessage(output.summary);
            output.detail.length && (message += "\n" + flattenMessage(output.detail)), result.warnings.push(message);
          }
        })), diffs.forEach((function(action) {
          var mutation = action[0], child = action[1], record = function(action) {
            var mutation = action[0], child = action[1];
            const isAlias = child.package && child.package._requested && "alias" === child.package._requested.type, name = isAlias ? child.package._requested.name : child.package && child.package.name;
            var result = {
              action: mutation,
              name,
              version: child.package && `${isAlias ? `npm:${child.package.name}@` : ""}${child.package.version}`,
              path: child.path
            };
            "move" === mutation ? result.previousPath = child.fromPath : "update" === mutation && (result.previousVersion = child.oldPkg.package && child.oldPkg.package.version);
            return result;
          }(action);
          child.failed ? result.failed.push(record) : "add" === mutation ? result.added.push(record) : "update" === mutation || "update-linked" === mutation ? result.updated.push(record) : "move" === mutation ? result.moved.push(record) : "remove" === mutation && result.removed.push(record);
        })), output(JSON.stringify(result, null, 2));
      }, Installer.prototype.printInstalledForParseable = function(diffs) {
        var self = this;
        diffs.forEach((function(action) {
          var mutation = action[0], child = action[1];
          if ("move" === mutation) var previousPath = path.relative(self.where, child.fromPath); else if ("update" === mutation) var previousVersion = child.oldPkg.package && child.oldPkg.package.version;
          const isAlias = child.package._requested && "alias" === child.package._requested.type, version = child.package && isAlias ? `npm:${child.package.name}@${child.package.version}` : child.package ? child.package.version : "";
          output(mutation + "\t" + moduleName(child) + "\t" + version + "\t" + (child.path ? path.relative(self.where, child.path) : "") + "\t" + (previousVersion || "") + "\t" + (previousPath || ""));
        }));
      }, Installer.prototype.debugActions = function(name, actionListName, cb) {
        validate("SSF", arguments);
        var actionsToLog = this[actionListName];
        log.silly(name, "action count", actionsToLog.length), actionsToLog.forEach((function(action) {
          log.silly(name, action.map((function(value) {
            return value && value.package ? packageId(value) : value;
          })).join(" "));
        })), cb();
      }, Installer.prototype.debugTree = function(name, treeName, cb) {
        validate("SSF", arguments), log.silly(name, this.archyDebugTree(this[treeName]).trim()), 
        cb();
      }, Installer.prototype.archyDebugTree = function(tree) {
        validate("O", arguments);
        var seen = new Set;
        function byName(aa, bb) {
          return packageId(aa).localeCompare(packageId(bb));
        }
        function expandTree(tree) {
          return seen.add(tree), {
            label: packageId(tree),
            nodes: tree.children.filter((tree => !seen.has(tree) && !tree.removed)).sort(byName).map(expandTree)
          };
        }
        return archy(expandTree(tree), "", {
          unicode: npm.config.get("unicode")
        });
      }, Installer.prototype.debugLogicalTree = function(name, treeName, cb) {
        validate("SSF", arguments), this[treeName] && log.silly(name, this.archyDebugLogicalTree(this[treeName]).trim()), 
        cb();
      }, Installer.prototype.archyDebugLogicalTree = function(tree) {
        validate("O", arguments);
        var seen = new Set;
        function byName(aa, bb) {
          return packageId(aa).localeCompare(packageId(bb));
        }
        function expandTree(tree) {
          return seen.add(tree), {
            label: packageId(tree),
            nodes: tree.requires.filter((tree => !seen.has(tree) && !tree.removed)).sort(byName).map(expandTree)
          };
        }
        return archy(expandTree(tree), "", {
          unicode: npm.config.get("unicode")
        });
      };
    },
    2101: module => {
      "use strict";
      module.exports = function(dir, er) {
        if (er) {
          var accessEr = new Error("EACCES, access '" + dir + "'", -13);
          return accessEr.code = "EACCES", accessEr.path = dir, accessEr;
        }
      };
    },
    95854: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var chain = __webpack_require__(89009).chain, build = __webpack_require__(34674), npm = __webpack_require__(44874), packageId = __webpack_require__(73531);
      module.exports = function(staging, pkg, log, next) {
        log.silly("build", packageId(pkg)), chain([ [ build.linkStuff, pkg.package, pkg.path, npm.config.get("global") ], [ build.writeBuiltinConf, pkg.package, pkg.path ] ], next);
      };
    },
    19232: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const finished = __webpack_require__(41142).promisify(__webpack_require__(30498).finished), npmConfig = __webpack_require__(23300), packageId = __webpack_require__(73531), pacote = __webpack_require__(96770);
      module.exports = function(staging, pkg, log, next) {
        log.silly("fetch", packageId(pkg));
        const opts = npmConfig({
          integrity: pkg.package._integrity
        });
        return finished(pacote.tarball.stream(pkg.package._requested, opts)).then((() => next()), next);
      };
    },
    35090: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const path = __webpack_require__(71017), fs = __webpack_require__(59799), Bluebird = __webpack_require__(41142), rimraf = Bluebird.promisify(__webpack_require__(68259)), mkdirp = Bluebird.promisify(__webpack_require__(33169).mkdir), lstat = Bluebird.promisify(fs.lstat), readdir = Bluebird.promisify(fs.readdir), symlink = Bluebird.promisify(fs.symlink), gentlyRm = Bluebird.promisify(__webpack_require__(8638)), moduleStagingPath = __webpack_require__(14703), move = __webpack_require__(25315), moveOpts = {
        fs,
        Promise: Bluebird,
        maxConcurrency: 4
      }, getRequested = __webpack_require__(87517), log = __webpack_require__(19334), packageId = __webpack_require__(73531);
      module.exports = function(staging, pkg, log) {
        log.silly("finalize", pkg.realpath);
        const extractedTo = moduleStagingPath(staging, pkg), delpath = path.join(path.dirname(pkg.realpath), "." + path.basename(pkg.realpath) + ".DELETE");
        let movedDestAway = !1;
        if ("directory" === (pkg.package._requested || getRequested(pkg)).type) {
          const relative = path.relative(path.dirname(pkg.path), pkg.realpath);
          return makeParentPath(pkg.path).then((() => symlink(relative, pkg.path, "junction"))).catch((ex => rimraf(pkg.path).then((() => symlink(relative, pkg.path, "junction")))));
        }
        return makeParentPath(pkg.realpath).then((function() {
          return lstat(pkg.realpath).then((() => {
            throw new Error("destination exists");
          }), (() => {})).then(actuallyMoveStaging).catch((() => rimraf(delpath).then((() => move(pkg.realpath, delpath, moveOpts))).then((() => {
            movedDestAway = !0;
          })).then(actuallyMoveStaging)));
        })).then((function() {
          if (!movedDestAway) return;
          return readdir(path.join(delpath, "node_modules")).catch((() => [])).then((modules => {
            if (modules.length) return mkdirp(path.join(pkg.realpath, "node_modules")).then((() => Bluebird.map(modules, (file => {
              const from = path.join(delpath, "node_modules", file), to = path.join(pkg.realpath, "node_modules", file);
              return move(from, to, moveOpts);
            }))));
          }));
        })).catch((err => {
          if (movedDestAway) return rimraf(pkg.realpath).then(moveOldDestinationBack).then((() => {
            throw err;
          }));
          throw err;
        })).then((() => rimraf(delpath)));
        function makeParentPath(dir) {
          return mkdirp(path.dirname(dir));
        }
        function actuallyMoveStaging() {
          return move(extractedTo, pkg.realpath, moveOpts);
        }
        function moveOldDestinationBack() {
          return move(delpath, pkg.realpath, moveOpts).then((() => {
            movedDestAway = !1;
          }));
        }
      }, module.exports.rollback = function(top, staging, pkg) {
        return Bluebird.try((() => {
          const requested = pkg.package._requested || getRequested(pkg);
          return requested && "directory" === requested.type ? Promise.resolve() : gentlyRm(pkg.path, !1, top).catch((err => {
            log.warn("rollback", `Rolling back ${packageId(pkg)} failed (this is probably harmless): ${err.message ? err.message : err}`);
          }));
        }));
      };
    },
    11797: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var path = __webpack_require__(71017), npm = __webpack_require__(44874), Installer = __webpack_require__(70913).Installer, packageId = __webpack_require__(73531), moduleName = __webpack_require__(7802);
      module.exports = function(staging, pkg, log, next) {
        log.silly("global-install", packageId(pkg));
        var globalRoot = path.resolve(npm.globalDir, "..");
        npm.config.set("global", !0);
        var install = new Installer(globalRoot, !1, [ moduleName(pkg) + "@" + pkg.package._requested.rawSpec ]);
        install.link = !1, install.run((function() {
          npm.config.set("global", !1), next.apply(null, arguments);
        }));
      };
    },
    98517: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var moduleName = __webpack_require__(7802), npm = __webpack_require__(44874), packageId = __webpack_require__(73531);
      module.exports = function(staging, pkg, log, next) {
        log.silly("global-link", packageId(pkg)), npm.link(moduleName(pkg), next);
      };
    },
    22366: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var lifecycle = __webpack_require__(4705), packageId = __webpack_require__(73531);
      module.exports = function(staging, pkg, log, next) {
        log.silly("install", packageId(pkg)), lifecycle(pkg.package, "install", pkg.path, next);
      };
    },
    73647: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var fs = __webpack_require__(59799), path = __webpack_require__(71017), chain = __webpack_require__(89009).chain, iferr = __webpack_require__(17367), rimraf = __webpack_require__(68259), mkdirp = __webpack_require__(33169).mkdir, rmStuff = __webpack_require__(24736).rmStuff, lifecycle = __webpack_require__(4705), move = __webpack_require__(57459);
      function removeEmptyParents(pkgdir, next) {
        fs.rmdir(pkgdir, (function(er) {
          if (er && "ENOENT" !== er.code) return next();
          removeEmptyParents(path.resolve(pkgdir, ".."), next);
        }));
      }
      function moveModuleOnly(from, to, log, done) {
        var fromModules = path.join(from, "node_modules"), tempFromModules = from + ".node_modules", toModules = path.join(to, "node_modules"), tempToModules = to + ".node_modules";
        function removeDestination(next) {
          return function(er) {
            log.silly("move", "remove existing destination", to), rimraf(to, iferr(next, makeDestination(er ? next : iferr(next, function(next) {
              return function() {
                log.silly("move", "move existing destination node_modules back", toModules), move(tempToModules, toModules).then(next, done);
              };
            }(next)))));
          };
        }
        function makeDestination(next) {
          return function() {
            log.silly("move", "make sure destination parent exists", path.resolve(to, "..")), 
            mkdirp(path.resolve(to, ".."), iferr(done, function(next) {
              return function() {
                log.silly("move", "move source node_modules away", fromModules), move(fromModules, tempFromModules).then(doMove(function(next) {
                  return function() {
                    mkdirp(from, iferr(done, (function() {
                      log.silly("move", "put source node_modules back", fromModules), move(tempFromModules, fromModules).then(next, done);
                    })));
                  };
                }(next)), doMove(next));
              };
            }(next)));
          };
        }
        function doMove(next) {
          return function() {
            log.silly("move", "move module dir to final dest", from, to), move(from, to).then(next, done);
          };
        }
        log.silly("move", "move existing destination node_modules away", toModules), move(toModules, tempToModules).then(removeDestination(done), removeDestination(done));
      }
      module.exports = function(staging, pkg, log, next) {
        log.silly("move", pkg.fromPath, pkg.path), chain([ [ lifecycle, pkg.package, "preuninstall", pkg.fromPath, {
          failOk: !0
        } ], [ lifecycle, pkg.package, "uninstall", pkg.fromPath, {
          failOk: !0
        } ], [ rmStuff, pkg.package, pkg.fromPath ], [ lifecycle, pkg.package, "postuninstall", pkg.fromPath, {
          failOk: !0
        } ], [ moveModuleOnly, pkg.fromPath, pkg.path, log ], [ lifecycle, pkg.package, "preinstall", pkg.path, {
          failOk: !0
        } ], [ removeEmptyParents, path.resolve(pkg.fromPath, "..") ] ], next);
      };
    },
    87969: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var lifecycle = __webpack_require__(4705), packageId = __webpack_require__(73531);
      module.exports = function(staging, pkg, log, next) {
        log.silly("postinstall", packageId(pkg)), lifecycle(pkg.package, "postinstall", pkg.path, next);
      };
    },
    18673: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var lifecycle = __webpack_require__(4705), packageId = __webpack_require__(73531);
      module.exports = function(staging, pkg, log, next) {
        log.silly("preinstall", packageId(pkg)), lifecycle(pkg.package, "preinstall", pkg.path, next);
      };
    },
    27892: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var chain = __webpack_require__(89009).chain, lifecycle = __webpack_require__(4705), packageId = __webpack_require__(73531), prepublishWarning = __webpack_require__(81158)("prepublish-on-install"), moduleStagingPath = __webpack_require__(14703);
      module.exports = function(staging, pkg, log, next) {
        log.silly("prepublish", packageId(pkg)), pkg.package && pkg.package.scripts && pkg.package.scripts.prepublish && prepublishWarning([ "As of npm@5, `prepublish` scripts are deprecated.", "Use `prepare` for build steps and `prepublishOnly` for upload-only.", "See the deprecation note in `npm help scripts` for more information." ]);
        var buildpath = moduleStagingPath(staging, pkg);
        chain([ [ lifecycle, pkg.package, "prepublish", buildpath ], [ lifecycle, pkg.package, "prepare", buildpath ] ], next);
      };
    },
    51519: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const Bluebird = __webpack_require__(41142), checkPlatform = Bluebird.promisify(__webpack_require__(27809).checkPlatform), getRequested = __webpack_require__(87517), npm = __webpack_require__(44874), path = __webpack_require__(71017), readJson = Bluebird.promisify(__webpack_require__(92200)), updatePackageJson = Bluebird.promisify(__webpack_require__(12155));
      module.exports = function(staging, pkg, log) {
        return log.silly("refresh-package-json", pkg.realpath), readJson(path.join(pkg.path, "package.json"), !1).then((metadata => {
          Object.keys(pkg.package).forEach((function(key) {
            var value;
            "version" !== key && "dependencies" !== key && (null != (value = pkg.package[key]) && (Array.isArray(value) ? value.length : "object" != typeof value || Object.keys(value).length)) && (metadata[key] = pkg.package[key]);
          })), null == metadata._resolved && pkg.fakeChild && (metadata._resolved = pkg.fakeChild.resolved), 
          delete metadata.readme, delete metadata.readmeFilename, pkg.package = metadata, 
          pkg.fakeChild = !1;
        })).catch((() => "ignore")).then((() => checkPlatform(pkg.package, npm.config.get("force")))).then((() => {
          if ("directory" !== (pkg.package._requested || getRequested(pkg)).type) return updatePackageJson(pkg, pkg.path);
        }));
      };
    },
    32689: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var path = __webpack_require__(71017), fs = __webpack_require__(59799), rimraf = __webpack_require__(68259), asyncMap = __webpack_require__(89009).asyncMap, mkdirp = __webpack_require__(33169).mkdir, npm = __webpack_require__(44874), andIgnoreErrors = __webpack_require__(77448), move = __webpack_require__(57459), isInside = __webpack_require__(13468), vacuum = __webpack_require__(8127);
      module.exports = function(staging, pkg, log, next) {
        log.silly("remove", pkg.path), pkg.target ? function(pkg, next) {
          var base = isInside(pkg.path, npm.prefix) ? npm.prefix : pkg.path;
          rimraf(pkg.path, (err => {
            if (err) return next(err);
            vacuum(pkg.path, {
              base
            }, next);
          }));
        }(pkg, next) : function(pkg, log, next) {
          var modpath = path.join(path.dirname(pkg.path), "." + path.basename(pkg.path) + ".MODULES");
          function unbuildPackage(moveEr) {
            rimraf(pkg.path, moveEr ? andRemoveEmptyParents(pkg.path) : moveModulesBack);
          }
          function andRemoveEmptyParents(path) {
            return function(er) {
              if (er) return next(er);
              removeEmptyParents(pkg.path);
            };
          }
          function moveModulesBack() {
            fs.readdir(modpath, makeTarget);
          }
          function makeTarget(readdirEr, files) {
            return readdirEr ? cleanup() : files.length ? void mkdirp(path.join(pkg.path, "node_modules"), (function(mkdirEr) {
              moveModules(mkdirEr, files);
            })) : cleanup();
          }
          function moveModules(mkdirEr, files) {
            if (mkdirEr) return next(mkdirEr);
            asyncMap(files, (function(file, done) {
              var from = path.join(modpath, file), to = path.join(pkg.path, "node_modules", file);
              move(from, to).then(andIgnoreErrors(done), andIgnoreErrors(done));
            }), cleanup);
          }
          function cleanup() {
            rimraf(modpath, afterCleanup);
          }
          function afterCleanup(rimrafEr) {
            rimrafEr && log.warn("remove", rimrafEr), removeEmptyParents(path.resolve(pkg.path, ".."));
          }
          function removeEmptyParents(pkgdir) {
            fs.rmdir(pkgdir, (function(er) {
              if (er && "ENOENT" !== er.code) return next();
              removeEmptyParents(path.resolve(pkgdir, ".."));
            }));
          }
          move(path.join(pkg.path, "node_modules"), modpath).then(unbuildPackage, unbuildPackage);
        }(pkg, log, next);
      };
    },
    54139: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var Bluebird = __webpack_require__(41142), lifecycle = Bluebird.promisify(__webpack_require__(4705)), packageId = __webpack_require__(73531), rmStuff = Bluebird.promisify(__webpack_require__(24736).rmStuff);
      module.exports = function(staging, pkg, log) {
        return log.silly("unbuild", packageId(pkg)), lifecycle(pkg.package, "preuninstall", pkg.path, {
          failOk: !0
        }).then((() => lifecycle(pkg.package, "uninstall", pkg.path, {
          failOk: !0
        }))).then((() => rmStuff(pkg.package, pkg.path))).then((() => lifecycle(pkg.package, "postuninstall", pkg.path, {
          failOk: !0
        })));
      };
    },
    80631: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      const BB = __webpack_require__(41142), andAddParentToErrors = __webpack_require__(42719), failedDependency = __webpack_require__(48045).failedDependency, isInstallable = BB.promisify(__webpack_require__(11674).isInstallable), moduleName = __webpack_require__(7802), npm = __webpack_require__(44874), reportOptionalFailure = __webpack_require__(6843), validate = __webpack_require__(95073), actions = {};
      function runAction(action, staging, pkg, log) {
        return BB.fromNode((cb => {
          const result = action(staging, pkg, log, cb);
          result && result.then && result.then((() => cb()), cb);
        }));
      }
      function markAsFailed(pkg) {
        pkg.failed || (pkg.failed = !0, pkg.requires.forEach((req => {
          0 !== req.requiredBy.filter((reqReqBy => !reqReqBy.failed)).length || req.userRequired || markAsFailed(req);
        })));
      }
      function runSerial(type, staging, actionsToRun, log, next) {
        const acts = actionsToRun.reduce(((acc, todo) => (todo[0] === type && acc.push(prepareAction(todo, staging, log)), 
        acc)), []);
        return time(log), acts.length ? withInit(actions[type], (() => BB.each(acts, execAction))).nodeify((err => {
          log.finish(), timeEnd(log), next(err);
        })) : next();
      }
      function time(log) {
        process.emit("time", "action:" + log.name);
      }
      function timeEnd(log) {
        process.emit("timeEnd", "action:" + log.name);
      }
      function withInit(action, body) {
        return BB.using(action.init().disposer((() => action.teardown())), body);
      }
      function prepareAction(action, staging, log) {
        validate("ASO", arguments), validate("SO", action);
        var cmd = action[0], pkg = action[1];
        if (!actions[cmd]) throw new Error('Unknown decomposed command "' + cmd + '" (is it new?)');
        return [ actions[cmd], staging, pkg, log.newGroup(cmd + ":" + moduleName(pkg)) ];
      }
      function execAction(todo) {
        return todo[0].apply(null, todo.slice(1));
      }
      actions.fetch = __webpack_require__(19232), actions.extract = __webpack_require__(10398), 
      actions.build = __webpack_require__(95854), actions.preinstall = __webpack_require__(18673), 
      actions.install = __webpack_require__(22366), actions.postinstall = __webpack_require__(87969), 
      actions.prepare = __webpack_require__(27892), actions.finalize = __webpack_require__(35090), 
      actions.remove = __webpack_require__(32689), actions.unbuild = __webpack_require__(54139), 
      actions.move = __webpack_require__(73647), actions["global-install"] = __webpack_require__(11797), 
      actions["global-link"] = __webpack_require__(98517), actions["refresh-package-json"] = __webpack_require__(51519), 
      Object.keys(actions).forEach((function(actionName) {
        var action = actions[actionName];
        actions[actionName] = (staging, pkg, log) => {
          if (validate("SOO", [ staging, pkg, log ]), pkg.failed) return BB.resolve();
          let actionP;
          return action.rollback && (pkg.rollback || (pkg.rollback = []), pkg.rollback.unshift(action.rollback)), 
          action.commit && (pkg.commit || (pkg.commit = []), pkg.commit.push(action.commit)), 
          actionP = pkg.knownInstallable ? runAction(action, staging, pkg, log) : isInstallable(null, pkg.package).then((() => (pkg.knownInstallable = !0, 
          runAction(action, staging, pkg, log)))), actionP.then((() => {
            log.finish();
          }), (err => BB.fromNode((cb => {
            andAddParentToErrors(pkg.parent, cb)(err);
          })).catch((err => function(pkg, err) {
            if (markAsFailed(pkg), failedDependency(pkg)) throw err;
            reportOptionalFailure(pkg, null, err);
          }(pkg, err)))));
        }, actions[actionName].init = action.init || (() => BB.resolve()), actions[actionName].teardown = action.teardown || (() => BB.resolve());
      })), exports.actions = actions, exports.doOne = function(cmd, staging, pkg, log, next) {
        validate("SSOOF", arguments);
        const prepped = prepareAction([ cmd, pkg ], staging, log);
        return withInit(actions[cmd], (() => execAction(prepped))).nodeify(next);
      }, exports.doParallel = function(type, staging, actionsToRun, log, next) {
        validate("SSAOF", arguments);
        const acts = actionsToRun.reduce(((acc, todo) => (todo[0] === type && acc.push(prepareAction(todo, staging, log)), 
        acc)), []);
        if (log.silly("doParallel", type + " " + acts.length), time(log), !acts.length) return next();
        return withInit(actions[type], (() => BB.map(acts, execAction, {
          concurrency: npm.limit.action
        }))).nodeify((err => {
          log.finish(), timeEnd(log), next(err);
        }));
      }, exports.doSerial = function(type, staging, actionsToRun, log, next) {
        validate("SSAOF", arguments), log.silly("doSerial", "%s %d", type, actionsToRun.length), 
        runSerial(type, staging, actionsToRun, log, next);
      }, exports.doReverseSerial = function(type, staging, actionsToRun, log, next) {
        validate("SSAOF", arguments), log.silly("doReverseSerial", "%s %d", type, actionsToRun.length), 
        runSerial(type, staging, [].concat(actionsToRun).reverse(), log, next);
      };
    },
    42719: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var moduleName = __webpack_require__(7802), validate = __webpack_require__(95073);
      module.exports = function(parent, cb) {
        return validate("F", [ cb ]), function(er) {
          if (!er) return cb.apply(null, arguments);
          er instanceof Error && parent && parent.package && parent.package.name && (er.parent = moduleName(parent)), 
          cb(er);
        };
      };
    },
    79266: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var validate = __webpack_require__(95073);
      module.exports = function(tracker, cb) {
        return validate("OF", [ tracker, cb ]), function() {
          tracker.finish(), cb.apply(null, arguments);
        };
      }, module.exports.now = function(tracker, cb) {
        validate("OF", [ tracker, cb ]), tracker.finish(), cb.apply(null, Array.prototype.slice.call(arguments, 2));
      };
    },
    77448: module => {
      "use strict";
      module.exports = function(cb) {
        return function() {
          var args = Array.prototype.slice.call(arguments, 1);
          return args.length && args.unshift(null), cb.apply(null, args);
        };
      };
    },
    64795: (module, exports, __webpack_require__) => {
      "use strict";
      exports.generate = generate, exports.generateFromInstall = function(tree, diffs, install, remove) {
        const requires = {};
        tree.requires.forEach((pkg => {
          requires[pkg.package.name] = tree.package.dependencies[pkg.package.name] || tree.package.devDependencies[pkg.package.name] || pkg.package.version;
        }));
        const auditInstall = (install || []).filter((a => a.name)).map(packageId), auditRemove = (remove || []).filter((a => a.name)).map(packageId), auditDiffs = {};
        return diffs.forEach((action => {
          const mutation = action[0], child = action[1];
          "add" !== mutation && "update" !== mutation && "remove" !== mutation || (auditDiffs[mutation] || (auditDiffs[mutation] = []), 
          "add" === mutation ? auditDiffs[mutation].push({
            location: child.location
          }) : "update" === mutation ? auditDiffs[mutation].push({
            location: child.location,
            previous: packageId(child.oldPkg)
          }) : "remove" === mutation && auditDiffs[mutation].push({
            previous: packageId(child)
          }));
        })), generate(treeToShrinkwrap(tree), requires, auditDiffs, auditInstall, auditRemove);
      }, exports.submitForInstallReport = function(auditData) {
        const opts = InstallAuditConfig(npmConfig());
        return [ ...opts.keys() ].filter((k => /:registry$/.test(k))).map((k => opts[k])).forEach((registry => {
          regFetch("/-/npm/v1/security/audits/quick", opts.concat({
            method: "POST",
            registry,
            gzip: !0,
            body: auditData
          })).then((_ => {
            _.body.on("error", (() => {})), _.body.destroy ? _.body.destroy() : _.body.resume();
          }), (_ => {}));
        })), perf.emit("time", "audit submit"), regFetch("/-/npm/v1/security/audits/quick", opts.concat({
          method: "POST",
          gzip: !0,
          body: auditData
        })).then((response => (perf.emit("timeEnd", "audit submit"), perf.emit("time", "audit body"), 
        response.json()))).then((result => (perf.emit("timeEnd", "audit body"), result)));
      }, exports.submitForFullReport = function(auditData) {
        perf.emit("time", "audit submit");
        const opts = InstallAuditConfig(npmConfig());
        return regFetch("/-/npm/v1/security/audits", opts.concat({
          method: "POST",
          gzip: !0,
          body: auditData
        })).then((response => (perf.emit("timeEnd", "audit submit"), perf.emit("time", "audit body"), 
        response.json()))).then((result => (perf.emit("timeEnd", "audit body"), result.runId = runId, 
        result)));
      }, exports.printInstallReport = function(auditResult) {
        const opts = InstallAuditConfig(npmConfig());
        return auditReport(auditResult, {
          reporter: "install",
          withColor: opts.color,
          withUnicode: opts.unicode
        }).then((result => output(result.report)));
      }, exports.printParseableReport = function(auditResult) {
        const opts = InstallAuditConfig(npmConfig());
        return auditReport(auditResult, {
          log: output,
          reporter: "parseable",
          withColor: opts.color,
          withUnicode: opts.unicode
        }).then((result => output(result.report)));
      }, exports.printFullReport = function(auditResult) {
        const opts = InstallAuditConfig(npmConfig());
        return auditReport(auditResult, {
          log: output,
          reporter: opts.json ? "json" : "detail",
          withColor: opts.color,
          withUnicode: opts.unicode
        }).then((result => output(result.report)));
      };
      const auditReport = __webpack_require__(82156), npmConfig = __webpack_require__(23300), figgyPudding = __webpack_require__(55212), treeToShrinkwrap = __webpack_require__(5446).treeToShrinkwrap, packageId = __webpack_require__(73531), output = __webpack_require__(1015), npm = __webpack_require__(44874), qw = __webpack_require__(63191), regFetch = __webpack_require__(11527), perf = __webpack_require__(87050), npa = __webpack_require__(19932), uuid = __webpack_require__(66054), ssri = __webpack_require__(87783), cloneDeep = __webpack_require__(1259), runId = uuid.v4(), InstallAuditConfig = figgyPudding({
        color: {},
        json: {},
        unicode: {}
      }, {
        other: key => /:registry$/.test(key)
      });
      function generate(shrinkwrap, requires, diffs, install, remove) {
        const sw = cloneDeep(shrinkwrap);
        return delete sw.lockfileVersion, sw.requires = scrubRequires(requires), scrubDeps(sw.dependencies), 
        sw.install = (install || []).map(scrubArg), sw.remove = (remove || []).map(scrubArg), 
        function() {
          const meta = {};
          return meta.npm_version = npm.version, meta.node_version = process.version, meta.platform = process.platform, 
          meta.node_env = process.env.NODE_ENV, Promise.resolve(meta);
        }().then((md => (sw.metadata = md, sw)));
      }
      const scrubKeys = qw`version`, deleteKeys = qw`from resolved`;
      function scrubDeps(deps) {
        deps && (Object.keys(deps).forEach((name => {
          if (!shouldScrubName(name) && !shouldScrubSpec(name, deps[name].version)) return;
          const value = deps[name];
          delete deps[name], deps[scrub(name)] = value;
        })), Object.keys(deps).forEach((name => {
          for (let toScrub of scrubKeys) deps[name][toScrub] && (deps[name][toScrub] = scrubSpec(name, deps[name][toScrub]));
          for (let toDelete of deleteKeys) delete deps[name][toDelete];
          scrubRequires(deps[name].requires), scrubDeps(deps[name].dependencies);
        })));
      }
      function scrubRequires(reqs) {
        return reqs ? (Object.keys(reqs).forEach((name => {
          const spec = reqs[name];
          shouldScrubName(name) || shouldScrubSpec(name, spec) ? (delete reqs[name], reqs[scrub(name)] = scrubSpec(name, spec)) : reqs[name] = scrubSpec(name, spec);
        })), reqs) : reqs;
      }
      function shouldScrubName(name) {
        const scope = function(name) {
          if ("@" === name[0]) return name.slice(0, name.indexOf("/"));
        }(name), cfg = npm.config;
        return Boolean(scope && cfg.get(scope + ":registry"));
      }
      function shouldScrubSpec(name, spec) {
        return !npa.resolve(name, spec).registry;
      }
      function scrubArg(arg) {
        const req = npa(arg);
        let name = req.name;
        (shouldScrubName(name) || shouldScrubSpec(name, req.rawSpec)) && (name = function(name) {
          return shouldScrubName(name) ? scrub(name) : name;
        }(name));
        return name + "@" + scrubSpec(req.name, req.rawSpec);
      }
      function scrubSpec(name, spec) {
        const req = npa.resolve(name, spec);
        return req.registry ? spec : "git" === req.type ? "git+ssh://" + scrub(spec) : "remote" === req.type ? "https://" + scrub(spec) : "directory" === req.type ? "file:" + scrub(spec) : "file" === req.type ? "file:" + scrub(spec) + ".tar" : scrub(spec);
      }
      function scrub(value, rid) {
        return ssri.fromData((rid || runId) + " " + value, {
          algorithms: [ "sha256" ]
        }).hexDigest();
      }
      module.exports.scrub = scrub;
    },
    129: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var path = __webpack_require__(71017), log = __webpack_require__(19334), validate = __webpack_require__(95073), uniq = __webpack_require__(67900), asyncMap = __webpack_require__(89009).asyncMap, npm = __webpack_require__(44874), exists = __webpack_require__(10833), writable = __webpack_require__(13047);
      function andHasWriteAccess(dir, errors, done) {
        return validate("SAF", arguments), function() {
          hasWriteAccess(dir, errors, done);
        };
      }
      function hasAnyWriteAccess(dir, errors, done) {
        function findNearestDir() {
          var nextDir = path.resolve(dir, "..");
          exists(dir, (function(dirDoesntExist) {
            if (!dirDoesntExist || nextDir === dir) return hasWriteAccess(dir, errors, done);
            dir = nextDir, findNearestDir();
          }));
        }
        validate("SAF", arguments), findNearestDir();
      }
      function hasWriteAccess(dir, errors, done) {
        validate("SAF", arguments), writable(dir, (function(er) {
          er && errors.push(er), done();
        }));
      }
      module.exports = function(actions, next) {
        validate("AF", arguments);
        var errors = [];
        asyncMap(actions, (function(action, done) {
          var cmd = action[0], pkg = action[1];
          switch (cmd) {
           case "add":
            hasAnyWriteAccess(path.resolve(pkg.path, ".."), errors, done);
            break;

           case "update":
           case "remove":
            hasWriteAccess(pkg.path, errors, andHasWriteAccess(path.resolve(pkg.path, ".."), errors, done));
            break;

           case "move":
            hasAnyWriteAccess(pkg.path, errors, andHasWriteAccess(path.resolve(pkg.fromPath, ".."), errors, done));
            break;

           default:
            done();
          }
        }), (function() {
          if (!errors.length) return next();
          uniq(errors.map((function(er) {
            return "Missing write access to " + er.path;
          }))).forEach((function(er) {
            log.warn("checkPermissions", er);
          })), npm.config.get("force") ? next() : next(errors[0]);
        }));
      };
    },
    9528: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var createNode = __webpack_require__(65061).create;
      function copyTree(tree, cache) {
        if (cache[tree.path]) return cache[tree.path];
        var newTree = cache[tree.path] = createNode(Object.assign({}, tree));
        return copyModuleList(newTree, "children", cache), newTree.children.forEach((function(child) {
          child.parent = newTree;
        })), copyModuleList(newTree, "requires", cache), copyModuleList(newTree, "requiredBy", cache), 
        newTree;
      }
      function copyModuleList(tree, key, cache) {
        var newList = [];
        tree[key] && tree[key].forEach((function(child) {
          const copy = copyTree(child, cache);
          copy && newList.push(copy);
        })), tree[key] = newList;
      }
      module.exports = function(tree) {
        return copyTree(tree, {});
      };
    },
    67485: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var validate = __webpack_require__(95073), npm = __webpack_require__(44874);
      function addAction(decomposed, action, pkg) {
        decomposed.some((_ => _[0] === action && _[1] === pkg)) || decomposed.push([ action, pkg ]);
      }
      function addSteps(decomposed, pkg) {
        pkg.fromBundle && (addAction(decomposed, "fetch", pkg.fromBundle), addAction(decomposed, "extract", pkg.fromBundle)), 
        pkg.fromBundle || pkg.isLink || (addAction(decomposed, "fetch", pkg), addAction(decomposed, "extract", pkg)), 
        pkg.fromBundle && !npm.config.get("rebuild-bundle") || (addAction(decomposed, "preinstall", pkg), 
        addAction(decomposed, "build", pkg), addAction(decomposed, "install", pkg), addAction(decomposed, "postinstall", pkg)), 
        pkg.fromBundle && pkg.isLink || addAction(decomposed, "finalize", pkg), addAction(decomposed, "refresh-package-json", pkg);
      }
      function updateSteps(decomposed, pkg) {
        removeSteps(decomposed, pkg.oldPkg), addSteps(decomposed, pkg);
      }
      function removeSteps(decomposed, pkg) {
        addAction(decomposed, "unbuild", pkg), addAction(decomposed, "remove", pkg);
      }
      function moveSteps(decomposed, pkg) {
        addAction(decomposed, "move", pkg), addAction(decomposed, "build", pkg), addAction(decomposed, "install", pkg), 
        addAction(decomposed, "postinstall", pkg), addAction(decomposed, "refresh-package-json", pkg);
      }
      function defaultSteps(decomposed, cmd, pkg) {
        addAction(decomposed, cmd, pkg);
      }
      module.exports = function(differences, decomposed, next) {
        validate("AAF", arguments), differences.forEach((action => {
          var cmd = action[0], pkg = action[1];
          switch (cmd) {
           case "add":
            addSteps(decomposed, pkg);
            break;

           case "update":
            updateSteps(decomposed, pkg);
            break;

           case "move":
            moveSteps(decomposed, pkg);
            break;

           case "remove":
            removeSteps(decomposed, pkg);
            break;

           default:
            defaultSteps(decomposed, cmd, pkg);
          }
        })), next();
      };
    },
    48045: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      const BB = __webpack_require__(41142);
      var fs = __webpack_require__(57147), assert = __webpack_require__(39491), path = __webpack_require__(71017), semver = __webpack_require__(73107), asyncMap = __webpack_require__(89009).asyncMap, chain = __webpack_require__(89009).chain, iferr = __webpack_require__(17367), npa = __webpack_require__(19932), validate = __webpack_require__(95073), dezalgo = __webpack_require__(21248), fetchPackageMetadata = __webpack_require__(3138), andAddParentToErrors = __webpack_require__(42719), addBundled = __webpack_require__(3138).addBundled, readShrinkwrap = __webpack_require__(34160), inflateShrinkwrap = __webpack_require__(13802), inflateBundled = __webpack_require__(80074), andFinishTracker = __webpack_require__(79266), npm = __webpack_require__(44874), flatNameFromTree = __webpack_require__(36140).flatNameFromTree, createChild = __webpack_require__(65061).create, resetMetadata = __webpack_require__(65061).reset, isInstallable = __webpack_require__(11674).isInstallable, packageId = __webpack_require__(73531), moduleName = __webpack_require__(7802), isDevDep = __webpack_require__(69504), isProdDep = __webpack_require__(12727), reportOptionalFailure = __webpack_require__(6843), getSaveType = __webpack_require__(29705).getSaveType, unixFormatPath = __webpack_require__(65665), isExtraneous = __webpack_require__(66305), isRegistry = __webpack_require__(80127), hasModernMeta = __webpack_require__(20278), registryTypes = {
        range: !0,
        version: !0
      };
      function doesChildVersionMatch(child, requested, requestor) {
        if (child.fromShrinkwrap && !child.hasRequiresFromLock) return !0;
        if ("range" === requested.type && "*" === requested.fetchSpec) return !0;
        if ("directory" === requested.type) return !!child.isLink && "" === path.relative(child.realpath, requested.fetchSpec);
        if ("git" === requested.type && child.fromShrinkwrap) {
          const fromSw = child.package._from ? npa(child.package._from) : child.fromShrinkwrap;
          if (fromSw.name = requested.name, fromSw.toString() === requested.toString()) return !0;
        }
        if ("git" === requested.type && requested.gitRange) {
          const sameRepo = npa(child.package._from).fetchSpec === requested.fetchSpec;
          try {
            return sameRepo && semver.satisfies(child.package.version, requested.gitRange, !0);
          } catch (e) {
            return !1;
          }
        }
        if ("alias" === requested.type) return doesChildVersionMatch(child, requested.subSpec, requestor);
        if (!registryTypes[requested.type]) {
          var childReq = child.package._requested;
          if (childReq) {
            if (childReq.rawSpec === requested.rawSpec) return !0;
            if (childReq.type === requested.type) {
              if (childReq.saveSpec === requested.saveSpec) return !0;
              if (childReq.fetchSpec === requested.fetchSpec && "git" !== requested.type) return !0;
            }
          }
          if (child.package._from) {
            var fromReq = npa(child.package._from);
            if (fromReq.rawSpec === requested.rawSpec) return !0;
            if (fromReq.type === requested.type && fromReq.saveSpec && fromReq.saveSpec === requested.saveSpec) return !0;
          }
          return !1;
        }
        try {
          return semver.satisfies(child.package.version, requested.fetchSpec, !0);
        } catch (e) {
          return !1;
        }
      }
      function childDependencySpecifier(tree, name, spec, where) {
        return npa.resolve(name, spec, where || packageRelativePath(tree));
      }
      function addRequiredDep(tree, child) {
        var dep = function(tree, child) {
          var matches, name = moduleName(child), prodVer = isProdDep(tree, name), devVer = isDevDep(tree, name);
          try {
            var prodSpec = childDependencySpecifier(tree, name, prodVer);
          } catch (err) {
            return {
              isDep: !0,
              isProdDep: !1,
              isDevDep: !1
            };
          }
          if (prodSpec && (matches = doesChildVersionMatch(child, prodSpec, tree)), matches) return {
            isDep: !0,
            isProdDep: prodSpec,
            isDevDep: !1
          };
          if (devVer === prodVer) return {
            isDep: child.fromShrinkwrap,
            isProdDep: !1,
            isDevDep: !1
          };
          try {
            var devSpec = childDependencySpecifier(tree, name, devVer);
            return {
              isDep: doesChildVersionMatch(child, devSpec, tree) || child.fromShrinkwrap,
              isProdDep: !1,
              isDevDep: devSpec
            };
          } catch (err) {
            return {
              isDep: child.fromShrinkwrap,
              isProdDep: !1,
              isDevDep: !1
            };
          }
        }(tree, child);
        return !!dep.isDep && (replaceModuleByPath(child, "requiredBy", tree), replaceModuleByName(tree, "requires", child), 
        dep.isProdDep && tree.missingDeps && delete tree.missingDeps[moduleName(child)], 
        dep.isDevDep && tree.missingDevDeps && delete tree.missingDevDeps[moduleName(child)], 
        !0);
      }
      function removeObsoleteDep(child, log) {
        child.removed || (child.removed = !0, log && log.silly("removeObsoleteDep", "removing " + packageId(child) + " from the tree as its been replaced by a newer version or is no longer required"), 
        child.parent && (child.parent.children = child.parent.children.filter((function(pchild) {
          return pchild !== child;
        }))), (child.requires || []).forEach((function(requirement) {
          requirement.requiredBy = requirement.requiredBy.filter((function(reqBy) {
            return reqBy !== child;
          })), isExtraneous(requirement) && removeObsoleteDep(requirement, log);
        })));
      }
      function packageRelativePath(tree) {
        if (!tree) return "";
        var requested = tree.package._requested || {};
        return "directory" === requested.type ? requested.fetchSpec : "file" === requested.type ? path.dirname(requested.fetchSpec) : !tree.isLink && !tree.isInLink || preserveSymlinks() ? tree.path : tree.realpath;
      }
      function isNotEmpty(value) {
        return null != value && "" !== value;
      }
      function computeVersionSpec(tree, child) {
        var requested;
        validate("OO", arguments);
        var childReq = child.package._requested;
        if (requested = child.isLink ? npa.resolve(moduleName(child), "file:" + child.realpath, getTop(tree).path) : childReq && (isNotEmpty(childReq.saveSpec) || isNotEmpty(childReq.rawSpec) && isNotEmpty(childReq.fetchSpec)) ? child.package._requested : child.package._from ? npa(child.package._from, tree.path) : child.name && child.name !== child.package.name ? npa.resolve(child.name, `npm:${child.package.name}@${child.package.version})`) : npa.resolve(child.package.name, child.package.version), 
        isRegistry(requested)) {
          var version = child.package.version, rangeDescriptor = "";
          return semver.valid(version, !0) && semver.gte(version, "0.1.0", !0) && !npm.config.get("save-exact") && (rangeDescriptor = npm.config.get("save-prefix")), 
          "alias" === requested.type && (rangeDescriptor = `npm:${requested.subSpec.name}@${rangeDescriptor}`), 
          rangeDescriptor + version;
        }
        return "directory" === requested.type || "file" === requested.type ? "file:" + unixFormatPath(path.relative(getTop(tree).path, requested.fetchSpec)) : requested.saveSpec || requested.rawSpec;
      }
      function moduleNameMatches(name) {
        return function(child) {
          return moduleName(child) === name;
        };
      }
      function flagAsRemoving(toRemove, seen) {
        seen || (seen = new Set), seen.has(toRemove) || (seen.add(toRemove), toRemove.removing = !0, 
        toRemove.requires.forEach((required => {
          flagAsRemoving(required, seen);
        })));
      }
      function andForEachChild(load, next) {
        return validate("F", [ next ]), next = dezalgo(next), function(er, children, logs) {
          if (!(er || children && 0 !== children.length)) return next();
          if (validate("EAA", arguments), er) return next(er);
          assert(children.length === logs.length);
          for (var cmds = [], ii = 0; ii < children.length; ++ii) cmds.push([ load, children[ii], logs[ii] ]);
          var sortedCmds = cmds.sort((function(aa, bb) {
            return moduleName(aa[1]).localeCompare(moduleName(bb[1]));
          }));
          chain(sortedCmds, next);
        };
      }
      function failedDependency(tree, name, pkg) {
        if (name && function(tree, name, pkg) {
          if (pkg.package && pkg.package._optional) return !0;
          const optDeps = tree.package.optionalDependencies;
          if (optDeps && null != optDeps[name]) return !0;
          const devDeps = tree.package.devDependencies;
          if (devDeps && null != devDeps[name]) return !(npm.config.get("dev") || !/^prod(uction)?$/.test(npm.config.get("only")) && !npm.config.get("production") || /^dev(elopment)?$/.test(npm.config.get("only")) || /^dev(elopment)?$/.test(npm.config.get("also")));
          const prodDeps = tree.package.dependencies;
          if (prodDeps && null != prodDeps[name]) return !!/^dev(elopment)?$/.test(npm.config.get("only"));
          return !1;
        }(tree, name, pkg || {})) return !1;
        if (tree.failed = !0, tree.isTop) return !0;
        if (tree.userRequired) return !0;
        if (!tree.requiredBy) return !1;
        let anyFailed = !1;
        for (var ii = 0; ii < tree.requiredBy.length; ++ii) {
          failedDependency(tree.requiredBy[ii], moduleName(tree), tree) && (anyFailed = !0);
        }
        return anyFailed;
      }
      function andHandleOptionalErrors(log, tree, name, done) {
        return validate("OOSF", arguments), function(er, child, childLog) {
          if (er || validate("OO", [ child, childLog ]), !er) return done(er, child, childLog);
          var isFatal = failedDependency(tree, name);
          return er && !isFatal ? (reportOptionalFailure(tree, name, er), done()) : done(er, child, childLog);
        };
      }
      function loadDeps(tree, log, next) {
        if (validate("OOF", arguments), tree.loaded || tree.parent && tree.parent.failed || tree.removed) return andFinishTracker.now(log, next);
        tree.parent && (tree.loaded = !0), tree.package.dependencies || (tree.package.dependencies = {}), 
        asyncMap(Object.keys(tree.package.dependencies), (function(dep, done) {
          addDependency(dep, tree.package.dependencies[dep], tree, log.newGroup("loadDep:" + dep), andHandleOptionalErrors(log, tree, dep, done));
        }), andForEachChild(loadDeps, andFinishTracker(log, next)));
      }
      exports.computeMetadata = function computeMetadata(tree, seen) {
        seen || (seen = new Set);
        if (!tree || seen.has(tree)) return;
        seen.add(tree), null == tree.parent && (resetMetadata(tree), tree.isTop = !0);
        function findChild(name, spec, kind) {
          try {
            var req = childDependencySpecifier(tree, name, spec);
          } catch (err) {
            return;
          }
          var child = findRequirement(tree, req.name, req);
          if (child) return resolveWithExistingModule(child, tree), !0;
        }
        tree.location = flatNameFromTree(tree);
        const deps = tree.package.dependencies || {}, reqs = tree.swRequires || {};
        for (let name of Object.keys(deps)) findChild(name, deps[name]) || name in reqs && findChild(name, reqs[name]) || (tree.missingDeps[name] = deps[name]);
        if (tree.isTop) {
          const devDeps = tree.package.devDependencies || {};
          for (let name of Object.keys(devDeps)) findChild(name, devDeps[name]) || (tree.missingDevDeps[name] = devDeps[name]);
        }
        return tree.children.filter((child => !child.removed)).forEach((child => computeMetadata(child, seen))), 
        tree;
      }, exports.removeObsoleteDep = removeObsoleteDep, exports.packageRelativePath = packageRelativePath, 
      exports.getAllMetadata = function(args, tree, where, next) {
        asyncMap(args, (function(arg, done) {
          let spec;
          try {
            spec = npa(arg);
          } catch (e) {
            return done(e);
          }
          return "file" === spec.type || "directory" === spec.type || null != spec.name && "" !== spec.rawSpec ? fetchPackageMetadata(spec, where, done) : fs.stat(path.join(arg, "package.json"), (err => {
            if (err) {
              var version = function(tree, name) {
                if (tree && tree.package) return tree.package.dependencies && tree.package.dependencies[name] ? tree.package.dependencies[name] : tree.package.devDependencies && tree.package.devDependencies[name] ? tree.package.devDependencies[name] : void 0;
              }(tree, spec.name);
              if (!version) return fetchPackageMetadata(spec, where, done);
              try {
                return fetchPackageMetadata(npa.resolve(spec.name, version), where, done);
              } catch (e) {
                return done(e);
              }
            } else try {
              return fetchPackageMetadata(npa("file:" + arg), where, done);
            } catch (e) {
              return done(e);
            }
          }));
        }), next);
      }, exports.loadRequestedDeps = function(args, tree, saveToDependencies, log, next) {
        validate("AOOF", [ args, tree, log, next ]), asyncMap(args, (function(pkg, done) {
          var depLoaded = andAddParentToErrors(tree, done);
          resolveWithNewModule(pkg, tree, log.newGroup("loadRequestedDeps"), iferr(depLoaded, (function(child, tracker) {
            validate("OO", arguments), npm.config.get("global") && (child.isGlobal = !0);
            var childName = moduleName(child);
            child.saveSpec = computeVersionSpec(tree, child), child.userRequired = !0, child.save = getSaveType(tree, child);
            const types = [ "dependencies", "devDependencies", "optionalDependencies" ];
            if (child.save) {
              tree.package[child.save][childName] = child.saveSpec;
              for (let saveType of types) child.save !== saveType && delete tree.package[saveType][childName];
              "optionalDependencies" === child.save && (tree.package.dependencies[childName] = child.saveSpec);
            }
            var childIsDep = addRequiredDep(tree, child);
            childIsDep || (child.userRequired = !0), depLoaded(null, child, tracker);
          })));
        }), andForEachChild(loadDeps, andFinishTracker(log, next)));
      }, exports.computeVersionSpec = computeVersionSpec, exports.removeDeps = function(args, tree, saveToDependencies, next) {
        validate("AOSF|AOZF", [ args, tree, saveToDependencies, next ]);
        for (let pkg of args) {
          var pkgName = moduleName(pkg), pkgToRemove = tree.children.filter(moduleNameMatches(pkgName))[0] || createChild({
            name: pkgName
          }), saveType = getSaveType(tree, pkg) || "dependencies";
          tree.isTop && saveToDependencies && (pkgToRemove.save = saveType), tree.package[saveType][pkgName] && (delete tree.package[saveType][pkgName], 
          "optionalDependencies" === saveType && tree.package.dependencies[pkgName] && delete tree.package.dependencies[pkgName]), 
          replaceModuleByPath(tree, "removedChildren", pkgToRemove);
          for (let parent of pkgToRemove.requiredBy) parent.requires = parent.requires.filter((child => child !== pkgToRemove));
          pkgToRemove.requiredBy = pkgToRemove.requiredBy.filter((parent => parent !== tree)), 
          flagAsRemoving(pkgToRemove);
        }
        next();
      }, exports.removeExtraneous = function(args, tree, next) {
        for (let pkg of args) {
          var pkgName = moduleName(pkg), toRemove = tree.children.filter(moduleNameMatches(pkgName));
          toRemove.length && removeObsoleteDep(toRemove[0]);
        }
        next();
      }, exports.failedDependency = failedDependency, exports.prefetchDeps = function(tree, deps, log, next) {
        validate("OOOF", arguments);
        var skipOptional = !npm.config.get("optional"), seen = new Set;
        const finished = andFinishTracker(log, next), fpm = BB.promisify(fetchPackageMetadata);
        function resolveBranchDeps(pkg, deps) {
          return BB.resolve(null).then((() => {
            var allDependencies = Object.keys(deps).map((dep => npa.resolve(dep, deps[dep]))).filter((dep => isRegistry(dep) && !seen.has(dep.toString()) && !findRequirement(tree, dep.name, dep)));
            if (skipOptional) {
              var optDeps = pkg.optionalDependencies || {};
              allDependencies = allDependencies.filter((dep => !optDeps[dep.name]));
            }
            return BB.map(allDependencies, (dep => (seen.add(dep.toString()), fpm(dep, "", {
              tracker: log.newItem("fetchMetadata")
            }).then((pkg => pkg && pkg.dependencies && resolveBranchDeps(pkg, pkg.dependencies)), (() => null)))));
          }));
        }
        resolveBranchDeps(tree.package, deps).then((() => finished()), finished);
      }, exports.loadDeps = loadDeps, exports.loadDevDeps = function(tree, log, next) {
        if (validate("OOF", arguments), !tree.package.devDependencies) return andFinishTracker.now(log, next);
        asyncMap(Object.keys(tree.package.devDependencies), (function(dep, done) {
          if (tree.package.dependencies[dep]) return done();
          var logGroup = log.newGroup("loadDevDep:" + dep);
          addDependency(dep, tree.package.devDependencies[dep], tree, logGroup, andHandleOptionalErrors(log, tree, dep, done));
        }), andForEachChild(loadDeps, andFinishTracker(log, next)));
      };
      var loadExtraneous = exports.loadExtraneous = function(tree, log, next) {
        var seen = new Set;
        !function loadExtraneous(tree) {
          if (!seen.has(tree)) for (var child of (seen.add(tree), tree.children)) child.loaded || (resolveWithExistingModule(child, tree), 
          loadExtraneous(child));
        }(tree), log.finish(), next();
      };
      function addDependency(name, versionSpec, tree, log, done) {
        validate("SSOOF", arguments);
        var next = andAddParentToErrors(tree, done);
        try {
          var req = childDependencySpecifier(tree, name, versionSpec);
          if (tree.swRequires && tree.swRequires[name]) var swReq = childDependencySpecifier(tree, name, tree.swRequires[name]);
        } catch (err) {
          return done(err);
        }
        var child = findRequirement(tree, name, req);
        !child && swReq && (child = findRequirement(tree, name, swReq)), hasModernMeta(child) ? (resolveWithExistingModule(child, tree), 
        void 0 === child.package._shrinkwrap ? readShrinkwrap.andInflate(child, (function(er) {
          next(er, child, log);
        })) : next(null, child, log)) : (child && (req.registry && (req = childDependencySpecifier(tree, name, child.package.version)), 
        child.fromBundle && reportBundleOverride(child, log), removeObsoleteDep(child, log)), 
        fetchPackageMetadata(req, packageRelativePath(tree), {
          tracker: log.newItem("fetchMetadata")
        }, iferr(next, (function(pkg) {
          resolveWithNewModule(pkg, tree, log, next);
        }))));
      }
      function getTop(pkg) {
        const seen = new Set;
        for (;pkg.parent && !seen.has(pkg.parent); ) pkg = pkg.parent, seen.add(pkg);
        return pkg;
      }
      function reportBundleOverride(child, log) {
        const code = "EBUNDLEOVERRIDE", top = getTop(child.fromBundle), bundlerId = packageId(child.fromBundle);
        if (!top.warnings.some((w => w.code === code))) {
          const err = new Error(`${bundlerId} had bundled packages that do not match the required version(s). They have been replaced with non-bundled versions.`);
          err.code = code, top.warnings.push(err);
        }
        log && log.verbose("bundle", `${code}: Replacing ${bundlerId}'s bundled version of ${moduleName(child)} with ${packageId(child)}.`);
      }
      function resolveWithExistingModule(child, tree) {
        validate("OO", arguments), addRequiredDep(tree, child), tree.parent && child.parent !== tree && updatePhantomChildren(tree.parent, child);
      }
      exports.loadExtraneous.andResolveDeps = function(tree, log, next) {
        if (validate("OOF", arguments), tree.loaded) return loadExtraneous(tree, log, next);
        asyncMap(tree.children.filter((function(child) {
          return !child.loaded;
        })), (function(child, done) {
          resolveWithExistingModule(child, tree), done(null, child, log);
        }), andForEachChild(loadDeps, andFinishTracker(log, next)));
      };
      var updatePhantomChildren = exports.updatePhantomChildren = function(current, child) {
        for (validate("OO", arguments); current && current !== child.parent; ) current.phantomChildren || (current.phantomChildren = {}), 
        current.phantomChildren[moduleName(child)] = child, current = current.parent;
      };
      function replaceModuleByPath(obj, key, child) {
        return replaceModule(obj, key, child, (function(replacing, child) {
          return replacing.path === child.path;
        }));
      }
      function replaceModuleByName(obj, key, child) {
        var childName = moduleName(child);
        return replaceModule(obj, key, child, (function(replacing, child) {
          return moduleName(replacing) === childName;
        }));
      }
      function replaceModule(obj, key, child, matchBy) {
        validate("OSOF", arguments), obj[key] || (obj[key] = []);
        for (var children = [].concat(obj[key]), replaceAt = 0; replaceAt < children.length && !matchBy(children[replaceAt], child); ++replaceAt) ;
        var replacing = children.splice(replaceAt, 1, child);
        return obj[key] = children, replacing[0];
      }
      function resolveWithNewModule(pkg, tree, log, next) {
        return validate("OOOF", arguments), log.silly("resolveWithNewModule", packageId(pkg), "checking installable status"), 
        isInstallable(tree, pkg, (err => {
          let installable = !err;
          addBundled(pkg, (bundleErr => {
            var parent = earliestInstallable(tree, tree, pkg, log) || tree, isLink = "directory" === pkg._requested.type, name = pkg._requested.name || pkg.name, child = createChild({
              name,
              package: pkg,
              parent,
              path: path.join(parent.isLink ? parent.realpath : parent.path, "node_modules", name),
              realpath: isLink ? pkg._requested.fetchSpec : path.join(parent.realpath, "node_modules", name),
              children: pkg._bundled || [],
              isLink,
              isInLink: parent.isLink,
              knownInstallable: installable
            });
            installable && !bundleErr || (child.failed = !0), delete pkg._bundled;
            var hasBundled = child.children.length, replaced = replaceModuleByName(parent, "children", child);
            if (replaced && (replaced.fromBundle && reportBundleOverride(replaced, log), removeObsoleteDep(replaced)), 
            addRequiredDep(tree, child), child.location = flatNameFromTree(child), tree.parent && parent !== tree && updatePhantomChildren(tree.parent, child), 
            hasBundled && inflateBundled(child, child, child.children), pkg._shrinkwrap && pkg._shrinkwrap.dependencies) return inflateShrinkwrap(child, pkg._shrinkwrap, (swErr => {
              swErr && (child.failed = !0), next(err || bundleErr || swErr, child, log);
            }));
            next(err || bundleErr, child, log);
          }));
        }));
      }
      exports._replaceModuleByPath = replaceModuleByPath, exports._replaceModuleByName = replaceModuleByName;
      var isOptionalPeerDep = exports.isOptionalPeerDep = function(tree, pkgname) {
        if (tree.package.peerDependenciesMeta && tree.package.peerDependenciesMeta[pkgname]) return !!tree.package.peerDependenciesMeta[pkgname].optional;
      }, validatePeerDeps = exports.validatePeerDeps = function(tree, onInvalid) {
        tree.package.peerDependencies && Object.keys(tree.package.peerDependencies).forEach((function(pkgname) {
          var version = tree.package.peerDependencies[pkgname];
          try {
            var spec = npa.resolve(pkgname, version);
          } catch (e) {}
          spec && findRequirement(tree.parent || tree, pkgname, spec) || isOptionalPeerDep(tree, pkgname) || onInvalid(tree, pkgname, version);
        }));
      };
      function validateAllPeerDeps(tree, onInvalid, seen) {
        validate("OFO", arguments), seen.has(tree) || (seen.add(tree), validatePeerDeps(tree, onInvalid), 
        tree.children.forEach((function(child) {
          validateAllPeerDeps(child, onInvalid, seen);
        })));
      }
      exports.validateAllPeerDeps = function(tree, onInvalid) {
        validateAllPeerDeps(tree, onInvalid, new Set);
      };
      var findRequirement = exports.findRequirement = function(tree, name, requested, requestor) {
        validate("OSO", [ tree, name, requested ]), requestor || (requestor = tree);
        var nameMatch = function(child) {
          return moduleName(child) === name && child.parent && !child.removed;
        }, versionMatch = function(child) {
          return doesChildVersionMatch(child, requested, requestor);
        };
        if (nameMatch(tree)) return versionMatch(tree) ? tree : null;
        var matches = tree.children.filter(nameMatch);
        return matches.length ? (matches = matches.filter(versionMatch)).length ? matches[0] : null : tree.isTop || !preserveSymlinks() && /^[.][.][\\/]/.test(path.relative(tree.parent.realpath, tree.realpath)) ? null : findRequirement(tree.parent, name, requested, requestor);
      };
      function preserveSymlinks() {
        if (!("NODE_PRESERVE_SYMLINKS" in process.env)) return !1;
        const value = process.env.NODE_PRESERVE_SYMLINKS;
        return null != value && "" !== value && "false" !== value && "no" !== value && "0" !== value;
      }
      var earliestInstallable = exports.earliestInstallable = function(requiredBy, tree, pkg, log) {
        function undeletedModuleMatches(child) {
          return !child.removed && moduleName(child) === (pkg._requested && pkg._requested.name || pkg.name);
        }
        validate("OOOO", arguments);
        const undeletedMatches = tree.children.filter(undeletedModuleMatches);
        if (undeletedMatches.length) {
          if (tree !== requiredBy) return null;
          undeletedMatches.forEach((pkg => {
            pkg.fromBundle && reportBundleOverride(pkg, log), removeObsoleteDep(pkg, log);
          }));
        }
        var binaryMatches = pkg.bin && tree.children.some((function(child) {
          return !(child.removed || !child.package.bin) && Object.keys(child.package.bin).some((function(bin) {
            return pkg.bin[bin];
          }));
        }));
        if (binaryMatches) return null;
        var deps = tree.package.dependencies || {};
        if (!tree.removed && requiredBy !== tree && deps[pkg.name]) return null;
        var devDeps = tree.package.devDependencies || {};
        if (tree.isTop && devDeps[pkg.name]) {
          var requested = childDependencySpecifier(tree, pkg.name, devDeps[pkg.name]);
          if (!doesChildVersionMatch({
            package: pkg
          }, requested, tree)) return null;
        }
        return tree.phantomChildren && tree.phantomChildren[pkg.name] ? null : tree.isTop || tree.isGlobal || npm.config.get("global-style") && tree.parent.isTop || npm.config.get("legacy-bundling") || !preserveSymlinks() && /^[.][.][\\/]/.test(path.relative(tree.parent.realpath, tree.realpath)) ? tree : earliestInstallable(requiredBy, tree.parent, pkg, log) || tree;
      };
    },
    30855: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var npm = __webpack_require__(44874), validate = __webpack_require__(95073), npa = __webpack_require__(19932), flattenTree = __webpack_require__(36140), isOnlyDev = __webpack_require__(35528), log = __webpack_require__(19334), path = __webpack_require__(71017), ssri = __webpack_require__(87783), moduleName = __webpack_require__(7802), isOnlyOptional = __webpack_require__(27849);
      function pkgRequested(pkg) {
        return pkg._requested || pkg._resolved && npa(pkg._resolved) || pkg._from && npa(pkg._from);
      }
      function nonRegistrySource(requested) {
        return !!fromGit(requested) || (!!function(requested) {
          return "file" === requested.type || "directory" === requested.type || "local" === requested.type;
        }(requested) || !!function(requested) {
          if ("remote" === requested.type) return !0;
        }(requested));
      }
      function fromGit(requested) {
        return "hosted" === requested.type || "git" === requested.type;
      }
      function pkgIntegrity(pkg) {
        try {
          var sri = pkg.dist && pkg.dist.integrity || pkg._integrity || pkg._shasum && ssri.fromHex(pkg._shasum, "sha1").toString();
          if (!sri) return;
          var integrity = ssri.parse(sri);
          if (0 === Object.keys(integrity).length) return;
          return integrity;
        } catch (ex) {}
      }
      function pkgAreEquiv(aa, bb) {
        if (aa.isInLink !== bb.isInLink) return !1;
        if (aa.package === bb.package) return !0;
        var aaIntegrity = pkgIntegrity(aa.package), bbIntegrity = pkgIntegrity(bb.package);
        if (aaIntegrity || bbIntegrity) return function(aa, bb) {
          if (!aa || !bb) return !1;
          for (let algo of Object.keys(aa)) if (bb[algo]) for (let aaHash of aa[algo]) for (let bbHash of bb[algo]) return aaHash.digest === bbHash.digest;
          return !1;
        }(aaIntegrity, bbIntegrity);
        if (aa.isLink && bb.isLink) return aa.realpath === bb.realpath;
        var aaReq = pkgRequested(aa.package), bbReq = pkgRequested(bb.package);
        return !(!aaReq || !bbReq) && (fromGit(aaReq) && fromGit(bbReq) ? aa.package._resolved && bb.package._resolved && aa.package._resolved === bb.package._resolved : !nonRegistrySource(aaReq) && !nonRegistrySource(bbReq) && aa.package.version === bb.package.version);
      }
      function pushAll(aa, bb) {
        Array.prototype.push.apply(aa, bb);
      }
      function isNotTopOrExtraneous(node) {
        return !node.isTop && !node.userRequired && !node.existing;
      }
      module.exports = function(oldTree, newTree, differences, log, next) {
        validate("OOAOF", arguments), pushAll(differences, sortActions(diffTrees(oldTree, newTree))), 
        log.finish(), next();
      };
      var sortActions = module.exports.sortActions = function(differences) {
        var actions = {};
        differences.forEach((function(action) {
          var child = action[1];
          actions[child.location] = action;
        }));
        var sorted = [], added = {}, sortedlocs = Object.keys(actions).sort(sortByLocation);
        function sortByLocation(aa, bb) {
          return bb.localeCompare(aa);
        }
        function sortModuleByLocation(aa, bb) {
          return sortByLocation(aa && aa.location, bb && bb.location);
        }
        function sortByDeps(action) {
          var mod = action[1];
          added[mod.location] || (added[mod.location] = action, mod.requiredBy || (mod.requiredBy = []), 
          mod.requiredBy.sort(sortModuleByLocation).forEach((function(mod) {
            actions[mod.location] && sortByDeps(actions[mod.location]);
          })), sorted.unshift(action));
        }
        return sortedlocs.filter((function(location) {
          var mod = actions[location][1];
          return !mod.requiredBy || !mod.requiredBy.some(isNotTopOrExtraneous);
        })).concat(sortedlocs).forEach((function(location) {
          sortByDeps(actions[location]);
        })), differences.forEach((_ => {
          -1 === sorted.indexOf(_) && sorted.push(_);
        })), sorted;
      };
      function setAction(differences, action, pkg) {
        differences.push([ action, pkg ]);
      }
      var diffTrees = module.exports._diffTrees = function(oldTree, newTree) {
        validate("OO", arguments);
        var differences = [], flatOldTree = flattenTree(oldTree), flatNewTree = flattenTree(newTree), toRemove = {}, toRemoveByName = {};
        return Object.keys(flatOldTree).forEach((function(flatname) {
          if ("/" !== flatname && !flatNewTree[flatname]) {
            var pkg = flatOldTree[flatname];
            if (!pkg.isInLink || !/^[.][.][/\\]/.test(path.relative(newTree.realpath, pkg.realpath))) {
              toRemove[flatname] = pkg;
              var name = moduleName(pkg);
              toRemoveByName[name] || (toRemoveByName[name] = []), toRemoveByName[name].push({
                flatname,
                pkg
              });
            }
          }
        })), Object.keys(flatNewTree).forEach((function(flatname) {
          if ("/" !== flatname) {
            var pkg = flatNewTree[flatname], oldPkg = pkg.oldPkg = flatOldTree[flatname];
            if (oldPkg) {
              if (!pkg.userRequired && pkgAreEquiv(oldPkg, pkg)) return;
              setAction(differences, "update", pkg);
            } else {
              var name = moduleName(pkg), removing = (toRemoveByName[name] || []).filter((rm => pkgAreEquiv(rm.pkg, pkg))), bundlesOrFromBundle = pkg.fromBundle || pkg.package.bundleDependencies;
              if (removing.length && !bundlesOrFromBundle) {
                var toMv = removing.shift();
                toRemoveByName[name] = toRemoveByName[name].filter((rm => rm !== toMv)), pkg.fromPath = toMv.pkg.path, 
                setAction(differences, "move", pkg), delete toRemove[toMv.flatname];
              } else pkg.isInLink && pkg.fromBundle && pkg.fromBundle.isLink || setAction(differences, "add", pkg);
            }
          }
        })), Object.keys(toRemove).map((flatname => toRemove[flatname])).forEach((pkg => setAction(differences, "remove", pkg))), 
        filterActions(differences);
      };
      function filterActions(differences) {
        const includeOpt = npm.config.get("optional"), includeDev = npm.config.get("dev") || !/^prod(uction)?$/.test(npm.config.get("only")) && !npm.config.get("production") || /^dev(elopment)?$/.test(npm.config.get("only")) || /^dev(elopment)?$/.test(npm.config.get("also")), includeProd = !/^dev(elopment)?$/.test(npm.config.get("only"));
        return includeProd && includeDev && includeOpt ? differences : (log.silly("diff-trees", "filtering actions:", "includeDev", includeDev, "includeProd", includeProd, "includeOpt", includeOpt), 
        differences.filter((diff => {
          const pkg = diff[1], pkgIsOnlyDev = isOnlyDev(pkg), pkgIsOnlyOpt = isOnlyOptional(pkg);
          return !(includeProd || !pkgIsOnlyDev) || (!(!includeDev || !pkgIsOnlyDev) || !(!includeProd || pkgIsOnlyDev || !includeOpt && pkgIsOnlyOpt));
        })));
      }
    },
    10833: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var fs = __webpack_require__(57147), inflight = __webpack_require__(59956), accessError = __webpack_require__(2101), isFsAccessAvailable = __webpack_require__(37339);
      function fsAccessImplementation(dir, done) {
        (done = inflight("exists:" + dir, done)) && fs.access(dir, fs.F_OK, done);
      }
      function fsStatImplementation(dir, done) {
        (done = inflight("exists:" + dir, done)) && fs.stat(dir, (function(er) {
          done(accessError(dir, er));
        }));
      }
      module.exports = isFsAccessAvailable ? fsAccessImplementation : fsStatImplementation, 
      module.exports.fsAccessImplementation = fsAccessImplementation, module.exports.fsStatImplementation = fsStatImplementation;
    },
    36140: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var validate = __webpack_require__(95073), moduleName = __webpack_require__(7802);
      function flatName(path, child) {
        return validate("SO", arguments), path + (moduleName(child) || "TOP");
      }
      module.exports = function(tree) {
        validate("O", arguments);
        var seen = new Set, flat = {}, todo = [ [ tree, "/" ] ];
        for (;todo.length; ) {
          var next = todo.shift(), pkg = next[0];
          seen.add(pkg);
          var path = next[1];
          flat[path] = pkg, "/" !== path && (path += "/");
          for (var ii = 0; ii < pkg.children.length; ++ii) {
            var child = pkg.children[ii];
            seen.has(child) || todo.push([ child, flatName(path, child) ]);
          }
        }
        return flat;
      }, module.exports.flatName = flatName, module.exports.flatNameFromTree = function flatNameFromTree(tree) {
        if (validate("O", arguments), tree.isTop) return "/";
        var path = flatNameFromTree(tree.parent);
        "/" !== path && (path += "/");
        return flatName(path, tree);
      };
    },
    12992: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      const {EOL} = __webpack_require__(22037), computeMetadata = __webpack_require__(48045).computeMetadata, mutateIntoLogicalTree = __webpack_require__(60867);
      var {getFundingInfo} = __webpack_require__(41539);
      function getPrintFundingReport({fund, idealTree}, opts) {
        const fundResult = function({fund, idealTree}) {
          if (fund) {
            const fundingInfoTree = mutateIntoLogicalTree.asReadInstalled(computeMetadata(idealTree));
            return getFundingInfo(fundingInfoTree, {
              countOnly: !0
            });
          }
          return {};
        }({
          fund,
          idealTree
        }), {length} = fundResult || {}, {json} = opts || {};
        function padding(msg) {
          return json ? "" : EOL + msg;
        }
        return length ? padding("") + length + " " + ("package" + (length > 1 ? "s are" : " is") + " looking for funding") + padding("  run `npm fund` for details\n") : "";
      }
      exports.getPrintFundingReport = getPrintFundingReport, exports.getPrintFundingReportJSON = function({fund, idealTree}) {
        return getPrintFundingReport({
          fund,
          idealTree
        }, {
          json: !0
        });
      };
    },
    87517: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const npa = __webpack_require__(19932), moduleName = __webpack_require__(7802), packageRelativePath = __webpack_require__(48045).packageRelativePath;
      module.exports = function(child, reqBy) {
        if (!child.requiredBy.length) return;
        reqBy || (reqBy = child.requiredBy[0]);
        const deps = reqBy.package.dependencies || {}, devDeps = reqBy.package.devDependencies || {}, optDeps = reqBy.package.optionalDependencies || {}, name = moduleName(child), spec = deps[name] || devDeps[name] || optDeps[name], where = packageRelativePath(reqBy);
        return npa.resolve(name, spec, where);
      };
    },
    20278: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = function(child) {
        if (!child) return !1;
        const resolved = child.package._resolved && npa.resolve(moduleName(child), child.package._resolved), version = npa.resolve(moduleName(child), child.package.version);
        return child.isTop || isLink(child) || child.fromBundle || child.package._inBundle || child.package._integrity || child.package._shasum || resolved && "git" === resolved.type || version && "git" === version.type;
      };
      const npa = __webpack_require__(19932), moduleName = __webpack_require__(7802);
      function isLink(child) {
        return child.isLink || child.parent && isLink(child.parent);
      }
    },
    80074: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var childPath = __webpack_require__(37013), reset = __webpack_require__(65061).reset;
      module.exports = function inflateBundled(bundler, parent, children) {
        children.forEach((function(child) {
          child.fromBundle !== bundler && (reset(child), child.fromBundle = bundler, child.isInLink = bundler.isLink, 
          child.parent = parent, child.path = childPath(parent.path, child), child.realpath = bundler.isLink ? child.realpath : childPath(parent.realpath, child), 
          child.isLink = child.isLink || parent.isLink || parent.target, inflateBundled(bundler, child, child.children));
        }));
      };
    },
    13802: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const BB = __webpack_require__(41142);
      let addBundled;
      const childPath = __webpack_require__(37013), createChild = __webpack_require__(65061).create;
      let fetchPackageMetadata;
      const inflateBundled = __webpack_require__(80074), moduleName = __webpack_require__(7802), normalizePackageData = __webpack_require__(17770), npm = __webpack_require__(44874), realizeShrinkwrapSpecifier = __webpack_require__(46900), validate = __webpack_require__(95073), path = __webpack_require__(71017), isRegistry = __webpack_require__(80127), hasModernMeta = __webpack_require__(20278), ssri = __webpack_require__(87783), npa = __webpack_require__(19932);
      function inflateShrinkwrap(topPath, tree, swdeps, opts) {
        if (!swdeps) return Promise.resolve();
        opts || (opts = {});
        const onDisk = {};
        return tree.children.forEach((child => {
          onDisk[moduleName(child)] = child;
        })), tree.children = [], BB.each(Object.keys(swdeps), (name => {
          const sw = swdeps[name], dependencies = sw.dependencies || {}, requested = realizeShrinkwrapSpecifier(name, sw, topPath);
          if (0 === Object.keys(sw).length) {
            let message = `Object for dependency "${name}" is empty.\n`;
            return message += 'Something went wrong. Regenerate the package-lock.json with "npm install".\n', 
            message += 'If using a shrinkwrap, regenerate with "npm shrinkwrap".', Promise.reject(new Error(message));
          }
          return function(onDiskChild, name, topPath, tree, sw, requested, opts) {
            validate("OSSOOOO|ZSSOOOO", arguments);
            const usesIntegrity = requested.registry || "remote" === requested.type || "file" === requested.type, regTarball = tarballToVersion(name, sw.version);
            regTarball && (sw.resolved = sw.version, sw.version = regTarball);
            sw.requires && Object.keys(sw.requires).forEach((name => {
              const spec = sw.requires[name];
              sw.requires[name] = tarballToVersion(name, spec) || relativizeLink(name, spec, topPath, requested) || spec;
            }));
            const modernLink = "directory" === requested.type && !sw.from;
            return hasModernMeta(onDiskChild) && childIsEquivalent(sw, requested, onDiskChild) ? (onDiskChild.fromShrinkwrap || (onDiskChild.fromShrinkwrap = requested), 
            onDiskChild.package._requested = requested, onDiskChild.package._spec = requested.rawSpec, 
            onDiskChild.package._where = topPath, onDiskChild.package._optional = sw.optional, 
            onDiskChild.package._development = sw.dev, onDiskChild.package._inBundle = sw.bundled, 
            onDiskChild.fromBundle = sw.bundled || onDiskChild.package._inBundle ? tree.fromBundle || tree : null, 
            onDiskChild.package._args || (onDiskChild.package._args = []), onDiskChild.package._args.push([ String(requested), topPath ]), 
            normalizePackageDataNoErrors(onDiskChild.package), onDiskChild.swRequires = sw.requires, 
            tree.children.push(onDiskChild), BB.resolve(onDiskChild)) : sw.version && (sw.integrity || !usesIntegrity) && ("directory" !== requested.type || modernLink) || sw.bundled ? BB.resolve(makeFakeChild(name, topPath, tree, sw, requested)) : fetchChild(topPath, tree, sw, requested);
          }(onDisk[name], name, topPath, tree, sw, requested, opts).then((child => (child.hasRequiresFromLock = tree.hasRequiresFromLock, 
          inflateShrinkwrap(topPath, child, dependencies))));
        }));
      }
      function normalizePackageDataNoErrors(pkg) {
        try {
          normalizePackageData(pkg);
        } catch (ex) {}
      }
      function quotemeta(str) {
        return str.replace(/([^A-Za-z_0-9/])/g, "\\$1");
      }
      function tarballToVersion(name, tb) {
        const registry = quotemeta(npm.config.get("registry") || "").replace(/https?:/, "https?:").replace(/([^/])$/, "$1/");
        let matchRegTarball;
        if (name) {
          const nameMatch = quotemeta(name);
          matchRegTarball = new RegExp(`^${registry}${nameMatch}/-/${nameMatch}-(.*)[.]tgz$`);
        } else matchRegTarball = new RegExp(`^${registry}(.*)?/-/\\1-(.*)[.]tgz$`);
        const match = tb.match(matchRegTarball);
        if (match) return match[2] || match[1];
      }
      function relativizeLink(name, spec, topPath, requested) {
        if (!spec.startsWith("file:")) return;
        let requestedPath = requested.fetchSpec;
        "file" === requested.type && (requestedPath = path.dirname(requestedPath));
        return "file:" + path.relative(requestedPath, path.resolve(topPath, spec.slice(5)));
      }
      function isGit(sw) {
        const version = npa.resolve(sw.name, sw.version);
        return version && "git" === version.type;
      }
      function makeFakeChild(name, topPath, tree, sw, requested) {
        const isDirectory = "directory" === requested.type, from = sw.from || requested.raw, pkg = {
          name,
          version: sw.version,
          _id: name + "@" + sw.version,
          _resolved: sw.resolved || isGit(sw) && sw.version,
          _requested: requested,
          _optional: sw.optional,
          _development: sw.dev,
          _inBundle: sw.bundled,
          _integrity: sw.integrity,
          _from: from,
          _spec: requested.rawSpec,
          _where: topPath,
          _args: [ [ requested.toString(), topPath ] ],
          dependencies: sw.requires
        };
        if (!sw.bundled) {
          const bundleDependencies = Object.keys(sw.dependencies || {}).filter((d => sw.dependencies[d].bundled));
          0 === bundleDependencies.length && (pkg.bundleDependencies = bundleDependencies);
        }
        const child = createChild({
          package: pkg,
          loaded: isDirectory,
          parent: tree,
          children: [],
          fromShrinkwrap: requested,
          fakeChild: sw,
          fromBundle: sw.bundled ? tree.fromBundle || tree : null,
          path: childPath(tree.path, pkg),
          realpath: isDirectory ? requested.fetchSpec : childPath(tree.realpath, pkg),
          location: ("/" === tree.location ? "" : tree.location + "/") + pkg.name,
          isLink: isDirectory,
          isInLink: tree.isLink || tree.isInLink,
          swRequires: sw.requires
        });
        return tree.children.push(child), child;
      }
      function fetchChild(topPath, tree, sw, requested) {
        return fetchPackageMetadata(requested, topPath).then((pkg => (pkg._from = sw.from || requested.raw, 
        pkg._optional = sw.optional, pkg._development = sw.dev, pkg._inBundle = !1, addBundled(pkg).then((() => pkg))))).then((pkg => {
          var isLink = "directory" === pkg._requested.type;
          const child = createChild({
            package: pkg,
            loaded: !1,
            parent: tree,
            fromShrinkwrap: requested,
            path: childPath(tree.path, pkg),
            realpath: isLink ? requested.fetchSpec : childPath(tree.realpath, pkg),
            children: pkg._bundled || [],
            location: ("/" === tree.location ? "" : tree.location + "/") + pkg.name,
            fromBundle: null,
            isLink,
            isInLink: tree.isLink,
            swRequires: sw.requires
          });
          return tree.children.push(child), pkg._bundled && (delete pkg._bundled, inflateBundled(child, child, child.children)), 
          child;
        }));
      }
      function childIsEquivalent(sw, requested, child) {
        return !!child && (!!child.fromShrinkwrap || (!!(sw.integrity && child.package._integrity && ssri.parse(sw.integrity).match(child.package._integrity)) || (child.isLink && "directory" === requested.type ? "" === path.relative(child.realpath, requested.fetchSpec) : sw.resolved ? child.package._resolved === sw.resolved : !isRegistry(requested) && sw.from ? child.package._from === sw.from : !isRegistry(requested) && child.package._resolved ? sw.version === child.package._resolved : child.package.version === sw.version)));
      }
      module.exports = function(tree, sw, opts, finishInflating) {
        return fetchPackageMetadata || (fetchPackageMetadata = BB.promisify(__webpack_require__(3138)), 
        addBundled = BB.promisify(fetchPackageMetadata.addBundled)), 3 === arguments.length && (finishInflating = opts, 
        opts = {}), npm.config.get("shrinkwrap") && npm.config.get("package-lock") ? (tree.loaded = !1, 
        tree.hasRequiresFromLock = sw.requires, inflateShrinkwrap(tree.path, tree, sw.dependencies, opts).then((() => finishInflating()), finishInflating)) : finishInflating();
      };
    },
    69504: module => {
      "use strict";
      module.exports = function(node, name) {
        return node.package && node.package.devDependencies && node.package.devDependencies[name];
      };
    },
    66305: module => {
      "use strict";
      function isNotExtraneous(tree, isCycle) {
        return isCycle || (isCycle = {}), !(!tree.isTop && !tree.userRequired) || (isCycle[tree.path] ? function(tree) {
          for (var top = tree; !top.isTop; ) top = top.parent;
          return top.error;
        }(tree) : (isCycle[tree.path] = !0, tree.requiredBy && tree.requiredBy.some((function(node) {
          return isNotExtraneous(node, Object.create(isCycle));
        }))));
      }
      module.exports = function(tree) {
        return !isNotExtraneous(tree);
      };
    },
    37339: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var fs = __webpack_require__(57147), semver = __webpack_require__(73107), isWindows = "win32" === process.platform;
      fs.access ? module.exports = !isWindows || semver.gte(process.version, "1.5.0") : module.exports = !1;
    },
    35528: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = isOnlyDev;
      const moduleName = __webpack_require__(7802), isDevDep = __webpack_require__(69504), isProdDep = __webpack_require__(12727);
      function isOnlyDev(node, seen) {
        return seen || (seen = new Set), node.requiredBy.length && node.requiredBy.every(function(name, seen) {
          return function(req) {
            const isDev = isDevDep(req, name), isProd = isProdDep(req, name);
            if (req.isTop) return isDev && !isProd;
            {
              if (seen.has(req)) return !0;
              seen.add(req);
              const result = isOnlyDev(req, seen);
              return seen.delete(req), result;
            }
          };
        }(moduleName(node), seen));
      }
    },
    27849: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = function isOptional(node, seen) {
        seen || (seen = new Set);
        if (seen.has(node) || 0 === node.requiredBy.length) return !1;
        seen.add(node);
        const swOptional = node.fromShrinkwrap && node.package._optional, result = node.requiredBy.every((function(req) {
          return !(!req.fakeChild || !swOptional) || (isOptDep(req, moduleName(node)) || isOptional(req, seen));
        }));
        return seen.delete(node), result;
      };
      const isOptDep = __webpack_require__(91295), moduleName = __webpack_require__(7802);
    },
    91295: module => {
      "use strict";
      module.exports = function(node, name) {
        return node.package && node.package.optionalDependencies && node.package.optionalDependencies[name];
      };
    },
    12727: module => {
      "use strict";
      module.exports = function(node, name) {
        return node.package && node.package.dependencies && node.package.dependencies[name];
      };
    },
    14703: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var uniqueFilename = __webpack_require__(16003), moduleName = __webpack_require__(7802);
      module.exports = function(staging, pkg) {
        return uniqueFilename(staging, moduleName(pkg), pkg.realpath);
      };
    },
    60867: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var union = __webpack_require__(59232), without = __webpack_require__(78400), validate = __webpack_require__(95073), flattenTree = __webpack_require__(36140), isExtraneous = __webpack_require__(66305), validateAllPeerDeps = __webpack_require__(48045).validateAllPeerDeps, packageId = __webpack_require__(73531), moduleName = __webpack_require__(7802), npm = __webpack_require__(44874);
      function isDisconnectedCycle(tree, seen) {
        return seen || (seen = {}), !tree.isTop && !tree.cycleTop && 0 !== tree.requiredBy.length && (!!seen[tree.path] || (seen[tree.path] = !0, 
        tree.requiredBy.every((function(node) {
          return isDisconnectedCycle(node, Object.create(seen));
        }))));
      }
      var mutateIntoLogicalTree = module.exports = function(tree) {
        validate("O", arguments), validateAllPeerDeps(tree, (function(tree, pkgname, version) {
          tree.missingPeers || (tree.missingPeers = {}), tree.missingPeers[pkgname] = version;
        }));
        var flat = flattenTree(tree);
        return Object.keys(flat).sort().forEach((function(flatname) {
          var node = flat[flatname];
          node.requiredBy && node.requiredBy.length && (node.parent && (isDisconnectedCycle(node) ? node.cycleTop = !0 : node.requiredBy.length && (node.parent.children = without(node.parent.children, node))), 
          node.requiredBy.forEach((function(parentNode) {
            parentNode.children = union(parentNode.children, [ node ]);
          })));
        })), tree;
      };
      function translateTree_(tree, seen) {
        var pkg = tree.package;
        if (seen.has(tree)) return pkg;
        if (seen.add(tree), pkg._dependencies) return pkg;
        function markMissing(name, requiredBy) {
          if (pkg.dependencies[name]) {
            if (pkg.dependencies[name].missing) return;
            pkg.dependencies[name].invalid = !0, pkg.dependencies[name].realName = name, pkg.dependencies[name].extraneous = !1;
          } else pkg.dependencies[name] = {
            requiredBy,
            missing: !0,
            optional: !!pkg.optionalDependencies[name]
          };
        }
        return pkg._dependencies = pkg.dependencies, pkg.dependencies = {}, tree.children.forEach((function(child) {
          const dep = pkg.dependencies[moduleName(child)] = translateTree_(child, seen);
          child.fakeChild && (dep.missing = !0, dep.optional = child.package._optional, dep.requiredBy = child.package._spec);
        })), Object.keys(tree.missingDeps).forEach((function(name) {
          markMissing(name, tree.missingDeps[name]);
        })), Object.keys(tree.missingDevDeps).forEach((function(name) {
          markMissing(name, tree.missingDevDeps[name]);
        })), (tree.parent ? [] : [ tree ]).concat(tree.children).filter((function(child) {
          return child.missingPeers;
        })).forEach((function(child) {
          Object.keys(child.missingPeers).forEach((function(pkgname) {
            var version = child.missingPeers[pkgname], peerPkg = pkg.dependencies[pkgname];
            peerPkg || (peerPkg = pkg.dependencies[pkgname] = {
              _id: pkgname + "@" + version,
              name: pkgname,
              version
            }), peerPkg.peerMissing || (peerPkg.peerMissing = []), peerPkg.peerMissing.push({
              requiredBy: packageId(child),
              requires: pkgname + "@" + version
            });
          }));
        })), pkg.path = tree.path, pkg.error = tree.error, pkg.extraneous = !tree.isTop && (!tree.parent.isTop || !tree.parent.error) && !npm.config.get("global") && isExtraneous(tree), 
        tree.target && tree.parent && !tree.parent.target && (pkg.link = tree.realpath), 
        pkg;
      }
      module.exports.asReadInstalled = function(tree) {
        return mutateIntoLogicalTree(tree), function(tree) {
          return translateTree_(tree, new Set);
        }(tree);
      };
    },
    65061: (__unused_webpack_module, exports) => {
      "use strict";
      var defaultTemplate = {
        package: {
          version: "",
          dependencies: {},
          devDependencies: {},
          optionalDependencies: {}
        },
        loaded: !1,
        children: [],
        requiredBy: [],
        requires: [],
        missingDeps: {},
        missingDevDeps: {},
        phantomChildren: {},
        path: null,
        realpath: null,
        location: null,
        userRequired: !1,
        save: !1,
        saveSpec: null,
        isTop: !1,
        fromBundle: !1
      };
      var create = exports.create = function(node, template, isNotTop) {
        return template || (template = defaultTemplate), Object.keys(template).forEach((function(key) {
          if (null != template[key] && "object" == typeof template[key] && !(template[key] instanceof Array)) return node[key] || (node[key] = {}), 
          create(node[key], template[key], !0);
          null == node[key] && (node[key] = template[key]);
        })), isNotTop || (null == node.isLink && (node.isLink = function(node) {
          return node && node.isLink;
        }(node.parent)), null == node.isInLink && (node.isInLink = function(node) {
          return node && (node.isInLink || node.isLink);
        }(node.parent)), null == node.fromBundle && (node.fromBundle = !1)), node;
      };
      function reset(node, seen) {
        if (!seen.has(node)) {
          seen.add(node);
          var child = create(node);
          "@" === child.package._id && delete child.package._id, child.isTop = !1, child.requiredBy = [], 
          child.requires = [], child.missingDeps = {}, child.missingDevDeps = {}, child.phantomChildren = {}, 
          child.location = null, child.children.forEach((function(child) {
            reset(child, seen);
          }));
        }
      }
      exports.reset = function(node) {
        reset(node, new Set);
      };
    },
    34160: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const BB = __webpack_require__(41142), fs = __webpack_require__(59799), iferr = __webpack_require__(17367), inflateShrinkwrap = __webpack_require__(13802), log = __webpack_require__(19334), parseJSON = __webpack_require__(51686), path = __webpack_require__(71017), PKGLOCK_VERSION = __webpack_require__(44874).lockfileVersion, readFileAsync = BB.promisify(fs.readFile);
      function readShrinkwrap(child, next) {
        if (child.package._shrinkwrap) return process.nextTick(next);
        BB.join(maybeReadFile("npm-shrinkwrap.json", child), child.isTop && maybeReadFile("package-lock.json", child), ((shrinkwrap, lockfile) => {
          shrinkwrap && lockfile && log.warn("read-shrinkwrap", "Ignoring package-lock.json because there is already an npm-shrinkwrap.json. Please use only one of the two.");
          const name = shrinkwrap ? "npm-shrinkwrap.json" : "package-lock.json", parsed = parsePkgLock(shrinkwrap || lockfile, name);
          parsed && parsed.lockfileVersion !== PKGLOCK_VERSION && log.warn("read-shrinkwrap", `This version of npm is compatible with lockfileVersion@${PKGLOCK_VERSION}, but ${name} was generated for lockfileVersion@${parsed.lockfileVersion || 0}. I'll try to do my best with it!`), 
          child.package._shrinkwrap = parsed;
        })).then((() => next()), next);
      }
      function maybeReadFile(name, child) {
        return readFileAsync(path.join(child.path, name), "utf8").catch({
          code: "ENOENT"
        }, (() => null));
      }
      module.exports = readShrinkwrap, module.exports.andInflate = function(child, next) {
        readShrinkwrap(child, iferr(next, (function() {
          return child.package._shrinkwrap ? inflateShrinkwrap(child, child.package._shrinkwrap || {}, next) : next();
        })));
      };
      const PARENT_RE = /\|{7,}/g, OURS_RE = /<{7,}/g, THEIRS_RE = /={7,}/g, END_RE = />{7,}/g;
      function isDiff(str) {
        return str.match(OURS_RE) && str.match(THEIRS_RE) && str.match(END_RE);
      }
      function parsePkgLock(str, filename) {
        if (!str) return null;
        try {
          return parseJSON(str);
        } catch (e) {
          if (!isDiff(str)) throw e;
          {
            log.warn("conflict", `A git conflict was detected in ${filename}. Attempting to auto-resolve.`), 
            log.warn("conflict", "To make this happen automatically on git rebase/merge, consider using the npm-merge-driver:"), 
            log.warn("conflict", "$ npx npm-merge-driver install -g");
            const pieces = str.split(/[\n\r]+/g).reduce(((acc, line) => (line.match(PARENT_RE) ? acc.state = "parent" : line.match(OURS_RE) ? acc.state = "ours" : line.match(THEIRS_RE) ? acc.state = "theirs" : line.match(END_RE) ? acc.state = "top" : ("top" !== acc.state && "ours" !== acc.state || (acc.ours += line), 
            "top" !== acc.state && "theirs" !== acc.state || (acc.theirs += line), "top" !== acc.state && "parent" !== acc.state || (acc.parent += line)), 
            acc)), {
              state: "top",
              ours: "",
              theirs: "",
              parent: ""
            });
            try {
              parseJSON(pieces.ours);
              return function(parent, ours, theirs) {
                return Object.assign({}, ours, theirs);
              }(0, parseJSON(pieces.theirs));
            } catch (_e) {
              throw log.error("conflict", `Automatic conflict resolution failed. Please manually resolve conflicts in ${filename} and try again.`), 
              log.silly("conflict", `Error during resolution: ${_e}`), e;
            }
          }
        }
      }
      module.exports._isDiff = isDiff, module.exports._parsePkgLock = parsePkgLock;
    },
    46900: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var npa = __webpack_require__(19932);
      const isRegistry = __webpack_require__(80127);
      module.exports = function(name, sw, where) {
        try {
          if (sw.version && sw.integrity) return npa.resolve(name, sw.version, where);
          if (sw.from) {
            const spec = npa(sw.from, where);
            if (isRegistry(spec) && sw.version) return npa.resolve(name, sw.version, where);
            if (!sw.resolved) return spec;
          }
          if (sw.resolved) return npa.resolve(name, sw.resolved, where);
        } catch (_) {}
        return npa.resolve(name, sw.version, where);
      };
    },
    6843: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var path = __webpack_require__(71017), moduleName = __webpack_require__(7802);
      function top(tree) {
        return tree.parent ? top(tree.parent) : tree;
      }
      module.exports = function(tree, what, error) {
        var id, topTree = top(tree);
        topTree.warnings || (topTree.warnings = []);
        if (what) {
          var depVer = tree.package.dependencies && tree.package.dependencies[what], optDepVer = tree.package.optionalDependencies && tree.package.optionalDependencies[what], devDepVer = tree.package.devDependencies && tree.package.devDependencies[what], version = depVer || optDepVer || devDepVer;
          id = what + (version ? "@" + version : "");
        } else id = tree._id || moduleName(tree) + (tree.package.version ? "@" + tree.package.version : "");
        var location = path.relative(topTree.path, tree.path);
        what && (location = path.join(location, "node_modules", what));
        error.optional = id, error.location = location, topTree.warnings.push(error);
      };
    },
    29705: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      const deepSortObject = __webpack_require__(21514), detectIndent = __webpack_require__(78632), detectNewline = __webpack_require__(9637), fs = __webpack_require__(59799), iferr = __webpack_require__(17367), log = __webpack_require__(19334), moduleName = __webpack_require__(7802), npm = __webpack_require__(44874), packageId = __webpack_require__(73531), parseJSON = __webpack_require__(51686), path = __webpack_require__(71017), stringifyPackage = __webpack_require__(22652), validate = __webpack_require__(95073), without = __webpack_require__(78400), writeFileAtomic = __webpack_require__(19804);
      function andSaveShrinkwrap(tree, andReturn) {
        return validate("OF", arguments), function(er) {
          validate("E", arguments), saveShrinkwrap(tree, andWarnErrors(andReturn));
        };
      }
      function andWarnErrors(cb) {
        return validate("F", arguments), function(er) {
          er && log.warn("saveError", er.message), arguments[0] = null, cb.apply(null, arguments);
        };
      }
      function saveShrinkwrap(tree, next) {
        if (validate("OF", arguments), !(npm.config.get("package-lock-only") || npm.config.get("shrinkwrap") && npm.config.get("package-lock"))) return next();
        __webpack_require__(5446).createShrinkwrap(tree, {
          silent: !1
        }, next);
      }
      function savePackageJson(tree, next) {
        validate("OF", arguments);
        var saveBundle = npm.config.get("save-bundle"), saveTarget = path.resolve(tree.path, "package.json");
        fs.readFile(saveTarget, "utf8", iferr(next, (function(packagejson) {
          const indent = detectIndent(packagejson).indent, newline = detectNewline(packagejson);
          try {
            tree.package = parseJSON(packagejson);
          } catch (ex) {
            return next(ex);
          }
          if (saveBundle) {
            var bundle = tree.package.bundleDependencies || tree.package.bundledDependencies;
            delete tree.package.bundledDependencies, Array.isArray(bundle) || (bundle = []);
          }
          var toSave = getThingsToSave(tree), toRemove = getThingsToRemove(tree), savingTo = {};
          toSave.forEach((function(pkg) {
            pkg.save && (savingTo[pkg.save] = !0);
          })), toRemove.forEach((function(pkg) {
            pkg.save && (savingTo[pkg.save] = !0);
          })), Object.keys(savingTo).forEach((function(save) {
            tree.package[save] || (tree.package[save] = {});
          })), log.verbose("saving", toSave);
          const types = [ "dependencies", "devDependencies", "optionalDependencies" ];
          toSave.forEach((function(pkg) {
            pkg.save && (tree.package[pkg.save][pkg.name] = pkg.spec);
            const movedFrom = [];
            for (let saveType of types) pkg.save !== saveType && tree.package[saveType] && tree.package[saveType][pkg.name] && (movedFrom.push(saveType), 
            delete tree.package[saveType][pkg.name]);
            (movedFrom.length && log.notice("save", `${pkg.name} is being moved from ${movedFrom.join(" and ")} to ${pkg.save}`), 
            saveBundle) && (-1 === bundle.indexOf(pkg.name) && bundle.push(pkg.name));
          })), toRemove.forEach((function(pkg) {
            pkg.save && delete tree.package[pkg.save][pkg.name], saveBundle && (bundle = without(bundle, pkg.name));
          })), Object.keys(savingTo).forEach((function(key) {
            tree.package[key] = deepSortObject(tree.package[key]);
          })), saveBundle && (tree.package.bundleDependencies = deepSortObject(bundle));
          var json = stringifyPackage(tree.package, indent, newline);
          json === packagejson ? (log.verbose("shrinkwrap", "skipping write for package.json because there were no changes."), 
          next()) : writeFileAtomic(saveTarget, json, next), tree.package._id = packageId(tree.package);
        })));
      }
      function getThingsToSave(tree) {
        validate("O", arguments);
        var toSave = tree.children.filter((function(child) {
          return child.save;
        })).map((function(child) {
          return {
            name: moduleName(child),
            spec: child.saveSpec,
            save: child.save
          };
        }));
        return toSave;
      }
      function getThingsToRemove(tree) {
        if (validate("O", arguments), !tree.removedChildren) return [];
        var toRemove = tree.removedChildren.map((function(child) {
          return {
            name: moduleName(child),
            save: child.save
          };
        }));
        return toRemove;
      }
      exports.saveRequested = function(tree, andReturn) {
        validate("OF", arguments), savePackageJson(tree, andWarnErrors(andSaveShrinkwrap(tree, andReturn)));
      }, exports.saveShrinkwrap = saveShrinkwrap, exports.getSaveType = function(tree, arg) {
        arguments.length && validate("OO", arguments);
        var globalInstall = npm.config.get("global"), noSaveFlags = !(npm.config.get("save") || npm.config.get("save-dev") || npm.config.get("save-prod") || npm.config.get("save-optional"));
        if (globalInstall || noSaveFlags) return null;
        if (npm.config.get("save-optional")) return "optionalDependencies";
        if (npm.config.get("save-dev")) return "devDependencies";
        if (npm.config.get("save-prod")) return "dependencies";
        if (arg) {
          var name = moduleName(arg);
          if (tree.package.optionalDependencies[name]) return "optionalDependencies";
          if (tree.package.devDependencies[name]) return "devDependencies";
        }
        return "dependencies";
      };
    },
    12155: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var path = __webpack_require__(71017), writeFileAtomic = __webpack_require__(19804), moduleName = __webpack_require__(7802), deepSortObject = __webpack_require__(21514), sortedObject = __webpack_require__(37713), isWindows = __webpack_require__(52290), sortKeys = [ "dependencies", "devDependencies", "bundleDependencies", "optionalDependencies", "keywords", "engines", "scripts", "files" ];
      module.exports = function(mod, buildpath, next) {
        var pkg = sortedObject(mod.package), name = moduleName(mod);
        pkg._requiredBy = mod.requiredBy.map((function(req) {
          return req.package.devDependencies && req.package.devDependencies[name] && !req.package.dependencies[name] ? "#DEV:" + req.location : req.location;
        })).concat(mod.userRequired ? [ "#USER" ] : []).sort(), pkg._location = mod.location, 
        pkg._phantomChildren = {}, Object.keys(mod.phantomChildren).sort().forEach((function(name) {
          pkg._phantomChildren[name] = mod.phantomChildren[name].package.version;
        })), pkg._inBundle = !!mod.fromBundle, sortKeys.forEach((function(key) {
          null != pkg[key] && (pkg[key] = deepSortObject(pkg[key]));
        }));
        var data = JSON.stringify(sortedObject(pkg), null, 2) + "\n";
        writeFileAtomic(path.resolve(buildpath, "package.json"), data, {
          fsync: isWindows
        }, next);
      };
    },
    11674: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var validate = __webpack_require__(95073), asyncMap = __webpack_require__(89009).asyncMap, chain = __webpack_require__(89009).chain, npmInstallChecks = __webpack_require__(27809), iferr = __webpack_require__(17367), checkEngine = npmInstallChecks.checkEngine, checkPlatform = npmInstallChecks.checkPlatform, npm = __webpack_require__(44874);
      function hasMinimumFields(pkg, cb) {
        return "" === pkg.name || null == pkg.name ? cb(new Error(`Can't install ${pkg._resolved}: Missing package name`)) : "" === pkg.version || null == pkg.version ? cb(new Error(`Can't install ${pkg._resolved}: Missing package version`)) : cb();
      }
      module.exports = function(idealTree, args, next) {
        validate("OAF", arguments);
        var force = npm.config.get("force");
        asyncMap(args, (function(pkg, done) {
          chain([ [ hasMinimumFields, pkg ], [ checkSelf, idealTree, pkg, force ], [ isInstallable, idealTree, pkg ] ], done);
        }), next);
      };
      var isInstallable = module.exports.isInstallable = function(idealTree, pkg, next) {
        var force = npm.config.get("force"), nodeVersion = npm.config.get("node-version");
        /-/.test(nodeVersion) && (nodeVersion = nodeVersion.replace(/-.*/, ""));
        var strict = npm.config.get("engine-strict");
        checkEngine(pkg, npm.version, nodeVersion, force, strict, iferr(next, (function(warn) {
          idealTree && warn && function(idealTree, warn) {
            var topTree = function top(tree) {
              return tree.parent ? top(tree.parent) : tree;
            }(idealTree);
            topTree.warnings || (topTree.warnings = []), topTree.warnings.every((i => i.code !== warn.code || i.required !== warn.required || i.pkgid !== warn.pkgid)) && topTree.warnings.push(warn);
          }(idealTree, warn);
          checkPlatform(pkg, force, next);
        })));
      };
      function checkSelf(idealTree, pkg, force, next) {
        if (idealTree.package && idealTree.package.name !== pkg.name) return next();
        if (force) {
          var warn = new Error("Wouldn't install " + pkg.name + " as a dependency of itself, but being forced");
          warn.code = "ENOSELF", idealTree.warnings.push(warn), next();
        } else {
          var er = new Error('Refusing to install package with name "' + pkg.name + '" under a package\nalso called "' + pkg.name + "\". Did you name your project the same\nas the dependency you're installing?\n\nFor more information, see:\n    <https://docs.npmjs.com/cli/install#limitations-of-npms-install-algorithm>");
          er.code = "ENOSELF", next(er);
        }
      }
    },
    49310: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var path = __webpack_require__(71017), validate = __webpack_require__(95073), asyncMap = __webpack_require__(89009).asyncMap, chain = __webpack_require__(89009).chain, checkGit = __webpack_require__(27809).checkGit, clone = __webpack_require__(1259), normalizePackageData = __webpack_require__(17770), npm = __webpack_require__(44874), andFinishTracker = __webpack_require__(79266), flattenTree = __webpack_require__(36140), validateAllPeerDeps = __webpack_require__(48045).validateAllPeerDeps, packageId = __webpack_require__(73531);
      function checkErrors(mod, idealTree, next) {
        mod.error && (mod.parent || path.resolve(npm.globalDir, "..") !== mod.path) && idealTree.warnings.push(mod.error), 
        next();
      }
      function thenValidateAllPeerDeps(idealTree, next) {
        validate("OF", arguments), validateAllPeerDeps(idealTree, (function(tree, pkgname, version) {
          var warn = new Error(packageId(tree) + " requires a peer of " + pkgname + "@" + version + " but none is installed. You must install peer dependencies yourself.");
          warn.code = "EPEERINVALID", idealTree.warnings.push(warn);
        })), next();
      }
      function thenCheckTop(idealTree, next) {
        if (validate("OF", arguments), idealTree.package.error) return next();
        var pkg = clone(idealTree.package);
        try {
          normalizePackageData(pkg, (function(warn) {
            var warnObj = new Error(packageId(idealTree) + " " + warn);
            warnObj.code = "EPACKAGEJSON", idealTree.warnings.push(warnObj);
          }), !1);
        } catch (er) {
          er.code = "EPACKAGEJSON", idealTree.warnings.push(er);
        }
        var nodeVersion = npm.config.get("node-version");
        if (/-/.test(nodeVersion)) {
          var warnObj = new Error("You are using a pre-release version of node and things may not work as expected");
          warnObj.code = "ENODEPRE", idealTree.warnings.push(warnObj);
        }
        next();
      }
      function thenCheckDuplicateDeps(idealTree, next) {
        var deps = idealTree.package.dependencies || {}, devDeps = idealTree.package.devDependencies || {};
        for (var pkg in devDeps) if (pkg in deps) {
          var warnObj = new Error("The package " + pkg + " is included as both a dev and production dependency.");
          warnObj.code = "EDUPLICATEDEP", idealTree.warnings.push(warnObj);
        }
        next();
      }
      module.exports = function(idealTree, log, next) {
        validate("OOF", arguments);
        var moduleMap = flattenTree(idealTree), modules = Object.keys(moduleMap).map((function(name) {
          return moduleMap[name];
        }));
        chain([ [ asyncMap, modules, function(mod, done) {
          chain([ mod.parent && !mod.isLink && [ checkGit, mod.realpath ], [ checkErrors, mod, idealTree ] ], done);
        } ], [ thenValidateAllPeerDeps, idealTree ], [ thenCheckTop, idealTree ], [ thenCheckDuplicateDeps, idealTree ] ], andFinishTracker(log, next));
      };
    },
    13047: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var path = __webpack_require__(71017), fs = __webpack_require__(57147), inflight = __webpack_require__(59956), accessError = __webpack_require__(2101), andIgnoreErrors = __webpack_require__(77448), isFsAccessAvailable = __webpack_require__(37339);
      function fsAccessImplementation(dir, done) {
        (done = inflight("writable:" + dir, done)) && fs.access(dir, fs.W_OK, done);
      }
      function fsOpenImplementation(dir, done) {
        if (done = inflight("writable:" + dir, done)) {
          var tmp = path.join(dir, ".npm.check.permissions");
          fs.open(tmp, "w", (function(er, fd) {
            if (er) return done(accessError(dir, er));
            fs.close(fd, (function() {
              fs.unlink(tmp, andIgnoreErrors(done));
            }));
          }));
        }
      }
      module.exports = isFsAccessAvailable ? fsAccessImplementation : fsOpenImplementation, 
      module.exports.fsAccessImplementation = fsAccessImplementation, module.exports.fsOpenImplementation = fsOpenImplementation;
    },
    20148: (module, __unused_webpack_exports, __webpack_require__) => {
      var npm = __webpack_require__(44874), symlink = __webpack_require__(32735), fs = __webpack_require__(59799), log = __webpack_require__(19334), asyncMap = __webpack_require__(89009).asyncMap, chain = __webpack_require__(89009).chain, path = __webpack_require__(71017), build = __webpack_require__(34674), npa = __webpack_require__(19932), usage = __webpack_require__(29320), output = __webpack_require__(1015);
      function link(args, cb) {
        if ("win32" === process.platform && !__webpack_require__(73107).gte(process.version, "0.7.9")) {
          var e = new Error("npm link not supported on windows prior to node 0.7.9");
          return e.code = "ENOTSUP", e.errno = __webpack_require__(22057).ENOTSUP, cb(e);
        }
        return npm.config.get("global") ? cb(new Error("link should never be --global.\nPlease re-run this command with --local")) : (1 === args.length && "." === args[0] && (args = []), 
        args.length ? function(pkgs, cb) {
          asyncMap(pkgs, (function(pkg, cb) {
            var t = path.resolve(npm.globalDir, ".."), pp = path.resolve(npm.globalDir, pkg), rp = null, target = path.resolve(npm.dir, pkg);
            function n(er, data) {
              if (er) return cb(er, data);
              var installed = data.filter((function(info) {
                return function(id, folder) {
                  return "@" === id[0] ? path.resolve(folder, "..", "..") : path.resolve(folder, "..");
                }(info[0], info[1]) === npm.globalDir;
              })), id = installed[0][0];
              pp = installed[0][1];
              var what = npa(id);
              pkg = what.name, target = path.resolve(npm.dir, pkg), next();
            }
            if ("@" !== pkg[0] && (-1 !== pkg.indexOf("/") || -1 !== pkg.indexOf("\\"))) return fs.lstat(path.resolve(pkg), (function(er, st) {
              er || !st.isDirectory() ? npm.commands.install(t, pkg, n) : linkPkg(rp = path.resolve(pkg), n);
            }));
            function next() {
              if (npm.config.get("dry-run")) return resultPrinter(pkg, pp, target, rp, cb);
              chain([ [ function(cb) {
                log.verbose("link", "symlinking %s to %s", pp, target), cb();
              } ], [ symlink, pp, target, !1, !1 ], rp && [ build, [ target ], npm.config.get("global"), build._noLC, !0 ], [ resultPrinter, pkg, pp, target, rp ] ], cb);
            }
            fs.lstat(pp, (function(er, st) {
              return er ? (rp = pp, npm.commands.install(t, [ pkg ], n)) : st.isSymbolicLink() ? fs.realpath(pp, (function(er, real) {
                er ? log.warn("invalid symbolic link", pkg) : rp = real, next();
              })) : (rp = pp, void next());
            }));
          }), cb);
        }(args, cb) : void linkPkg(npm.prefix, cb));
      }
      function linkPkg(folder, cb_) {
        var me = folder || npm.prefix, readJson = __webpack_require__(92200);
        log.verbose("linkPkg", folder), readJson(path.resolve(me, "package.json"), (function(er, d) {
          function cb(er) {
            return cb_(er, [ [ d && d._id, target, null, null ] ]);
          }
          if (er) return cb(er);
          if (!d.name) return cb(er = new Error("Package must have a name field to be linked"));
          var target = path.resolve(npm.globalDir, d.name);
          if (npm.config.get("dry-run")) return resultPrinter(path.basename(me), me, target, cb);
          symlink(me, target, !1, !0, (function(er) {
            if (er) return cb(er);
            log.verbose("link", "build target", target), npm.commands.install(me, [], (function(er) {
              if (er) return cb(er);
              build([ target ], !0, build._noLC, !0, (function(er) {
                if (er) return cb(er);
                resultPrinter(path.basename(me), me, target, cb);
              }));
            }));
          }));
        }));
      }
      function resultPrinter(pkg, src, dest, rp, cb) {
        "function" != typeof cb && (cb = rp, rp = null);
        var where = dest;
        if (rp = (rp || "").trim(), src = (src || "").trim(), npm.config.get("parseable")) return function(dest, rp, cb) {
          output(dest + "::" + rp), cb();
        }(dest, rp || src, cb);
        rp === src && (rp = null), output(where + " -> " + src + (rp ? " -> " + rp : "")), 
        cb();
      }
      module.exports = link, link.usage = usage("link", "npm link (in package dir)\nnpm link [<@scope>/]<pkg>[@<version>]"), 
      link.completion = function(opts, cb) {
        var dir = npm.globalDir;
        fs.readdir(dir, (function(er, files) {
          cb(er, files.filter((function(f) {
            return !f.match(/^[._-]/);
          })));
        }));
      };
    },
    51209: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const BB = __webpack_require__(41142), eu = encodeURIComponent, getAuth = __webpack_require__(59505), log = __webpack_require__(19334), npm = __webpack_require__(44874), npmConfig = __webpack_require__(23300), npmFetch = __webpack_require__(27382);
      function afterLogout(normalized) {
        var scope = npm.config.get("scope");
        return scope && npm.config.del(scope + ":registry"), npm.config.clearCredentialsByURI(normalized), 
        BB.fromNode((cb => npm.config.save("user", cb)));
      }
      function logout(args, cb) {
        const opts = npmConfig();
        BB.try((() => {
          const reg = npmFetch.pickRegistry("foo", opts), auth = getAuth(reg, opts);
          if (auth.token) return log.verbose("logout", "clearing session token for", reg), 
          npmFetch(`/-/user/token/${eu(auth.token)}`, opts.concat({
            method: "DELETE",
            ignoreBody: !0
          })).then((() => afterLogout(reg)));
          if (auth.username || auth.password) return log.verbose("logout", "clearing user credentials for", reg), 
          afterLogout(reg);
          throw new Error("Not logged in to", reg + ",", "so can't log out.");
        })).nodeify(cb);
      }
      logout.usage = "npm logout [--registry=<url>] [--scope=<@scope>]", module.exports = logout;
    },
    46627: (module, exports, __webpack_require__) => {
      module.exports = ls;
      var path = __webpack_require__(71017), url = __webpack_require__(57310), readPackageTree = __webpack_require__(7338), archy = __webpack_require__(84032), semver = __webpack_require__(73107), color = __webpack_require__(53987), moduleName = __webpack_require__(7802), npa = __webpack_require__(19932), sortedObject = __webpack_require__(37713), npm = __webpack_require__(44874), mutateIntoLogicalTree = __webpack_require__(60867), computeMetadata = __webpack_require__(48045).computeMetadata, readShrinkwrap = __webpack_require__(34160), packageId = __webpack_require__(73531), usage = __webpack_require__(29320), output = __webpack_require__(1015);
      function ls(args, silent, cb) {
        "function" != typeof cb && (cb = silent, silent = !1);
        var dir = path.resolve(npm.dir, "..");
        readPackageTree(dir, (function(_, physicalTree) {
          physicalTree || (physicalTree = {
            package: {},
            path: dir
          }), physicalTree.isTop = !0, readShrinkwrap.andInflate(physicalTree, (function() {
            lsFromTree(dir, computeMetadata(physicalTree), args, silent, cb);
          }));
        }));
      }
      function inList(list, value) {
        return -1 !== list.indexOf(value);
      }
      ls.usage = usage("ls", "npm ls [[<@scope>/]<pkg> ...]"), ls.completion = __webpack_require__(46624);
      var lsFromTree = ls.fromTree = function(dir, physicalTree, args, silent, cb) {
        "function" != typeof cb && (cb = silent, silent = !1), args = args ? args.map((function(a) {
          if ("object" == typeof a && "alias" === a.package._requested.type) return [ moduleName(a), `npm:${a.package.name}@${a.package.version}`, a ];
          if ("object" == typeof a) return [ a.package.name, a.package.version, a ];
          var p = npa(a);
          return [ p.name, p.rawSpec && (semver.validRange(p.rawSpec) || ""), a ];
        })) : [];
        var data = mutateIntoLogicalTree.asReadInstalled(physicalTree);
        pruneNestedExtraneous(data), function(data) {
          var dev = npm.config.get("dev") || /^dev(elopment)?$/.test(npm.config.get("only")), production = npm.config.get("production") || /^prod(uction)?$/.test(npm.config.get("only")), dependencies = {}, devKeys = Object.keys(data.devDependencies || []), prodKeys = Object.keys(data._dependencies || []);
          Object.keys(data.dependencies).forEach((function(name) {
            !dev && inList(devKeys, name) && !inList(prodKeys, name) && data.dependencies[name].missing || (dev && inList(devKeys, name) || production && inList(prodKeys, name) || !dev && !production) && (dependencies[name] = data.dependencies[name]);
          })), data.dependencies = dependencies;
        }(data), function(data) {
          if (npm.config.get("link")) {
            var dependencies = {};
            Object.keys(data.dependencies).forEach((function(name) {
              var dependency = data.dependencies[name];
              dependency.link && (dependencies[name] = dependency);
            })), data.dependencies = dependencies;
          }
        }(data);
        var unlooped = function(root, args) {
          if (!args.length) return root;
          if (!root.dependencies) return root;
          var toMark = [ root ];
          for (;toMark.length; ) {
            var markPkg = toMark.shift(), markDeps = markPkg.dependencies;
            markDeps && Object.keys(markDeps).forEach((function(depName) {
              var dep = markDeps[depName];
              if (!dep.peerMissing || dep._from) {
                dep._parent = markPkg;
                for (var ii = 0; ii < args.length; ii++) {
                  var found, argName = args[ii][0], argVersion = args[ii][1], argRaw = args[ii][2];
                  if ("object" == typeof argRaw ? dep.path === argRaw.path && (found = !0) : depName === argName && argVersion ? found = semver.satisfies(dep.version, argVersion, !0) : depName === argName && (found = !0), 
                  found) {
                    dep._found = "explicit";
                    for (var parent = dep._parent; parent && !parent._found && !parent._deduped; ) parent._found = "implicit", 
                    parent = parent._parent;
                    break;
                  }
                }
                toMark.push(dep);
              }
            }));
          }
          var toTrim = [ root ];
          for (;toTrim.length; ) {
            var trimPkg = toTrim.shift(), trimDeps = trimPkg.dependencies;
            trimDeps && (trimPkg.dependencies = {}, Object.keys(trimDeps).forEach((function(name) {
              var dep = trimDeps[name];
              dep._found && ("implicit" === dep._found && dep._deduped || (trimPkg.dependencies[name] = dep, 
              toTrim.push(dep)));
            })));
          }
          return root;
        }(function(root) {
          var queue = [ root ], seen = new Set;
          seen.add(root);
          for (;queue.length; ) {
            var current = queue.shift(), deps = current.dependencies = current.dependencies || {};
            Object.keys(deps).forEach((function(d) {
              var dep = deps[d];
              if (!dep.missing || dep.dependencies) {
                if (dep.path && seen.has(dep)) return (dep = deps[d] = Object.assign({}, dep)).dependencies = {}, 
                void (dep._deduped = path.relative(root.path, dep.path).replace(/node_modules\//g, ""));
                seen.add(dep), queue.push(dep);
              }
            }));
          }
          return root;
        }(data), args), lite = getLite(unlooped);
        if (silent) return cb(null, data, lite);
        var out, er, long = npm.config.get("long");
        if (npm.config.get("json")) {
          var seen = new Set, d = long ? unlooped : lite;
          out = JSON.stringify(d, (function(k, o) {
            if ("object" == typeof o) {
              if (seen.has(o)) return "[Circular]";
              seen.add(o);
            }
            return o;
          }), 2);
        } else npm.config.get("parseable") ? out = makeParseable(unlooped, long, dir) : data && (out = function(data, long, dir) {
          var out = makeArchy_(data, long, dir, 0);
          return archy(out, "", {
            unicode: npm.config.get("unicode")
          });
        }(unlooped, long, dir));
        output(out), args.length && !data._found && (process.exitCode = 1), lite.problems && lite.problems.length && (er = lite.problems.join("\n")), 
        cb(er, data, lite);
      };
      function pruneNestedExtraneous(data, visited) {
        for (var i in (visited = visited || []).push(data), data.dependencies) data.dependencies[i].extraneous ? data.dependencies[i].dependencies = {} : -1 === visited.indexOf(data.dependencies[i]) && pruneNestedExtraneous(data.dependencies[i], visited);
      }
      function alphasort(a, b) {
        return (a = a.toLowerCase()) > (b = b.toLowerCase()) ? 1 : a < b ? -1 : 0;
      }
      function isCruft(data) {
        return data.extraneous && data.error && "ENOTDIR" === data.error.code;
      }
      function getLite(data, noname, depth) {
        var lite = {};
        if (isCruft(data)) return lite;
        var maxDepth = npm.config.get("depth");
        if (void 0 === depth && (depth = 0), !noname && data.name && (lite.name = data.name), 
        data.version && (lite.version = data.version), data.extraneous && (lite.extraneous = !0, 
        lite.problems = lite.problems || [], lite.problems.push("extraneous: " + packageId(data) + " " + (data.path || ""))), 
        data.error && data.path !== path.resolve(npm.globalDir, "..") && ("ENOENT" !== data.error.code || noname)) {
          lite.invalid = !0, lite.problems = lite.problems || [];
          var message = data.error.message;
          lite.problems.push("error in " + data.path + ": " + message);
        }
        data._from && (lite.from = data._from), data._resolved && (lite.resolved = data._resolved), 
        data.invalid && (lite.invalid = !0, lite.problems = lite.problems || [], lite.problems.push("invalid: " + packageId(data) + " " + (data.path || ""))), 
        data.peerInvalid && (lite.peerInvalid = !0, lite.problems = lite.problems || [], 
        lite.problems.push("peer dep not met: " + packageId(data) + " " + (data.path || "")));
        var deps = data.dependencies && Object.keys(data.dependencies) || [];
        return deps.length && (lite.dependencies = deps.map((function(d) {
          var p, dep = data.dependencies[d];
          return dep.missing && !dep.optional ? (lite.problems = lite.problems || [], p = data.depth > maxDepth ? "max depth reached: " : "missing: ", 
          p += d + "@" + dep.requiredBy + ", required by " + packageId(data), lite.problems.push(p), 
          dep.dependencies ? [ d, getLite(dep, !0) ] : [ d, {
            required: dep.requiredBy,
            missing: !0
          } ]) : dep.peerMissing ? (lite.problems = lite.problems || [], dep.peerMissing.forEach((function(missing) {
            var pdm = "peer dep missing: " + missing.requires + ", required by " + missing.requiredBy;
            lite.problems.push(pdm);
          })), [ d, {
            required: dep,
            peerMissing: !0
          } ]) : npm.config.get("json") ? (depth === maxDepth && delete dep.dependencies, 
          [ d, getLite(dep, !0, depth + 1) ]) : [ d, getLite(dep, !0) ];
        })).reduce((function(deps, d) {
          return d[1].problems && (lite.problems = lite.problems || [], lite.problems.push.apply(lite.problems, d[1].problems)), 
          deps[d[0]] = d[1], deps;
        }), {})), lite;
      }
      function makeArchy_(data, long, dir, depth, parent, d) {
        if (data.missing) {
          if (depth - 1 <= npm.config.get("depth")) {
            var unmet = "UNMET " + (data.optional ? "OPTIONAL " : "") + "DEPENDENCY";
            npm.color && (unmet = data.optional ? color.bgBlack(color.yellow(unmet)) : color.bgBlack(color.red(unmet)));
            var label = data._id || d + "@" + data.requiredBy;
            return "explicit" === data._found && data._id && (label = npm.color ? color.bgBlack(color.yellow(label.trim())) + " " : label.trim() + " "), 
            {
              label: unmet + " " + label,
              nodes: Object.keys(data.dependencies || {}).sort(alphasort).filter((function(d) {
                return !isCruft(data.dependencies[d]);
              })).map((function(d) {
                return makeArchy_(sortedObject(data.dependencies[d]), long, dir, depth + 1, data, d);
              }))
            };
          }
          return {
            label: d + "@" + data.requiredBy
          };
        }
        var out = {};
        if (data._requested && "alias" === data._requested.type ? out.label = `${d}@npm:${data._id}` : out.label = data._id || "", 
        "explicit" === data._found && data._id && (npm.color ? out.label = color.bgBlack(color.yellow(out.label.trim())) + " " : out.label = out.label.trim() + " "), 
        data.link && (out.label += " -> " + data.link), data._deduped && (npm.color ? out.label += " " + color.brightBlack("deduped") : out.label += " deduped"), 
        data.invalid) {
          data.realName !== data.name && (out.label += " (" + data.realName + ")");
          var invalid = "invalid";
          npm.color && (invalid = color.bgBlack(color.red(invalid))), out.label += " " + invalid;
        }
        if (data.peerInvalid) {
          var peerInvalid = "peer invalid";
          npm.color && (peerInvalid = color.bgBlack(color.red(peerInvalid))), out.label += " " + peerInvalid;
        }
        if (data.peerMissing) {
          var peerMissing = "UNMET PEER DEPENDENCY";
          npm.color && (peerMissing = color.bgBlack(color.red(peerMissing))), out.label = peerMissing + " " + out.label;
        }
        if (data.extraneous && data.path !== dir) {
          var extraneous = "extraneous";
          npm.color && (extraneous = color.bgBlack(color.green(extraneous))), out.label += " " + extraneous;
        }
        if (data.error && depth) {
          var message = data.error.message;
          message.indexOf("\n") && (message = message.slice(0, message.indexOf("\n")));
          var error = "error: " + message;
          npm.color && (error = color.bgRed(color.brightWhite(error))), out.label += " " + error;
        }
        if (data._resolved) try {
          var type = npa(data._resolved).type;
          ("git" === type || "hosted" === type) && (out.label += " (" + data._resolved + ")");
        } catch (ex) {}
        return long ? (dir === data.path && (out.label += "\n" + dir), out.label += "\n" + function(data) {
          var extras = [];
          data.description && extras.push(data.description);
          data.repository && extras.push(data.repository.url);
          data.homepage && extras.push(data.homepage);
          if (data._from) {
            var from = data._from;
            0 === from.indexOf(data.name + "@") && (from = from.substr(data.name.length + 1)), 
            url.parse(from).protocol && extras.push(from);
          }
          return extras.join("\n");
        }(data)) : dir === data.path && (out.label && (out.label += " "), out.label += dir), 
        out.nodes = [], depth <= npm.config.get("depth") && (out.nodes = Object.keys(data.dependencies || {}).sort(alphasort).filter((function(d) {
          return !isCruft(data.dependencies[d]);
        })).map((function(d) {
          return makeArchy_(sortedObject(data.dependencies[d]), long, dir, depth + 1, data, d);
        }))), 0 === out.nodes.length && data.path === dir && (out.nodes = [ "(empty)" ]), 
        out;
      }
      function makeParseable(data, long, dir, depth, parent, d) {
        return data._deduped ? [] : (depth = depth || 0) > npm.config.get("depth") ? [ makeParseable_(data, long, dir, depth, parent, d) ] : [ makeParseable_(data, long, dir, depth, parent, d) ].concat(Object.keys(data.dependencies || {}).sort(alphasort).map((function(d) {
          return makeParseable(data.dependencies[d], long, dir, depth + 1, data, d);
        }))).filter((function(x) {
          return x && x.length;
        })).join("\n");
      }
      function makeParseable_(data, long, dir, depth, parent, d) {
        return data.hasOwnProperty("_found") && "explicit" !== data._found ? "" : data.missing ? data = depth < npm.config.get("depth") ? npm.config.get("long") ? path.resolve(parent.path, "node_modules", d) + ":" + d + "@" + JSON.stringify(data.requiredBy) + ":INVALID:MISSING" : "" : path.resolve(dir || "", "node_modules", d || "") + (npm.config.get("long") ? ":" + d + "@" + JSON.stringify(data.requiredBy) + "::MAXDEPTH" : "") : npm.config.get("long") ? data.path + ":" + (data._id || "") + (data.link && data.link !== data.path ? ":" + data.link : "") + (data.extraneous ? ":EXTRANEOUS" : "") + (data.error && data.path !== path.resolve(npm.globalDir, "..") ? ":ERROR" : "") + (data.invalid ? ":INVALID" : "") + (data.peerInvalid ? ":PEERINVALID" : "") + (data.peerMissing ? ":PEERINVALID:MISSING" : "") : data.path;
      }
    },
    98361: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const figgyPudding = __webpack_require__(55212), liborg = __webpack_require__(11043), npmConfig = __webpack_require__(23300), output = __webpack_require__(1015), otplease = __webpack_require__(83304), Table = __webpack_require__(27275);
      module.exports = org, org.subcommands = [ "set", "rm", "ls" ], org.usage = "npm org set orgname username [developer | admin | owner]\nnpm org rm orgname username\nnpm org ls orgname [<username>]";
      const OrgConfig = figgyPudding({
        json: {},
        loglevel: {},
        parseable: {},
        silent: {}
      });
      function org([cmd, orgname, username, role], cb) {
        otplease(npmConfig(), (opts => {
          switch (opts = OrgConfig(opts), cmd) {
           case "add":
           case "set":
            return function(org, user, role, opts) {
              if (role = role || "developer", !org) throw new Error("First argument `orgname` is required.");
              if (!user) throw new Error("Second argument `username` is required.");
              if (![ "owner", "admin", "developer" ].find((x => x === role))) throw new Error("Third argument `role` must be one of `owner`, `admin`, or `developer`, with `developer` being the default value if omitted.");
              return liborg.set(org, user, role, opts).then((memDeets => (opts.json ? output(JSON.stringify(memDeets, null, 2)) : opts.parseable ? (output([ "org", "orgsize", "user", "role" ].join("\t")), 
              output([ memDeets.org.name, memDeets.org.size, memDeets.user, memDeets.role ])) : opts.silent || "silent" === opts.loglevel || output(`Added ${memDeets.user} as ${memDeets.role} to ${memDeets.org.name}. You now ${memDeets.org.size} member${1 === memDeets.org.size ? "" : "s"} in this org.`), 
              memDeets)));
            }(orgname, username, role, opts);

           case "rm":
            return function(org, user, opts) {
              if (!org) throw new Error("First argument `orgname` is required.");
              if (!user) throw new Error("Second argument `username` is required.");
              return liborg.rm(org, user, opts).then((() => liborg.ls(org, opts))).then((roster => {
                user = user.replace(/^[~@]?/, ""), org = org.replace(/^[~@]?/, "");
                const userCount = Object.keys(roster).length;
                opts.json ? output(JSON.stringify({
                  user,
                  org,
                  userCount,
                  deleted: !0
                })) : opts.parseable ? (output([ "user", "org", "userCount", "deleted" ].join("\t")), 
                output([ user, org, userCount, !0 ].join("\t"))) : opts.silent || "silent" === opts.loglevel || output(`Successfully removed ${user} from ${org}. You now have ${userCount} member${1 === userCount ? "" : "s"} in this org.`);
              }));
            }(orgname, username, opts);

           case "ls":
            return function(org, user, opts) {
              if (!org) throw new Error("First argument `orgname` is required.");
              return liborg.ls(org, opts).then((roster => {
                if (user) {
                  const newRoster = {};
                  roster[user] && (newRoster[user] = roster[user]), roster = newRoster;
                }
                if (opts.json) output(JSON.stringify(roster, null, 2)); else if (opts.parseable) output([ "user", "role" ].join("\t")), 
                Object.keys(roster).forEach((user => {
                  output([ user, roster[user] ].join("\t"));
                })); else if (!opts.silent && "silent" !== opts.loglevel) {
                  const table = new Table({
                    head: [ "user", "role" ]
                  });
                  Object.keys(roster).sort().forEach((user => {
                    table.push([ user, roster[user] ]);
                  })), output(table.toString());
                }
              }));
            }(orgname, username, opts);

           default:
            !function() {
              throw Object.assign(new Error(org.usage), {
                code: "EUSAGE"
              });
            }();
          }
        })).then((x => cb(null, x)), (err => cb("EUSAGE" === err.code ? err.message : err)));
      }
      org.completion = function(opts, cb) {
        var argv = opts.conf.argv.remain;
        if (2 === argv.length) return cb(null, org.subcommands);
        switch (argv[2]) {
         case "ls":
         case "add":
         case "rm":
         case "set":
          return cb(null, []);

         default:
          return cb(new Error(argv[2] + " not recognized"));
        }
      };
    },
    45857: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = outdated, outdated.usage = "npm outdated [[<@scope>/]<pkg> ...]", 
      outdated.completion = __webpack_require__(46624);
      const os = __webpack_require__(22037), url = __webpack_require__(57310), path = __webpack_require__(71017), readPackageTree = __webpack_require__(7338), asyncMap = __webpack_require__(89009).asyncMap, color = __webpack_require__(53987), styles = __webpack_require__(65308), table = __webpack_require__(5371), semver = __webpack_require__(73107), npa = __webpack_require__(4422), pickManifest = __webpack_require__(90346), fetchPackageMetadata = __webpack_require__(3138), mutateIntoLogicalTree = __webpack_require__(60867), npm = __webpack_require__(44874), npmConfig = __webpack_require__(23300), figgyPudding = __webpack_require__(55212), packument = __webpack_require__(76111), long = npm.config.get("long"), isExtraneous = __webpack_require__(66305), computeMetadata = __webpack_require__(48045).computeMetadata, computeVersionSpec = __webpack_require__(48045).computeVersionSpec, moduleName = __webpack_require__(7802), output = __webpack_require__(1015), ansiTrim = __webpack_require__(82576), OutdatedConfig = figgyPudding({
        also: {},
        color: {},
        depth: {},
        dev: "development",
        development: {},
        global: {},
        json: {},
        only: {},
        parseable: {},
        prod: "production",
        production: {},
        save: {},
        "save-dev": {},
        "save-optional": {}
      });
      function outdated(args, silent, cb) {
        "function" != typeof cb && (cb = silent, silent = !1);
        let opts = OutdatedConfig(npmConfig());
        var next, dir = path.resolve(npm.dir, "..");
        opts.depth === 1 / 0 && (opts = opts.concat({
          depth: 0
        })), readPackageTree(dir, (next = function(er, tree) {
          if (!tree) return cb(er);
          mutateIntoLogicalTree(tree), outdated_(args, "", tree, {}, 0, opts, (function(er, list) {
            if (list = function(list) {
              var uniqed = [], seen = new Set;
              return list.forEach((function(item) {
                seen.has(item) || (seen.add(item), uniqed.push(item));
              })), uniqed;
            }(list || []).sort((function(aa, bb) {
              return aa[0].path.localeCompare(bb[0].path) || aa[1].localeCompare(bb[1]);
            })), er || silent || 0 === list.length && !opts.json) return cb(er, list);
            if (opts.json) output(function(list, opts) {
              var out = {};
              return list.forEach((function(p) {
                var dep = p[0], depname = p[1], dir = dep.path, has = p[2], want = p[3], latest = p[4], type = p[6];
                opts.global || (dir = path.relative(process.cwd(), dir)), out[depname] = {
                  current: has,
                  wanted: want,
                  latest,
                  location: dir
                }, long && (out[depname].type = type, out[depname].homepage = dep.package.homepage);
              })), JSON.stringify(out, null, 2);
            }(list, opts)); else if (opts.parseable) output(function(list) {
              return list.map((function(p) {
                var dep = p[0], depname = p[1], dir = dep.path, has = p[2], want = p[3], latest = p[4], type = p[6], out = [ dir, depname + "@" + want, has ? depname + "@" + has : "MISSING", depname + "@" + latest ];
                return long && out.push(type, dep.package.homepage), out.join(":");
              })).join(os.EOL);
            }(list)); else {
              var outList = list.map((x => function(p, opts) {
                var depname = p[1], has = p[2], want = p[3], latest = p[4], type = p[6], deppath = p[7], homepage = p[0].package.homepage || "", columns = [ depname, has || "MISSING", want, latest, deppath || "global" ];
                return long && (columns[5] = type, columns[6] = homepage), opts.color && (columns[0] = color[has === want ? "yellow" : "red"](columns[0]), 
                columns[2] = color.green(columns[2]), columns[3] = color.magenta(columns[3])), columns;
              }(x, opts))), outHead = [ "Package", "Current", "Wanted", "Latest", "Location" ];
              long && outHead.push("Package Type", "Homepage");
              var outTable = [ outHead ].concat(outList);
              opts.color && (outTable[0] = outTable[0].map((function(heading) {
                return styles.underline(heading);
              }))), output(table(outTable, {
                align: [ "l", "r", "r", "r", "l" ],
                stringLength: function(s) {
                  return ansiTrim(s).length;
                }
              }));
            }
            process.exitCode = list.length ? 1 : 0, cb(null, list.map((function(item) {
              return [ item[0].parent.path ].concat(item.slice(1, 7));
            })));
          }));
        }, function(er, tree) {
          if (er) return next(er);
          next(null, computeMetadata(tree));
        }));
      }
      function outdated_(args, path, tree, parentHas, depth, opts, cb) {
        if (tree.package || (tree.package = {}), path && moduleName(tree) && (path += " > " + tree.package.name), 
        !path && moduleName(tree) && (path = tree.package.name), depth > opts.depth) return cb(null, []);
        var types = {}, pkg = tree.package;
        tree.children || (tree.children = []);
        var deps = tree.error ? tree.children : tree.children.filter((child => !isExtraneous(child)));
        deps.forEach((function(dep) {
          types[moduleName(dep)] = "dependencies";
        })), Object.keys(tree.missingDeps || {}).forEach((function(name) {
          deps.push({
            package: {
              name
            },
            path: tree.path,
            parent: tree,
            isMissing: !0
          }), types[name] = "dependencies";
        }));
        var dev = opts.dev || /^dev(elopment)?$/.test(opts.also), prod = opts.production || /^prod(uction)?$/.test(opts.only);
        !dev && prod || !opts["save-dev"] && (opts.save || opts["save-optional"]) || Object.keys(tree.missingDevDeps).forEach((function(name) {
          deps.push({
            package: {
              name
            },
            path: tree.path,
            parent: tree,
            isMissing: !0
          }), types[name] || (types[name] = "devDependencies");
        })), opts["save-dev"] ? (deps = deps.filter((function(dep) {
          return pkg.devDependencies[moduleName(dep)];
        }))).forEach((function(dep) {
          types[moduleName(dep)] = "devDependencies";
        })) : opts.save ? deps = deps.filter((function(dep) {
          return !pkg.optionalDependencies[moduleName(dep)];
        })) : opts["save-optional"] && (deps = deps.filter((function(dep) {
          return pkg.optionalDependencies[moduleName(dep)];
        }))).forEach((function(dep) {
          types[moduleName(dep)] = "optionalDependencies";
        })), (dev || !prod && !Object.keys(parentHas).length && !opts.global) && Object.keys(pkg.devDependencies || {}).forEach((function(k) {
          k in parentHas || (deps[k] = pkg.devDependencies[k], types[k] = "devDependencies");
        }));
        var has = Object.create(parentHas);
        tree.children.forEach((function(child) {
          moduleName(child) && child.package.private && (deps = deps.filter((function(dep) {
            return dep !== child;
          }))), has[moduleName(child)] = {
            version: child.isLink ? "linked" : child.package.version,
            from: child.isLink ? "file:" + child.path : child.package._from
          };
        })), asyncMap(deps, (function(dep, cb) {
          var required, name = moduleName(dep);
          if (tree.package.dependencies && name in tree.package.dependencies ? required = tree.package.dependencies[name] : tree.package.optionalDependencies && name in tree.package.optionalDependencies ? required = tree.package.optionalDependencies[name] : tree.package.devDependencies && name in tree.package.devDependencies ? required = tree.package.devDependencies[name] : has[name] && (required = computeVersionSpec(tree, dep)), 
          !long) return shouldUpdate(args, dep, name, has, required, depth, path, opts, cb);
          shouldUpdate(args, dep, name, has, required, depth, path, opts, cb, types[name]);
        }), cb);
      }
      function shouldUpdate(args, tree, dep, has, req, depth, pkgpath, opts, cb, type) {
        var curr = has[dep];
        function skip(er) {
          if (er) return cb(er);
          outdated_(args, pkgpath, tree, has, depth + 1, opts, cb);
        }
        if (args.length && -1 === args.indexOf(dep)) return skip();
        if (tree.isLink && null == req) return skip();
        null != req && "" !== req || (req = "*");
        var latestRegistryVersion, parsed = npa.resolve(dep, req);
        return "directory" === parsed.type ? tree.isLink ? skip() : doIt("linked", "linked") : "git" === parsed.type ? doIt("git", "git") : "file" === parsed.type ? void fetchPackageMetadata("file:" + parsed.fetchSpec, ".", ((er, localDependency) => {
          if (er) return cb();
          var wanted = localDependency.version, latest = localDependency.version;
          latestRegistryVersion && (latest = latestRegistryVersion, semver.lt(wanted, latestRegistryVersion) && (wanted = latestRegistryVersion, 
          req = dep + "@" + latest)), curr && curr.version === wanted ? skip() : doIt(wanted, latest);
        })) : "remote" === parsed.type ? doIt("remote", "remote") : packument(parsed, opts.concat({
          "prefer-online": !0
        })).nodeify((function(er, d) {
          if (er) return cb(er);
          "alias" === parsed.type && (req = parsed.subSpec.rawSpec);
          try {
            var l = pickManifest(d, "latest"), m = pickManifest(d, req);
          } catch (er) {
            return "ETARGET" === er.code || "E403" === er.code ? skip(er) : skip();
          }
          var dFromUrl = m._from && url.parse(m._from).protocol, cFromUrl = curr && curr.from && url.parse(curr.from).protocol;
          !curr || dFromUrl && cFromUrl && m._from !== curr.from || m.version !== curr.version || m.version !== l.version ? "alias" === parsed.type ? doIt(`npm:${parsed.subSpec.name}@${m.version}`, `npm:${parsed.subSpec.name}@${l.version}`) : doIt(m.version, l.version) : skip();
        }));
        function doIt(wanted, latest) {
          let c = curr && curr.version;
          if ("alias" === parsed.type && (c = `npm:${parsed.subSpec.name}@${c}`), !long) return cb(null, [ [ tree, dep, c, wanted, latest, req, null, pkgpath ] ]);
          cb(null, [ [ tree, dep, c, wanted, latest, req, type, pkgpath ] ]);
        }
      }
    },
    80357: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = owner;
      const BB = __webpack_require__(41142), log = __webpack_require__(19334), npa = __webpack_require__(4422), npmConfig = __webpack_require__(23300), npmFetch = __webpack_require__(27382), output = __webpack_require__(1015), otplease = __webpack_require__(83304), packument = __webpack_require__(76111), readLocalPkg = BB.promisify(__webpack_require__(6236)), usage = __webpack_require__(29320), whoami = BB.promisify(__webpack_require__(9364));
      function UsageError() {
        throw Object.assign(new Error(owner.usage), {
          code: "EUSAGE"
        });
      }
      function owner([action, ...args], cb) {
        const opts = npmConfig();
        BB.try((() => {
          switch (action) {
           case "ls":
           case "list":
            return ls(args[0], opts);

           case "add":
            return add(args[0], args[1], opts);

           case "rm":
           case "remove":
            return function(user, pkg, opts) {
              user || UsageError();
              if (!pkg) return readLocalPkg().then((pkg => (pkg || UsageError(), add(user, pkg, opts))));
              log.verbose("owner rm", "%s from %s", user, pkg);
              return withMutation(npa(pkg), user, opts, (function(u, owners) {
                let found = !1;
                const m = owners.filter((function(o) {
                  var match = o.name === user;
                  return found = found || match, !match;
                }));
                if (!found) return log.info("owner rm", "Not a package owner: " + user), !1;
                if (!m.length) throw new Error("Cannot remove all owners of a package.  Add someone else first.");
                return m;
              }));
            }(args[0], args[1], opts);

           default:
            UsageError();
          }
        })).then((data => cb(null, data)), (err => "EUSAGE" === err.code ? cb(err.message) : cb(err)));
      }
      function ls(pkg, opts) {
        if (!pkg) return readLocalPkg().then((pkg => (pkg || UsageError(), ls(pkg, opts))));
        const spec = npa(pkg);
        return packument(spec, opts.concat({
          fullMetadata: !0
        })).then((data => {
          var owners = data.maintainers;
          return owners && owners.length ? output(owners.map((o => `${o.name} <${o.email}>`)).join("\n")) : output("admin party!"), 
          owners;
        }), (err => {
          throw log.error("owner ls", "Couldn't get owner data", pkg), err;
        }));
      }
      function add(user, pkg, opts) {
        if (user || UsageError(), !pkg) return readLocalPkg().then((pkg => (pkg || UsageError(), 
        add(user, pkg, opts))));
        log.verbose("owner add", "%s to %s", user, pkg);
        return withMutation(npa(pkg), user, opts, ((u, owners) => {
          owners || (owners = []);
          for (var i = 0, l = owners.length; i < l; i++) {
            var o = owners[i];
            if (o.name === u.name) return log.info("owner add", "Already a package owner: " + o.name + " <" + o.email + ">"), 
            !1;
          }
          return owners.push(u), owners;
        }));
      }
      function withMutation(spec, user, opts, mutation) {
        return BB.try((() => {
          if (user) {
            const uri = `/-/user/org.couchdb.user:${encodeURIComponent(user)}`;
            return npmFetch.json(uri, opts).then(mutate_, (err => {
              throw log.error("owner mutate", "Error getting user data for %s", user), err;
            }));
          }
          return mutate_(null);
        }));
        function mutate_(u) {
          if (user && (!u || u.error)) throw new Error("Couldn't get user data for " + user + ": " + JSON.stringify(u));
          return u && (u = {
            name: u.name,
            email: u.email
          }), packument(spec, opts.concat({
            fullMetadata: !0
          })).then((data => {
            const beforeMutation = data.maintainers.length, m = mutation(u, data.maintainers);
            if (!m) return;
            if (m instanceof Error) throw m;
            data = {
              _id: data._id,
              _rev: data._rev,
              maintainers: m
            };
            const dataPath = `/${spec.escapedName}/-rev/${encodeURIComponent(data._rev)}`;
            return otplease(opts, (opts => {
              const reqOpts = opts.concat({
                method: "PUT",
                body: data,
                spec
              });
              return npmFetch.json(dataPath, reqOpts);
            })).then((data => {
              if (data.error) throw new Error("Failed to update package metadata: " + JSON.stringify(data));
              return m.length > beforeMutation ? output("+ %s (%s)", user, spec.name) : m.length < beforeMutation && output("- %s (%s)", user, spec.name), 
              data;
            }));
          }));
        }
      }
      owner.usage = usage("owner", "npm owner add <user> [<@scope>/]<pkg>\nnpm owner rm <user> [<@scope>/]<pkg>\nnpm owner ls [<@scope>/]<pkg>"), 
      owner.completion = function(opts, cb) {
        const argv = opts.conf.argv.remain;
        if (argv.length > 4) return cb();
        if (argv.length <= 2) {
          var subs = [ "add", "rm" ];
          return "l" === opts.partialWord ? subs.push("ls") : subs.push("ls", "list"), cb(null, subs);
        }
        BB.try((() => {
          const opts = npmConfig();
          return whoami([], !0).then((username => {
            const un = encodeURIComponent(username);
            let byUser, theUser;
            switch (argv[2]) {
             case "ls":
              return;

             case "rm":
              if (argv.length > 3) return theUser = encodeURIComponent(argv[3]), byUser = `/-/by-user/${theUser}|${un}`, 
              npmFetch.json(byUser, opts).then((d => d[theUser].filter((p => "isaacs" === un || -1 === d[un].indexOf(p)))));

             case "add":
              return argv.length > 3 ? (theUser = encodeURIComponent(argv[3]), byUser = `/-/by-user/${theUser}|${un}`, 
              npmFetch.json(byUser, opts).then((d => {
                var mine = d[un] || [], theirs = d[theUser] || [];
                return mine.filter((p => -1 === theirs.indexOf(p)));
              }))) : npmFetch.json("/-/users", opts).then((list => Object.keys(list).filter((n => n !== un))));

             default:
              return cb();
            }
          }));
        })).nodeify(cb);
      };
    },
    23447: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const npmConfig = __webpack_require__(23300), fetch = __webpack_require__(27382), figgyPudding = __webpack_require__(55212), log = __webpack_require__(19334), npm = __webpack_require__(44874), output = __webpack_require__(1015), PingConfig = figgyPudding({
        json: {},
        registry: {}
      });
      function ping(args, silent, cb) {
        "function" != typeof cb && (cb = silent, silent = !1);
        const opts = PingConfig(npmConfig()), registry = opts.registry;
        log.notice("PING", registry);
        const start = Date.now();
        return fetch("/-/ping?write=true", opts).then((res => res.json().catch((() => ({}))))).then((details => {
          if (silent) ; else {
            const time = Date.now() - start;
            log.notice("PONG", time / 1e3 + "ms"), npm.config.get("json") ? output(JSON.stringify({
              registry,
              time,
              details
            }, null, 2)) : Object.keys(details).length && log.notice("PONG", `${JSON.stringify(details, null, 2)}`);
          }
        })).nodeify(cb);
      }
      module.exports = ping, ping.usage = "npm ping\nping registry";
    },
    5240: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = prefix;
      var npm = __webpack_require__(44874), output = __webpack_require__(1015);
      function prefix(args, silent, cb) {
        "function" != typeof cb && (cb = silent, silent = !1), silent || output(npm.prefix), 
        process.nextTick(cb.bind(this, null, npm.prefix));
      }
      prefix.usage = "npm prefix [-g]";
    },
    24709: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const BB = __webpack_require__(41142), ansistyles = __webpack_require__(65308), figgyPudding = __webpack_require__(55212), inspect = __webpack_require__(73837).inspect, log = __webpack_require__(19334), npm = __webpack_require__(44874), npmConfig = __webpack_require__(23300), otplease = __webpack_require__(83304), output = __webpack_require__(1015), profile = __webpack_require__(29668), pulseTillDone = __webpack_require__(26549), qrcodeTerminal = __webpack_require__(50860), queryString = __webpack_require__(75781), qw = __webpack_require__(63191), readUserInfo = __webpack_require__(87121), Table = __webpack_require__(27275), url = __webpack_require__(57310);
      function withCb(prom, cb) {
        prom.then((value => cb(null, value)), cb);
      }
      module.exports = profileCmd, profileCmd.usage = "npm profile enable-2fa [auth-only|auth-and-writes]\nnpm profile disable-2fa\nnpm profile get [<key>]\nnpm profile set <key> <value>", 
      profileCmd.subcommands = qw`enable-2fa disable-2fa get set`, profileCmd.completion = function(opts, cb) {
        var argv = opts.conf.argv.remain;
        switch (argv[2]) {
         case "enable-2fa":
         case "enable-tfa":
          return 3 === argv.length ? cb(null, qw`auth-and-writes auth-only`) : cb(null, []);

         case "disable-2fa":
         case "disable-tfa":
         case "get":
         case "set":
          return cb(null, []);

         default:
          return cb(new Error(argv[2] + " not recognized"));
        }
      };
      const ProfileOpts = figgyPudding({
        json: {},
        otp: {},
        parseable: {},
        registry: {}
      });
      function profileCmd(args, cb) {
        if (0 === args.length) return cb(new Error(profileCmd.usage));
        switch (log.gauge.show("profile"), args[0]) {
         case "enable-2fa":
         case "enable-tfa":
         case "enable2fa":
         case "enabletfa":
          withCb(function(args) {
            if (args.length > 1) return Promise.reject(new Error("npm profile enable-2fa [auth-and-writes|auth-only]"));
            const mode = args[0] || "auth-and-writes";
            if ("auth-only" !== mode && "auth-and-writes" !== mode) return Promise.reject(new Error(`Invalid two-factor authentication mode "${mode}".\nValid modes are:\n  auth-only - Require two-factor authentication only when logging in\n  auth-and-writes - Require two-factor authentication when logging in AND when publishing`));
            const conf = ProfileOpts(npmConfig());
            if (conf.json || conf.parseable) return Promise.reject(new Error("Enabling two-factor authentication is an interactive operation and " + (conf.json ? "JSON" : "parseable") + " output mode is not available"));
            const info = {
              tfa: {
                mode
              }
            };
            return BB.try((() => {
              const auth = function(conf) {
                const creds = npm.config.getCredentialsByURI(conf.registry);
                let auth;
                if (creds.token) auth = {
                  token: creds.token
                }; else if (creds.username) auth = {
                  basic: {
                    username: creds.username,
                    password: creds.password
                  }
                }; else if (creds.auth) {
                  const basic = Buffer.from(creds.auth, "base64").toString().split(":", 2);
                  auth = {
                    basic: {
                      username: basic[0],
                      password: basic[1]
                    }
                  };
                } else auth = {};
                conf.otp && (auth.otp = conf.otp);
                return auth;
              }(conf);
              if (auth.basic) return log.info("profile", "Updating authentication to bearer token"), 
              profile.createToken(auth.basic.password, !1, [], conf).then((result => {
                if (!result.token) throw new Error("Your registry " + conf.registry + "does not seem to support bearer tokens. Bearer tokens are required for two-factor authentication");
                return npm.config.setCredentialsByURI(conf.registry, {
                  token: result.token
                }), BB.fromNode((cb => npm.config.save("user", cb)));
              }));
            })).then((() => (log.notice("profile", "Enabling two factor authentication for " + mode), 
            readUserInfo.password()))).then((password => (info.tfa.password = password, log.info("profile", "Determine if tfa is pending"), 
            pulseTillDone.withPromise(profile.get(conf)).then((info => {
              if (info.tfa) {
                if (info.tfa.pending) return log.info("profile", "Resetting two-factor authentication"), 
                pulseTillDone.withPromise(profile.set({
                  tfa: {
                    password,
                    mode: "disable"
                  }
                }, conf));
                if (!conf.auth.otp) return readUserInfo.otp("Enter one-time password: ").then((otp => {
                  conf.auth.otp = otp;
                }));
              }
            }))))).then((() => (log.info("profile", "Setting two-factor authentication to " + mode), 
            pulseTillDone.withPromise(profile.set(info, conf))))).then((challenge => {
              if (null === challenge.tfa) return void output("Two factor authentication mode changed to: " + mode);
              if ("string" != typeof challenge.tfa || !/^otpauth:[/][/]/.test(challenge.tfa)) throw new Error("Unknown error enabling two-factor authentication. Expected otpauth URL, got: " + inspect(challenge.tfa));
              const otpauth = url.parse(challenge.tfa), opts = queryString.parse(otpauth.query);
              return function(url) {
                return new Promise((resolve => qrcodeTerminal.generate(url, resolve)));
              }(challenge.tfa).then((code => {
                output("Scan into your authenticator app:\n" + code + "\n Or enter code:", opts.secret);
              })).then((code => readUserInfo.otp("And an OTP code from your authenticator: "))).then((otp1 => (log.info("profile", "Finalizing two-factor authentication"), 
              profile.set({
                tfa: [ otp1 ]
              }, conf)))).then((result => {
                output("2FA successfully enabled. Below are your recovery codes, please print these out."), 
                output("You will need these to recover access to your account if you lose your authentication device."), 
                result.tfa.forEach((c => output("\t" + c)));
              }));
            }));
          }(args.slice(1)), cb);
          break;

         case "disable-2fa":
         case "disable-tfa":
         case "disable2fa":
         case "disabletfa":
          withCb(function(args) {
            let conf = ProfileOpts(npmConfig());
            return pulseTillDone.withPromise(profile.get(conf)).then((info => {
              if (info.tfa && !info.tfa.pending) return readUserInfo.password().then((password => BB.try((() => {
                if (!conf.otp) return readUserInfo.otp("Enter one-time password: ").then((otp => {
                  conf = conf.concat({
                    otp
                  });
                }));
              })).then((() => (log.info("profile", "disabling tfa"), pulseTillDone.withPromise(profile.set({
                tfa: {
                  password,
                  mode: "disable"
                }
              }, conf)).then((() => {
                conf.json ? output(JSON.stringify({
                  tfa: !1
                }, null, 2)) : conf.parseable ? output("tfa\tfalse") : output("Two factor authentication disabled.");
              })))))));
              output("Two factor authentication not enabled.");
            }));
          }(), cb);
          break;

         case "get":
          withCb(function(args) {
            const tfa = "two-factor auth", conf = ProfileOpts(npmConfig());
            return pulseTillDone.withPromise(profile.get(conf)).then((info => {
              if (info.cidr_whitelist || delete info.cidr_whitelist, conf.json) return void output(JSON.stringify(info, null, 2));
              const cleaned = {};
              if (knownProfileKeys.forEach((k => {
                cleaned[k] = info[k] || "";
              })), Object.keys(info).filter((k => !(k in cleaned))).forEach((k => {
                cleaned[k] = info[k] || "";
              })), delete cleaned.tfa, delete cleaned.email_verified, cleaned.email += info.email_verified ? " (verified)" : "(unverified)", 
              info.tfa && !info.tfa.pending ? cleaned[tfa] = info.tfa.mode : cleaned[tfa] = "disabled", 
              args.length) {
                const values = args.join(",").split(/,/).map((arg => arg.trim())).filter((arg => "" !== arg)).map((arg => cleaned[arg])).join("\t");
                output(values);
              } else if (conf.parseable) Object.keys(info).forEach((key => {
                output("tfa" === key ? `${key}\t${cleaned[tfa]}` : `${key}\t${info[key]}`);
              })); else {
                const table = new Table;
                Object.keys(cleaned).forEach((k => table.push({
                  [ansistyles.bright(k)]: cleaned[k]
                }))), output(table.toString());
              }
            }));
          }(args.slice(1)), cb);
          break;

         case "set":
          withCb(function(args) {
            let conf = ProfileOpts(npmConfig());
            const prop = (args[0] || "").toLowerCase().trim();
            let value = args.length > 1 ? args.slice(1).join(" ") : null;
            if ("password" !== prop && null === value) return Promise.reject(Error("npm profile set <prop> <value>"));
            if ("password" === prop && null !== value) return Promise.reject(Error("npm profile set password\nDo not include your current or new passwords on the command line."));
            if (-1 === writableProfileKeys.indexOf(prop)) return Promise.reject(Error(`"${prop}" is not a property we can set. Valid properties are: ` + writableProfileKeys.join(", ")));
            return BB.try((() => {
              if ("password" === prop) return readUserInfo.password("Current password: ").then((current => readPasswords().then((newpassword => {
                value = {
                  old: current,
                  new: newpassword
                };
              }))));
              if ("email" === prop) return readUserInfo.password("Password: ").then((current => ({
                password: current,
                email: value
              })));
              function readPasswords() {
                return readUserInfo.password("New password: ").then((password1 => readUserInfo.password("       Again:     ").then((password2 => password1 !== password2 ? (log.warn("profile", "Passwords do not match, please try again."), 
                readPasswords()) : password1))));
              }
            })).then((() => pulseTillDone.withPromise(profile.get(conf).then((user => {
              const newUser = {};
              return writableProfileKeys.forEach((k => {
                newUser[k] = user[k];
              })), newUser[prop] = value, otplease(conf, (conf => profile.set(newUser, conf))).then((result => {
                conf.json ? output(JSON.stringify({
                  [prop]: result[prop]
                }, null, 2)) : conf.parseable ? output(prop + "\t" + result[prop]) : null != result[prop] ? output("Set", prop, "to", result[prop]) : output("Set", prop);
              }));
            })))));
          }(args.slice(1)), cb);
          break;

         default:
          cb(new Error("Unknown profile command: " + args[0]));
        }
      }
      const knownProfileKeys = qw`
  name email ${"two-factor auth"} fullname homepage
  freenode twitter github created updated`;
      const writableProfileKeys = qw`
  email password fullname homepage freenode twitter github`;
    },
    50970: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = prune, module.exports.Pruner = Pruner, prune.usage = "npm prune [[<@scope>/]<pkg>...] [--production]";
      var npm = __webpack_require__(44874), log = __webpack_require__(19334), util = __webpack_require__(73837), moduleName = __webpack_require__(7802), Installer = __webpack_require__(70913).Installer, isExtraneous = __webpack_require__(66305), isOnlyDev = __webpack_require__(35528), removeDeps = __webpack_require__(48045).removeDeps, loadExtraneous = __webpack_require__(48045).loadExtraneous, chain = __webpack_require__(89009).chain, computeMetadata = __webpack_require__(48045).computeMetadata;
      function prune(args, cb) {
        new Pruner(".", !!npm.config.get("dry-run"), args).run(cb);
      }
      function Pruner(where, dryrun, args) {
        Installer.call(this, where, dryrun, args), this.autoPrune = !0;
      }
      prune.completion = __webpack_require__(46624), util.inherits(Pruner, Installer), 
      Pruner.prototype.loadAllDepsIntoIdealTree = function(cb) {
        log.silly("uninstall", "loadAllDepsIntoIdealTree");
        var cg = this.progress["loadIdealTree:loadAllDepsIntoIdealTree"], steps = [];
        computeMetadata(this.idealTree);
        var self = this, excludeDev = npm.config.get("production") || /^prod(uction)?$/.test(npm.config.get("only"));
        var toPrune = this.idealTree.children.filter((function(child) {
          return !!isExtraneous(child) || !!excludeDev && isOnlyDev(child);
        })).map((function(child) {
          return moduleName(child);
        })).filter((function(name) {
          return 0 === self.args.length || -1 !== self.args.indexOf(name);
        })).map((function(name) {
          return {
            name
          };
        }));
        steps.push([ removeDeps, toPrune, this.idealTree, null ], [ loadExtraneous, this.idealTree, cg.newGroup("loadExtraneous") ]), 
        chain(steps, cb);
      }, Pruner.prototype.runPreinstallTopLevelLifecycles = function(cb) {
        cb();
      }, Pruner.prototype.runPostinstallTopLevelLifecycles = function(cb) {
        cb();
      }, Pruner.prototype.saveToDependencies = function(cb) {
        cb();
      };
    },
    3539: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = rebuild;
      var readInstalled = __webpack_require__(6576), semver = __webpack_require__(73107), log = __webpack_require__(19334), npm = __webpack_require__(44874), npa = __webpack_require__(19932), usage = __webpack_require__(29320), output = __webpack_require__(1015);
      function rebuild(args, cb) {
        var opt = {
          depth: npm.config.get("depth"),
          dev: !0
        };
        readInstalled(npm.prefix, opt, (function(er, data) {
          if (log.info("readInstalled", typeof data), er) return cb(er);
          var set = filter(data, args), folders = Object.keys(set).filter((function(f) {
            return f !== npm.prefix;
          }));
          if (!folders.length) return cb();
          log.silly("rebuild set", folders), function(folders, set, cb) {
            npm.commands.build(folders, (function(er) {
              if (er) return cb(er);
              output(folders.map((function(f) {
                return set[f] + " " + f;
              })).join("\n")), cb();
            }));
          }(folders, set, cb);
        }));
      }
      function filter(data, args, set, seen) {
        if (set || (set = {}), seen || (seen = new Set), set.hasOwnProperty(data.path)) return set;
        if (seen.has(data)) return set;
        var pass;
        if (seen.add(data), args.length) {
          if (data.name && data._id) for (var i = 0, l = args.length; i < l; i++) {
            var arg = args[i], nv = npa(arg), n = nv.name, v = nv.rawSpec;
            if (n === data.name && semver.satisfies(data.version, v, !0)) {
              pass = !0;
              break;
            }
          }
        } else pass = !0;
        return pass && data._id && (log.verbose("rebuild", "path, id", [ data.path, data._id ]), 
        set[data.path] = data._id), Object.keys(data.dependencies || {}).forEach((function(d) {
          var dep = data.dependencies[d];
          "string" != typeof dep && filter(dep, args, set, seen);
        })), set;
      }
      rebuild.usage = usage("rebuild", "npm rebuild [[<@scope>/<name>]...]"), rebuild.completion = __webpack_require__(46624);
    },
    13057: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = repo, repo.usage = "npm repo [<pkg>]";
      const openUrl = __webpack_require__(89562), hostedGitInfo = __webpack_require__(71438), url_ = __webpack_require__(57310), fetchPackageMetadata = __webpack_require__(3138);
      function repo(args, cb) {
        const n = args.length ? args[0] : ".";
        fetchPackageMetadata(n, ".", {
          fullMetadata: !0
        }, (function(er, d) {
          if (er) return cb(er);
          !function(d, cb) {
            const r = d.repository;
            if (!r) return cb(new Error("no repository"));
            const info = hostedGitInfo.fromUrl(r.url), url = info ? info.browse() : function(url) {
              try {
                const idx = url.indexOf("@");
                -1 !== idx && (url = url.slice(idx + 1).replace(/:([^\d]+)/, "/$1")), url = url_.parse(url);
                return ("https:" === url.protocol ? "https:" : "http:") + "//" + (url.host || "") + url.path.replace(/\.git$/, "");
              } catch (e) {}
            }(r.url);
            if (!url) return cb(new Error("no repository: could not get url"));
            openUrl(url, "repository available at the following URL", cb);
          }(d, cb);
        }));
      }
      repo.completion = function(opts, cb) {
        cb();
      };
    },
    85933: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = __webpack_require__(6444)("restart");
    },
    30176: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = root;
      const npm = __webpack_require__(44874), output = __webpack_require__(1015);
      function root(args, silent, cb) {
        "function" != typeof cb && (cb = silent, silent = !1), silent || output(npm.dir), 
        process.nextTick(cb.bind(this, null, npm.dir));
      }
      root.usage = "npm root [-g]";
    },
    54948: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = runScript;
      var lifecycle = __webpack_require__(4705), npm = __webpack_require__(44874), path = __webpack_require__(71017), readJson = __webpack_require__(92200), log = __webpack_require__(19334), chain = __webpack_require__(89009).chain, usage = __webpack_require__(29320), output = __webpack_require__(1015), didYouMean = __webpack_require__(90594), isWindowsShell = __webpack_require__(98892);
      function runScript(args, cb) {
        if (!args.length) return function(cb) {
          var json = path.join(npm.localPrefix, "package.json"), cmdList = [ "publish", "install", "uninstall", "test", "stop", "start", "restart", "version" ].reduce((function(l, p) {
            return l.concat([ "pre" + p, p, "post" + p ]);
          }), []);
          return readJson(json, (function(er, d) {
            if (er && "ENOENT" !== er.code && "ENOTDIR" !== er.code) return cb(er);
            er && (d = {});
            var allScripts = Object.keys(d.scripts || {}), scripts = [], runScripts = [];
            if (allScripts.forEach((function(script) {
              -1 !== cmdList.indexOf(script) ? scripts.push(script) : runScripts.push(script);
            })), "silent" === log.level) return cb(null, allScripts);
            if (npm.config.get("json")) return output(JSON.stringify(d.scripts || {}, null, 2)), 
            cb(null, allScripts);
            if (npm.config.get("parseable")) return allScripts.forEach((function(script) {
              output(script + ":" + d.scripts[script]);
            })), cb(null, allScripts);
            var s = "\n    ", prefix = "  ";
            return scripts.length && output("Lifecycle scripts included in %s:", d.name), scripts.forEach((function(script) {
              output(prefix + script + s + d.scripts[script]);
            })), !scripts.length && runScripts.length ? output("Scripts available in %s via `npm run-script`:", d.name) : runScripts.length && output("\navailable via `npm run-script`:"), 
            runScripts.forEach((function(script) {
              output(prefix + script + s + d.scripts[script]);
            })), cb(null, allScripts);
          }));
        }(cb);
        var pkgdir = npm.localPrefix, cmd = args.shift();
        readJson(path.resolve(pkgdir, "package.json"), (function(er, d) {
          if (er) return cb(er);
          !function(pkg, wd, cmd, args, cb) {
            pkg.scripts || (pkg.scripts = {});
            var cmds;
            if ("restart" !== cmd || pkg.scripts.restart) {
              if (null == pkg.scripts[cmd]) if ("test" === cmd) pkg.scripts.test = "echo 'Error: no test specified'"; else {
                if ("env" !== cmd) {
                  if (npm.config.get("if-present")) return cb(null);
                  {
                    let suggestions = didYouMean(cmd, Object.keys(pkg.scripts));
                    return suggestions = suggestions ? "\n" + suggestions : "", cb(new Error("missing script: " + cmd + suggestions));
                  }
                }
                isWindowsShell ? (log.verbose("run-script using default platform env: SET (Windows)"), 
                pkg.scripts[cmd] = "SET") : (log.verbose("run-script using default platform env: env (Unix)"), 
                pkg.scripts[cmd] = "env");
              }
              cmds = [ cmd ];
            } else cmds = [ "prestop", "stop", "poststop", "restart", "prestart", "start", "poststart" ];
            cmd.match(/^(pre|post)/) || (cmds = [ "pre" + cmd ].concat(cmds).concat("post" + cmd));
            log.verbose("run-script", cmds), chain(cmds.map((function(c) {
              return pkg.scripts[c] && c === cmd && (pkg.scripts[c] = pkg.scripts[c] + function(args) {
                var joinedArgs = "";
                return args.forEach((function(arg) {
                  joinedArgs += ' "' + arg.replace(/"/g, '\\"') + '"';
                })), joinedArgs;
              }(args)), [ lifecycle, pkg, c, wd, {
                unsafePerm: !0
              } ];
            })), cb);
          }(d, pkgdir, cmd, args, cb);
        }));
      }
      runScript.usage = usage("run-script", "npm run-script <command> [-- <args>...]"), 
      runScript.completion = function(opts, cb) {
        var argv = opts.conf.argv.remain;
        if (argv.length >= 4) return cb();
        if (3 === argv.length) {
          var json = path.join(npm.localPrefix, "package.json");
          return readJson(json, (function(er, d) {
            if (er && "ENOENT" !== er.code && "ENOTDIR" !== er.code) return cb(er);
            er && (d = {});
            var scripts = Object.keys(d.scripts || {});
            if (console.error("local scripts", scripts), -1 !== scripts.indexOf(argv[2])) return cb();
            var pref = npm.config.get("global") ? npm.config.get("prefix") : npm.localPrefix, pkgDir = path.resolve(pref, "node_modules", argv[2], "package.json");
            readJson(pkgDir, (function(er, d) {
              if (er && "ENOENT" !== er.code && "ENOTDIR" !== er.code) return cb(er);
              er && (d = {});
              var scripts = Object.keys(d.scripts || {});
              return cb(null, scripts);
            }));
          }));
        }
        readJson(path.join(npm.localPrefix, "package.json"), (function(er, d) {
          if (er && "ENOENT" !== er.code && "ENOTDIR" !== er.code) return cb(er);
          d = d || {}, cb(null, Object.keys(d.scripts || {}));
        }));
      };
    },
    97535: (module, exports, __webpack_require__) => {
      "use strict";
      module.exports = search;
      const npm = __webpack_require__(44874), allPackageSearch = __webpack_require__(43456), figgyPudding = __webpack_require__(55212), formatPackageStream = __webpack_require__(73728), libSearch = __webpack_require__(44323), log = __webpack_require__(19334), ms = __webpack_require__(30498), npmConfig = __webpack_require__(23300), output = __webpack_require__(1015), usage = __webpack_require__(29320);
      search.usage = usage("search", "npm search [--long] [search terms ...]"), search.completion = function(opts, cb) {
        cb(null, []);
      };
      const SearchOpts = figgyPudding({
        description: {},
        exclude: {},
        include: {},
        limit: {},
        log: {},
        staleness: {},
        unicode: {}
      });
      function search(args, cb) {
        const opts = SearchOpts(npmConfig()).concat({
          description: npm.config.get("description"),
          exclude: prepareExcludes(npm.config.get("searchexclude")),
          include: prepareIncludes(args, npm.config.get("searchopts")),
          limit: npm.config.get("searchlimit") || 20,
          log,
          staleness: npm.config.get("searchstaleness"),
          unicode: npm.config.get("unicode")
        });
        if (0 === opts.include.length) return cb(new Error("search must be called with arguments"));
        let anyOutput = !1;
        const entriesStream = ms.through.obj();
        let esearchWritten = !1;
        libSearch.stream(opts.include, opts).on("data", (pkg => {
          entriesStream.write(pkg), !esearchWritten && (esearchWritten = !0);
        })).on("error", (err => {
          if (esearchWritten) return entriesStream.emit("error", err);
          log.warn("search", "fast search endpoint errored. Using old search."), allPackageSearch(opts).on("data", (pkg => entriesStream.write(pkg))).on("error", (err => entriesStream.emit("error", err))).on("end", (() => entriesStream.end()));
        })).on("end", (() => entriesStream.end()));
        var outputStream = formatPackageStream({
          args,
          long: npm.config.get("long"),
          description: npm.config.get("description"),
          json: npm.config.get("json"),
          parseable: npm.config.get("parseable"),
          color: npm.color
        });
        outputStream.on("data", (chunk => {
          anyOutput || (anyOutput = !0), output(chunk.toString("utf8"));
        })), log.silly("search", "searching packages"), ms.pipe(entriesStream, outputStream, (err => {
          if (err) return cb(err);
          anyOutput || npm.config.get("json") || npm.config.get("parseable") || output("No matches found for " + args.map(JSON.stringify).join(" ")), 
          log.silly("search", "search completed"), log.clearProgress(), cb(null, {});
        }));
      }
      function prepareIncludes(args, searchopts) {
        return "string" != typeof searchopts && (searchopts = ""), searchopts.split(/\s+/).concat(args).map((function(s) {
          return s.toLowerCase();
        })).filter((function(s) {
          return s;
        }));
      }
      function prepareExcludes(searchexclude) {
        return ("string" == typeof searchexclude ? searchexclude.split(/\s+/) : []).map((function(s) {
          return s.toLowerCase();
        }));
      }
    },
    37379: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const BB = __webpack_require__(41142), cacheFile = __webpack_require__(79831), chownr = BB.promisify(__webpack_require__(13159)), correctMkdir = BB.promisify(__webpack_require__(79501)), figgyPudding = __webpack_require__(55212), fs = __webpack_require__(59799), JSONStream = __webpack_require__(93012), log = __webpack_require__(19334), mkdir = BB.promisify(__webpack_require__(33169).mkdir), ms = __webpack_require__(30498), npmFetch = __webpack_require__(27382), path = __webpack_require__(71017), sortedUnionStream = __webpack_require__(7195), url = __webpack_require__(57310), writeStreamAtomic = __webpack_require__(63322), statAsync = BB.promisify(fs.stat), APMOpts = figgyPudding({
        cache: {},
        registry: {}
      });
      function createEntryStream(cachePath, staleness, opts) {
        return createCacheEntryStream(cachePath, opts).catch((err => (log.warn("", "Failed to read search cache. Rebuilding"), 
        log.silly("all-package-metadata", "cache read error: ", err), {}))).then((({updateStream: cacheStream, updatedLatest: cacheLatest}) => createEntryUpdateStream(staleness, cacheLatest = cacheLatest || 0, opts).catch((err => (log.warn("", "Search data request failed, search might be stale"), 
        log.silly("all-package-metadata", "update request error: ", err), {}))).then((({updateStream, updatedLatest}) => {
          const latest = (updatedLatest = updatedLatest || 0) || cacheLatest;
          if (!cacheStream && !updateStream) throw new Error("No search sources available");
          return cacheStream && updateStream ? {
            entryStream: createMergedStream(cacheStream, updateStream),
            latest,
            newEntries: !!updatedLatest
          } : {
            entryStream: cacheStream || updateStream,
            latest,
            newEntries: !!updatedLatest
          };
        }))));
      }
      function createMergedStream(a, b) {
        return linkStreams(a, b), sortedUnionStream(b, a, (({name}) => name));
      }
      function createCacheEntryStream(cacheFile, opts) {
        return log.verbose("all-package-metadata", "creating entry stream from local cache"), 
        log.verbose("all-package-metadata", cacheFile), statAsync(cacheFile).then((stat => extractUpdated(ms.pipeline.obj(fs.createReadStream(cacheFile), JSONStream.parse("*"), ms.through.obj()), "cached-entry-stream", opts)));
      }
      function createEntryUpdateStream(staleness, latest, opts) {
        log.verbose("all-package-metadata", "creating remote entry stream");
        let partialUpdate = !1, uri = "/-/all";
        return latest && Date.now() - latest < 1e3 * staleness ? (log.verbose("all-package-metadata", "Local data up to date, skipping update"), 
        BB.resolve({})) : (0 === latest ? (log.warn("", "Building the local index for the first time, please be patient"), 
        log.verbose("all-package-metadata", "No cached data: requesting full metadata db")) : (log.verbose("all-package-metadata", "Cached data present with timestamp:", latest, "requesting partial index update"), 
        uri += "/since?stale=update_after&startkey=" + latest, partialUpdate = !0), npmFetch(uri, opts).then((res => {
          log.silly("all-package-metadata", "request stream opened, code:", res.statusCode);
          let entryStream = ms.pipeline.obj(res.body, JSONStream.parse("*", ((pkg, key) => {
            if ("_updated" === key[0] || "_" !== key[0][0]) return pkg;
          })));
          return partialUpdate ? {
            updateStream: entryStream,
            updatedLatest: Date.parse(res.headers.get("date"))
          } : extractUpdated(entryStream, "entry-update-stream", opts);
        })));
      }
      function extractUpdated(entryStream, label, opts) {
        return log.silly("all-package-metadata", "extracting latest"), new BB(((resolve, reject) => {
          function nope(msg) {
            return function() {
              log.warn("all-package-metadata", label, msg), entryStream.removeAllListeners(), 
              entryStream.destroy(), reject(new Error(msg));
            };
          }
          const onErr = nope("Failed to read stream"), onEnd = nope("Empty or invalid stream");
          entryStream.on("error", onErr), entryStream.on("end", onEnd), entryStream.once("data", (latest => {
            log.silly("all-package-metadata", "got first stream entry for", label, latest), 
            entryStream.removeListener("error", onErr), entryStream.removeListener("end", onEnd), 
            "number" == typeof latest ? resolve({
              updateStream: entryStream.pipe(ms.through.obj()),
              updatedLatest: latest
            }) : reject(new Error("expected first entry to be _updated"));
          }));
        }));
      }
      function createCacheWriteStream(cacheFile, latest, opts) {
        return function(cacheFile, opts) {
          var cacheBase = path.dirname(cacheFile);
          return log.silly("all-package-metadata", "making sure cache dir exists at", cacheBase), 
          correctMkdir(opts.cache).then((st => mkdir(cacheBase).then((made => chownr(made || cacheBase, st.uid, st.gid))).then((() => ({
            uid: st.uid,
            gid: st.gid
          })))));
        }(cacheFile, opts).then((({uid, gid}) => {
          log.silly("all-package-metadata", "creating output stream");
          const outStream = ms.pipeline.obj(ms.through(), JSONStream.parse("*", ((obj, key) => {
            if ("object" == typeof obj) return obj;
          })), ms.through.obj()), cacheFileStream = writeStreamAtomic(cacheFile), inputStream = function(writer, outStream, latest) {
            let updatedWritten = !1;
            const inStream = ms.pipeline.obj(ms.through.obj(((pkg, enc, cb) => {
              if (!updatedWritten && "number" == typeof pkg) return updatedWritten = !0, cb(null, [ "_updated", pkg ]);
              "object" != typeof pkg ? this.emit("error", new Error("invalid value written to input stream")) : cb(null, [ pkg.name, pkg ]);
            })), JSONStream.stringifyObject("{", ",", "}"), ms.through(((chunk, enc, cb) => {
              outStream.write(chunk, enc, (() => cb(null, chunk)));
            })), writer);
            return inStream.write(latest), inStream;
          }(cacheFileStream, outStream, latest);
          let errEmitted = !1;
          return linkStreams(inputStream, outStream, (() => {
            errEmitted = !0;
          })), cacheFileStream.on("close", (() => {
            errEmitted || ("number" == typeof uid && "number" == typeof gid && process.getuid && process.getgid && (process.getuid() !== uid || process.getgid() !== gid) && chownr.sync(cacheFile, uid, gid), 
            outStream.end());
          })), ms.duplex.obj(inputStream, outStream);
        }));
      }
      function linkStreams(a, b, cb) {
        var lastError = null;
        a.on("error", (function(err) {
          err !== lastError && (lastError = err, b.emit("error", err), cb && cb(err));
        })), b.on("error", (function(err) {
          err !== lastError && (lastError = err, a.emit("error", err), cb && cb(err));
        }));
      }
      module.exports = function(opts) {
        const staleness = opts.staleness, stream = ms.through.obj();
        opts = APMOpts(opts);
        const cacheBase = cacheFile(path.resolve(path.dirname(opts.cache)))(url.resolve(opts.registry, "/-/all")), cachePath = path.join(cacheBase, ".cache.json");
        return createEntryStream(cachePath, staleness, opts).then((({entryStream, latest, newEntries}) => {
          if (log.silly("all-package-metadata", "entry stream created"), entryStream && newEntries) return createCacheWriteStream(cachePath, latest, opts).then((writer => {
            log.silly("all-package-metadata", "output stream created"), ms.pipeline.obj(entryStream, writer, stream);
          }));
          entryStream ? ms.pipeline.obj(entryStream, stream) : stream.emit("error", new Error("No search sources available"));
        })).catch((err => stream.emit("error", err))), stream;
      }, module.exports._createEntryStream = createEntryStream, module.exports._createMergedStream = createMergedStream, 
      module.exports._createCacheEntryStream = createCacheEntryStream, module.exports._createEntryUpdateStream = createEntryUpdateStream, 
      module.exports._createCacheWriteStream = createCacheWriteStream;
    },
    43456: (module, __unused_webpack_exports, __webpack_require__) => {
      var ms = __webpack_require__(30498), allPackageMetadata = __webpack_require__(37379), packageFilter = __webpack_require__(81111);
      module.exports = function(opts) {
        var searchSection = (opts.unicode ? " " : "") + "search", allEntriesStream = allPackageMetadata(opts), filterStream = (filter = function(pkg) {
          return opts.log.gauge.pulse("search"), opts.log.gauge.show({
            section: searchSection,
            logline: "scanning " + pkg.name
          }), packageFilter(pkg, opts.include, opts.exclude, {
            description: opts.description
          });
        }, ms.through.obj((function(data, enc, cb) {
          filter(data) && this.push(function(data) {
            return {
              name: data.name,
              description: data.description,
              maintainers: (data.maintainers || []).map((function(m) {
                return {
                  username: m.name,
                  email: m.email
                };
              })),
              keywords: data.keywords || [],
              version: Object.keys(data.versions || {})[0] || [],
              date: data.time && data.time.modified && new Date(data.time.modified) || null
            };
          }(data)), cb();
        })));
        var filter;
        return ms.pipeline.obj(allEntriesStream, filterStream);
      };
    },
    73728: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var ms = __webpack_require__(30498), jsonstream = __webpack_require__(93012), columnify = __webpack_require__(75231);
      module.exports = function(opts) {
        return (opts = opts || {}).json ? ms.pipeline.obj(ms.through.obj(), jsonstream.stringify("[", ",", "]"), ms.through()) : function(opts) {
          var line = 0;
          return ms.through.obj((function(pkg, enc, cb) {
            cb(null, function(data, num, opts) {
              var truncate = !(opts = opts || {}).long, pkg = function(data, opts) {
                return opts = opts || {}, {
                  name: data.name,
                  description: opts.description ? data.description : "",
                  author: (data.maintainers || []).map((function(m) {
                    return "=" + m.username;
                  })).join(" "),
                  keywords: Array.isArray(data.keywords) ? data.keywords.join(" ") : "string" == typeof data.keywords ? data.keywords.replace(/[,\s]+/, " ") : "",
                  version: data.version,
                  date: data.date && data.date.toISOString().split("T").join(" ").replace(/:[0-9]{2}\.[0-9]{3}Z$/, "").slice(0, -5) || "prehistoric"
                };
              }(data, opts), columns = opts.description ? [ "name", "description", "author", "date", "version", "keywords" ] : [ "name", "author", "date", "version", "keywords" ];
              if (opts.parseable) return columns.map((function(col) {
                return pkg[col] && ("" + pkg[col]).replace(/\t/g, " ");
              })).join("\t");
              var output = columnify([ pkg ], {
                include: columns,
                showHeaders: num <= 1,
                columnSplitter: " | ",
                truncate,
                config: {
                  name: {
                    minWidth: 25,
                    maxWidth: 25,
                    truncate: !1,
                    truncateMarker: ""
                  },
                  description: {
                    minWidth: 20,
                    maxWidth: 20
                  },
                  author: {
                    minWidth: 15,
                    maxWidth: 15
                  },
                  date: {
                    maxWidth: 11
                  },
                  version: {
                    minWidth: 8,
                    maxWidth: 8
                  },
                  keywords: {
                    maxWidth: 1 / 0
                  }
                }
              });
              output = function(str) {
                var maxWidth = function() {
                  var cols;
                  try {
                    var tty = __webpack_require__(76224), stdout = process.stdout;
                    cols = 0 === (cols = tty.isatty(stdout.fd) ? process.stdout.getWindowSize()[0] : 1 / 0) ? 1 / 0 : cols;
                  } catch (ex) {
                    cols = 1 / 0;
                  }
                  return cols;
                }();
                return str.split("\n").map((function(line) {
                  return line.slice(0, maxWidth);
                })).join("\n");
              }(output), opts.color && (str = output, opts.args.forEach((function(arg, i) {
                str = function(str, arg, i) {
                  var m = i % cl + 1, markStart = String.fromCharCode(m), markEnd = String.fromCharCode(0);
                  if ("/" === arg.charAt(0)) return str.replace(new RegExp(arg.substr(1, arg.length - 2), "gi"), (function(bit) {
                    return markStart + bit + markEnd;
                  }));
                  var pieces = str.toLowerCase().split(arg.toLowerCase()), p = 0;
                  return pieces.map((function(piece) {
                    piece = str.substr(p, piece.length);
                    var mark = markStart + str.substr(p + piece.length, arg.length) + markEnd;
                    return p += piece.length + arg.length, piece + mark;
                  })).join("");
                }(str, arg, i);
              })), output = function(line) {
                for (var i = 0; i < cl; i++) {
                  var m = i + 1, color = "[" + colors[i] + "m";
                  line = line.split(String.fromCharCode(m)).join(color);
                }
                var uncolor = "[0m";
                return line.split("\0").join(uncolor);
              }(str).trim());
              var str;
              return output;
            }(pkg, ++line, opts));
          }));
        }(opts);
      };
      var colors = [ 31, 33, 32, 36, 34, 35 ], cl = colors.length;
    },
    81111: module => {
      "use strict";
      function match(words, pattern) {
        return "/" === pattern.charAt(0) ? (pattern = pattern.replace(/\/$/, ""), pattern = new RegExp(pattern.substr(1, pattern.length - 1)), 
        words.match(pattern)) : -1 !== words.indexOf(pattern);
      }
      module.exports = function(data, include, exclude, opts) {
        return "object" == typeof data && function(data, include, exclude, opts) {
          for (var words = function(data, opts) {
            return [ data.name ].concat(opts && opts.description ? data.description : []).concat((data.maintainers || []).map((function(m) {
              return "=" + m.name;
            }))).concat(data.versions && data.versions.length && data.url && "<" + data.url + ">").concat(data.keywords || []).map((function(f) {
              return f && f.trim && f.trim();
            })).filter((function(f) {
              return f;
            })).join(" ").toLowerCase();
          }(data, opts), i = 0, l = include.length; i < l; i++) if (!match(words, include[i])) return !1;
          for (i = 0, l = exclude.length; i < l; i++) if (match(words, exclude[i])) return !1;
          return !0;
        }(data, include, exclude, opts);
      };
    },
    7433: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = set, set.usage = "npm set <key> <value> (See `npm config`)";
      var npm = __webpack_require__(44874);
      function set(args, cb) {
        if (!args.length) return cb(set.usage);
        npm.commands.config([ "set" ].concat(args), cb);
      }
      set.completion = npm.commands.config.completion;
    },
    5446: (module, exports, __webpack_require__) => {
      "use strict";
      const BB = __webpack_require__(41142), chain = __webpack_require__(89009).chain, detectIndent = __webpack_require__(78632), detectNewline = __webpack_require__(9637), readFile = BB.promisify(__webpack_require__(59799).readFile), getRequested = __webpack_require__(87517), id = __webpack_require__(48045), iferr = __webpack_require__(17367), isOnlyOptional = __webpack_require__(27849), isOnlyDev = __webpack_require__(35528), lifecycle = __webpack_require__(4705), log = __webpack_require__(19334), moduleName = __webpack_require__(7802), move = __webpack_require__(25315), npm = __webpack_require__(44874), path = __webpack_require__(71017), readPackageTree = BB.promisify(__webpack_require__(7338)), ssri = __webpack_require__(87783), stringifyPackage = __webpack_require__(22652), validate = __webpack_require__(95073), writeFileAtomic = __webpack_require__(19804), unixFormatPath = __webpack_require__(65665), isRegistry = __webpack_require__(80127), {chown} = __webpack_require__(57147), inferOwner = __webpack_require__(84876), selfOwner_uid = process.getuid && process.getuid(), selfOwner_gid = process.getgid && process.getgid(), PKGLOCK = "package-lock.json", SHRINKWRAP = "npm-shrinkwrap.json", PKGLOCK_VERSION = npm.lockfileVersion;
      function shrinkwrap(args, silent, cb) {
        "function" != typeof cb && (cb = silent, silent = !1), args.length && log.warn("shrinkwrap", "doesn't take positional args"), 
        move(path.resolve(npm.prefix, PKGLOCK), path.resolve(npm.prefix, SHRINKWRAP), {
          Promise: BB
        }).then((() => (log.notice("", `${PKGLOCK} has been renamed to ${SHRINKWRAP}. ${SHRINKWRAP} will be used for future installations.`), 
        readFile(path.resolve(npm.prefix, SHRINKWRAP)).then((d => JSON.parse(d))))), (err => {
          if ("ENOENT" !== err.code) throw err;
          return readPackageTree(npm.localPrefix).then(id.computeMetadata).then((tree => BB.fromNode((cb => {
            createShrinkwrap(tree, {
              silent,
              defaultFile: SHRINKWRAP
            }, cb);
          }))));
        })).then((data => cb(null, data)), cb);
      }
      function createShrinkwrap(tree, opts, cb) {
        opts = opts || {}, lifecycle(tree.package, "preshrinkwrap", tree.path, (function() {
          const pkginfo = treeToShrinkwrap(tree);
          chain([ [ lifecycle, tree.package, "shrinkwrap", tree.path ], [ shrinkwrap_, tree.path, pkginfo, opts ], [ lifecycle, tree.package, "postshrinkwrap", tree.path ] ], iferr(cb, (function(data) {
            cb(null, pkginfo);
          })));
        }));
      }
      function treeToShrinkwrap(tree) {
        validate("O", arguments);
        var pkginfo = {};
        return tree.package.name && (pkginfo.name = tree.package.name), tree.package.version && (pkginfo.version = tree.package.version), 
        tree.children.length && (pkginfo.requires = !0, shrinkwrapDeps(pkginfo.dependencies = {}, tree, tree)), 
        pkginfo;
      }
      function shrinkwrapDeps(deps, top, tree, seen) {
        validate("OOO", [ deps, top, tree ]), seen || (seen = new Set), seen.has(tree) || (seen.add(tree), 
        sortModules(tree.children).forEach((function(child) {
          var childIsOnlyDev = isOnlyDev(child), pkginfo = deps[moduleName(child)] = {}, requested = getRequested(child) || child.package._requested || {}, linked = child.isLink || child.isInLink;
          pkginfo.version = function(top, child, req) {
            return "directory" === req.type || "file" === req.type ? "file:" + unixFormatPath(path.relative(top.path, child.package._resolved || req.fetchSpec)) : isRegistry(req) || child.fromBundle ? "alias" === req.type ? `npm:${child.package.name}@${child.package.version}` : child.package.version : child.package._resolved || req.saveSpec || req.rawSpec;
          }(top, child, requested), "git" === requested.type && child.package._from && (pkginfo.from = child.package._from), 
          child.fromBundle && !linked ? pkginfo.bundled = !0 : (isRegistry(requested) && (pkginfo.resolved = child.package._resolved), 
          "git" !== requested.type && (pkginfo.integrity = child.package._integrity || void 0, 
          !pkginfo.integrity && child.package._shasum && (pkginfo.integrity = ssri.fromHex(child.package._shasum, "sha1")))), 
          childIsOnlyDev && (pkginfo.dev = !0), isOnlyOptional(child) && (pkginfo.optional = !0), 
          child.requires.length && (pkginfo.requires = {}, sortModules(child.requires).forEach((required => {
            var requested = getRequested(required, child) || required.package._requested || {};
            pkginfo.requires[moduleName(required)] = function(top, child, requested) {
              return "directory" === requested.type || "file" === requested.type ? "file:" + unixFormatPath(path.relative(top.path, child.package._resolved || requested.fetchSpec)) : "git" === requested.type && child.package._from ? child.package._from : isRegistry(requested) || child.fromBundle ? "tag" === requested.type ? npm.config.get("save-prefix") + child.package.version : requested.saveSpec || requested.rawSpec ? requested.saveSpec || requested.rawSpec : child.package._from || child.package._requested && child.package._requested.rawSpec ? child.package._from.replace(/^@?[^@]+@/, "") || child.package._requested.rawSpec : child.package.version : child.package._resolved || requested.saveSpec || requested.rawSpec;
            }(top, required, requested);
          }))), child.children.length && (pkginfo.dependencies = {}, shrinkwrapDeps(pkginfo.dependencies, top, child, seen));
        })));
      }
      function sortModules(modules) {
        var sortedModuleNames = modules.map(moduleName).sort();
        return modules.sort(((a, b) => sortedModuleNames.indexOf(moduleName(a)) - sortedModuleNames.indexOf(moduleName(b))));
      }
      function shrinkwrap_(dir, pkginfo, opts, cb) {
        !function(dir, pkginfo, opts, cb) {
          BB.join(checkPackageFile(dir, SHRINKWRAP), checkPackageFile(dir, PKGLOCK), checkPackageFile(dir, "package.json"), ((shrinkwrap, lockfile, pkg) => {
            const info = shrinkwrap || lockfile || {
              path: path.resolve(dir, opts.defaultFile || PKGLOCK),
              data: "{}",
              indent: pkg && pkg.indent,
              newline: pkg && pkg.newline
            }, updated = function(pkginfo, pkgJson) {
              const newPkg = {};
              let metainfoWritten = !1;
              const metainfo = new Set([ "lockfileVersion", "preserveSymlinks" ]);
              Object.keys(pkginfo).forEach((k => {
                "dependencies" === k && writeMetainfo(newPkg), metainfo.has(k) || (newPkg[k] = pkginfo[k]), 
                "version" === k && writeMetainfo(newPkg);
              })), metainfoWritten || writeMetainfo(newPkg);
              function writeMetainfo(pkginfo) {
                pkginfo.lockfileVersion = PKGLOCK_VERSION, process.env.NODE_PRESERVE_SYMLINKS && (pkginfo.preserveSymlinks = process.env.NODE_PRESERVE_SYMLINKS), 
                metainfoWritten = !0;
              }
              return newPkg;
            }(pkginfo, pkg && JSON.parse(pkg.raw)), swdata = stringifyPackage(updated, info.indent, info.newline);
            swdata === info.raw ? (log.verbose("shrinkwrap", `skipping write for ${path.basename(info.path)} because there were no changes.`), 
            cb(null, pkginfo)) : inferOwner(info.path).then((owner => {
              writeFileAtomic(info.path, swdata, (err => err ? cb(err) : opts.silent ? cb(null, pkginfo) : (shrinkwrap || lockfile || log.notice("", `created a lockfile as ${path.basename(info.path)}. You should commit this file.`), 
              void (0 !== selfOwner_uid || selfOwner_uid === owner.uid && selfOwner_gid === owner.gid ? cb(null, pkginfo) : chown(info.path, owner.uid, owner.gid, (er => cb(er, pkginfo)))))));
            }));
          })).then((file => {}), cb);
        }(dir, pkginfo, opts, cb);
      }
      function checkPackageFile(dir, name) {
        const file = path.resolve(dir, name);
        return readFile(file, "utf8").then((data => {
          const format = !1 !== npm.config.get("format-package-lock"), indent = format ? detectIndent(data).indent : 0, newline = format ? detectNewline(data) : 0;
          return {
            path: file,
            raw: data,
            indent,
            newline
          };
        })).catch({
          code: "ENOENT"
        }, (() => {}));
      }
      shrinkwrap.usage = "npm shrinkwrap", module.exports = exports = shrinkwrap, exports.treeToShrinkwrap = treeToShrinkwrap, 
      module.exports.createShrinkwrap = createShrinkwrap;
    },
    1945: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const BB = __webpack_require__(41142), fetch = __webpack_require__(27382), figgyPudding = __webpack_require__(55212), log = __webpack_require__(19334), npa = __webpack_require__(4422), npm = __webpack_require__(44874), npmConfig = __webpack_require__(23300), output = __webpack_require__(1015), usage = __webpack_require__(29320), whoami = __webpack_require__(9364), StarConfig = figgyPudding({
        unicode: {}
      });
      function star(args, cb) {
        const opts = StarConfig(npmConfig());
        return BB.try((() => {
          if (!args.length) throw new Error(star.usage);
          let s = opts.unicode ? " " : "(*)";
          const u = opts.unicode ? " " : "( )", using = !npm.command.match(/^un/);
          return using || (s = u), BB.map(args.map(npa), (pkg => BB.all([ whoami([ pkg ], !0, (() => {})), fetch.json(pkg.escapedName, opts.concat({
            spec: pkg,
            query: {
              write: !0
            },
            "prefer-online": !0
          })) ]).then((([username, fullData]) => {
            if (!username) throw new Error("You need to be logged in!");
            const body = {
              _id: fullData._id,
              _rev: fullData._rev,
              users: fullData.users || {}
            };
            return using ? (log.info("star", "starring", body._id), body.users[username] = !0, 
            log.verbose("star", "starring", body)) : (delete body.users[username], log.info("star", "unstarring", body._id), 
            log.verbose("star", "unstarring", body)), fetch.json(pkg.escapedName, opts.concat({
              spec: pkg,
              method: "PUT",
              body
            }));
          })).then((data => (output(s + " " + pkg.name), log.verbose("star", data), data)))));
        })).nodeify(cb);
      }
      star.usage = usage("star", "npm star [<pkg>...]\nnpm unstar [<pkg>...]"), star.completion = function(opts, cb) {
        cb();
      }, module.exports = star;
    },
    83094: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const BB = __webpack_require__(41142), npmConfig = __webpack_require__(23300), fetch = __webpack_require__(27382), log = __webpack_require__(19334), output = __webpack_require__(1015), whoami = __webpack_require__(9364);
      function stars([user], cb) {
        const opts = npmConfig();
        return BB.try((() => (user ? BB.resolve(user) : whoami([], !0, (() => {}))).then((usr => fetch.json("/-/_view/starredByUser", opts.concat({
          query: {
            key: `"${usr}"`
          }
        })))).then((data => data.rows)).then((stars => {
          0 === stars.length ? log.warn("stars", "user has not starred any packages.") : stars.forEach((s => output(s.value)));
        })))).catch((err => {
          throw "ENEEDAUTH" === err.code ? Object.assign(new Error("'npm stars' on your own user account requires auth"), {
            code: "ENEEDAUTH"
          }) : err;
        })).nodeify(cb);
      }
      stars.usage = "npm stars [<user>]", module.exports = stars;
    },
    10361: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = __webpack_require__(6444)("start");
    },
    43605: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = __webpack_require__(6444)("stop");
    },
    83103: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = function(args, cb) {
        var i = Math.floor(Math.random() * isms.length);
        output(isms[i]);
        var c = args.shift();
        c ? npm.commands[c](args, cb) : cb();
      };
      var npm = __webpack_require__(44874), output = __webpack_require__(1015), isms = [ "[32mbeep [35mboop[m", "Replace your configs with services", "SEPARATE ALL THE CONCERNS!", "MODULE ALL THE THINGS!", "\\o/", "but first, burritos", "full time mad scientist here", "c/,,\\" ];
    },
    38720: (module, __unused_webpack_exports, __webpack_require__) => {
      const columns = __webpack_require__(33998), figgyPudding = __webpack_require__(55212), libteam = __webpack_require__(25171), npmConfig = __webpack_require__(23300), output = __webpack_require__(1015), otplease = __webpack_require__(83304), usage = __webpack_require__(29320);
      module.exports = team, team.subcommands = [ "create", "destroy", "add", "rm", "ls", "edit" ], 
      team.usage = usage("team", "npm team create <scope:team> [--otp <otpcode>]\nnpm team destroy <scope:team> [--otp <otpcode>]\nnpm team add <scope:team> <user> [--otp <otpcode>]\nnpm team rm <scope:team> <user> [--otp <otpcode>]\nnpm team ls <scope>|<scope:team>\nnpm team edit <scope:team>");
      const TeamConfig = figgyPudding({
        json: {},
        loglevel: {},
        parseable: {},
        silent: {}
      });
      function team([cmd, entity = "", user = ""], cb) {
        otplease(npmConfig(), (opts => {
          switch (opts = TeamConfig(opts).concat({
            description: null
          }), entity = entity.replace(/^@/, ""), cmd) {
           case "create":
            return function(entity, opts) {
              return libteam.create(entity, opts).then((() => {
                opts.json ? output(JSON.stringify({
                  created: !0,
                  team: entity
                })) : opts.parseable ? output(`${entity}\tcreated`) : opts.silent || "silent" === opts.loglevel || output(`+@${entity}`);
              }));
            }(entity, opts);

           case "destroy":
            return function(entity, opts) {
              return libteam.destroy(entity, opts).then((() => {
                opts.json ? output(JSON.stringify({
                  deleted: !0,
                  team: entity
                })) : opts.parseable ? output(`${entity}\tdeleted`) : opts.silent || "silent" === opts.loglevel || output(`-@${entity}`);
              }));
            }(entity, opts);

           case "add":
            return function(entity, user, opts) {
              return libteam.add(user, entity, opts).then((() => {
                opts.json ? output(JSON.stringify({
                  added: !0,
                  team: entity,
                  user
                })) : opts.parseable ? output(`${user}\t${entity}\tadded`) : opts.silent || "silent" === opts.loglevel || output(`${user} added to @${entity}`);
              }));
            }(entity, user, opts);

           case "rm":
            return function(entity, user, opts) {
              return libteam.rm(user, entity, opts).then((() => {
                opts.json ? output(JSON.stringify({
                  removed: !0,
                  team: entity,
                  user
                })) : opts.parseable ? output(`${user}\t${entity}\tremoved`) : opts.silent || "silent" === opts.loglevel || output(`${user} removed from @${entity}`);
              }));
            }(entity, user, opts);

           case "ls":
            return entity.match(/[^:]+:.+/) ? function(entity, opts) {
              return libteam.lsUsers(entity, opts).then((users => {
                users = users.sort(), opts.json ? output(JSON.stringify(users, null, 2)) : opts.parseable ? output(users.join("\n")) : opts.silent || "silent" === opts.loglevel || (output(`\n@${entity} has ${users.length} user${1 === users.length ? "" : "s"}:\n`), 
                output(columns(users, {
                  padding: 1
                })));
              }));
            }(entity, opts) : function(entity, opts) {
              return libteam.lsTeams(entity, opts).then((teams => {
                teams = teams.sort(), opts.json ? output(JSON.stringify(teams, null, 2)) : opts.parseable ? output(teams.join("\n")) : opts.silent || "silent" === opts.loglevel || (output(`\n@${entity} has ${teams.length} team${1 === teams.length ? "" : "s"}:\n`), 
                output(columns(teams.map((t => `@${t}`)), {
                  padding: 1
                })));
              }));
            }(entity, opts);

           case "edit":
            throw new Error("`npm team edit` is not implemented yet.");

           default:
            !function() {
              throw Object.assign(new Error(team.usage), {
                code: "EUSAGE"
              });
            }();
          }
        })).then((data => cb(null, data)), (err => "EUSAGE" === err.code ? cb(err.message) : cb(err)));
      }
      team.completion = function(opts, cb) {
        var argv = opts.conf.argv.remain;
        if (2 === argv.length) return cb(null, team.subcommands);
        switch (argv[2]) {
         case "ls":
         case "create":
         case "destroy":
         case "add":
         case "rm":
         case "edit":
          return cb(null, []);

         default:
          return cb(new Error(argv[2] + " not recognized"));
        }
      };
    },
    75842: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = test;
      const testCmd = __webpack_require__(6444)("test");
      function test(args, cb) {
        testCmd(args, (function(er) {
          return er ? "ELIFECYCLE" === er.code ? cb("Test failed.  See above for more details.") : cb(er) : cb();
        }));
      }
      test.usage = testCmd.usage;
    },
    35526: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const profile = __webpack_require__(29668), npm = __webpack_require__(44874), figgyPudding = __webpack_require__(55212), npmConfig = __webpack_require__(23300), output = __webpack_require__(1015), otplease = __webpack_require__(83304), Table = __webpack_require__(27275), Bluebird = __webpack_require__(41142), isCidrV4 = __webpack_require__(24173).v4, isCidrV6 = __webpack_require__(24173).v6, readUserInfo = __webpack_require__(87121), ansistyles = __webpack_require__(65308), log = __webpack_require__(19334), pulseTillDone = __webpack_require__(26549);
      function withCb(prom, cb) {
        prom.then((value => cb(null, value)), cb);
      }
      function token(args, cb) {
        if (log.gauge.show("token"), 0 === args.length) return withCb(list([]), cb);
        switch (args[0]) {
         case "list":
         case "ls":
          withCb(list(), cb);
          break;

         case "delete":
         case "revoke":
         case "remove":
         case "rm":
          withCb(function(args) {
            if (0 === args.length) throw new Error("npm token revoke <tokenKey>");
            const conf = config(), toRemove = [];
            return log.newItem("removing tokens", toRemove.length).info("token", "getting existing list"), 
            pulseTillDone.withPromise(profile.listTokens(conf).then((tokens => (args.forEach((id => {
              const matches = tokens.filter((token => 0 === token.key.indexOf(id)));
              if (1 === matches.length) toRemove.push(matches[0].key); else {
                if (matches.length > 1) throw new Error(`Token ID "${id}" was ambiguous, a new token may have been created since you last ran \`npm-profile token list\`.`);
                {
                  const tokenMatches = tokens.filter((token => 0 === id.indexOf(token.token)));
                  if (0 === tokenMatches) throw new Error(`Unknown token id or value "${id}".`);
                  toRemove.push(id);
                }
              }
            })), Bluebird.map(toRemove, (key => otplease(conf, (conf => profile.removeToken(key, conf))))))))).then((() => {
              conf.json ? output(JSON.stringify(toRemove)) : conf.parseable ? output(toRemove.join("\t")) : output("Removed " + toRemove.length + " token" + (1 !== toRemove.length ? "s" : ""));
            }));
          }(args.slice(1)), cb);
          break;

         case "create":
          withCb(function(args) {
            const conf = config(), cidr = conf.cidr, readonly = conf["read-only"], validCIDR = validateCIDRList(cidr);
            return readUserInfo.password().then((password => (log.info("token", "creating"), 
            pulseTillDone.withPromise(otplease(conf, (conf => profile.createToken(password, readonly, validCIDR, conf))))))).then((result => {
              if (delete result.key, delete result.updated, conf.json) output(JSON.stringify(result)); else if (conf.parseable) Object.keys(result).forEach((k => output(k + "\t" + result[k]))); else {
                const table = new Table;
                Object.keys(result).forEach((k => table.push({
                  [ansistyles.bright(k)]: String(result[k])
                }))), output(table.toString());
              }
            }));
          }(args.slice(1)), cb);
          break;

         default:
          cb(new Error("Unknown profile command: " + args[0]));
        }
      }
      module.exports = token, token._validateCIDRList = validateCIDRList, token.usage = "npm token list\nnpm token revoke <tokenKey>\nnpm token create [--read-only] [--cidr=list]\n", 
      token.subcommands = [ "list", "revoke", "create" ], token.completion = function(opts, cb) {
        var argv = opts.conf.argv.remain;
        switch (argv[2]) {
         case "list":
         case "revoke":
         case "create":
          return cb(null, []);

         default:
          return cb(new Error(argv[2] + " not recognized"));
        }
      };
      const TokenConfig = figgyPudding({
        auth: {},
        registry: {},
        otp: {},
        cidr: {},
        "read-only": {},
        json: {},
        parseable: {}
      });
      function config() {
        let conf = TokenConfig(npmConfig());
        const creds = npm.config.getCredentialsByURI(conf.registry);
        if (creds.token) conf = conf.concat({
          auth: {
            token: creds.token
          }
        }); else if (creds.username) conf = conf.concat({
          auth: {
            basic: {
              username: creds.username,
              password: creds.password
            }
          }
        }); else if (creds.auth) {
          const auth = Buffer.from(creds.auth, "base64").toString().split(":", 2);
          conf = conf.concat({
            auth: {
              basic: {
                username: auth[0],
                password: auth[1]
              }
            }
          });
        } else conf = conf.concat({
          auth: {}
        });
        return conf.otp && (conf.auth.otp = conf.otp), conf;
      }
      function list(args) {
        const conf = config();
        return log.info("token", "getting list"), pulseTillDone.withPromise(profile.listTokens(conf)).then((tokens => {
          if (conf.json) return void output(JSON.stringify(tokens, null, 2));
          if (conf.parseable) return output([ "key", "token", "created", "readonly", "CIDR whitelist" ].join("\t")), 
          void tokens.forEach((token => {
            output([ token.key, token.token, token.created, token.readonly ? "true" : "false", token.cidr_whitelist ? token.cidr_whitelist.join(",") : "" ].join("\t"));
          }));
          !function(tokens, minLength) {
            const byId = {};
            tokens.forEach((token => {
              token.id = token.key;
              for (let ii = minLength; ii < token.key.length; ++ii) if (!tokens.some((ot => ot !== token && ot.key.slice(0, ii) === token.key.slice(0, ii)))) {
                token.id = token.key.slice(0, ii);
                break;
              }
              byId[token.id] = token;
            }));
          }(tokens, 6);
          const idWidth = tokens.reduce(((acc, token) => Math.max(acc, token.id.length)), 0), table = new Table({
            head: [ "id", "token", "created", "readonly", "CIDR whitelist" ],
            colWidths: [ Math.max(idWidth, 2) + 2, 9, 12, 10 ]
          });
          tokens.forEach((token => {
            table.push([ token.id, token.token + "", String(token.created).slice(0, 10), token.readonly ? "yes" : "no", token.cidr_whitelist ? token.cidr_whitelist.join(", ") : "" ]);
          })), output(table.toString());
        }));
      }
      function validateCIDR(cidr) {
        if (isCidrV6(cidr)) throw new Error("CIDR whitelist can only contain IPv4 addresses, " + cidr + " is IPv6");
        if (!isCidrV4(cidr)) throw new Error("CIDR whitelist contains invalid CIDR entry: " + cidr);
      }
      function validateCIDRList(cidrs) {
        const maybeList = cidrs ? Array.isArray(cidrs) ? cidrs : [ cidrs ] : [], list = 1 === maybeList.length ? maybeList[0].split(/,\s*/) : maybeList;
        return list.forEach(validateCIDR), list;
      }
    },
    24736: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = unbuild, module.exports.rmStuff = rmStuff, unbuild.usage = "npm unbuild <folder>\n(this is plumbing)";
      const readJson = __webpack_require__(92200), gentlyRm = __webpack_require__(8638), npm = __webpack_require__(44874), path = __webpack_require__(71017), isInside = __webpack_require__(13468), lifecycle = __webpack_require__(4705), asyncMap = __webpack_require__(89009).asyncMap, chain = __webpack_require__(89009).chain, log = __webpack_require__(19334), build = __webpack_require__(34674), output = __webpack_require__(1015);
      function unbuild(args, silent, cb) {
        "function" == typeof silent && (cb = silent, silent = !1), asyncMap(args, function(silent) {
          return function(folder, cb_) {
            function cb(er) {
              cb_(er, path.relative(npm.root, folder));
            }
            folder = path.resolve(folder);
            const base = isInside(folder, npm.prefix) ? npm.prefix : folder;
            delete build._didBuild[folder], log.verbose("unbuild", folder.substr(npm.prefix.length + 1)), 
            readJson(path.resolve(folder, "package.json"), (function(er, pkg) {
              if (er) return gentlyRm(folder, !1, base, cb);
              chain([ [ lifecycle, pkg, "preuninstall", folder, {
                failOk: !0
              } ], [ lifecycle, pkg, "uninstall", folder, {
                failOk: !0
              } ], !silent && function(cb) {
                output("unbuild " + pkg._id), cb();
              }, [ rmStuff, pkg, folder ], [ lifecycle, pkg, "postuninstall", folder, {
                failOk: !0
              } ], [ gentlyRm, folder, !1, base ] ], cb);
            }));
          };
        }(silent), cb);
      }
      function rmStuff(pkg, folder, cb) {
        const dir = path.dirname(folder), parent = "@" === path.basename(dir).charAt(0) ? path.dirname(dir) : dir, gnm = npm.dir, top = "" === path.relative(gnm, parent);
        log.verbose("unbuild rmStuff", pkg._id, "from", gnm), top || log.verbose("unbuild rmStuff", "in", parent), 
        asyncMap([ rmBins, rmMans ], (function(fn, cb) {
          fn(pkg, folder, parent, top, cb);
        }), cb);
      }
      function rmBins(pkg, folder, parent, top, cb) {
        if (!pkg.bin) return cb();
        const binRoot = top ? npm.bin : path.resolve(parent, ".bin");
        asyncMap(Object.keys(pkg.bin), (function(b, cb) {
          "win32" === process.platform ? chain([ [ gentlyRm, path.resolve(binRoot, b) + ".ps1", !0, folder ], [ gentlyRm, path.resolve(binRoot, b) + ".cmd", !0, folder ], [ gentlyRm, path.resolve(binRoot, b), !0, folder ] ], cb) : gentlyRm(path.resolve(binRoot, b), !0, folder, cb);
        }), (function(err) {
          return err || top ? cb(err) : gentlyRm(binRoot, !0, parent, cb);
        }));
      }
      function rmMans(pkg, folder, parent, top, cb) {
        if (!pkg.man || !top || "win32" === process.platform || !npm.config.get("global")) return cb();
        const manRoot = path.resolve(npm.config.get("prefix"), "share", "man");
        log.verbose("rmMans", "man files are", pkg.man, "in", manRoot), asyncMap(pkg.man, (function(man, cb) {
          function rmMan(man) {
            log.silly("rmMan", "preparing to remove", man);
            const parseMan = man.match(/(.*\.([0-9]+)(\.gz)?)$/);
            if (!parseMan) return log.error("rmMan", man, "is not a valid name for a man file.", "Man files must end with a number, and optionally a .gz suffix if they are compressed."), 
            cb();
            const stem = parseMan[1], sxn = parseMan[2], gz = parseMan[3] || "", bn = path.basename(stem), manDest = path.join(manRoot, "man" + sxn, (0 === bn.indexOf(pkg.name) ? bn : pkg.name + "-" + bn) + "." + sxn + gz);
            gentlyRm(manDest, !0, cb);
          }
          Array.isArray(man) ? man.forEach(rmMan) : rmMan(man);
        }), cb);
      }
    },
    71012: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = uninstall;
      const path = __webpack_require__(71017), validate = __webpack_require__(95073), readJson = __webpack_require__(92200), iferr = __webpack_require__(17367), npm = __webpack_require__(44874), Installer = __webpack_require__(70913).Installer, getSaveType = __webpack_require__(29705).getSaveType, removeDeps = __webpack_require__(48045).removeDeps, log = __webpack_require__(19334), usage = __webpack_require__(29320);
      function uninstall(args, cb) {
        validate("AF", arguments);
        const dryrun = !!npm.config.get("dry-run");
        1 === args.length && "." === args[0] && (args = []);
        const where = npm.config.get("global") || !args.length ? path.resolve(npm.globalDir, "..") : npm.prefix;
        (args = args.filter((function(a) {
          return path.resolve(a) !== where;
        }))).length ? new Uninstaller(where, dryrun, args).run(cb) : readJson(path.resolve(npm.localPrefix, "package.json"), (function(er, pkg) {
          return er && "ENOENT" !== er.code && "ENOTDIR" !== er.code ? cb(er) : er ? cb(uninstall.usage) : void new Uninstaller(where, dryrun, [ pkg.name ]).run(cb);
        }));
      }
      uninstall.usage = usage("uninstall", "npm uninstall [<@scope>/]<pkg>[@<version>]... [--save-prod|--save-dev|--save-optional] [--no-save]"), 
      uninstall.completion = __webpack_require__(73486);
      class Uninstaller extends Installer {
        constructor(where, dryrun, args) {
          super(where, dryrun, args), this.remove = [];
        }
        loadArgMetadata(next) {
          this.args = this.args.map((function(arg) {
            return {
              name: arg
            };
          })), next();
        }
        loadAllDepsIntoIdealTree(cb) {
          validate("F", arguments), this.remove = this.args, this.args = [], log.silly("uninstall", "loadAllDepsIntoIdealTree");
          const saveDeps = getSaveType();
          super.loadAllDepsIntoIdealTree(iferr(cb, (() => {
            removeDeps(this.remove, this.idealTree, saveDeps, cb);
          })));
        }
        runPreinstallTopLevelLifecycles(cb) {
          cb();
        }
        runPostinstallTopLevelLifecycles(cb) {
          cb();
        }
      }
      module.exports.Uninstaller = Uninstaller;
    },
    72190: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = unpublish;
      const BB = __webpack_require__(41142), figgyPudding = __webpack_require__(55212), libaccess = __webpack_require__(87878), libunpub = __webpack_require__(37805), log = __webpack_require__(19334), npa = __webpack_require__(19932), npm = __webpack_require__(44874), npmConfig = __webpack_require__(23300), npmFetch = __webpack_require__(11527), otplease = __webpack_require__(83304), output = __webpack_require__(1015), path = __webpack_require__(71017), readJson = BB.promisify(__webpack_require__(92200)), usage = __webpack_require__(29320), whoami = BB.promisify(__webpack_require__(9364));
      unpublish.usage = usage("unpublish", "\nnpm unpublish [<@scope>/]<pkg>@<version>\nnpm unpublish [<@scope>/]<pkg> --force");
      const UnpublishConfig = figgyPudding({
        force: {},
        loglevel: {},
        silent: {}
      });
      function unpublish(args, cb) {
        if (args.length > 1) return cb(unpublish.usage);
        const spec = args.length && npa(args[0]), opts = UnpublishConfig(npmConfig()), version = spec.rawSpec;
        BB.try((() => {
          if (log.silly("unpublish", "args[0]", args[0]), log.silly("unpublish", "spec", spec), 
          !version && !opts.force) throw Object.assign(new Error("Refusing to delete entire project.\nRun with --force to do this.\n" + unpublish.usage), {
            code: "EUSAGE"
          });
          if (spec && path.resolve(spec.name) !== npm.localPrefix) return otplease(opts, (opts => libunpub(spec, opts)));
          {
            const cwdJson = path.join(npm.localPrefix, "package.json");
            return readJson(cwdJson).then((data => (log.verbose("unpublish", data), otplease(opts, (opts => libunpub(npa.resolve(data.name, data.version), opts.concat(data.publishConfig)))))), (err => {
              if (err && "ENOENT" !== err.code && "ENOTDIR" !== err.code) throw err;
              !function() {
                throw Object.assign(new Error(`Usage: ${unpublish.usage}`), {
                  code: "EUSAGE"
                });
              }();
            }));
          }
        })).then((ret => {
          opts.silent || "silent" === opts.loglevel || output(`- ${spec.name}${"version" === spec.type ? `@${spec.rawSpec}` : ""}`), 
          cb(null, ret);
        }), (err => "EUSAGE" === err.code ? cb(err.message) : cb(err)));
      }
      unpublish.completion = function(cliOpts, cb) {
        if (cliOpts.conf.argv.remain.length >= 3) return cb();
        whoami([], !0).then((username => {
          if (!username) return [];
          const opts = UnpublishConfig(npmConfig());
          return libaccess.lsPackages(username, opts).then((access => {
            let pkgs = Object.keys(access);
            if (!cliOpts.partialWord || !pkgs.length) return pkgs;
            const pp = npa(cliOpts.partialWord).name;
            return pkgs = pkgs.filter((p => !p.indexOf(pp))), pkgs.length > 1 ? pkgs : npmFetch.json(npa(pkgs[0]).escapedName, opts).then((doc => {
              const vers = Object.keys(doc.versions);
              return vers.length ? vers.map((v => `${pkgs[0]}@${v}`)) : pkgs;
            }));
          }));
        })).nodeify(cb);
      };
    },
    33714: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = update;
      const url = __webpack_require__(57310), log = __webpack_require__(19334), Bluebird = __webpack_require__(41142), npm = __webpack_require__(44874), Installer = __webpack_require__(70913).Installer, usage = __webpack_require__(29320), outdated = Bluebird.promisify(npm.commands.outdated);
      function update(args, cb) {
        return function(args) {
          let dryrun = !1;
          npm.config.get("dry-run") && (dryrun = !0);
          return log.verbose("update", "computing outdated modules to update"), outdated(args, !0).then((rawOutdated => {
            const wanted = rawOutdated.map((function(ww) {
              return {
                dep: ww[0],
                depname: ww[1],
                current: ww[2],
                wanted: ww[3],
                latest: ww[4],
                req: ww[5],
                what: ww[1] + "@" + ww[3]
              };
            })).filter((function(ww) {
              return ww.current === ww.wanted && ww.wanted !== ww.latest && log.verbose("outdated", "not updating", ww.depname, "because it's currently at the maximum version that matches its specified semver range"), 
              ww.current !== ww.wanted;
            }));
            if (0 === wanted.length) return;
            log.info("outdated", "updating", wanted);
            const toInstall = {};
            return wanted.forEach((function(ww) {
              url.parse(ww.req).protocol && (ww.what = ww.req);
              const where = ww.dep.parent && ww.dep.parent.path || ww.dep.path, isTransitive = !(ww.dep.requiredBy || []).some((p => p.isTop)), key = where + ":" + String(isTransitive);
              toInstall[key] || (toInstall[key] = {
                where,
                opts: {
                  saveOnlyLock: isTransitive
                },
                what: []
              }), -1 === toInstall[key].what.indexOf(ww.what) && toInstall[key].what.push(ww.what);
            })), Bluebird.each(Object.keys(toInstall), (key => {
              const deps = toInstall[key];
              return new Installer(deps.where, dryrun, deps.what, deps.opts).run();
            }));
          }));
        }(args).asCallback(cb);
      }
      update.usage = usage("update", "npm update [-g] [<pkg>...]"), update.completion = npm.commands.outdated.completion;
    },
    82576: module => {
      module.exports = function(str) {
        var r = new RegExp("(?:\\[(?:\\d+[ABCDEFGJKSTm]|\\d+;\\d+[Hfm]|\\d+;\\d+;\\d+m|6n|s|u|\\?25[lh])|\\w)", "g");
        return str.replace(r, "");
      };
    },
    5651: (__unused_webpack_module, exports, __webpack_require__) => {
      const npm = __webpack_require__(44874), path = __webpack_require__(71017), chownr = __webpack_require__(13159), writeFileAtomic = __webpack_require__(19804), mkdirp = __webpack_require__(41718), fs = __webpack_require__(59799);
      let cache = null, cacheUid = null, cacheGid = null, needChown = "function" == typeof process.getuid;
      const writeOrAppend = (method, file, data) => {
        cache || (cache = npm.config.get("cache")), file = path.resolve(cache, file), null === cacheUid && needChown && (() => {
          let st;
          try {
            st = fs.lstatSync(cache);
          } catch (er) {
            if ("ENOENT" !== er.code) throw er;
            st = fs.lstatSync(path.dirname(cache));
          }
          cacheUid = st.uid, cacheGid = st.gid, needChown = st.uid !== process.getuid() || st.gid !== process.getgid();
        })();
        const dir = path.dirname(file), firstMade = mkdirp.sync(dir);
        if (!needChown) return method(file, data);
        let methodThrew = !0;
        try {
          method(file, data), methodThrew = !1;
        } finally {
          if (methodThrew) try {
            chownr.sync(firstMade || file, cacheUid, cacheGid);
          } catch (_) {} else chownr.sync(firstMade || file, cacheUid, cacheGid);
        }
      };
      exports.append = (file, data) => writeOrAppend(fs.appendFileSync, file, data), exports.write = (file, data) => writeOrAppend(writeFileAtomic.sync, file, data);
    },
    37013: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var path = __webpack_require__(71017), validate = __webpack_require__(95073), moduleName = __webpack_require__(7802);
      module.exports = function(parentPath, child) {
        return validate("SO", arguments), path.join(parentPath, "node_modules", moduleName(child));
      };
    },
    82463: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = function(root, req, depth, cb) {
        "function" != typeof cb && (cb = depth, depth = 1 / 0);
        mkdir(root, (function(er) {
          if (er) return cb(er);
          glob(root + "/{" + req + "," + req + "/**/*}", {
            mark: !0,
            dot: !0,
            maxDepth: depth
          }, (function(er, files) {
            return er ? cb(er) : cb(null, (files || []).map((function(f) {
              return f.substr(root.length + 1).replace(/^\/|\/$/g, "");
            })));
          }));
        }));
      };
      var mkdir = __webpack_require__(41718), glob = __webpack_require__(34436);
    },
    46624: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = function(opts, cb) {
        var local, global, opt = {
          depth: npm.config.get("depth"),
          dev: !0
        };
        npm.config.get("global") ? (local = [], next()) : readInstalled(npm.prefix, opt, (function(er, data) {
          local = getNames(data || {}), next();
        }));
        function getNames_(d, n) {
          if (d.realName && n) {
            if (n[d.realName]) return n;
            n[d.realName] = !0;
          }
          return n || (n = {}), Object.keys(d.dependencies || {}).forEach((function(dep) {
            getNames_(d.dependencies[dep], n);
          })), n;
        }
        function getNames(d) {
          return Object.keys(getNames_(d));
        }
        function next() {
          if (local && global) {
            npm.config.get("global") || (global = global.map((function(g) {
              return [ g, "-g" ];
            })));
            var names = local.concat(global);
            return cb(null, names);
          }
        }
        readInstalled(npm.config.get("prefix"), opt, (function(er, data) {
          global = getNames(data || {}), next();
        }));
      };
      var npm = __webpack_require__(44874), readInstalled = __webpack_require__(6576);
    },
    73486: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = function(opts, filter, cb) {
        "function" != typeof cb && (cb = filter, filter = null);
        var local, global;
        if (opts.conf.argv.remain.length > 3) return cb();
        var localDir = npm.dir, globalDir = npm.globalDir;
        npm.config.get("global") ? (local = [], next()) : fs.readdir(localDir, (function(er, pkgs) {
          local = (pkgs || []).filter((function(p) {
            return "." !== p.charAt(0);
          })), next();
        }));
        function next() {
          local && global && function(local, global, filter, cb) {
            var fl, fg;
            if (!filter) return fl = local, fg = global, next();
            asyncMap(local, (function(p, cb) {
              readJson(path.join(npm.dir, p, "package.json"), (function(er, d) {
                return d && filter(d) ? cb(null, d.name) : cb(null, []);
              }));
            }), (function(er, local) {
              fl = local || [], next();
            }));
            var globalDir = npm.globalDir;
            function next() {
              if (fg && fl) return npm.config.get("global") || (fg = fg.map((function(g) {
                return [ g, "-g" ];
              }))), console.error("filtered", fl, fg), cb(null, fl.concat(fg));
            }
            asyncMap(global, (function(p, cb) {
              readJson(path.join(globalDir, p, "package.json"), (function(er, d) {
                return d && filter(d) ? cb(null, d.name) : cb(null, []);
              }));
            }), (function(er, global) {
              fg = global || [], next();
            }));
          }(local, global, filter, cb);
        }
        fs.readdir(globalDir, (function(er, pkgs) {
          global = (pkgs || []).filter((function(p) {
            return "." !== p.charAt(0);
          })), next();
        }));
      };
      var npm = __webpack_require__(44874), fs = __webpack_require__(59799), path = __webpack_require__(71017), readJson = __webpack_require__(92200), asyncMap = __webpack_require__(89009).asyncMap;
    },
    79501: (module, __unused_webpack_exports, __webpack_require__) => {
      const chownr = __webpack_require__(13159), inflight = __webpack_require__(59956), log = __webpack_require__(19334), mkdirp = __webpack_require__(41718), inferOwner = __webpack_require__(84876);
      module.exports = function(path, cb) {
        return (cb = inflight("correctMkdir: " + path, cb)) ? (log.verbose("correctMkdir", path, "correctMkdir not in flight; initializing"), 
        process.getuid ? void inferOwner(path).then((owner => {
          mkdirp(path, ((er, made) => {
            if (er) return log.error("correctMkdir", "failed to make directory %s", path), cb(er);
            chownr(made || path, owner.uid, owner.gid, (er => cb(er, owner)));
          }));
        }), (er => (log.error("correctMkdir", "failed to infer path ownership %s", path), 
        cb(er)))) : (log.verbose("makeCacheDir", "UID & GID are irrelevant on", process.platform), 
        mkdirp(path, ((er, made) => cb(er, {
          uid: 0,
          gid: 0
        }))))) : log.verbose("correctMkdir", path, "correctMkdir already in flight; waiting");
      };
    },
    21514: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var sortedObject = __webpack_require__(37713);
      module.exports = function deepSortObject(obj) {
        return null == obj || "object" != typeof obj ? obj : obj instanceof Array ? obj.map(deepSortObject) : (obj = sortedObject(obj), 
        Object.keys(obj).forEach((function(key) {
          obj[key] = deepSortObject(obj[key]);
        })), obj);
      };
    },
    8956: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const log = __webpack_require__(19334), deprecated = {}, deprWarned = {};
      module.exports = function(data) {
        deprecated[data._id] && (data.deprecated = deprecated[data._id]);
        data.deprecated && (deprecated[data._id] = data.deprecated, deprWarned[data._id] || (deprWarned[data._id] = !0, 
        log.warn("deprecated", "%s: %s", data._id, data.deprecated)));
        return data;
      };
    },
    90594: (module, __unused_webpack_exports, __webpack_require__) => {
      var meant = __webpack_require__(75935);
      module.exports = function(scmd, commands) {
        var bestSimilarity = meant(scmd, commands).map((function(str) {
          return "    " + str;
        }));
        return 0 === bestSimilarity.length ? "" : 1 === bestSimilarity.length ? "\nDid you mean this?\n" + bestSimilarity[0] : [ "\nDid you mean one of these?" ].concat(bestSimilarity.slice(0, 3)).join("\n");
      };
    },
    62978: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = errorHandler, module.exports.exit = exit;
      var cbCalled = !1, log = __webpack_require__(19334), npm = __webpack_require__(44874), itWorked = !1, path = __webpack_require__(71017), wroteLogFile = !1, exitCode = 0, rollbacks = npm.rollbacks, chain = __webpack_require__(89009).chain, errorMessage = __webpack_require__(78611), replaceInfo = __webpack_require__(45042), stopMetrics = __webpack_require__(21694).stop;
      const cacheFile = __webpack_require__(5651);
      var logFileName;
      function getLogFile() {
        return logFileName || (logFileName = path.resolve(npm.config.get("cache"), "_logs", (new Date).toISOString().replace(/[.:]/g, "_") + "-debug.log")), 
        logFileName;
      }
      var timings = {
        version: npm.version,
        command: process.argv.slice(2),
        logfile: null
      };
      function exit(code, noLog) {
        exitCode = exitCode || process.exitCode || code;
        var doExit = !npm.config || !npm.config.loaded || npm.config.get("_exit");
        function reallyExit(er) {
          er && !code && (code = "number" == typeof er.errno ? er.errno : 1), itWorked = !code, 
          process.stdout.write("", (() => {
            process.exit(code);
          }));
        }
        log.verbose("exit", [ code, doExit ]), "silent" === log.level && (noLog = !0), rollbacks.length ? (chain(rollbacks.map((function(f) {
          return function(cb) {
            npm.commands.unbuild([ f ], !0, cb);
          };
        })), (function(er) {
          er ? (log.error("error rolling back", er), code ? (noLog || writeLogFile(), reallyExit(er)) : errorHandler(er)) : (!noLog && code && writeLogFile(), 
          reallyExit());
        })), rollbacks.length = 0) : code && !noLog ? writeLogFile() : reallyExit();
      }
      function errorHandler(er) {
        if (log.disableProgress(), npm.config && npm.config.loaded || (er = er || new Error("Exit prior to config file resolving."), 
        console.error(er.stack || er.message)), cbCalled && (er = er || new Error("Callback called more than once.")), 
        cbCalled = !0, !er) return exit(0);
        if ("string" == typeof er) return log.error("", er), exit(1, !0);
        if (!(er instanceof Error)) return log.error("weird error", er), exit(1, !0);
        var m = er.code || er.message.match(/^(?:Error: )?(E[A-Z]+)/);
        m && !er.code && (er.code = m), [ "type", "stack", "statusCode", "pkgid" ].forEach((function(k) {
          var v = er[k];
          v && (v = replaceInfo(v), log.verbose(k, v));
        })), log.verbose("cwd", process.cwd());
        var os = __webpack_require__(22037), args = replaceInfo(process.argv);
        log.verbose("", os.type() + " " + os.release()), log.verbose("argv", args.map(JSON.stringify).join(" ")), 
        log.verbose("node", process.version), log.verbose("npm ", "v" + npm.version), [ "code", "syscall", "file", "path", "dest", "errno" ].forEach((function(k) {
          var v = er[k];
          v && log.error(k, v);
        }));
        var msg = errorMessage(er);
        if (msg.summary.concat(msg.detail).forEach((function(errline) {
          log.error.apply(log, errline);
        })), npm.config && npm.config.get("json")) {
          var error = {
            error: {
              code: er.code,
              summary: messageText(msg.summary),
              detail: messageText(msg.detail)
            }
          };
          console.log(JSON.stringify(error, null, 2));
        }
        exit("number" == typeof er.errno ? er.errno : 1);
      }
      function messageText(msg) {
        return msg.map((function(line) {
          return line.slice(1).join(" ");
        })).join("\n");
      }
      function writeLogFile() {
        if (!wroteLogFile) {
          var os = __webpack_require__(22037);
          try {
            var logOutput = "";
            log.record.forEach((function(m) {
              var pref = [ m.id, m.level ];
              m.prefix && pref.push(m.prefix), pref = pref.join(" "), m.message.trim().split(/\r?\n/).map((function(line) {
                return (pref + " " + line).trim();
              })).forEach((function(line) {
                logOutput += line + os.EOL;
              }));
            })), cacheFile.write(getLogFile(), logOutput), log.record.length = 0, wroteLogFile = !0;
          } catch (ex) {}
        }
      }
      process.on("timing", (function(name, value) {
        timings[name] ? timings[name] += value : timings[name] = value;
      })), process.on("exit", (function(code) {
        if (process.emit("timeEnd", "npm"), log.disableProgress(), npm.config && npm.config.loaded && npm.config.get("timing")) try {
          timings.logfile = getLogFile(), cacheFile.append("_timing.json", JSON.stringify(timings) + "\n");
        } catch (_) {}
        stopMetrics(), code && (itWorked = !1), itWorked ? log.info("ok") : (cbCalled || (log.error("", "cb() never called!"), 
        console.error(""), log.error("", "This is an error with npm itself. Please report this error at:"), 
        log.error("", "    <https://npm.community>"), writeLogFile()), code && log.verbose("code", code)), 
        npm.config && npm.config.loaded && npm.config.get("timing") && !wroteLogFile && writeLogFile(), 
        wroteLogFile && (log.levels[log.level] <= log.levels.error && console.error(""), 
        log.error("", [ "A complete log of this run can be found in:", "    " + getLogFile() ].join("\n")), 
        wroteLogFile = !1), npm.config && npm.config.loaded && npm.config.get("_exit") ? (0 !== exitCode || itWorked || (exitCode = 1), 
        0 !== exitCode && process.exit(exitCode)) : itWorked = !1;
      }));
    },
    78611: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var npm = __webpack_require__(44874), util = __webpack_require__(73837), nameValidator = __webpack_require__(70630), npmlog = __webpack_require__(19334), replaceInfo = __webpack_require__(45042);
      module.exports = function(er) {
        var short = [], detail = [];
        switch (er.message = replaceInfo(er.message), er.stack = replaceInfo(er.stack), 
        er.code) {
         case "ENOAUDIT":
         case "EAUDITNOPJSON":
          short.push([ "audit", er.message ]);
          break;

         case "EAUDITNOLOCK":
          short.push([ "audit", er.message ]), detail.push([ "audit", "Try creating one first with: npm i --package-lock-only" ]);
          break;

         case "ECONNREFUSED":
          short.push([ "", er ]), detail.push([ "", [ "\nIf you are behind a proxy, please make sure that the", "'proxy' config is set properly.  See: 'npm help config'" ].join("\n") ]);
          break;

         case "EACCES":
         case "EPERM":
          const isCachePath = "string" == typeof er.path && npm.config && er.path.startsWith(npm.config.get("cache")), isCacheDest = "string" == typeof er.dest && npm.config && er.dest.startsWith(npm.config.get("cache"));
          "win32" === process.platform || !isCachePath && !isCacheDest ? (short.push([ "", er ]), 
          detail.push([ "", [ "\nThe operation was rejected by your operating system.", "win32" === process.platform ? "It's possible that the file was already in use (by a text editor or antivirus),\nor that you lack permissions to access it." : "It is likely you do not have the permissions to access this file as the current user", "\nIf you believe this might be a permissions issue, please double-check the", "permissions of the file and its containing directories, or try running", "the command again as root/Administrator." ].join("\n") ])) : (npmlog.verbose(er.stack), 
          short.push([ "", [ "", "Your cache folder contains root-owned files, due to a bug in", "previous versions of npm which has since been addressed.", "", "To permanently fix this problem, please run:", `  sudo chown -R ${process.getuid()}:${process.getgid()} ${JSON.stringify(npm.config.get("cache"))}` ].join("\n") ]));
          break;

         case "EUIDLOOKUP":
          short.push([ "lifecycle", er.message ]), detail.push([ "", [ "", "Failed to look up the user/group for running scripts.", "", "Try again with a different --user or --group settings, or", "run with --unsafe-perm to execute scripts as root." ].join("\n") ]);
          break;

         case "ELIFECYCLE":
          short.push([ "", er.message ]), detail.push([ "", [ "", "Failed at the " + er.pkgid + " " + er.stage + " script.", "This is probably not a problem with npm. There is likely additional logging output above." ].join("\n") ]);
          break;

         case "ENOGIT":
          short.push([ "", er.message ]), detail.push([ "", [ "", "Failed using git.", "Please check if you have git installed and in your PATH." ].join("\n") ]);
          break;

         case "EJSONPARSE":
          const path = __webpack_require__(71017);
          if (er.file === path.join(npm.prefix, "package.json")) {
            const isDiff = __webpack_require__(34160)._isDiff, txt = __webpack_require__(57147).readFileSync(er.file, "utf8");
            if (isDiff(txt)) {
              detail.push([ "", [ "Merge conflict detected in your package.json.", "", "Please resolve the package.json conflict and retry the command:", "", `$ ${process.argv.join(" ")}` ].join("\n") ]);
              break;
            }
          }
          short.push([ "JSON.parse", er.message ]), detail.push([ "JSON.parse", [ "Failed to parse package.json data.", "package.json must be actual JSON, not just JavaScript." ].join("\n") ]);
          break;

         case "EOTP":
         case "E401":
          if ("EOTP" === er.code || /one-time pass/.test(er.message)) short.push([ "", "This operation requires a one-time password from your authenticator." ]), 
          detail.push([ "", [ "You can provide a one-time password by passing --otp=<code> to the command you ran.", "If you already provided a one-time password then it is likely that you either typoed", "it, or it timed out. Please try again." ].join("\n") ]); else {
            const auth = er.headers && er.headers["www-authenticate"] && er.headers["www-authenticate"].map((au => au.split(/,\s*/)))[0] || [];
            -1 !== auth.indexOf("Bearer") ? (short.push([ "", "Unable to authenticate, your authentication token seems to be invalid." ]), 
            detail.push([ "", [ "To correct this please trying logging in again with:", "    npm login" ].join("\n") ])) : -1 !== auth.indexOf("Basic") ? (short.push([ "", "Incorrect or missing password." ]), 
            detail.push([ "", [ "If you were trying to login, change your password, create an", "authentication token or enable two-factor authentication then", "that means you likely typed your password in incorrectly.", "Please try again, or recover your password at:", "    https://www.npmjs.com/forgot", "", "If you were doing some other operation then your saved credentials are", "probably out of date. To correct this please try logging in again with:", "    npm login" ].join("\n") ])) : short.push([ "", er.message || er ]);
          }
          break;

         case "E404":
          var msg = er.message.replace(/^404\s+/, "");
          if (short.push([ "404", msg ]), er.pkgid && "-" !== er.pkgid) {
            var pkg = er.pkgid.replace(/(?!^)@.*$/, "");
            detail.push([ "404", "" ]), detail.push([ "404", "", "'" + er.pkgid + "' is not in the npm registry." ]);
            var valResult = nameValidator(pkg);
            if (valResult.validForNewPackages) detail.push([ "404", "You should bug the author to publish it (or use the name yourself!)" ]); else detail.push([ "404", "Your package name is not valid, because", "" ]), 
            (valResult.errors || []).concat(valResult.warnings || []).forEach((function(item, idx) {
              detail.push([ "404", " " + (idx + 1) + ". " + item ]);
            }));
            er.parent && detail.push([ "404", "It was specified as a dependency of '" + er.parent + "'" ]), 
            detail.push([ "404", "\nNote that you can also install from a" ]), detail.push([ "404", "tarball, folder, http url, or git url." ]);
          }
          break;

         case "EPUBLISHCONFLICT":
          short.push([ "publish fail", "Cannot publish over existing version." ]), detail.push([ "publish fail", "Update the 'version' field in package.json and try again." ]), 
          detail.push([ "publish fail", "" ]), detail.push([ "publish fail", "To automatically increment version numbers, see:" ]), 
          detail.push([ "publish fail", "    npm help version" ]);
          break;

         case "EISGIT":
          short.push([ "git", er.message ]), short.push([ "git", "    " + er.path ]), detail.push([ "git", [ "Refusing to remove it. Update manually,", "or move it out of the way first." ].join("\n") ]);
          break;

         case "ECYCLE":
          short.push([ "cycle", [ er.message, "While installing: " + er.pkgid ].join("\n") ]), 
          detail.push([ "cycle", [ "Found a pathological dependency case that npm cannot solve.", "Please report this to the package author." ].join("\n") ]);
          break;

         case "EBADPLATFORM":
          var validOs = er.os.join ? er.os.join(",") : er.os, validArch = er.cpu.join ? er.cpu.join(",") : er.cpu, expected = {
            os: validOs,
            arch: validArch
          }, actual = {
            os: process.platform,
            arch: process.arch
          };
          short.push([ "notsup", [ util.format("Unsupported platform for %s: wanted %j (current: %j)", er.pkgid, expected, actual) ].join("\n") ]), 
          detail.push([ "notsup", [ "Valid OS:    " + validOs, "Valid Arch:  " + validArch, "Actual OS:   " + process.platform, "Actual Arch: " + process.arch ].join("\n") ]);
          break;

         case "EEXIST":
          short.push([ "", er.message ]), short.push([ "", "File exists: " + (er.dest || er.path) ]), 
          detail.push([ "", "Remove the existing file and try again, or run npm" ]), detail.push([ "", "with --force to overwrite files recklessly." ]);
          break;

         case "ENEEDAUTH":
          short.push([ "need auth", er.message ]), detail.push([ "need auth", "You need to authorize this machine using `npm adduser`" ]);
          break;

         case "ECONNRESET":
         case "ENOTFOUND":
         case "ETIMEDOUT":
         case "EAI_FAIL":
          short.push([ "network", er.message ]), detail.push([ "network", [ "This is a problem related to network connectivity.", "In most cases you are behind a proxy or have bad network settings.", "\nIf you are behind a proxy, please make sure that the", "'proxy' config is set properly.  See: 'npm help config'" ].join("\n") ]);
          break;

         case "ENOPACKAGEJSON":
          short.push([ "package.json", er.message ]), detail.push([ "package.json", [ "npm can't find a package.json file in your current directory." ].join("\n") ]);
          break;

         case "ETARGET":
          short.push([ "notarget", er.message ]), msg = [ "In most cases you or one of your dependencies are requesting", "a package version that doesn't exist." ], 
          er.parent && msg.push("\nIt was specified as a dependency of '" + er.parent + "'\n"), 
          detail.push([ "notarget", msg.join("\n") ]);
          break;

         case "E403":
          short.push([ "403", er.message ]), msg = [ "In most cases, you or one of your dependencies are requesting", "a package version that is forbidden by your security policy." ], 
          er.parent && msg.push("\nIt was specified as a dependency of '" + er.parent + "'\n"), 
          detail.push([ "403", msg.join("\n") ]);
          break;

         case "ENOTSUP":
          if (er.required) {
            short.push([ "notsup", er.message ]), short.push([ "notsup", "Not compatible with your version of node/npm: " + er.pkgid ]), 
            detail.push([ "notsup", [ "Not compatible with your version of node/npm: " + er.pkgid, "Required: " + JSON.stringify(er.required), "Actual:   " + JSON.stringify({
              npm: npm.version,
              node: npm.config.get("node-version")
            }) ].join("\n") ]);
            break;
          }

         case "ENOSPC":
          short.push([ "nospc", er.message ]), detail.push([ "nospc", [ "There appears to be insufficient space on your system to finish.", "Clear up some disk space and try again." ].join("\n") ]);
          break;

         case "EROFS":
          short.push([ "rofs", er.message ]), detail.push([ "rofs", [ "Often virtualized file systems, or other file systems", "that don't support symlinks, give this error." ].join("\n") ]);
          break;

         case "ENOENT":
          short.push([ "enoent", er.message ]), detail.push([ "enoent", [ "This is related to npm not being able to find a file.", er.file ? "\nCheck if the file '" + er.file + "' is present." : "" ].join("\n") ]);
          break;

         case "EMISSINGARG":
         case "EUNKNOWNTYPE":
         case "EINVALIDTYPE":
         case "ETOOMANYARGS":
          short.push([ "typeerror", er.stack ]), detail.push([ "typeerror", [ "This is an error with npm itself. Please report this error at:", "    <https://npm.community>" ].join("\n") ]);
          break;

         default:
          short.push([ "", er.message || er ]);
        }
        er.optional && (short.unshift([ "optional", er.optional + " (" + er.location + "):" ]), 
        short.concat(detail).forEach((function(msg) {
          msg[0] || (msg[0] = "optional"), msg[1] && (msg[1] = msg[1].toString().replace(/(^|\n)/g, "$1SKIPPING OPTIONAL DEPENDENCY: "));
        })));
        return {
          summary: short,
          detail
        };
      };
    },
    43795: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var path = __webpack_require__(71017), isWindows = __webpack_require__(52290);
      module.exports = function(str) {
        return isWindows ? '"' + path.normalize(str) + '"' : /[^-_.~/\w]/.test(str) ? "'" + str.replace(/'/g, "'\"'\"'") + "'" : str;
      };
    },
    19787: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var path = __webpack_require__(71017), isWindows = __webpack_require__(52290);
      function windowsQuotes(str) {
        return / /.test(str) ? '"' + str + '"' : str;
      }
      module.exports = function(str) {
        return isWindows ? path.normalize(str).split(/\\/).map(windowsQuotes).join("\\") : /[^-_.~/\w]/.test(str) ? "'" + str.replace(/'/g, "'\"'\"'") + "'" : str;
      };
    },
    41539: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      const URL = __webpack_require__(57310).URL;
      exports.getFundingInfo = function(idealTree, opts) {
        let packageWithFundingCount = 0;
        const flat = empty(), seen = new Set, {countOnly} = opts || {}, _trailingDependencies = Symbol("trailingDependencies");
        function retrieveDependencies(dependencies) {
          const trailing = dependencies[_trailingDependencies];
          return trailing ? Object.assign(empty(), dependencies, trailing) : dependencies;
        }
        function attachFundingInfo(target, funding, dep) {
          funding && validFundingField(funding) && (target.funding = retrieveFunding(funding), 
          countOnly || function(funding, dep) {
            [].concat(funding || []).forEach((f => {
              const key = f.url;
              Array.isArray(flat[key]) || (flat[key] = []), flat[key].push(dep);
            }));
          }(target.funding, dep), packageWithFundingCount++);
        }
        const idealTreeDependencies = function getFundingDependencies(tree) {
          const deps = tree && tree.dependencies;
          return deps ? Object.keys(deps).map((key => {
            const dep = deps[key], {name, funding, version} = dep;
            if (function(name, version) {
              const key = String(name) + String(version);
              if (seen.has(key)) return !0;
              seen.add(key);
            }(name, version)) return empty();
            const fundingItem = {};
            return version && (fundingItem.version = version), attachFundingInfo(fundingItem, funding, dep), 
            {
              dep,
              fundingItem
            };
          })).reduce(((res, {dep: directDep, fundingItem}, i) => {
            if (!fundingItem || 0 === fundingItem.length) return res;
            const transitiveDependencies = directDep.dependencies && Object.keys(directDep.dependencies).length > 0 && getFundingDependencies(directDep);
            return countOnly ? null : ((dependencies = transitiveDependencies) && (Object.keys(dependencies).length || dependencies[_trailingDependencies]) && (fundingItem.dependencies = retrieveDependencies(transitiveDependencies)), 
            fundingItem.funding && 0 !== fundingItem.funding.length ? res[directDep.name] = fundingItem : fundingItem.dependencies && (res[_trailingDependencies] = Object.assign(empty(), res[_trailingDependencies], fundingItem.dependencies)), 
            res);
            var dependencies;
          }), countOnly ? null : empty()) : empty();
        }(idealTree), result = {
          length: packageWithFundingCount
        };
        countOnly || (result.name = idealTree.name || idealTree.path, idealTree && idealTree.version && (result.version = idealTree.version), 
        idealTree && idealTree.funding && (result.funding = retrieveFunding(idealTree.funding)), 
        result.dependencies = retrieveDependencies(idealTreeDependencies), result[flatCacheSymbol] = flat);
        return result;
      }, exports.retrieveFunding = retrieveFunding, exports.validFundingField = validFundingField;
      const flatCacheSymbol = Symbol("npm flat cache");
      function retrieveFunding(funding) {
        const sources = [].concat(funding || []).map((item => "string" == typeof item ? {
          url: item
        } : item));
        return Array.isArray(funding) ? sources : sources[0];
      }
      function validFundingField(funding) {
        if (!funding) return !1;
        if (Array.isArray(funding)) return funding.every((f => !Array.isArray(f) && validFundingField(f)));
        try {
          var parsed = new URL(funding.url || funding);
        } catch (error) {
          return !1;
        }
        return ("https:" === parsed.protocol || "http:" === parsed.protocol) && Boolean(parsed.host);
      }
      exports.flatCacheSymbol = flatCacheSymbol;
      const empty = () => Object.create(null);
    },
    8638: (module, exports, __webpack_require__) => {
      module.exports = function(target, gently, base, cb) {
        cb || (cb = base, base = void 0);
        cb || (cb = gently, gently = !1);
        return gentleFS.rm(target, gentleFSOpts(gently, base), cb);
      };
      var gentleFS = __webpack_require__(33169), gentleFSOpts = __webpack_require__(64565);
    },
    46993: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      const BB = __webpack_require__(41142), exec = __webpack_require__(32081).execFile, spawn = __webpack_require__(34998), npm = __webpack_require__(44874), which = __webpack_require__(7017), git = npm.config.get("git"), assert = __webpack_require__(39491), log = __webpack_require__(19334), noProgressTillDone = __webpack_require__(39474).tillDone;
      function prefixGitArgs() {
        return "win32" === process.platform ? [ "-c", "core.longpaths=true" ] : [];
      }
      function execGit(args, options, cb) {
        log.info("git", args);
        const fullArgs = prefixGitArgs().concat(args || []);
        return exec(git, fullArgs, options, noProgressTillDone(cb));
      }
      exports.spawn = function(args, options) {
        return log.info("git", args), options.env = options.env || Object.keys(process.env).filter((k => !/^GIT/.test(k))).reduce(((set, k) => (set[k] = process.env[k], 
        set)), {}), spawn(git, prefixGitArgs().concat(args || []), options);
      }, exports.exec = BB.promisify(execGit), exports.chainableExec = function() {
        var args = Array.prototype.slice.call(arguments);
        return [ execGit ].concat(args);
      }, exports.whichAndExec = function(args, options, cb) {
        assert.equal(typeof cb, "function", "no callback provided"), which(git, (function(err) {
          if (err) return err.code = "ENOGIT", cb(err);
          execGit(args, options, cb);
        }));
      };
    },
    99890: (module, __unused_webpack_exports, __webpack_require__) => {
      var duplex = __webpack_require__(30498).duplex, through = __webpack_require__(30498).through, zlib = __webpack_require__(59796);
      module.exports = function() {
        var stream = duplex(), peeker = through((function(chunk, enc, cb) {
          var c, newStream = 31 === (c = chunk)[0] && 139 === c[1] && 8 === c[2] ? zlib.createGunzip() : through();
          stream.setReadable(newStream), stream.setWritable(newStream), stream.write(chunk);
        }));
        return stream.setWritable(peeker), stream;
      };
    },
    80127: module => {
      "use strict";
      module.exports = function(req) {
        return null != req && ("registry" in req ? req.registry : "range" === req.type || "version" === req.type || "tag" === req.type);
      };
    },
    79201: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var isWindows = __webpack_require__(52290);
      module.exports = isWindows && (/^MINGW(32|64)$/.test(process.env.MSYSTEM) || "cygwin" === process.env.TERM);
    },
    98892: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var isWindows = __webpack_require__(52290), isWindowsBash = __webpack_require__(79201);
      module.exports = isWindows && !isWindowsBash;
    },
    52290: module => {
      "use strict";
      module.exports = "win32" === process.platform;
    },
    6444: (module, exports, __webpack_require__) => {
      module.exports = function(stage) {
        function CMD(args, cb) {
          npm.commands["run-script"]([ stage ].concat(args), cb);
        }
        CMD.usage = usage(stage, "npm " + stage + " [-- <args>]");
        var installedShallow = __webpack_require__(73486);
        return CMD.completion = function(opts, cb) {
          installedShallow(opts, (function(d) {
            return d.scripts && d.scripts[stage];
          }), cb);
        }, CMD;
      };
      var npm = __webpack_require__(44874), usage = __webpack_require__(29320);
    },
    4705: (module, exports, __webpack_require__) => {
      module.exports = function(pkg, stage, wd, moreOpts, cb) {
        "function" == typeof moreOpts && (cb = moreOpts, moreOpts = null);
        const opts = lifecycleOpts(moreOpts);
        lifecycle(pkg, stage, wd, opts).then(cb, cb);
      };
      const lifecycleOpts = __webpack_require__(96058), lifecycle = __webpack_require__(38175);
    },
    32735: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = function(from, to, gently, abs, cb) {
        return gentleFS.link(from, to, gentleFSOpts(gently, void 0, abs), cb);
      };
      var gentleFS = __webpack_require__(33169), gentleFSOpts = __webpack_require__(64565);
    },
    67797: (module, __unused_webpack_exports, __webpack_require__) => {
      var crypto = __webpack_require__(6113), resolve = __webpack_require__(71017).resolve, lockfile = __webpack_require__(84174), log = __webpack_require__(19334), npm = __webpack_require__(44874), correctMkdir = __webpack_require__(79501), installLocks = {};
      function lockFileName(base, name) {
        var c = name.replace(/[^a-zA-Z0-9]+/g, "-").replace(/^-+|-+$/g, ""), p = resolve(base, name), h = crypto.createHash("sha1").update(p).digest("hex"), l = resolve(npm.cache, "_locks");
        return resolve(l, c.substr(0, 24) + "-" + h.substr(0, 16) + ".lock");
      }
      module.exports = {
        lock: function(base, name, cb) {
          var lockDir = resolve(npm.cache, "_locks");
          correctMkdir(lockDir, (function(er) {
            if (er) return cb(er);
            var opts = {
              stale: npm.config.get("cache-lock-stale"),
              retries: npm.config.get("cache-lock-retries"),
              wait: npm.config.get("cache-lock-wait")
            }, lf = lockFileName(base, name);
            lockfile.lock(lf, opts, (function(er) {
              er && log.warn("locking", lf, "failed", er), er || (log.verbose("lock", "using", lf, "for", resolve(base, name)), 
              installLocks[lf] = !0), cb(er);
            }));
          }));
        },
        unlock: function(base, name, cb) {
          var lf = lockFileName(base, name), locked = installLocks[lf];
          if (!1 === locked) return process.nextTick(cb);
          if (!0 !== locked) {
            var notLocked = new Error("Attempt to unlock " + resolve(base, name) + ", which hasn't been locked");
            throw notLocked.code = "ENOTLOCKED", notLocked;
          }
          lockfile.unlock(lf, (function(er) {
            er ? log.warn("unlocking", lf, "failed", er) : (installLocks[lf] = !1, log.verbose("unlock", "done using", lf, "for", resolve(base, name))), 
            cb(er);
          }));
        }
      };
    },
    21694: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.start = function() {
        if (inMetrics) return;
        var metricsLaunch = __webpack_require__(33491);
        npm.metricsProcess = metricsLaunch();
      }, exports.stop = stopMetrics, exports.save = function(itWorked) {
        if (inMetrics) return;
        stopMetrics();
        var metrics, metricsFile = path.join(npm.config.get("cache"), "anonymous-cli-metrics.json");
        try {
          (metrics = JSON.parse(fs.readFileSync(metricsFile))).metrics.to = (new Date).toISOString(), 
          itWorked ? ++metrics.metrics.successfulInstalls : ++metrics.metrics.failedInstalls;
        } catch (ex) {
          metrics = {
            metricId: uuid.v4(),
            metrics: {
              from: (new Date).toISOString(),
              to: (new Date).toISOString(),
              successfulInstalls: itWorked ? 1 : 0,
              failedInstalls: itWorked ? 0 : 1
            }
          };
        }
        try {
          cacheFile.write(metricsFile, JSON.stringify(metrics));
        } catch (ex) {}
      }, exports.send = function(metricsFile, metricsRegistry) {
        inMetrics = !0;
        var cliMetrics = JSON.parse(fs.readFileSync(metricsFile));
        regFetch(`/-/npm/anon-metrics/v1/${encodeURIComponent(cliMetrics.metricId)}`, {
          registry: metricsRegistry,
          method: "PUT",
          body: cliMetrics.metrics,
          retry: !1
        }).then((() => {
          fs.unlinkSync(metricsFile);
        }), (err => {
          cacheFile.write(path.join(path.dirname(metricsFile), "last-send-metrics-error.txt"), err.stack);
        }));
      };
      const fs = __webpack_require__(57147), path = __webpack_require__(71017), npm = __webpack_require__(44874), regFetch = __webpack_require__(27382), uuid = __webpack_require__(66054), cacheFile = __webpack_require__(5651);
      let inMetrics = !1;
      function stopMetrics() {
        inMetrics || npm.metricsProcess && npm.metricsProcess.kill("SIGKILL");
      }
    },
    7802: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var path = __webpack_require__(71017);
      function pathToPackageName(dir) {
        if (null == dir) return "";
        if ("" === dir) return "";
        var name = path.relative(path.resolve(dir, ".."), dir), scoped = path.relative(path.resolve(dir, "../.."), dir);
        return "@" === scoped[0] ? scoped.replace(/\\/g, "/") : name.trim();
      }
      function isNotEmpty(str) {
        return null != str && "" !== str;
      }
      module.exports = function(tree) {
        if (tree.name) return tree.name;
        var pkg = tree.package || tree;
        if (isNotEmpty(pkg.name) && "string" == typeof pkg.name) return pkg.name.trim();
        var pkgName = pathToPackageName(tree.path);
        return "" !== pkgName ? pkgName : (null != tree._invalidName || (tree._invalidName = "!invalid#" + ++unknown), 
        tree._invalidName);
      }, module.exports.test = {}, module.exports.test.pathToPackageName = pathToPackageName, 
      module.exports.test.isNotEmpty = isNotEmpty;
      var unknown = 0;
    },
    57459: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = function(from, to) {
        return move(from, to, options);
      };
      const fs = __webpack_require__(59799), move = __webpack_require__(25315), options = {
        fs,
        Promise: __webpack_require__(41142),
        maxConcurrency: 4
      };
    },
    39474: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      var progressEnabled, log = __webpack_require__(19334), running = 0, startRunning = exports.startRunning = function() {
        null == progressEnabled && (progressEnabled = log.progressEnabled), progressEnabled && log.disableProgress(), 
        ++running;
      }, stopRunning = exports.stopRunning = function() {
        --running, progressEnabled && 0 === running && log.enableProgress();
      };
      exports.tillDone = function(cb) {
        return startRunning(), function() {
          stopRunning(), cb.apply(this, arguments);
        };
      };
    },
    89562: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const npm = __webpack_require__(44874), output = __webpack_require__(1015), opener = __webpack_require__(95815);
      module.exports = function(url, errMsg, cb, browser = npm.config.get("browser")) {
        function printAlternateMsg() {
          const alternateMsg = npm.config.get("json") ? JSON.stringify({
            title: errMsg,
            url
          }, null, 2) : `${errMsg}:\n\n${url}`;
          output(alternateMsg);
        }
        if (process.argv.indexOf("--no-browser") > -1) return printAlternateMsg(), cb();
        opener(url, {
          command: browser
        }, (er => er && "ENOENT" === er.code ? (printAlternateMsg(), cb()) : cb(er)));
      };
    },
    83304: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const BB = __webpack_require__(41142), optCheck = __webpack_require__(55212)({
        prompt: {
          default: "This operation requires a one-time password.\nEnter OTP:"
        },
        otp: {}
      }), readUserInfo = __webpack_require__(87121);
      module.exports = function(opts, fn) {
        return opts = opts.concat ? opts : optCheck(opts), BB.try((() => fn(opts))).catch((err => {
          if ("EOTP" === err.code || "E401" === err.code && /one-time pass/.test(err.body)) {
            if (process.stdin.isTTY && process.stdout.isTTY) return readUserInfo.otp(optCheck(opts).prompt).then((otp => fn(opts.concat({
              otp
            }))));
            throw err;
          }
          throw err;
        }));
      };
    },
    1015: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var log = __webpack_require__(19334);
      module.exports = function() {
        log.clearProgress(), console.log.apply(console, arguments), log.showProgress();
      };
    },
    73531: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var moduleName = __webpack_require__(7802);
      module.exports = function(tree) {
        var pkg = tree.package || tree;
        if (pkg._id && "@" !== pkg._id) return pkg._id;
        var name = moduleName(tree);
        return pkg.version ? name + "@" + pkg.version : name;
      };
    },
    51686: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var parseJsonWithErrors = __webpack_require__(15071), parseJSON = module.exports = function(content) {
        return parseJsonWithErrors(function(content) {
          65279 === (content = content.toString()).charCodeAt(0) && (content = content.slice(1));
          return content;
        }(content));
      };
      parseJSON.noExceptions = function(content) {
        try {
          return parseJSON(content);
        } catch (ex) {}
      };
    },
    87050: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var log = __webpack_require__(19334), perf = new (0, __webpack_require__(82361).EventEmitter);
      module.exports = perf;
      var timings = {};
      function time(name) {
        timings[name] = Date.now();
      }
      function timeEnd(name) {
        name in timings ? (perf.emit("timing", name, Date.now() - timings[name]), delete timings[name]) : log.silly("timing", "Tried to end timer that doesn't exist:", name);
      }
      process.on("time", time), process.on("timeEnd", timeEnd), perf.on("time", time), 
      perf.on("timeEnd", timeEnd);
    },
    76064: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = function(spec, tag, versions, metadata) {
        log.silly("pickManifestFromRegistryMetadata", "spec", spec, "tag", tag, "versions", versions);
        var tagged = metadata["dist-tags"][tag];
        if (tagged && metadata.versions[tagged] && semver.satisfies(tagged, spec, !0)) return {
          resolvedTo: tag,
          manifest: metadata.versions[tagged]
        };
        var ms = semver.maxSatisfying(versions, spec, !0);
        if (ms) return {
          resolvedTo: ms,
          manifest: metadata.versions[ms]
        };
        if ("*" === spec && versions.length && tagged && metadata.versions[tagged]) return {
          resolvedTo: tag,
          manifest: metadata.versions[tagged]
        };
      };
      var log = __webpack_require__(19334), semver = __webpack_require__(73107);
    },
    26549: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const validate = __webpack_require__(95073), log = __webpack_require__(19334), Bluebird = __webpack_require__(41142);
      let pulse, pulsers = 0;
      function pulseStart(prefix) {
        ++pulsers > 1 || (pulse = setInterval((function() {
          log.gauge.pulse(prefix);
        }), 150));
      }
      function pulseStop() {
        --pulsers > 0 || clearInterval(pulse);
      }
      module.exports = function(prefix, cb) {
        return validate("SF", [ prefix, cb ]), prefix || (prefix = "network"), pulseStart(prefix), 
        function() {
          pulseStop(), cb.apply(null, arguments);
        };
      }, module.exports.withPromise = function(prefix, promise) {
        promise || (promise = prefix, prefix = "");
        return pulseStart(prefix), Bluebird.resolve(promise).finally((() => pulseStop()));
      };
    },
    6236: (module, exports, __webpack_require__) => {
      module.exports = function(cb) {
        if (npm.config.get("global")) return cb();
        var path = __webpack_require__(71017);
        readJson(path.resolve(npm.prefix, "package.json"), (function(er, d) {
          return cb(er, d && d.name);
        }));
      };
      var npm = __webpack_require__(44874), readJson = __webpack_require__(92200);
    },
    87121: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      const Bluebird = __webpack_require__(41142), readAsync = Bluebird.promisify(__webpack_require__(9547)), userValidate = __webpack_require__(49598), log = __webpack_require__(19334);
      function read(opts) {
        return Bluebird.try((() => (log.clearProgress(), readAsync(opts)))).finally((() => {
          log.showProgress();
        }));
      }
      exports.otp = function readOTP(msg, otp, isRetry) {
        msg || (msg = [ "This command requires a one-time password (OTP) from your authenticator app.", "Enter one below. You can also pass one on the command line by appending --otp=123456.", "For more information, see:", "https://docs.npmjs.com/getting-started/using-two-factor-authentication", "Enter OTP: " ].join("\n"));
        return isRetry && otp && /^[\d ]+$|^[A-Fa-f0-9]{64,64}$/.test(otp) ? otp.replace(/\s+/g, "") : read({
          prompt: msg,
          default: otp || ""
        }).then((otp => readOTP(msg, otp, !0)));
      }, exports.password = function readPassword(msg, password, isRetry) {
        msg || (msg = "npm password: ");
        return isRetry && password ? password : read({
          prompt: msg,
          silent: !0,
          default: password || ""
        }).then((password => readPassword(msg, password, !0)));
      }, exports.username = function readUsername(msg, username, opts, isRetry) {
        msg || (msg = "npm username: ");
        if (isRetry && username) {
          const error = userValidate.username(username);
          if (!error) return Promise.resolve(username.trim());
          opts.log && opts.log.warn(error.message);
        }
        return read({
          prompt: msg,
          default: username || ""
        }).then((username => readUsername(msg, username, opts, !0)));
      }, exports.email = function readEmail(msg, email, opts, isRetry) {
        msg || (msg = "email (this IS public): ");
        if (isRetry && email) {
          const error = userValidate.email(email);
          if (!error) return email.trim();
          opts.log && opts.log.warn(error.message);
        }
        return read({
          prompt: msg,
          default: email || ""
        }).then((username => readEmail(msg, username, opts, !0)));
      };
    },
    45042: (module, __unused_webpack_exports, __webpack_require__) => {
      const URL = __webpack_require__(57310).URL;
      module.exports = function(arg) {
        const isString = "string" == typeof arg;
        if (!Array.isArray(arg) && !isString) return arg;
        const info = (isString ? arg.split(" ") : arg).map((arg => {
          try {
            const url = new URL(arg);
            return "" === url.password ? arg : arg.replace(url.password, "***");
          } catch (e) {
            return arg;
          }
        }));
        return isString ? info.join(" ") : info;
      };
    },
    80833: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var inherits = __webpack_require__(90741);
      function SaveStack(fn) {
        Error.call(this), Error.captureStackTrace(this, fn || SaveStack);
      }
      module.exports = SaveStack, inherits(SaveStack, Error), SaveStack.prototype.completeWith = function(er) {
        return this.__proto__ = er, this.stack = this.stack + "\n\n" + er.stack, this;
      };
    },
    34998: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = function(cmd, args, options) {
        var cmdWillOutput = function(stdio) {
          if ("inherit" === stdio) return !0;
          if (!Array.isArray(stdio)) return !1;
          for (var fh = 1; fh <= 2; ++fh) {
            if ("inherit" === stdio[fh]) return !0;
            if (1 === stdio[fh] || 2 === stdio[fh]) return !0;
          }
          return !1;
        }(options && options.stdio);
        cmdWillOutput && npwr.startRunning();
        var raw = _spawn(cmd, args, options), cooked = new EventEmitter;
        return raw.on("error", (function(er) {
          cmdWillOutput && npwr.stopRunning(), er.file = cmd, cooked.emit("error", er);
        })).on("close", (function(code, signal) {
          if (cmdWillOutput && npwr.stopRunning(), 127 === code) {
            var er = new Error("spawn ENOENT");
            er.code = "ENOENT", er.errno = "ENOENT", er.syscall = "spawn", er.file = cmd, cooked.emit("error", er);
          } else cooked.emit("close", code, signal);
        })), cooked.stdin = raw.stdin, cooked.stdout = raw.stdout, cooked.stderr = raw.stderr, 
        cooked.kill = function(sig) {
          return raw.kill(sig);
        }, cooked;
      };
      var _spawn = __webpack_require__(32081).spawn, EventEmitter = __webpack_require__(82361).EventEmitter, npwr = __webpack_require__(39474);
    },
    10081: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var uniqueFilename = __webpack_require__(16003), npm = __webpack_require__(44874);
      module.exports = function(prefix) {
        return uniqueFilename(npm.tmp, prefix);
      };
    },
    84175: (module, __unused_webpack_exports, __webpack_require__) => {
      var umask = __webpack_require__(37289), npmlog = __webpack_require__(19334), _fromString = umask.fromString;
      module.exports = umask, umask.fromString = function(val) {
        return _fromString(val, (function(err, result) {
          err && npmlog.warn("invalid umask", err.message), val = result;
        })), val;
      };
    },
    65665: module => {
      "use strict";
      module.exports = function(path) {
        return path.replace(/\\/g, "/");
      };
    },
    79625: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      var semver = __webpack_require__(73107), supported = __webpack_require__(2401).h$.d, checkVersion = exports.checkVersion = function(version) {
        var versionNoPrerelease = version.replace(/-.*$/, "");
        return {
          version: versionNoPrerelease,
          broken: semver.satisfies(versionNoPrerelease, "<6.2.0 || 9 <9.3.0"),
          unsupported: !semver.satisfies(versionNoPrerelease, supported)
        };
      };
      exports.checkForBrokenNode = function() {
        checkVersion(process.version).broken && (console.error("ERROR: npm is known not to run on Node.js " + process.version), 
        console.error("You'll need to upgrade to a newer Node.js version in order to use this"), 
        console.error("version of npm. You can find the latest version at https://nodejs.org/"), 
        process.exit(1));
      }, exports.checkForUnsupportedNode = function() {
        if (checkVersion(process.version).unsupported) {
          var log = __webpack_require__(19334);
          log.warn("npm", "npm does not support Node.js " + process.version), log.warn("npm", "You should probably upgrade to a newer version of node as we"), 
          log.warn("npm", "can't make any promises that npm will work with this version."), 
          log.warn("npm", "You can find the latest version at https://nodejs.org/");
        }
      };
    },
    29320: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var aliases = __webpack_require__(27572).aliases;
      module.exports = function(cmd, txt, opt) {
        var post = Object.keys(aliases).reduce((function(p, c) {
          return aliases[c] !== cmd ? p : p.concat(c);
        }), []);
        return (opt || post.length > 0) && (txt += "\n\n"), 1 === post.length ? (txt += "alias: ", 
        txt += post.join(", ")) : post.length > 1 && (txt += "aliases: ", txt += post.join(", ")), 
        opt && (post.length > 0 && (txt += "\n"), txt += "common options: " + opt), txt;
      };
    },
    81158: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = function(type) {
        return function(messages, instance) {
          instance ? (deprecations[type] || (deprecations[type] = {}), deprecations[type][instance] || (deprecations[type][instance] = !0, 
          messages.forEach((function(m) {
            log.warn(type, m);
          })))) : deprecations[type] || (deprecations[type] = {}, messages.forEach((function(m) {
            log.warn(type, m);
          })));
        };
      };
      var log = __webpack_require__(19334), deprecations = {};
    },
    25610: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const BB = __webpack_require__(41142), assert = __webpack_require__(39491), chain = __webpack_require__(89009).chain, detectIndent = __webpack_require__(78632), detectNewline = __webpack_require__(9637), fs = __webpack_require__(59799), readFile = BB.promisify(__webpack_require__(59799).readFile), git = __webpack_require__(46993), lifecycle = __webpack_require__(4705), log = __webpack_require__(19334), npm = __webpack_require__(44874), output = __webpack_require__(1015), parseJSON = __webpack_require__(51686), path = __webpack_require__(71017), semver = __webpack_require__(73107), stringifyPackage = __webpack_require__(22652), writeFileAtomic = __webpack_require__(19804);
      function version(args, silent, cb_) {
        if ("function" != typeof cb_ && (cb_ = silent, silent = !1), args.length > 1) return cb_(version.usage);
        readPackage((function(er, data, indent, newline) {
          if (!args.length) return function(data, cb) {
            var v = {};
            data && data.name && data.version && (v[data.name] = data.version);
            v.npm = npm.version, Object.keys(process.versions).sort().forEach((function(k) {
              v[k] = process.versions[k];
            })), npm.config.get("json") && (v = JSON.stringify(v, null, 2));
            output(v), cb();
          }(data, cb_);
          if (er) return log.error("version", "No valid package.json found"), cb_(er);
          if ("from-git" === args[0]) !function(silent, data, cb_) {
            chain([ verifyGit, parseLastGitTag ], (function(er, results) {
              if (er) return cb_(er);
              var localData = {
                hasGit: !0,
                existingTag: !0
              };
              persistVersion(results[results.length - 1], silent, data, localData, cb_);
            }));
          }(silent, data, cb_); else {
            var newVersion = semver.valid(args[0]);
            if (newVersion || (newVersion = semver.inc(data.version, args[0], npm.config.get("preid"))), 
            !newVersion) return cb_(version.usage);
            persistVersion(newVersion, silent, data, cb_);
          }
        }));
      }
      function parseLastGitTag(cb) {
        var options = {
          env: process.env
        };
        git.whichAndExec([ "describe", "--abbrev=0" ], options, (function(er, stdout) {
          if (er) return -1 !== er.message.indexOf("No names found") ? cb(new Error("No tags found")) : cb(er);
          var tag = stdout.trim(), prefix = npm.config.get("tag-version-prefix");
          0 === tag.indexOf(prefix) && (tag = tag.slice(prefix.length));
          var version = semver.valid(tag);
          if (!version) return cb(new Error(tag + " is not a valid version"));
          cb(null, version);
        }));
      }
      function persistVersion(newVersion, silent, data, localData, cb_) {
        if ("function" == typeof localData && (cb_ = localData, localData = {}), !npm.config.get("allow-same-version") && data.version === newVersion) return cb_(new Error("Version not changed, might want --allow-same-version"));
        data.version = newVersion;
        var lifecycleData = Object.create(data);
        lifecycleData._id = data.name + "@" + newVersion;
        var where = npm.prefix;
        chain([ !localData.hasGit && [ checkGit, localData ], [ lifecycle, lifecycleData, "preversion", where ], [ updatePackage, newVersion, silent ], [ lifecycle, lifecycleData, "version", where ], [ commit, localData, newVersion ], [ lifecycle, lifecycleData, "postversion", where ] ], cb_);
      }
      function readPackage(cb) {
        var packagePath = path.join(npm.localPrefix, "package.json");
        fs.readFile(packagePath, "utf8", (function(er, data) {
          if (er) return cb(new Error(er));
          var indent, newline;
          try {
            indent = detectIndent(data).indent, newline = detectNewline(data), data = JSON.parse(data);
          } catch (e) {
            er = e, data = null;
          }
          cb(er, data, indent, newline);
        }));
      }
      function updatePackage(newVersion, silent, cb_) {
        function cb(er) {
          er || silent || output("v" + newVersion), cb_(er);
        }
        readPackage((function(er, data, indent, newline) {
          if (er) return cb(new Error(er));
          data.version = newVersion, write(data, "package.json", indent, newline, cb);
        }));
      }
      function commit(localData, newVersion, cb) {
        !function(newVersion, cb) {
          BB.join(readLockfile(SHRINKWRAP), readLockfile(PKGLOCK), ((shrinkwrap, lockfile) => {
            if (!shrinkwrap && !lockfile) return cb(null, !1, !1);
            const file = shrinkwrap ? SHRINKWRAP : PKGLOCK;
            let data, indent, newline;
            try {
              data = parseJSON(shrinkwrap || lockfile), indent = detectIndent(shrinkwrap || lockfile).indent, 
              newline = detectNewline(shrinkwrap || lockfile);
            } catch (err) {
              return log.error("version", `Bad ${file} data.`), cb(err);
            }
            data.version = newVersion, write(data, file, indent, newline, (err => err ? (log.error("version", `Failed to update version in ${file}`), 
            cb(err)) : cb(null, !!shrinkwrap, !!lockfile)));
          }));
        }(newVersion, (function(er, hasShrinkwrap, hasLock) {
          if (er || !localData.hasGit) return cb(er);
          localData.hasShrinkwrap = hasShrinkwrap, localData.hasPackageLock = hasLock, function(version, localData, cb) {
            const options = {
              env: process.env
            }, message = npm.config.get("message").replace(/%s/g, version), commitArgs = buildCommitArgs([ "commit", ...npm.config.get("sign-git-commit") ? [ "-S", "-m" ] : [ "-m" ], message ]);
            (function(localData, options) {
              return addLocalFile("package.json", options, !1).then((() => localData.hasShrinkwrap ? addLocalFile("npm-shrinkwrap.json", options, !0) : localData.hasPackageLock ? addLocalFile("package-lock.json", options, !0) : void 0));
            })(localData, options).then((() => git.exec(commitArgs, options))).then((() => {
              if (!localData.existingTag) return git.exec([ "tag", npm.config.get("tag-version-prefix") + version, buildTagFlags(), message ], options);
            })).nodeify(cb);
          }(newVersion, localData, cb);
        }));
      }
      version.usage = "npm version [<newversion> | major | minor | patch | premajor | preminor | prepatch | prerelease [--preid=<prerelease-id>] | from-git]\n(run in package dir)\n'npm -v' or 'npm --version' to print npm version (" + npm.version + ")\n'npm view <pkg> version' to view a package's published version\n'npm ls' to inspect current package/dependency versions", 
      module.exports = version;
      const SHRINKWRAP = "npm-shrinkwrap.json", PKGLOCK = "package-lock.json";
      function readLockfile(name) {
        return readFile(path.join(npm.localPrefix, name), "utf8").catch({
          code: "ENOENT"
        }, (() => null));
      }
      function statGitFolder(cb) {
        fs.stat(path.join(npm.localPrefix, ".git"), cb);
      }
      function callGitStatus(cb) {
        git.whichAndExec([ "status", "--porcelain" ], {
          env: process.env
        }, cb);
      }
      function cleanStatusLines(stdout) {
        return stdout.trim().split("\n").filter((function(line) {
          return line.trim() && !line.match(/^\?\? /);
        })).map((function(line) {
          return line.trim();
        }));
      }
      function verifyGit(cb) {
        function checkStdout(er, stdout) {
          if (er) return cb(er);
          var lines = cleanStatusLines(stdout);
          if (lines.length > 0) return cb(new Error("Git working directory not clean.\n" + lines.join("\n")));
          cb();
        }
        statGitFolder((function(er) {
          if (er) return cb(er);
          callGitStatus(checkStdout);
        }));
      }
      function checkGit(localData, cb) {
        statGitFolder((function(er) {
          if (!(!er && npm.config.get("git-tag-version"))) return er && npm.config.get("git-tag-version") && log.verbose("version", "error checking for .git", er), 
          log.verbose("version", "not tagging in git"), cb(null, !1);
          callGitStatus((function(er, stdout) {
            if (er && "ENOGIT" === er.code) return log.warn("version", "This is a Git checkout, but the git command was not found.", "npm could not create a Git tag for this release!"), 
            cb(null, !1);
            var lines = cleanStatusLines(stdout);
            if (lines.length && !npm.config.get("force")) return cb(new Error("Git working directory not clean.\n" + lines.join("\n")));
            localData.hasGit = !0, cb(null, !0);
          }));
        }));
      }
      function buildCommitArgs(args) {
        const add = [];
        return "commit" === (args = args || [])[0] && args.shift(), npm.config.get("commit-hooks") || add.push("-n"), 
        npm.config.get("allow-same-version") && add.push("--allow-empty"), [ "commit", ...add, ...args ];
      }
      function buildTagFlags() {
        return "-".concat(npm.config.get("sign-git-tag") ? "s" : "", npm.config.get("allow-same-version") ? "f" : "", "m");
      }
      function addLocalFile(file, options, ignoreFailure) {
        const p = git.exec([ "add", path.join(npm.localPrefix, file) ], options);
        return ignoreFailure ? p.catch((() => {})) : p;
      }
      function write(data, file, indent, newline, cb) {
        assert(data && "object" == typeof data, "must pass data to version write"), assert("string" == typeof file, "must pass filename to write to version write"), 
        log.verbose("version.write", "data", data, "to", file), writeFileAtomic(path.join(npm.localPrefix, file), stringifyPackage(data, indent, newline), cb);
      }
      module.exports.buildCommitArgs = buildCommitArgs, module.exports.buildTagFlags = buildTagFlags;
    },
    27259: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = view;
      const BB = __webpack_require__(41142), byteSize = __webpack_require__(52822), color = __webpack_require__(53987), columns = __webpack_require__(33998), npmConfig = __webpack_require__(23300), log = __webpack_require__(19334), figgyPudding = __webpack_require__(55212), npa = __webpack_require__(4422), npm = __webpack_require__(44874), packument = __webpack_require__(76111), path = __webpack_require__(71017), readJson = __webpack_require__(44421), relativeDate = __webpack_require__(38100), semver = __webpack_require__(73107), style = __webpack_require__(65308), usage = __webpack_require__(29320), util = __webpack_require__(73837), validateName = __webpack_require__(70630), ViewConfig = figgyPudding({
        global: {},
        json: {},
        tag: {},
        unicode: {}
      });
      function view(args, silent, cb) {
        "function" != typeof cb && (cb = silent, silent = !1), args.length || (args = [ "." ]);
        const opts = ViewConfig(npmConfig()), pkg = args.shift();
        let nv;
        nv = /^[.]@/.test(pkg) ? npa.resolve(null, pkg.slice(2)) : npa(pkg);
        const name = nv.name, local = "." === name || !name;
        if (opts.global && local) return cb(new Error("Cannot use view command in global mode."));
        if (local) {
          const dir = npm.prefix;
          BB.resolve(readJson(path.resolve(dir, "package.json"))).nodeify(((er, d) => {
            if (d = d || {}, er && "ENOENT" !== er.code && "ENOTDIR" !== er.code) return cb(er);
            if (!d.name) return cb(new Error("Invalid package.json"));
            const p = d.name;
            nv = npa(p), pkg && ~pkg.indexOf("@") && (nv.rawSpec = pkg.split("@")[pkg.indexOf("@")]), 
            fetchAndRead(nv, args, silent, opts, cb);
          }));
        } else fetchAndRead(nv, args, silent, opts, cb);
      }
      function fetchAndRead(nv, args, silent, opts, cb) {
        let version = nv.rawSpec || npm.config.get("tag");
        return packument(nv, opts.concat({
          fullMetadata: !0,
          "prefer-online": !0
        })).catch((err => {
          if ("E404" === err.code) {
            err.message = `'${nv.name}' is not in the npm registry.`;
            const validated = validateName(nv.name);
            validated.validForNewPackages ? (err.message += "\nYou should bug the author to publish it", 
            err.message += "\n(or use the name yourself!)", err.message += "\n", err.message += "\nNote that you can also install from a", 
            err.message += "\ntarball, folder, http url, or git url.") : (err.message += "\n", 
            err.message += (validated.errors || []).join("\n"), err.message += (validated.warnings || []).join("\n"));
          }
          throw err;
        })).then((data => {
          if (data["dist-tags"] && data["dist-tags"][version] && (version = data["dist-tags"][version]), 
          data.time && data.time.unpublished) {
            const u = data.time.unpublished;
            let er = new Error("Unpublished by " + u.name + " on " + u.time);
            throw er.statusCode = 404, er.code = "E404", er.pkgid = data._id, er;
          }
          const results = [];
          const versions = data.versions || {};
          data.versions = Object.keys(versions).sort(semver.compareLoose), args.length || (args = [ "" ]), 
          -1 === args.indexOf("readme") && delete data.readme, Object.keys(versions).forEach((function(v) {
            semver.satisfies(v, version, !0) && args.forEach((function(args) {
              -1 !== args.indexOf("readme") && delete versions[v].readme, results.push(function(data, version, fields) {
                const o = {};
                return [ data, version ].forEach((function(s) {
                  Object.keys(s).forEach((function(k) {
                    o[k] = s[k];
                  }));
                })), search(o, fields.split("."), version.version, fields);
              }(data, versions[v], args));
            }));
          }));
          let retval = results.reduce(reducer, {});
          return 1 === args.length && "" === args[0] && (retval = function(obj) {
            const clean = {};
            return Object.keys(obj).forEach((function(version) {
              clean[version] = obj[version][""];
            })), clean;
          }(retval), log.silly("view", retval)), silent ? retval : opts.json || 1 !== args.length || "" !== args[0] ? BB.fromNode((cb => {
            !function(data, name, opts, cb) {
              const versions = Object.keys(data);
              let msg = "", msgJson = [];
              const includeVersions = versions.length > 1;
              let includeFields;
              if (versions.forEach((function(v) {
                const fields = Object.keys(data[v]);
                includeFields = includeFields || fields.length > 1, opts.json && msgJson.push({}), 
                fields.forEach((function(f) {
                  let d = cleanup(data[v][f]);
                  1 === fields.length && opts.json && (msgJson[msgJson.length - 1][f] = d), includeVersions || includeFields || "string" != typeof d ? opts.json ? msgJson[msgJson.length - 1][f] = d : d = util.inspect(d, {
                    showHidden: !1,
                    depth: 5,
                    colors: npm.color,
                    maxArrayLength: null
                  }) : "string" == typeof d && opts.json && (d = JSON.stringify(d)), opts.json || (f && includeFields && (f += " = "), 
                  -1 !== d.indexOf("\n") && (d = " \n" + d), msg += (includeVersions ? name + "@" + v + " " : "") + (includeFields ? f : "") + d + "\n");
                }));
              })), opts.json) {
                if (msgJson.length && 1 === Object.keys(msgJson[0]).length) {
                  const k = Object.keys(msgJson[0])[0];
                  msgJson = msgJson.map((function(m) {
                    return m[k];
                  }));
                }
                1 === msgJson.length ? msg = JSON.stringify(msgJson[0], null, 2) + "\n" : msgJson.length > 1 && (msg = JSON.stringify(msgJson, null, 2) + "\n");
              }
              /^\s*\n/.test(msg) && (msg += "\n");
              log.disableProgress(), process.stdout.write(msg, (() => cb(null, data)));
            }(retval, data._id, opts, cb);
          })).then((() => retval)) : (data.version = version, BB.all(results.map((v => function(packument, manifest, opts) {
            const unicode = opts.unicode;
            return BB.try((() => {
              if (!manifest) return void log.error("view", `No matching versions.\nTo see a list of versions, run:\n> npm view ${packument.name} versions`);
              const tags = [];
              Object.keys(packument["dist-tags"]).forEach((t => {
                const version = packument["dist-tags"][t];
                tags.push(`${style.bright(color.green(t))}: ${version}`);
              }));
              const unpackedSize = manifest.dist.unpackedSize && byteSize(manifest.dist.unpackedSize), licenseField = manifest.license || manifest.licence || "Proprietary", info = {
                name: color.green(manifest.name),
                version: color.green(manifest.version),
                bins: Object.keys(manifest.bin || {}).map(color.yellow),
                versions: color.yellow(packument.versions.length + ""),
                description: manifest.description,
                deprecated: manifest.deprecated,
                keywords: (packument.keywords || []).map(color.yellow),
                license: "string" == typeof licenseField ? licenseField : licenseField.type || "Proprietary",
                deps: Object.keys(manifest.dependencies || {}).map((dep => `${color.yellow(dep)}: ${manifest.dependencies[dep]}`)),
                publisher: manifest._npmUser && unparsePerson({
                  name: color.yellow(manifest._npmUser.name),
                  email: color.cyan(manifest._npmUser.email)
                }),
                modified: packument.time ? color.yellow(relativeDate(packument.time[packument.version])) : void 0,
                maintainers: (packument.maintainers || []).map((u => unparsePerson({
                  name: color.yellow(u.name),
                  email: color.cyan(u.email)
                }))),
                repo: manifest.bugs && (manifest.bugs.url || manifest.bugs) || manifest.repository && (manifest.repository.url || manifest.repository),
                site: manifest.homepage && (manifest.homepage.url || manifest.homepage),
                stars: color.yellow("" + packument.users ? Object.keys(packument.users || {}).length : 0),
                tags,
                tarball: color.cyan(manifest.dist.tarball),
                shasum: color.yellow(manifest.dist.shasum),
                integrity: manifest.dist.integrity && color.yellow(manifest.dist.integrity),
                fileCount: manifest.dist.fileCount && color.yellow(manifest.dist.fileCount),
                unpackedSize: unpackedSize && color.yellow(unpackedSize.value) + " " + unpackedSize.unit
              };
              "proprietary" === info.license.toLowerCase().trim() ? info.license = style.bright(color.red(info.license)) : info.license = color.green(info.license), 
              console.log(""), console.log(style.underline(style.bright(`${info.name}@${info.version}`)) + " | " + info.license + " | deps: " + (info.deps.length ? color.cyan(info.deps.length) : color.green("none")) + " | versions: " + info.versions), 
              info.description && console.log(info.description), (info.repo || info.site) && info.site && console.log(color.cyan(info.site));
              const warningSign = unicode ? "  " : "!!";
              info.deprecated && console.log(`\n${style.bright(color.red("DEPRECATED"))}${warningSign} - ${info.deprecated}`), 
              info.keywords.length && (console.log(""), console.log("keywords:", info.keywords.join(", "))), 
              info.bins.length && (console.log(""), console.log("bin:", info.bins.join(", "))), 
              console.log(""), console.log("dist"), console.log(".tarball:", info.tarball), console.log(".shasum:", info.shasum), 
              info.integrity && console.log(".integrity:", info.integrity), info.unpackedSize && console.log(".unpackedSize:", info.unpackedSize);
              const maxDeps = 24;
              if (info.deps.length && (console.log(""), console.log("dependencies:"), console.log(columns(info.deps.slice(0, maxDeps), {
                padding: 1
              })), info.deps.length > maxDeps && console.log(`(...and ${info.deps.length - maxDeps} more.)`)), 
              info.maintainers && info.maintainers.length && (console.log(""), console.log("maintainers:"), 
              info.maintainers.forEach((u => console.log("-", u)))), console.log(""), console.log("dist-tags:"), 
              console.log(columns(info.tags)), info.publisher || info.modified) {
                let publishInfo = "published";
                info.modified && (publishInfo += ` ${info.modified}`), info.publisher && (publishInfo += ` by ${info.publisher}`), 
                console.log(""), console.log(publishInfo);
              }
            }));
          }(data, v[Object.keys(v)[0]][""], opts)))).then((() => retval)));
        })).nodeify(cb);
      }
      function reducer(l, r) {
        return r && Object.keys(r).forEach((function(v) {
          l[v] = l[v] || {}, Object.keys(r[v]).forEach((function(t) {
            l[v][t] = r[v][t];
          }));
        })), l;
      }
      function search(data, fields, version, title) {
        let field;
        const tail = fields;
        for (;!field && fields.length; ) field = tail.shift();
        let o;
        if (fields = [ field ].concat(tail), !field && !tail.length) return o = {}, o[version] = {}, 
        o[version][title] = data, o;
        let index = field.match(/(.+)\[([^\]]+)\]$/);
        if (index) {
          if (field = index[1], index = index[2], data.field && data.field.hasOwnProperty(index)) return search(data[field][index], tail, version, title);
          field = field + "[" + index + "]";
        }
        if (Array.isArray(data)) {
          if (1 === data.length) return search(data[0], fields, version, title);
          let results = [];
          return data.forEach((function(data, i) {
            const tl = title.length, newt = title.substr(0, tl - fields.join(".").length - 1) + "[" + i + "]" + [ "" ].concat(fields).join(".");
            results.push(search(data, fields.slice(), version, newt));
          })), results = results.reduce(reducer, {}), results;
        }
        return data.hasOwnProperty(field) ? (data = data[field], tail.length ? "object" == typeof data ? search(data, tail, version, title) : new Error("Not an object: " + data) : (o = {}, 
        o[version] = {}, o[version][title] = data, o)) : void 0;
      }
      function cleanup(data) {
        if (Array.isArray(data)) return data.map(cleanup);
        if (!data || "object" != typeof data) return data;
        "object" == typeof data.versions && data.versions && !Array.isArray(data.versions) && (data.versions = Object.keys(data.versions || {}));
        let keys = Object.keys(data);
        return keys.forEach((function(d) {
          "_" === d.charAt(0) ? delete data[d] : "object" == typeof data[d] && (data[d] = cleanup(data[d]));
        })), keys = Object.keys(data), keys.length <= 3 && data.name && (1 === keys.length || 3 === keys.length && data.email && data.url || 2 === keys.length && (data.email || data.url)) && (data = unparsePerson(data)), 
        data;
      }
      function unparsePerson(d) {
        return "string" == typeof d ? d : d.name + (d.email ? " <" + d.email + ">" : "") + (d.url ? " (" + d.url + ")" : "");
      }
      view.usage = usage("view", "npm view [<@scope>/]<pkg>[@<version>] [<field>[.subfield]...]"), 
      view.completion = function(opts, cb) {
        if (opts.conf.argv.remain.length <= 2) return cb();
        const config = ViewConfig(npmConfig()), tag = config.tag, spec = npa(opts.conf.argv.remain[2]);
        return packument(spec, config).then((d => {
          const dv = d.versions[d["dist-tags"][tag]];
          return d.versions = Object.keys(d.versions).sort(semver.compareLoose), getFields(d).concat(getFields(dv));
        })).nodeify(cb);
        function getFields(d, f, pref) {
          return f = f || [], d ? (pref = pref || [], Object.keys(d).forEach((function(k) {
            if ("_" === k.charAt(0) || -1 !== k.indexOf(".")) return;
            const p = pref.concat(k).join(".");
            f.push(p), Array.isArray(d[k]) ? d[k].forEach((function(val, i) {
              const pi = p + "[" + i + "]";
              val && "object" == typeof val ? getFields(val, f, [ p ]) : f.push(pi);
            })) : "object" == typeof d[k] && getFields(d[k], f, [ p ]);
          })), f) : f;
        }
      };
    },
    53229: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = function(args, cb) {
        handsomeFace.forEach((function(line) {
          output(line.map((function(ch) {
            return "[" + (ch ? "48;5;" + ch : ch) + "m";
          })).join(" "));
        }));
        var c = args.shift();
        c ? npm.commands[c](args, cb) : cb();
      };
      var npm = __webpack_require__(44874), output = __webpack_require__(1015), handsomeFace = [ [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 232, 237, 236, 236, 232, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 235, 236, 235, 233, 237, 235, 233, 232, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 232, 235, 233, 232, 235, 235, 234, 233, 236, 232, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 0, 237, 235, 232, 232, 234, 233, 233, 232, 232, 233, 232, 232, 235, 232, 233, 234, 234, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 232, 232, 232, 239, 238, 235, 233, 232, 232, 232, 232, 232, 232, 232, 233, 235, 232, 233, 233, 232, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 234, 234, 232, 233, 234, 233, 234, 235, 233, 235, 60, 238, 238, 234, 234, 233, 234, 233, 238, 251, 246, 233, 233, 232, 0, 0, 0, 0, 0, 0 ], [ 0, 0, 233, 233, 233, 232, 232, 239, 249, 251, 252, 231, 231, 188, 250, 254, 59, 60, 255, 231, 231, 231, 252, 235, 239, 235, 232, 233, 0, 0, 0, 0, 0, 0 ], [ 0, 0, 232, 233, 232, 232, 232, 248, 231, 231, 231, 231, 231, 231, 231, 254, 238, 254, 231, 231, 231, 231, 231, 252, 233, 235, 237, 233, 234, 0, 0, 0, 0, 0 ], [ 0, 0, 233, 232, 232, 232, 248, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 251, 233, 233, 233, 236, 233, 0, 0, 0, 0 ], [ 232, 233, 233, 232, 232, 246, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 249, 233, 234, 234, 0, 0, 0, 0 ], [ 232, 232, 232, 232, 233, 249, 231, 255, 255, 255, 255, 254, 109, 60, 239, 237, 238, 237, 235, 235, 235, 235, 236, 235, 235, 235, 234, 232, 232, 232, 232, 232, 233, 0 ], [ 0, 232, 232, 233, 233, 233, 233, 233, 233, 233, 233, 233, 235, 236, 238, 238, 235, 188, 254, 254, 145, 236, 252, 254, 254, 254, 254, 249, 236, 235, 232, 232, 233, 0 ], [ 0, 0, 233, 237, 249, 239, 233, 252, 231, 231, 231, 231, 231, 231, 254, 235, 235, 254, 231, 231, 251, 235, 237, 231, 231, 231, 231, 7, 237, 235, 232, 233, 233, 0 ], [ 0, 0, 0, 0, 233, 248, 239, 233, 231, 231, 231, 231, 254, 233, 233, 235, 254, 255, 231, 254, 237, 236, 254, 239, 235, 235, 233, 233, 232, 232, 233, 232, 0, 0 ], [ 0, 0, 0, 232, 233, 246, 255, 255, 236, 236, 236, 236, 236, 255, 231, 231, 231, 231, 231, 231, 252, 234, 248, 231, 231, 231, 231, 248, 232, 232, 232, 0, 0, 0 ], [ 0, 0, 0, 0, 235, 237, 7, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 255, 238, 235, 7, 231, 231, 231, 246, 232, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 235, 103, 188, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 252, 232, 238, 231, 231, 255, 244, 232, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 235, 236, 103, 146, 253, 255, 231, 231, 231, 231, 231, 253, 251, 250, 250, 250, 246, 232, 235, 152, 255, 146, 66, 233, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 233, 103, 146, 146, 146, 146, 254, 231, 231, 231, 109, 103, 146, 255, 188, 239, 240, 103, 255, 253, 103, 238, 234, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 232, 235, 109, 146, 146, 146, 146, 146, 252, 152, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 103, 235, 233, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 235, 235, 103, 146, 146, 146, 146, 146, 146, 188, 188, 188, 188, 188, 188, 152, 146, 146, 146, 66, 235, 0, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 0, 233, 235, 66, 146, 146, 146, 146, 152, 255, 146, 240, 239, 241, 109, 146, 146, 146, 103, 233, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 234, 237, 109, 146, 146, 146, 146, 146, 254, 231, 231, 188, 146, 146, 146, 103, 233, 0, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 233, 237, 60, 103, 146, 146, 146, 146, 146, 103, 66, 60, 235, 232, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 232, 233, 233, 236, 235, 237, 235, 237, 237, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] ];
    },
    9364: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const BB = __webpack_require__(41142), npmConfig = __webpack_require__(23300), fetch = __webpack_require__(27382), figgyPudding = __webpack_require__(55212), npm = __webpack_require__(44874), output = __webpack_require__(1015), WhoamiConfig = figgyPudding({
        json: {},
        registry: {}
      });
      function whoami([spec], silent, cb) {
        "function" != typeof cb && (cb = silent, silent = !1);
        const opts = WhoamiConfig(npmConfig());
        return BB.try((() => {
          const registry = opts.registry;
          if (!registry) throw new Error("no default registry set");
          return npm.config.getCredentialsByURI(registry);
        })).then((({username, token}) => {
          if (username) return username;
          if (token) return fetch.json("/-/whoami", opts.concat({
            spec
          })).then((({username}) => {
            if (username) return username;
            throw Object.assign(new Error("Your auth token is no longer valid. Please log in again."), {
              code: "ENEEDAUTH"
            });
          }));
          throw Object.assign(new Error("This command requires you to be logged in."), {
            code: "ENEEDAUTH"
          });
        })).then((username => (silent || (opts.json ? output(JSON.stringify(username)) : output(username)), 
        username))).nodeify(cb);
      }
      module.exports = whoami, whoami.usage = "npm whoami [--registry <registry>]\n(just prints username according to given registry)";
    },
    43967: (module, __unused_webpack_exports, __webpack_require__) => {
      var log = __webpack_require__(19334);
      module.exports = function(args, cb) {
        var s = "win32" === process.platform ? " *" : " ", x = "win32" === process.platform ? " " : "", o = [ "i", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "", "", "", "&", "@", "" ], oc = [ 33, 34, 35, 36, 37 ];
        function w(s) {
          process.stderr.write(s);
        }
        w("\n"), function(H) {
          for (var i = 0; i < H; i++) w(" ");
          w(x + "[33m" + s + "\n");
          for (var M = 2 * H - 1, L = 1; L <= H; L++) {
            var O = 2 * L - 2, S = (M - O) / 2;
            for (i = 0; i < S; i++) w(" ");
            for (w(x + "[21m"), w(x + "[32m"), i = 0; i < O; i++) w("[" + oc[Math.floor(Math.random() * oc.length)] + "m" + o[Math.floor(Math.random() * o.length)]);
            w(x + "[32m\n"), w(x + "[0m");
          }
          for (w(" "), i = 1; i < H; i++) w("[32m^");
          for (w("| " + x + " |"), i = 1; i < H; i++) w("[32m^");
          if (H > 10) {
            for (w("\n "), i = 1; i < H; i++) w(" ");
            for (w("| " + x + " |"), i = 1; i < H; i++) w(" ");
          }
        }(20), w("\n\n"), log.heading = "", log.addLevel("npm", 1e5, log.headingStyle), 
        log.npm("loves you", "Happy Xmas, JavaScripters!"), cb();
      };
      var dg = !1;
      Object.defineProperty(module.exports, "usage", {
        get: function() {
          return dg && module.exports([], (function() {})), dg = !0, " ";
        }
      });
    },
    7885: (module, __unused_webpack_exports, __webpack_require__) => {
      var map = {
        "./access.js": 24844,
        "./adduser.js": 59117,
        "./audit.js": 20609,
        "./auth/legacy.js": 2126,
        "./auth/oauth.js": 4620,
        "./auth/saml.js": 7474,
        "./auth/sso.js": 14956,
        "./bin.js": 51791,
        "./bugs.js": 73741,
        "./build.js": 34674,
        "./cache.js": 15285,
        "./ci.js": 35200,
        "./completion.js": 41121,
        "./config.js": 80214,
        "./config/bin-links.js": 96228,
        "./config/clear-credentials-by-uri.js": 95959,
        "./config/cmd-list.js": 27572,
        "./config/core.js": 25560,
        "./config/defaults.js": 25476,
        "./config/figgy-config.js": 23300,
        "./config/gentle-fs.js": 64565,
        "./config/get-credentials-by-uri.js": 43932,
        "./config/lifecycle.js": 96058,
        "./config/load-cafile.js": 8033,
        "./config/load-prefix.js": 24226,
        "./config/nerf-dart.js": 43444,
        "./config/set-credentials-by-uri.js": 58089,
        "./config/set-user.js": 14871,
        "./dedupe.js": 84495,
        "./deprecate.js": 68037,
        "./dist-tag.js": 64112,
        "./docs.js": 97702,
        "./doctor.js": 24240,
        "./doctor/check-files-permission.js": 99420,
        "./doctor/check-ping.js": 59634,
        "./doctor/get-git-path.js": 67008,
        "./doctor/get-latest-nodejs-version.js": 9583,
        "./doctor/get-latest-npm-version.js": 10305,
        "./doctor/verify-cached-files.js": 59125,
        "./edit.js": 25758,
        "./explore.js": 19434,
        "./fetch-package-metadata.js": 3138,
        "./fund.js": 35094,
        "./get.js": 67870,
        "./help-search.js": 89982,
        "./help.js": 53210,
        "./hook.js": 95503,
        "./init.js": 35153,
        "./install-ci-test.js": 17577,
        "./install-test.js": 59330,
        "./install.js": 70913,
        "./install/access-error.js": 2101,
        "./install/action/build.js": 95854,
        "./install/action/extract-worker.js": 83990,
        "./install/action/extract.js": 10398,
        "./install/action/fetch.js": 19232,
        "./install/action/finalize.js": 35090,
        "./install/action/global-install.js": 11797,
        "./install/action/global-link.js": 98517,
        "./install/action/install.js": 22366,
        "./install/action/move.js": 73647,
        "./install/action/postinstall.js": 87969,
        "./install/action/preinstall.js": 18673,
        "./install/action/prepare.js": 27892,
        "./install/action/refresh-package-json.js": 51519,
        "./install/action/remove.js": 32689,
        "./install/action/unbuild.js": 54139,
        "./install/actions.js": 80631,
        "./install/and-add-parent-to-errors.js": 42719,
        "./install/and-finish-tracker.js": 79266,
        "./install/and-ignore-errors.js": 77448,
        "./install/audit.js": 64795,
        "./install/check-permissions.js": 129,
        "./install/copy-tree.js": 9528,
        "./install/decompose-actions.js": 67485,
        "./install/deps.js": 48045,
        "./install/diff-trees.js": 30855,
        "./install/exists.js": 10833,
        "./install/flatten-tree.js": 36140,
        "./install/fund.js": 12992,
        "./install/get-requested.js": 87517,
        "./install/has-modern-meta.js": 20278,
        "./install/inflate-bundled.js": 80074,
        "./install/inflate-shrinkwrap.js": 13802,
        "./install/is-dev-dep.js": 69504,
        "./install/is-extraneous.js": 66305,
        "./install/is-fs-access-available.js": 37339,
        "./install/is-only-dev.js": 35528,
        "./install/is-only-optional.js": 27849,
        "./install/is-opt-dep.js": 91295,
        "./install/is-prod-dep.js": 12727,
        "./install/module-staging-path.js": 14703,
        "./install/mutate-into-logical-tree.js": 60867,
        "./install/node.js": 65061,
        "./install/read-shrinkwrap.js": 34160,
        "./install/realize-shrinkwrap-specifier.js": 46900,
        "./install/report-optional-failure.js": 6843,
        "./install/save.js": 29705,
        "./install/update-package-json.js": 12155,
        "./install/validate-args.js": 11674,
        "./install/validate-tree.js": 49310,
        "./install/writable.js": 13047,
        "./link.js": 20148,
        "./logout.js": 51209,
        "./ls.js": 46627,
        "./npm.js": 44874,
        "./org.js": 98361,
        "./outdated.js": 45857,
        "./owner.js": 80357,
        "./pack.js": 69797,
        "./ping.js": 23447,
        "./prefix.js": 5240,
        "./profile.js": 24709,
        "./prune.js": 50970,
        "./publish.js": 88836,
        "./rebuild.js": 3539,
        "./repo.js": 13057,
        "./restart.js": 85933,
        "./root.js": 30176,
        "./run-script.js": 54948,
        "./search.js": 97535,
        "./search/all-package-metadata.js": 37379,
        "./search/all-package-search.js": 43456,
        "./search/format-package-stream.js": 73728,
        "./search/package-filter.js": 81111,
        "./set.js": 7433,
        "./shrinkwrap.js": 5446,
        "./star.js": 1945,
        "./stars.js": 83094,
        "./start.js": 10361,
        "./stop.js": 43605,
        "./substack.js": 83103,
        "./team.js": 38720,
        "./test.js": 75842,
        "./token.js": 35526,
        "./unbuild.js": 24736,
        "./uninstall.js": 71012,
        "./unpublish.js": 72190,
        "./update.js": 33714,
        "./utils/ansi-trim.js": 82576,
        "./utils/cache-file.js": 5651,
        "./utils/child-path.js": 37013,
        "./utils/completion/file-completion.js": 82463,
        "./utils/completion/installed-deep.js": 46624,
        "./utils/completion/installed-shallow.js": 73486,
        "./utils/correct-mkdir.js": 79501,
        "./utils/deep-sort-object.js": 21514,
        "./utils/depr-check.js": 8956,
        "./utils/did-you-mean.js": 90594,
        "./utils/error-handler.js": 62978,
        "./utils/error-message.js": 78611,
        "./utils/escape-arg.js": 43795,
        "./utils/escape-exec-path.js": 19787,
        "./utils/funding.js": 41539,
        "./utils/gently-rm.js": 8638,
        "./utils/git.js": 46993,
        "./utils/gunzip-maybe.js": 99890,
        "./utils/is-registry.js": 80127,
        "./utils/is-windows-bash.js": 79201,
        "./utils/is-windows-shell.js": 98892,
        "./utils/is-windows.js": 52290,
        "./utils/lifecycle-cmd.js": 6444,
        "./utils/lifecycle.js": 4705,
        "./utils/link.js": 32735,
        "./utils/locker.js": 67797,
        "./utils/metrics-launch.js": 33491,
        "./utils/metrics.js": 21694,
        "./utils/module-name.js": 7802,
        "./utils/move.js": 57459,
        "./utils/no-progress-while-running.js": 39474,
        "./utils/open-url.js": 89562,
        "./utils/otplease.js": 83304,
        "./utils/output.js": 1015,
        "./utils/package-id.js": 73531,
        "./utils/parse-json.js": 51686,
        "./utils/perf.js": 87050,
        "./utils/pick-manifest-from-registry-metadata.js": 76064,
        "./utils/pulse-till-done.js": 26549,
        "./utils/read-local-package.js": 6236,
        "./utils/read-user-info.js": 87121,
        "./utils/replace-info.js": 45042,
        "./utils/save-stack.js": 80833,
        "./utils/spawn.js": 34998,
        "./utils/temp-filename.js": 10081,
        "./utils/umask.js": 84175,
        "./utils/unix-format-path.js": 65665,
        "./utils/unsupported.js": 79625,
        "./utils/usage.js": 29320,
        "./utils/warn-deprecated.js": 81158,
        "./version.js": 25610,
        "./view.js": 27259,
        "./visnup.js": 53229,
        "./whoami.js": 9364,
        "./xmas.js": 43967
      };
      function webpackContext(req) {
        var id = webpackContextResolve(req);
        return __webpack_require__(id);
      }
      function webpackContextResolve(req) {
        if (!__webpack_require__.o(map, req)) {
          var e = new Error("Cannot find module '" + req + "'");
          throw e.code = "MODULE_NOT_FOUND", e;
        }
        return map[req];
      }
      webpackContext.keys = function() {
        return Object.keys(map);
      }, webpackContext.resolve = webpackContextResolve, module.exports = webpackContext, 
      webpackContext.id = 7885;
    },
    93012: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      var Parser = __webpack_require__(84105), through = __webpack_require__(49760), bufferFrom = Buffer.from && Buffer.from !== Uint8Array.from;
      function check(x, y) {
        return "string" == typeof x ? y == x : x && "function" == typeof x.exec ? x.exec(y) : "boolean" == typeof x || "object" == typeof x ? x : "function" == typeof x && x(y);
      }
      exports.parse = function(path, map) {
        var header, footer, parser = new Parser, stream = through((function(chunk) {
          "string" == typeof chunk && (chunk = bufferFrom ? Buffer.from(chunk) : new Buffer(chunk)), 
          parser.write(chunk);
        }), (function(data) {
          data && stream.write(data), header && stream.emit("header", header), footer && stream.emit("footer", footer), 
          stream.queue(null);
        }));
        "string" == typeof path && (path = path.split(".").map((function(e) {
          return "$*" === e ? {
            emitKey: !0
          } : "*" === e || ("" === e ? {
            recurse: !0
          } : e);
        })));
        return path && path.length || (path = null), parser.onValue = function(value) {
          if (this.root || (stream.root = value), path) {
            for (var i = 0, j = 0, emitKey = !1, emitPath = !1; i < path.length; ) {
              var c, key = path[i];
              if (j++, key && !key.recurse) {
                if (!(c = j === this.stack.length ? this : this.stack[j])) return;
                if (!check(key, c.key)) return void setHeaderFooter(c.key, value);
                emitKey = !!key.emitKey, emitPath = !!key.emitPath, i++;
              } else {
                i++;
                var nextKey = path[i];
                if (!nextKey) return;
                for (;;) {
                  if (!(c = j === this.stack.length ? this : this.stack[j])) return;
                  if (check(nextKey, c.key)) {
                    i++, Object.isFrozen(this.stack[j]) || (this.stack[j].value = null);
                    break;
                  }
                  setHeaderFooter(c.key, value), j++;
                }
              }
            }
            if (header && (stream.emit("header", header), header = !1), j === this.stack.length) {
              0;
              var actualPath = this.stack.slice(1).map((function(element) {
                return element.key;
              })).concat([ this.key ]), data = value;
              for (var k in null != data && null != (data = map ? map(data, actualPath) : data) && ((emitKey || emitPath) && (data = {
                value: data
              }, emitKey && (data.key = this.key), emitPath && (data.path = actualPath)), stream.queue(data)), 
              this.value && delete this.value[this.key], this.stack) Object.isFrozen(this.stack[k]) || (this.stack[k].value = null);
            }
          }
        }, parser._onToken = parser.onToken, parser.onToken = function(token, value) {
          parser._onToken(token, value), 0 === this.stack.length && stream.root && (path || stream.queue(stream.root), 
          0, stream.root = null);
        }, parser.onError = function(err) {
          err.message.indexOf("at position") > -1 && (err.message = "Invalid JSON (" + err.message + ")"), 
          stream.emit("error", err);
        }, stream;
        function setHeaderFooter(key, value) {
          !1 !== header && ((header = header || {})[key] = value), !1 !== footer && !1 === header && ((footer = footer || {})[key] = value);
        }
      }, exports.stringify = function(op, sep, cl, indent) {
        indent = indent || 0, !1 === op ? (op = "", sep = "\n", cl = "") : null == op && (op = "[\n", 
        sep = "\n,\n", cl = "\n]\n");
        var stream, first = !0, anyData = !1;
        return stream = through((function(data) {
          anyData = !0;
          try {
            var json = JSON.stringify(data, null, indent);
          } catch (err) {
            return stream.emit("error", err);
          }
          first ? (first = !1, stream.queue(op + json)) : stream.queue(sep + json);
        }), (function(data) {
          anyData || stream.queue(op), stream.queue(cl), stream.queue(null);
        }));
      }, exports.stringifyObject = function(op, sep, cl, indent) {
        indent = indent || 0, !1 === op ? (op = "", sep = "\n", cl = "") : null == op && (op = "{\n", 
        sep = "\n,\n", cl = "\n}\n");
        var first = !0, anyData = !1;
        return through((function(data) {
          anyData = !0;
          var json = JSON.stringify(data[0]) + ":" + JSON.stringify(data[1], null, indent);
          first ? (first = !1, this.queue(op + json)) : this.queue(sep + json);
        }), (function(data) {
          anyData || this.queue(op), this.queue(cl), this.queue(null);
        }));
      };
    },
    70143: (module, exports) => {
      function abbrev(list) {
        1 === arguments.length && Array.isArray(list) || (list = Array.prototype.slice.call(arguments, 0));
        for (var i = 0, l = list.length, args = []; i < l; i++) args[i] = "string" == typeof list[i] ? list[i] : String(list[i]);
        var abbrevs = {}, prev = "";
        for (i = 0, l = (args = args.sort(lexSort)).length; i < l; i++) {
          var current = args[i], next = args[i + 1] || "", nextMatches = !0, prevMatches = !0;
          if (current !== next) {
            for (var j = 0, cl = current.length; j < cl; j++) {
              var curChar = current.charAt(j);
              if (nextMatches = nextMatches && curChar === next.charAt(j), prevMatches = prevMatches && curChar === prev.charAt(j), 
              !nextMatches && !prevMatches) {
                j++;
                break;
              }
            }
            if (prev = current, j !== cl) for (var a = current.substr(0, j); j <= cl; j++) abbrevs[a] = current, 
            a += current.charAt(j); else abbrevs[current] = current;
          }
        }
        return abbrevs;
      }
      function lexSort(a, b) {
        return a === b ? 0 : a > b ? 1 : -1;
      }
      module.exports = abbrev.abbrev = abbrev, abbrev.monkeyPatch = function() {
        Object.defineProperty(Array.prototype, "abbrev", {
          value: function() {
            return abbrev(this);
          },
          enumerable: !1,
          configurable: !0,
          writable: !0
        }), Object.defineProperty(Object.prototype, "abbrev", {
          value: function() {
            return abbrev(Object.keys(this));
          },
          enumerable: !1,
          configurable: !0,
          writable: !0
        });
      };
    },
    53987: module => {
      "use strict";
      var colorNums = {
        white: 37,
        black: 30,
        blue: 34,
        cyan: 36,
        green: 32,
        magenta: 35,
        red: 31,
        yellow: 33,
        brightBlack: 90,
        brightRed: 91,
        brightGreen: 92,
        brightYellow: 93,
        brightBlue: 94,
        brightMagenta: 95,
        brightCyan: 96,
        brightWhite: 97
      }, backgroundColorNums = {
        bgBlack: 40,
        bgRed: 41,
        bgGreen: 42,
        bgYellow: 43,
        bgBlue: 44,
        bgMagenta: 45,
        bgCyan: 46,
        bgWhite: 47,
        bgBrightBlack: 100,
        bgBrightRed: 101,
        bgBrightGreen: 102,
        bgBrightYellow: 103,
        bgBrightBlue: 104,
        bgBrightMagenta: 105,
        bgBrightCyan: 106,
        bgBrightWhite: 107
      }, open = {}, close = {}, colors = {};
      Object.keys(colorNums).forEach((function(k) {
        var o = open[k] = "[" + colorNums[k] + "m", c = close[k] = "[39m";
        colors[k] = function(s) {
          return o + s + c;
        };
      })), Object.keys(backgroundColorNums).forEach((function(k) {
        var o = open[k] = "[" + backgroundColorNums[k] + "m", c = close[k] = "[49m";
        colors[k] = function(s) {
          return o + s + c;
        };
      })), module.exports = colors, colors.open = open, colors.close = close;
    },
    65308: module => {
      "use strict";
      var styleNums = {
        reset: [ 0, 22 ],
        bright: [ 1, 22 ],
        dim: [ 2, 22 ],
        italic: [ 3, 23 ],
        underline: [ 4, 24 ],
        blink: [ 5, 25 ],
        inverse: [ 7, 27 ]
      }, styles = {};
      Object.keys(styleNums).forEach((function(k) {
        styles[k] = function(s) {
          return "[" + styleNums[k][0] + "m" + s + "[" + styleNums[k][1] + "m";
        };
      })), module.exports = styles;
    },
    95073: module => {
      "use strict";
      module.exports = validate;
      const types = {
        "*": {
          label: "any",
          check: () => !0
        },
        A: {
          label: "array",
          check: _ => {
            return Array.isArray(_) || null != (thingy = _) && "object" == typeof thingy && thingy.hasOwnProperty("callee");
            var thingy;
          }
        },
        S: {
          label: "string",
          check: _ => "string" == typeof _
        },
        N: {
          label: "number",
          check: _ => "number" == typeof _
        },
        F: {
          label: "function",
          check: _ => "function" == typeof _
        },
        O: {
          label: "object",
          check: _ => "object" == typeof _ && null != _ && !types.A.check(_) && !types.E.check(_)
        },
        B: {
          label: "boolean",
          check: _ => "boolean" == typeof _
        },
        E: {
          label: "error",
          check: _ => _ instanceof Error
        },
        Z: {
          label: "null",
          check: _ => null == _
        }
      };
      function addSchema(schema, arity) {
        const group = arity[schema.length] = arity[schema.length] || [];
        -1 === group.indexOf(schema) && group.push(schema);
      }
      function validate(rawSchemas, args) {
        if (2 !== arguments.length) throw wrongNumberOfArgs([ "SA" ], arguments.length);
        if (!rawSchemas) throw missingRequiredArg(0);
        if (!args) throw missingRequiredArg(1);
        if (!types.S.check(rawSchemas)) throw invalidType(0, [ "string" ], rawSchemas);
        if (!types.A.check(args)) throw invalidType(1, [ "array" ], args);
        const schemas = rawSchemas.split("|"), arity = {};
        schemas.forEach((schema => {
          for (let ii = 0; ii < schema.length; ++ii) {
            const type = schema[ii];
            if (!types[type]) throw unknownType(ii, type);
          }
          if (/E.*E/.test(schema)) throw moreThanOneError(schema);
          addSchema(schema, arity), /E/.test(schema) && (addSchema(schema.replace(/E.*$/, "E"), arity), 
          addSchema(schema.replace(/E/, "Z"), arity), 1 === schema.length && addSchema("", arity));
        }));
        let matching = arity[args.length];
        if (!matching) throw wrongNumberOfArgs(Object.keys(arity), args.length);
        for (let ii = 0; ii < args.length; ++ii) {
          let newMatching = matching.filter((schema => {
            const type = schema[ii];
            return (0, types[type].check)(args[ii]);
          }));
          if (!newMatching.length) {
            const labels = matching.map((_ => types[_[ii]].label)).filter((_ => null != _));
            throw invalidType(ii, labels, args[ii]);
          }
          matching = newMatching;
        }
      }
      function missingRequiredArg(num) {
        return newException("EMISSINGARG", "Missing required argument #" + (num + 1));
      }
      function unknownType(num, type) {
        return newException("EUNKNOWNTYPE", "Unknown type " + type + " in argument #" + (num + 1));
      }
      function invalidType(num, expectedTypes, value) {
        let valueType;
        return Object.keys(types).forEach((typeCode => {
          types[typeCode].check(value) && (valueType = types[typeCode].label);
        })), newException("EINVALIDTYPE", "Argument #" + (num + 1) + ": Expected " + englishList(expectedTypes) + " but got " + valueType);
      }
      function englishList(list) {
        return list.join(", ").replace(/, ([^,]+)$/, " or $1");
      }
      function wrongNumberOfArgs(expected, got) {
        return newException("EWRONGARGCOUNT", "Expected " + englishList(expected) + " " + (expected.every((ex => 1 === ex.length)) ? "argument" : "arguments") + " but got " + got);
      }
      function moreThanOneError(schema) {
        return newException("ETOOMANYERRORTYPES", 'Only one error type per argument signature is allowed, more than one found in "' + schema + '"');
      }
      function newException(code, msg) {
        const err = new Error(msg);
        return err.code = code, Error.captureStackTrace && Error.captureStackTrace(err, validate), 
        err;
      }
    },
    84032: module => {
      module.exports = function archy(obj, prefix, opts) {
        void 0 === prefix && (prefix = ""), opts || (opts = {});
        var chr = function(s) {
          return !1 === opts.unicode ? {
            "": "|",
            "": "`",
            "": "+",
            "": "-",
            "": "-"
          }[s] : s;
        };
        "string" == typeof obj && (obj = {
          label: obj
        });
        var nodes = obj.nodes || [], lines = (obj.label || "").split("\n"), splitter = "\n" + prefix + (nodes.length ? chr("") : " ") + " ";
        return prefix + lines.join(splitter) + "\n" + nodes.map((function(node, ix) {
          var last = ix === nodes.length - 1, more = node.nodes && node.nodes.length, prefix_ = prefix + (last ? " " : chr("")) + " ";
          return prefix + chr(last ? "" : "") + chr("") + chr(more ? "" : "") + " " + archy(node, prefix_, opts).slice(prefix.length + 2);
        })).join("");
      };
    },
    40574: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var rawAsap = __webpack_require__(62327), freeTasks = [];
      function RawTask() {
        this.task = null, this.domain = null;
      }
      module.exports = function(task) {
        var rawTask;
        rawTask = freeTasks.length ? freeTasks.pop() : new RawTask;
        rawTask.task = task, rawTask.domain = process.domain, rawAsap(rawTask);
      }, RawTask.prototype.call = function() {
        this.domain && this.domain.enter();
        var threw = !0;
        try {
          this.task.call(), threw = !1, this.domain && this.domain.exit();
        } finally {
          threw && rawAsap.requestFlush(), this.task = null, this.domain = null, freeTasks.push(this);
        }
      };
    },
    62327: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var domain, hasSetImmediate = "function" == typeof setImmediate;
      function rawAsap(task) {
        queue.length || (requestFlush(), flushing = !0), queue[queue.length] = task;
      }
      module.exports = rawAsap;
      var queue = [], flushing = !1, index = 0;
      function flush() {
        for (;index < queue.length; ) {
          var currentIndex = index;
          if (index += 1, queue[currentIndex].call(), index > 1024) {
            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) queue[scan] = queue[scan + index];
            queue.length -= index, index = 0;
          }
        }
        queue.length = 0, index = 0, flushing = !1;
      }
      function requestFlush() {
        var parentDomain = process.domain;
        parentDomain && (domain || (domain = __webpack_require__(13639)), domain.active = process.domain = null), 
        flushing && hasSetImmediate ? setImmediate(flush) : process.nextTick(flush), parentDomain && (domain.active = process.domain = parentDomain);
      }
      rawAsap.requestFlush = requestFlush;
    },
    10475: module => {
      "use strict";
      function balanced(a, b, str) {
        a instanceof RegExp && (a = maybeMatch(a, str)), b instanceof RegExp && (b = maybeMatch(b, str));
        var r = range(a, b, str);
        return r && {
          start: r[0],
          end: r[1],
          pre: str.slice(0, r[0]),
          body: str.slice(r[0] + a.length, r[1]),
          post: str.slice(r[1] + b.length)
        };
      }
      function maybeMatch(reg, str) {
        var m = str.match(reg);
        return m ? m[0] : null;
      }
      function range(a, b, str) {
        var begs, beg, left, right, result, ai = str.indexOf(a), bi = str.indexOf(b, ai + 1), i = ai;
        if (ai >= 0 && bi > 0) {
          if (a === b) return [ ai, bi ];
          for (begs = [], left = str.length; i >= 0 && !result; ) i == ai ? (begs.push(i), 
          ai = str.indexOf(a, i + 1)) : 1 == begs.length ? result = [ begs.pop(), bi ] : ((beg = begs.pop()) < left && (left = beg, 
          right = bi), bi = str.indexOf(b, i + 1)), i = ai < bi && ai >= 0 ? ai : bi;
          begs.length && (result = [ left, right ]);
        }
        return result;
      }
      module.exports = balanced, balanced.range = range;
    },
    82503: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const path = __webpack_require__(71017), fs = __webpack_require__(59799), BB = __webpack_require__(41142), gentleFs = __webpack_require__(33169), linkIfExists = BB.promisify(gentleFs.linkIfExists), gentleFsBinLink = BB.promisify(gentleFs.binLink), open = BB.promisify(fs.open), close = BB.promisify(fs.close), read = BB.promisify(fs.read, {
        multiArgs: !0
      }), chmod = BB.promisify(fs.chmod), readFile = BB.promisify(fs.readFile), writeFileAtomic = BB.promisify(__webpack_require__(19804)), normalize = __webpack_require__(71921);
      function getLinkOpts(opts, gently) {
        return Object.assign({}, opts, {
          gently
        });
      }
      module.exports = BB.promisify((function(pkg, folder, global, opts, cb) {
        pkg = normalize(pkg), folder = path.resolve(folder);
        var parent = pkg.name && "@" === pkg.name[0] ? path.dirname(path.dirname(folder)) : path.dirname(folder), gnm = global && opts.globalDir, gtop = parent === gnm;
        opts.log.info("linkStuff", opts.pkgId), opts.log.silly("linkStuff", opts.pkgId, "has", parent, "as its parent node_modules"), 
        global && opts.log.silly("linkStuff", opts.pkgId, "is part of a global install");
        gnm && opts.log.silly("linkStuff", opts.pkgId, "is installed into a global node_modules");
        gtop && opts.log.silly("linkStuff", opts.pkgId, "is installed into the top-level global node_modules");
        return BB.join(function(pkg, folder, parent, gtop, opts) {
          if (!pkg.bin || !gtop && "node_modules" !== path.basename(parent)) return;
          var linkOpts = getLinkOpts(opts, gtop && folder), execMode = parseInt("0777", 8) & ~opts.umask, binRoot = gtop ? opts.globalBin : path.resolve(parent, ".bin");
          return opts.log.verbose("linkBins", [ pkg.bin, binRoot, gtop ]), BB.map(Object.keys(pkg.bin), (bin => {
            var dest = path.resolve(binRoot, bin), src = path.resolve(folder, pkg.bin[bin]);
            if (0 !== src.indexOf(folder)) throw new Error("invalid bin entry for package " + pkg._id + ". key=" + bin + ", value=" + pkg.bin[bin]);
            return function(from, to, opts) {
              opts.globalBin && 0 === to.indexOf(opts.globalBin) && (opts.clobberLinkGently = !0);
              return gentleFsBinLink(from, to, opts);
            }(src, dest, linkOpts).then((() => chmod(src, execMode))).then((() => open(src, "r").then((fileHandle => read(fileHandle, Buffer.alloc(2), 0, 2, 0).spread(((_, buf) => function(buf) {
              return "#!" === buf.toString().slice(0, 2);
            }(buf) ? read(fileHandle, Buffer.alloc(2048), 0, 2048, 0) : [])).spread(((_, buf) => buf && function(buf) {
              return /^#![^\n]+\r\n/.test(buf);
            }(buf)), (() => !1)).finally((() => close(fileHandle))))).catch((() => !1)))).then((isHashbang => {
              var file;
              if (isHashbang) return opts.log.silly("linkBins", "Converting line endings of hashbang file:", src), 
              readFile(file = src, "utf8").then((content => writeFileAtomic(file, content.replace(/^(#![^\n]+)\r\n/, "$1\n"))));
            })).then((() => {
              if (gtop) {
                var dest = path.resolve(binRoot, bin), out = opts.parseable ? dest + "::" + src + ":BINFILE" : dest + " -> " + src;
                opts.json || opts.parseable || (opts.log.clearProgress(), console.log(out), opts.log.showProgress());
              }
            })).catch((err => {
              if ("ENOENT" !== err.code || !opts.ignoreScripts) throw err;
            }));
          }));
        }(pkg, folder, parent, gtop, opts), function(pkg, folder, parent, gtop, opts) {
          if (!pkg.man || !gtop || "win32" === process.platform) return;
          var manRoot = path.resolve(opts.prefix, "share", "man");
          opts.log.verbose("linkMans", "man files are", pkg.man, "in", manRoot);
          var set = pkg.man.reduce((function(acc, man) {
            if ("string" != typeof man) return acc;
            const cleanMan = path.join("/", man).replace(/\\|:/g, "/").substr(1);
            return acc[path.basename(man)] = cleanMan, acc;
          }), {}), manpages = pkg.man.filter((function(man) {
            if ("string" != typeof man) return !1;
            const cleanMan = path.join("/", man).replace(/\\|:/g, "/").substr(1);
            return set[path.basename(man)] === cleanMan;
          }));
          return BB.map(manpages, (man => {
            opts.log.silly("linkMans", "preparing to link", man);
            var parseMan = man.match(/(.*\.([0-9]+)(\.gz)?)$/);
            if (!parseMan) throw new Error(man + " is not a valid name for a man file.  Man files must end with a number, and optionally a .gz suffix if they are compressed.");
            var stem = parseMan[1], sxn = parseMan[2], bn = path.basename(stem), manSrc = path.resolve(folder, man);
            if (0 !== manSrc.indexOf(folder)) throw new Error("invalid man entry for package " + pkg._id + ". man=" + manSrc);
            var manDest = path.join(manRoot, "man" + sxn, bn);
            return opts.clobberLinkGently = !0, linkIfExists(manSrc, manDest, getLinkOpts(opts, gtop && folder));
          }));
        }(pkg, folder, 0, gtop, opts)).asCallback(cb);
      }));
    },
    21901: (module, __unused_webpack_exports, __webpack_require__) => {
      var concatMap = __webpack_require__(16148), balanced = __webpack_require__(10475);
      module.exports = function(str) {
        if (!str) return [];
        "{}" === str.substr(0, 2) && (str = "\\{\\}" + str.substr(2));
        return expand(function(str) {
          return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
        }(str), !0).map(unescapeBraces);
      };
      var escSlash = "\0SLASH" + Math.random() + "\0", escOpen = "\0OPEN" + Math.random() + "\0", escClose = "\0CLOSE" + Math.random() + "\0", escComma = "\0COMMA" + Math.random() + "\0", escPeriod = "\0PERIOD" + Math.random() + "\0";
      function numeric(str) {
        return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
      }
      function unescapeBraces(str) {
        return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
      }
      function parseCommaParts(str) {
        if (!str) return [ "" ];
        var parts = [], m = balanced("{", "}", str);
        if (!m) return str.split(",");
        var pre = m.pre, body = m.body, post = m.post, p = pre.split(",");
        p[p.length - 1] += "{" + body + "}";
        var postParts = parseCommaParts(post);
        return post.length && (p[p.length - 1] += postParts.shift(), p.push.apply(p, postParts)), 
        parts.push.apply(parts, p), parts;
      }
      function embrace(str) {
        return "{" + str + "}";
      }
      function isPadded(el) {
        return /^-?0\d/.test(el);
      }
      function lte(i, y) {
        return i <= y;
      }
      function gte(i, y) {
        return i >= y;
      }
      function expand(str, isTop) {
        var expansions = [], m = balanced("{", "}", str);
        if (!m || /\$$/.test(m.pre)) return [ str ];
        var n, isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body), isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body), isSequence = isNumericSequence || isAlphaSequence, isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) return m.post.match(/,.*\}/) ? expand(str = m.pre + "{" + m.body + escClose + m.post) : [ str ];
        if (isSequence) n = m.body.split(/\.\./); else if (1 === (n = parseCommaParts(m.body)).length && 1 === (n = expand(n[0], !1).map(embrace)).length) return (post = m.post.length ? expand(m.post, !1) : [ "" ]).map((function(p) {
          return m.pre + n[0] + p;
        }));
        var N, pre = m.pre, post = m.post.length ? expand(m.post, !1) : [ "" ];
        if (isSequence) {
          var x = numeric(n[0]), y = numeric(n[1]), width = Math.max(n[0].length, n[1].length), incr = 3 == n.length ? Math.abs(numeric(n[2])) : 1, test = lte;
          y < x && (incr *= -1, test = gte);
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) "\\" === (c = String.fromCharCode(i)) && (c = ""); else if (c = String(i), 
            pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                c = i < 0 ? "-" + z + c.slice(1) : z + c;
              }
            }
            N.push(c);
          }
        } else N = concatMap(n, (function(el) {
          return expand(el, !1);
        }));
        for (var j = 0; j < N.length; j++) for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          (!isTop || isSequence || expansion) && expansions.push(expansion);
        }
        return expansions;
      }
    },
    52854: (module, __unused_webpack_exports, __webpack_require__) => {
      var stream = __webpack_require__(12781), util = __webpack_require__(73837), timers = __webpack_require__(39512);
      function createLineStream(readStream, options) {
        if (!readStream) throw new Error("expected readStream");
        if (!readStream.readable) throw new Error("readStream must be readable");
        var ls = new LineStream(options);
        return readStream.pipe(ls), ls;
      }
      function LineStream(options) {
        stream.Transform.call(this, options), options = options || {}, this._readableState.objectMode = !0, 
        this._lineBuffer = [], this._keepEmptyLines = options.keepEmptyLines || !1, this._lastChunkEndedWithCR = !1;
        var self = this;
        this.on("pipe", (function(src) {
          self.encoding || src instanceof stream.Readable && (self.encoding = src._readableState.encoding);
        }));
      }
      module.exports = function(readStream, options) {
        return module.exports.createStream(readStream, options);
      }, module.exports.createStream = function(readStream, options) {
        return readStream ? createLineStream(readStream, options) : new LineStream(options);
      }, module.exports.createLineStream = function(readStream) {
        return console.log("WARNING: byline#createLineStream is deprecated and will be removed soon"), 
        createLineStream(readStream);
      }, module.exports.LineStream = LineStream, util.inherits(LineStream, stream.Transform), 
      LineStream.prototype._transform = function(chunk, encoding, done) {
        encoding = encoding || "utf8", Buffer.isBuffer(chunk) && ("buffer" == encoding ? (chunk = chunk.toString(), 
        encoding = "utf8") : chunk = chunk.toString(encoding)), this._chunkEncoding = encoding;
        var lines = chunk.split(/\r\n|[\n\v\f\r\x85\u2028\u2029]/g);
        this._lastChunkEndedWithCR && "\n" == chunk[0] && lines.shift(), this._lineBuffer.length > 0 && (this._lineBuffer[this._lineBuffer.length - 1] += lines[0], 
        lines.shift()), this._lastChunkEndedWithCR = "\r" == chunk[chunk.length - 1], this._lineBuffer = this._lineBuffer.concat(lines), 
        this._pushBuffer(encoding, 1, done);
      }, LineStream.prototype._pushBuffer = function(encoding, keep, done) {
        for (;this._lineBuffer.length > keep; ) {
          var line = this._lineBuffer.shift();
          if ((this._keepEmptyLines || line.length > 0) && !this.push(this._reencode(line, encoding))) {
            var self = this;
            return void timers.setImmediate((function() {
              self._pushBuffer(encoding, keep, done);
            }));
          }
        }
        done();
      }, LineStream.prototype._flush = function(done) {
        this._pushBuffer(this._chunkEncoding, 0, done);
      }, LineStream.prototype._reencode = function(line, chunkEncoding) {
        return this.encoding && this.encoding != chunkEncoding ? new Buffer(line, chunkEncoding).toString(this.encoding) : this.encoding ? line : new Buffer(line, chunkEncoding);
      };
    },
    71247: module => {
      "use strict";
      const limit = module.exports = function(func, maxRunning) {
        const state = {
          running: 0,
          queue: []
        };
        return maxRunning || (maxRunning = 50), function() {
          const args = Array.prototype.slice.call(arguments);
          state.running >= maxRunning ? state.queue.push({
            obj: this,
            args
          }) : callFunc(this, args);
        };
        function callNext() {
          if (0 === state.queue.length) return;
          const next = state.queue.shift();
          callFunc(next.obj, next.args);
        }
        function callFunc(obj, args) {
          const cb = "function" == typeof args[args.length - 1] && args.pop();
          try {
            ++state.running, func.apply(obj, args.concat((function() {
              --state.running, process.nextTick(callNext), cb && process.nextTick((() => cb.apply(obj, arguments)));
            })));
          } catch (err) {
            --state.running, cb && process.nextTick((() => cb.call(obj, err))), process.nextTick(callNext);
          }
        }
      };
      module.exports.method = function(classOrObj, method, maxRunning) {
        if ("function" == typeof classOrObj) {
          const func = classOrObj.prototype[method];
          classOrObj.prototype[method] = limit(func, maxRunning);
        } else {
          const func = classOrObj[method];
          classOrObj[method] = limit(func, maxRunning);
        }
      }, module.exports.promise = function(func, maxRunning) {
        const state = {
          running: 0,
          queue: []
        };
        return maxRunning || (maxRunning = 50), function() {
          const args = Array.prototype.slice.call(arguments);
          return state.running >= maxRunning ? new Promise((resolve => {
            state.queue.push({
              resolve,
              obj: this,
              args
            });
          })) : callFunc(this, args);
        };
        function callNext() {
          if (0 === state.queue.length) return;
          const next = state.queue.shift();
          next.resolve(callFunc(next.obj, next.args));
        }
        function callFunc(obj, args) {
          return function(action, fin) {
            try {
              return Promise.resolve(action()).then((value => (fin(), value)), (err => (fin(), 
              Promise.reject(err))));
            } catch (err) {
              return fin(), Promise.reject(err);
            }
          }((() => (++state.running, func.apply(obj, args))), (() => {
            --state.running, process.nextTick(callNext);
          }));
        }
      }, module.exports.promise.method = function(classOrObj, method, maxRunning) {
        if ("function" == typeof classOrObj) {
          const func = classOrObj.prototype[method];
          classOrObj.prototype[method] = limit.promise(func, maxRunning);
        } else {
          const func = classOrObj[method];
          classOrObj[method] = limit.promise(func, maxRunning);
        }
      };
    },
    13159: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const fs = __webpack_require__(57147), path = __webpack_require__(71017), LCHOWN = fs.lchown ? "lchown" : "chown", LCHOWNSYNC = fs.lchownSync ? "lchownSync" : "chownSync", needEISDIRHandled = fs.lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/), lchownSync = (path, uid, gid) => {
        try {
          return fs[LCHOWNSYNC](path, uid, gid);
        } catch (er) {
          if ("ENOENT" !== er.code) throw er;
        }
      }, handleEISDIR = needEISDIRHandled ? (path, uid, gid, cb) => er => {
        er && "EISDIR" === er.code ? fs.chown(path, uid, gid, cb) : cb(er);
      } : (_, __, ___, cb) => cb, handleEISDirSync = needEISDIRHandled ? (path, uid, gid) => {
        try {
          return lchownSync(path, uid, gid);
        } catch (er) {
          if ("EISDIR" !== er.code) throw er;
          ((path, uid, gid) => {
            try {
              fs.chownSync(path, uid, gid);
            } catch (er) {
              if ("ENOENT" !== er.code) throw er;
            }
          })(path, uid, gid);
        }
      } : (path, uid, gid) => lchownSync(path, uid, gid), nodeVersion = process.version;
      let readdir = (path, options, cb) => fs.readdir(path, options, cb);
      /^v4\./.test(nodeVersion) && (readdir = (path, options, cb) => fs.readdir(path, cb));
      const chown = (cpath, uid, gid, cb) => {
        fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, (er => {
          cb(er && "ENOENT" !== er.code ? er : null);
        })));
      }, chownrKid = (p, child, uid, gid, cb) => {
        if ("string" == typeof child) return fs.lstat(path.resolve(p, child), ((er, stats) => {
          if (er) return cb("ENOENT" !== er.code ? er : null);
          stats.name = child, chownrKid(p, stats, uid, gid, cb);
        }));
        if (child.isDirectory()) chownr(path.resolve(p, child.name), uid, gid, (er => {
          if (er) return cb(er);
          const cpath = path.resolve(p, child.name);
          chown(cpath, uid, gid, cb);
        })); else {
          const cpath = path.resolve(p, child.name);
          chown(cpath, uid, gid, cb);
        }
      }, chownr = (p, uid, gid, cb) => {
        readdir(p, {
          withFileTypes: !0
        }, ((er, children) => {
          if (er) {
            if ("ENOENT" === er.code) return cb();
            if ("ENOTDIR" !== er.code && "ENOTSUP" !== er.code) return cb(er);
          }
          if (er || !children.length) return chown(p, uid, gid, cb);
          let len = children.length, errState = null;
          const then = er => {
            if (!errState) return er ? cb(errState = er) : 0 == --len ? chown(p, uid, gid, cb) : void 0;
          };
          children.forEach((child => chownrKid(p, child, uid, gid, then)));
        }));
      }, chownrSync = (p, uid, gid) => {
        let children;
        try {
          children = ((path, options) => fs.readdirSync(path, options))(p, {
            withFileTypes: !0
          });
        } catch (er) {
          if ("ENOENT" === er.code) return;
          if ("ENOTDIR" === er.code || "ENOTSUP" === er.code) return handleEISDirSync(p, uid, gid);
          throw er;
        }
        return children && children.length && children.forEach((child => ((p, child, uid, gid) => {
          if ("string" == typeof child) try {
            const stats = fs.lstatSync(path.resolve(p, child));
            stats.name = child, child = stats;
          } catch (er) {
            if ("ENOENT" === er.code) return;
            throw er;
          }
          child.isDirectory() && chownrSync(path.resolve(p, child.name), uid, gid), handleEISDirSync(path.resolve(p, child.name), uid, gid);
        })(p, child, uid, gid))), handleEISDirSync(p, uid, gid);
      };
      module.exports = chownr, chownr.sync = chownrSync;
    },
    47535: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const ipRegex = __webpack_require__(33573), v4 = ipRegex.v4().source + "\\/(3[0-2]|[12]?[0-9])", v6 = ipRegex.v6().source + "\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])", cidr = module.exports = opts => opts && opts.exact ? new RegExp(`(?:^${v4}$)|(?:^${v6}$)`) : new RegExp(`(?:${v4})|(?:${v6})`, "g");
      cidr.v4 = opts => opts && opts.exact ? new RegExp(`^${v4}$`) : new RegExp(v4, "g"), 
      cidr.v6 = opts => opts && opts.exact ? new RegExp(`^${v6}$`) : new RegExp(v6, "g");
    },
    33998: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const stringWidth = __webpack_require__(41055), stripAnsi = __webpack_require__(42935), concat = Array.prototype.concat, defaults = {
        character: " ",
        newline: "\n",
        padding: 2,
        sort: !0,
        width: 0
      };
      function byPlainText(a, b) {
        const plainA = stripAnsi(a), plainB = stripAnsi(b);
        return plainA === plainB ? 0 : plainA > plainB ? 1 : -1;
      }
      function makeArray() {
        return [];
      }
      function makeList(count) {
        return Array.apply(null, Array(count));
      }
      function padCell(fullWidth, character, value) {
        return value + makeList(fullWidth - stringWidth(value) + 1).join(character);
      }
      function toRows(rows, cell, i) {
        return rows[i % rows.length].push(cell), rows;
      }
      function toString(arr) {
        return arr.join("");
      }
      module.exports = function(values, options) {
        values = concat.apply([], values), options = Object.assign({}, defaults, options);
        let cells = values.filter(Boolean).map(String);
        !1 !== options.sort && (cells = cells.sort(byPlainText));
        const termWidth = options.width || process.stdout.columns, cellWidth = Math.max.apply(null, cells.map(stringWidth)) + options.padding, columnCount = Math.floor(termWidth / cellWidth) || 1, rowCount = Math.ceil(cells.length / columnCount) || 1;
        return 1 === columnCount ? cells.join(options.newline) : cells.map(padCell.bind(null, cellWidth, options.character)).reduce(toRows, makeList(rowCount).map(makeArray)).map(toString).join(options.newline);
      };
    },
    96213: (module, __unused_webpack_exports, __webpack_require__) => {
      const utils = __webpack_require__(95741);
      class Cell {
        constructor(options) {
          this.setOptions(options), this.x = null, this.y = null;
        }
        setOptions(options) {
          -1 !== [ "boolean", "number", "string" ].indexOf(typeof options) && (options = {
            content: "" + options
          }), options = options || {}, this.options = options;
          let content = options.content;
          if (-1 !== [ "boolean", "number", "string" ].indexOf(typeof content)) this.content = String(content); else {
            if (content) throw new Error("Content needs to be a primitive, got: " + typeof content);
            this.content = "";
          }
          this.colSpan = options.colSpan || 1, this.rowSpan = options.rowSpan || 1;
        }
        mergeTableOptions(tableOptions, cells) {
          this.cells = cells;
          let optionsChars = this.options.chars || {}, tableChars = tableOptions.chars, chars = this.chars = {};
          CHAR_NAMES.forEach((function(name) {
            setOption(optionsChars, tableChars, name, chars);
          })), this.truncate = this.options.truncate || tableOptions.truncate;
          let style = this.options.style = this.options.style || {}, tableStyle = tableOptions.style;
          setOption(style, tableStyle, "padding-left", this), setOption(style, tableStyle, "padding-right", this), 
          this.head = style.head || tableStyle.head, this.border = style.border || tableStyle.border;
          let fixedWidth = tableOptions.colWidths[this.x];
          if (tableOptions.wordWrap && fixedWidth) {
            if (fixedWidth -= this.paddingLeft + this.paddingRight, this.colSpan) {
              let i = 1;
              for (;i < this.colSpan; ) fixedWidth += tableOptions.colWidths[this.x + i], i++;
            }
            this.lines = utils.colorizeLines(utils.wordWrap(fixedWidth, this.content));
          } else this.lines = utils.colorizeLines(this.content.split("\n"));
          this.desiredWidth = utils.strlen(this.content) + this.paddingLeft + this.paddingRight, 
          this.desiredHeight = this.lines.length;
        }
        init(tableOptions) {
          let x = this.x, y = this.y;
          this.widths = tableOptions.colWidths.slice(x, x + this.colSpan), this.heights = tableOptions.rowHeights.slice(y, y + this.rowSpan), 
          this.width = this.widths.reduce(sumPlusOne, -1), this.height = this.heights.reduce(sumPlusOne, -1), 
          this.hAlign = this.options.hAlign || tableOptions.colAligns[x], this.vAlign = this.options.vAlign || tableOptions.rowAligns[y], 
          this.drawRight = x + this.colSpan == tableOptions.colWidths.length;
        }
        draw(lineNum, spanningCell) {
          if ("top" == lineNum) return this.drawTop(this.drawRight);
          if ("bottom" == lineNum) return this.drawBottom(this.drawRight);
          let padTop, padLen = Math.max(this.height - this.lines.length, 0);
          switch (this.vAlign) {
           case "center":
            padTop = Math.ceil(padLen / 2);
            break;

           case "bottom":
            padTop = padLen;
            break;

           default:
            padTop = 0;
          }
          if (lineNum < padTop || lineNum >= padTop + this.lines.length) return this.drawEmpty(this.drawRight, spanningCell);
          let forceTruncation = this.lines.length > this.height && lineNum + 1 >= this.height;
          return this.drawLine(lineNum - padTop, this.drawRight, forceTruncation, spanningCell);
        }
        drawTop(drawRight) {
          let content = [];
          return this.cells ? this.widths.forEach((function(width, index) {
            content.push(this._topLeftChar(index)), content.push(utils.repeat(this.chars[0 == this.y ? "top" : "mid"], width));
          }), this) : (content.push(this._topLeftChar(0)), content.push(utils.repeat(this.chars[0 == this.y ? "top" : "mid"], this.width))), 
          drawRight && content.push(this.chars[0 == this.y ? "topRight" : "rightMid"]), this.wrapWithStyleColors("border", content.join(""));
        }
        _topLeftChar(offset) {
          let leftChar, x = this.x + offset;
          if (0 == this.y) leftChar = 0 == x ? "topLeft" : 0 == offset ? "topMid" : "top"; else if (0 == x) leftChar = "leftMid"; else if (leftChar = 0 == offset ? "midMid" : "bottomMid", 
          this.cells) {
            if (this.cells[this.y - 1][x] instanceof Cell.ColSpanCell && (leftChar = 0 == offset ? "topMid" : "mid"), 
            0 == offset) {
              let i = 1;
              for (;this.cells[this.y][x - i] instanceof Cell.ColSpanCell; ) i++;
              this.cells[this.y][x - i] instanceof Cell.RowSpanCell && (leftChar = "leftMid");
            }
          }
          return this.chars[leftChar];
        }
        wrapWithStyleColors(styleProperty, content) {
          if (!this[styleProperty] || !this[styleProperty].length) return content;
          try {
            let colors = __webpack_require__(13043);
            for (let i = this[styleProperty].length - 1; i >= 0; i--) colors = colors[this[styleProperty][i]];
            return colors(content);
          } catch (e) {
            return content;
          }
        }
        drawLine(lineNum, drawRight, forceTruncationSymbol, spanningCell) {
          let left = this.chars[0 == this.x ? "left" : "middle"];
          if (this.x && spanningCell && this.cells) {
            let cellLeft = this.cells[this.y + spanningCell][this.x - 1];
            for (;cellLeft instanceof ColSpanCell; ) cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];
            cellLeft instanceof RowSpanCell || (left = this.chars.rightMid);
          }
          let leftPadding = utils.repeat(" ", this.paddingLeft), right = drawRight ? this.chars.right : "", rightPadding = utils.repeat(" ", this.paddingRight), line = this.lines[lineNum], len = this.width - (this.paddingLeft + this.paddingRight);
          forceTruncationSymbol && (line += this.truncate || "");
          let content = utils.truncate(line, len, this.truncate);
          return content = utils.pad(content, len, " ", this.hAlign), content = leftPadding + content + rightPadding, 
          this.stylizeLine(left, content, right);
        }
        stylizeLine(left, content, right) {
          return left = this.wrapWithStyleColors("border", left), right = this.wrapWithStyleColors("border", right), 
          0 === this.y && (content = this.wrapWithStyleColors("head", content)), left + content + right;
        }
        drawBottom(drawRight) {
          let left = this.chars[0 == this.x ? "bottomLeft" : "bottomMid"], content = utils.repeat(this.chars.bottom, this.width), right = drawRight ? this.chars.bottomRight : "";
          return this.wrapWithStyleColors("border", left + content + right);
        }
        drawEmpty(drawRight, spanningCell) {
          let left = this.chars[0 == this.x ? "left" : "middle"];
          if (this.x && spanningCell && this.cells) {
            let cellLeft = this.cells[this.y + spanningCell][this.x - 1];
            for (;cellLeft instanceof ColSpanCell; ) cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];
            cellLeft instanceof RowSpanCell || (left = this.chars.rightMid);
          }
          let right = drawRight ? this.chars.right : "", content = utils.repeat(" ", this.width);
          return this.stylizeLine(left, content, right);
        }
      }
      class ColSpanCell {
        constructor() {}
        draw() {
          return "";
        }
        init() {}
        mergeTableOptions() {}
      }
      class RowSpanCell {
        constructor(originalCell) {
          this.originalCell = originalCell;
        }
        init(tableOptions) {
          let y = this.y, originalY = this.originalCell.y;
          this.cellOffset = y - originalY, this.offset = function(dimensionTable, startingIndex, span) {
            let ret = dimensionTable[startingIndex];
            for (let i = 1; i < span; i++) ret += 1 + dimensionTable[startingIndex + i];
            return ret;
          }(tableOptions.rowHeights, originalY, this.cellOffset);
        }
        draw(lineNum) {
          return "top" == lineNum ? this.originalCell.draw(this.offset, this.cellOffset) : "bottom" == lineNum ? this.originalCell.draw("bottom") : this.originalCell.draw(this.offset + 1 + lineNum);
        }
        mergeTableOptions() {}
      }
      function setOption(objA, objB, nameB, targetObj) {
        let nameA = nameB.split("-");
        nameA.length > 1 ? (nameA[1] = nameA[1].charAt(0).toUpperCase() + nameA[1].substr(1), 
        nameA = nameA.join(""), targetObj[nameA] = objA[nameA] || objA[nameB] || objB[nameA] || objB[nameB]) : targetObj[nameB] = objA[nameB] || objB[nameB];
      }
      function sumPlusOne(a, b) {
        return a + b + 1;
      }
      let CHAR_NAMES = [ "top", "top-mid", "top-left", "top-right", "bottom", "bottom-mid", "bottom-left", "bottom-right", "left", "left-mid", "mid", "mid-mid", "right", "right-mid", "middle" ];
      module.exports = Cell, module.exports.ColSpanCell = ColSpanCell, module.exports.RowSpanCell = RowSpanCell;
    },
    65229: (module, __unused_webpack_exports, __webpack_require__) => {
      const objectAssign = __webpack_require__(22799), Cell = __webpack_require__(96213), {ColSpanCell, RowSpanCell} = Cell;
      function makeComputeWidths(colSpan, desiredWidth, x, forcedMin) {
        return function(vals, table) {
          let result = [], spanners = [];
          table.forEach((function(row) {
            row.forEach((function(cell) {
              (cell[colSpan] || 1) > 1 ? spanners.push(cell) : result[cell[x]] = Math.max(result[cell[x]] || 0, cell[desiredWidth] || 0, forcedMin);
            }));
          })), vals.forEach((function(val, index) {
            "number" == typeof val && (result[index] = val);
          }));
          for (let k = spanners.length - 1; k >= 0; k--) {
            let cell = spanners[k], span = cell[colSpan], col = cell[x], existingWidth = result[col], editableCols = "number" == typeof vals[col] ? 0 : 1;
            for (let i = 1; i < span; i++) existingWidth += 1 + result[col + i], "number" != typeof vals[col + i] && editableCols++;
            if (cell[desiredWidth] > existingWidth) {
              let i = 0;
              for (;editableCols > 0 && cell[desiredWidth] > existingWidth; ) {
                if ("number" != typeof vals[col + i]) {
                  let dif = Math.round((cell[desiredWidth] - existingWidth) / editableCols);
                  existingWidth += dif, result[col + i] += dif, editableCols--;
                }
                i++;
              }
            }
          }
          objectAssign(vals, result);
          for (let j = 0; j < vals.length; j++) vals[j] = Math.max(forcedMin, vals[j] || 0);
        };
      }
      !function() {
        function layoutTable(table) {
          table.forEach((function(row, rowIndex) {
            row.forEach((function(cell, columnIndex) {
              cell.y = rowIndex, cell.x = columnIndex;
              for (let y = rowIndex; y >= 0; y--) {
                let row2 = table[y], xMax = y === rowIndex ? columnIndex : row2.length;
                for (let x = 0; x < xMax; x++) {
                  let cell2 = row2[x];
                  for (;cellsConflict(cell, cell2); ) cell.x++;
                }
              }
            }));
          }));
        }
        function maxWidth(table) {
          let mw = 0;
          return table.forEach((function(row) {
            row.forEach((function(cell) {
              mw = Math.max(mw, cell.x + (cell.colSpan || 1));
            }));
          })), mw;
        }
        function cellsConflict(cell1, cell2) {
          let yMin1 = cell1.y, yMax1 = cell1.y - 1 + (cell1.rowSpan || 1), yMin2 = cell2.y, yConflict = !(yMin1 > cell2.y - 1 + (cell2.rowSpan || 1) || yMin2 > yMax1), xMin1 = cell1.x, xMax1 = cell1.x - 1 + (cell1.colSpan || 1), xMin2 = cell2.x, xMax2 = cell2.x - 1 + (cell2.colSpan || 1);
          return yConflict && !(xMin1 > xMax2 || xMin2 > xMax1);
        }
        function conflictExists(rows, x, y) {
          let i_max = Math.min(rows.length - 1, y), cell = {
            x,
            y
          };
          for (let i = 0; i <= i_max; i++) {
            let row = rows[i];
            for (let j = 0; j < row.length; j++) if (cellsConflict(cell, row[j])) return !0;
          }
          return !1;
        }
        function allBlank(rows, y, xMin, xMax) {
          for (let x = xMin; x < xMax; x++) if (conflictExists(rows, x, y)) return !1;
          return !0;
        }
        function addRowSpanCells(table) {
          table.forEach((function(row, rowIndex) {
            row.forEach((function(cell) {
              for (let i = 1; i < cell.rowSpan; i++) {
                let rowSpanCell = new RowSpanCell(cell);
                rowSpanCell.x = cell.x, rowSpanCell.y = cell.y + i, rowSpanCell.colSpan = cell.colSpan, 
                insertCell(rowSpanCell, table[rowIndex + i]);
              }
            }));
          }));
        }
        function insertCell(cell, row) {
          let x = 0;
          for (;x < row.length && row[x].x < cell.x; ) x++;
          row.splice(x, 0, cell);
        }
        function fillInTable(table) {
          let h_max = function(table) {
            return table.length;
          }(table), w_max = maxWidth(table);
          for (let y = 0; y < h_max; y++) for (let x = 0; x < w_max; x++) if (!conflictExists(table, x, y)) {
            let opts = {
              x,
              y,
              colSpan: 1,
              rowSpan: 1
            };
            for (x++; x < w_max && !conflictExists(table, x, y); ) opts.colSpan++, x++;
            let y2 = y + 1;
            for (;y2 < h_max && allBlank(table, y2, opts.x, opts.x + opts.colSpan); ) opts.rowSpan++, 
            y2++;
            let cell = new Cell(opts);
            cell.x = opts.x, cell.y = opts.y, insertCell(cell, table[y]);
          }
        }
        module.exports = {
          makeTableLayout: function(rows) {
            let cellRows = function(rows) {
              return rows.map((function(row) {
                if (!Array.isArray(row)) {
                  let key = Object.keys(row)[0];
                  row = row[key], Array.isArray(row) ? (row = row.slice()).unshift(key) : row = [ key, row ];
                }
                return row.map((function(cell) {
                  return new Cell(cell);
                }));
              }));
            }(rows);
            return layoutTable(cellRows), fillInTable(cellRows), addRowSpanCells(cellRows), 
            function(cellRows) {
              for (let rowIndex = cellRows.length - 1; rowIndex >= 0; rowIndex--) {
                let cellColumns = cellRows[rowIndex];
                for (let columnIndex = 0; columnIndex < cellColumns.length; columnIndex++) {
                  let cell = cellColumns[columnIndex];
                  for (let k = 1; k < cell.colSpan; k++) {
                    let colSpanCell = new ColSpanCell;
                    colSpanCell.x = cell.x + k, colSpanCell.y = cell.y, cellColumns.splice(columnIndex + 1, 0, colSpanCell);
                  }
                }
              }
            }(cellRows), cellRows;
          },
          layoutTable,
          addRowSpanCells,
          maxWidth,
          fillInTable,
          computeWidths: makeComputeWidths("colSpan", "desiredWidth", "x", 1),
          computeHeights: makeComputeWidths("rowSpan", "desiredHeight", "y", 1)
        };
      }();
    },
    27275: (module, __unused_webpack_exports, __webpack_require__) => {
      const utils = __webpack_require__(95741), tableLayout = __webpack_require__(65229);
      function doDraw(row, lineNum, result) {
        let line = [];
        row.forEach((function(cell) {
          line.push(cell.draw(lineNum));
        }));
        let str = line.join("");
        str.length && result.push(str);
      }
      module.exports = class extends Array {
        constructor(options) {
          super(), this.options = utils.mergeOptions(options);
        }
        toString() {
          let array = this, headersPresent = this.options.head && this.options.head.length;
          headersPresent ? (array = [ this.options.head ], this.length && array.push.apply(array, this)) : this.options.style.head = [];
          let cells = tableLayout.makeTableLayout(array);
          cells.forEach((function(row) {
            row.forEach((function(cell) {
              cell.mergeTableOptions(this.options, cells);
            }), this);
          }), this), tableLayout.computeWidths(this.options.colWidths, cells), tableLayout.computeHeights(this.options.rowHeights, cells), 
          cells.forEach((function(row) {
            row.forEach((function(cell) {
              cell.init(this.options);
            }), this);
          }), this);
          let result = [];
          for (let rowIndex = 0; rowIndex < cells.length; rowIndex++) {
            let row = cells[rowIndex], heightOfRow = this.options.rowHeights[rowIndex];
            (0 === rowIndex || !this.options.style.compact || 1 == rowIndex && headersPresent) && doDraw(row, "top", result);
            for (let lineNum = 0; lineNum < heightOfRow; lineNum++) doDraw(row, lineNum, result);
            rowIndex + 1 == cells.length && doDraw(row, "bottom", result);
          }
          return result.join("\n");
        }
        get width() {
          return this.toString().split("\n")[0].length;
        }
      };
    },
    95741: (module, __unused_webpack_exports, __webpack_require__) => {
      const objectAssign = __webpack_require__(22799), stringWidth = __webpack_require__(41055);
      function codeRegex(capture) {
        return capture ? /\u001b\[((?:\d*;){0,5}\d*)m/g : /\u001b\[(?:\d*;){0,5}\d*m/g;
      }
      function strlen(str) {
        let code = codeRegex();
        return ("" + str).replace(code, "").split("\n").reduce((function(memo, s) {
          return stringWidth(s) > memo ? stringWidth(s) : memo;
        }), 0);
      }
      function repeat(str, times) {
        return Array(times + 1).join(str);
      }
      let codeCache = {};
      function addToCodeCache(name, on, off) {
        off = "[" + off + "m", codeCache[on = "[" + on + "m"] = {
          set: name,
          to: !0
        }, codeCache[off] = {
          set: name,
          to: !1
        }, codeCache[name] = {
          on,
          off
        };
      }
      function updateState(state, controlChars) {
        let controlCode = controlChars[1] ? parseInt(controlChars[1].split(";")[0]) : 0;
        if (controlCode >= 30 && controlCode <= 39 || controlCode >= 90 && controlCode <= 97) return void (state.lastForegroundAdded = controlChars[0]);
        if (controlCode >= 40 && controlCode <= 49 || controlCode >= 100 && controlCode <= 107) return void (state.lastBackgroundAdded = controlChars[0]);
        if (0 === controlCode) {
          for (let i in state) state.hasOwnProperty(i) && delete state[i];
          return;
        }
        let info = codeCache[controlChars[0]];
        info && (state[info.set] = info.to);
      }
      function readState(line) {
        let code = codeRegex(!0), controlChars = code.exec(line), state = {};
        for (;null !== controlChars; ) updateState(state, controlChars), controlChars = code.exec(line);
        return state;
      }
      function unwindState(state, ret) {
        let lastBackgroundAdded = state.lastBackgroundAdded, lastForegroundAdded = state.lastForegroundAdded;
        return delete state.lastBackgroundAdded, delete state.lastForegroundAdded, Object.keys(state).forEach((function(key) {
          state[key] && (ret += codeCache[key].off);
        })), lastBackgroundAdded && "[49m" != lastBackgroundAdded && (ret += "[49m"), 
        lastForegroundAdded && "[39m" != lastForegroundAdded && (ret += "[39m"), ret;
      }
      function rewindState(state, ret) {
        let lastBackgroundAdded = state.lastBackgroundAdded, lastForegroundAdded = state.lastForegroundAdded;
        return delete state.lastBackgroundAdded, delete state.lastForegroundAdded, Object.keys(state).forEach((function(key) {
          state[key] && (ret = codeCache[key].on + ret);
        })), lastBackgroundAdded && "[49m" != lastBackgroundAdded && (ret = lastBackgroundAdded + ret), 
        lastForegroundAdded && "[39m" != lastForegroundAdded && (ret = lastForegroundAdded + ret), 
        ret;
      }
      function truncateWidth(str, desiredLength) {
        if (str.length === strlen(str)) return str.substr(0, desiredLength);
        for (;strlen(str) > desiredLength; ) str = str.slice(0, -1);
        return str;
      }
      function wordWrap(maxLength, input) {
        let whitespace, lines = [], split = input.split(/(\s+)/g), line = [], lineLength = 0;
        for (let i = 0; i < split.length; i += 2) {
          let word = split[i], newLength = lineLength + strlen(word);
          lineLength > 0 && whitespace && (newLength += whitespace.length), newLength > maxLength ? (0 !== lineLength && lines.push(line.join("")), 
          line = [ word ], lineLength = strlen(word)) : (line.push(whitespace || "", word), 
          lineLength = newLength), whitespace = split[i + 1];
        }
        return lineLength && lines.push(line.join("")), lines;
      }
      addToCodeCache("bold", 1, 22), addToCodeCache("italics", 3, 23), addToCodeCache("underline", 4, 24), 
      addToCodeCache("inverse", 7, 27), addToCodeCache("strikethrough", 9, 29), module.exports = {
        strlen,
        repeat,
        pad: function(str, len, pad, dir) {
          let length = strlen(str);
          if (len + 1 >= length) {
            let padlen = len - length;
            switch (dir) {
             case "right":
              str = repeat(pad, padlen) + str;
              break;

             case "center":
              {
                let right = Math.ceil(padlen / 2);
                str = repeat(pad, padlen - right) + str + repeat(pad, right);
                break;
              }

             default:
              str += repeat(pad, padlen);
            }
          }
          return str;
        },
        truncate: function(str, desiredLength, truncateChar) {
          if (truncateChar = truncateChar || "", strlen(str) <= desiredLength) return str;
          let ret = function(str, desiredLength) {
            let myArray, code = codeRegex(!0), split = str.split(codeRegex()), splitIndex = 0, retLen = 0, ret = "", state = {};
            for (;retLen < desiredLength; ) {
              myArray = code.exec(str);
              let toAdd = split[splitIndex];
              if (splitIndex++, retLen + strlen(toAdd) > desiredLength && (toAdd = truncateWidth(toAdd, desiredLength - retLen)), 
              ret += toAdd, retLen += strlen(toAdd), retLen < desiredLength) {
                if (!myArray) break;
                ret += myArray[0], updateState(state, myArray);
              }
            }
            return unwindState(state, ret);
          }(str, desiredLength -= strlen(truncateChar));
          return ret + truncateChar;
        },
        mergeOptions: function(options, defaults) {
          let ret = objectAssign({}, defaults = defaults || {
            chars: {
              top: "",
              "top-mid": "",
              "top-left": "",
              "top-right": "",
              bottom: "",
              "bottom-mid": "",
              "bottom-left": "",
              "bottom-right": "",
              left: "",
              "left-mid": "",
              mid: "",
              "mid-mid": "",
              right: "",
              "right-mid": "",
              middle: ""
            },
            truncate: "",
            colWidths: [],
            rowHeights: [],
            colAligns: [],
            rowAligns: [],
            style: {
              "padding-left": 1,
              "padding-right": 1,
              head: [ "red" ],
              border: [ "grey" ],
              compact: !1
            },
            head: []
          }, options = options || {});
          return ret.chars = objectAssign({}, defaults.chars, options.chars), ret.style = objectAssign({}, defaults.style, options.style), 
          ret;
        },
        wordWrap: function(maxLength, input) {
          let output = [];
          input = input.split("\n");
          for (let i = 0; i < input.length; i++) output.push.apply(output, wordWrap(maxLength, input[i]));
          return output;
        },
        colorizeLines: function(input) {
          let state = {}, output = [];
          for (let i = 0; i < input.length; i++) {
            let line = rewindState(state, input[i]);
            state = readState(line);
            let temp = objectAssign({}, state);
            output.push(unwindState(temp, line));
          }
          return output;
        }
      };
    },
    6120: module => {
      var clone = function() {
        "use strict";
        function clone(parent, circular, depth, prototype) {
          "object" == typeof circular && (depth = circular.depth, prototype = circular.prototype, 
          circular.filter, circular = circular.circular);
          var allParents = [], allChildren = [], useBuffer = "undefined" != typeof Buffer;
          return void 0 === circular && (circular = !0), void 0 === depth && (depth = 1 / 0), 
          function _clone(parent, depth) {
            if (null === parent) return null;
            if (0 == depth) return parent;
            var child, proto;
            if ("object" != typeof parent) return parent;
            if (clone.__isArray(parent)) child = []; else if (clone.__isRegExp(parent)) child = new RegExp(parent.source, __getRegExpFlags(parent)), 
            parent.lastIndex && (child.lastIndex = parent.lastIndex); else if (clone.__isDate(parent)) child = new Date(parent.getTime()); else {
              if (useBuffer && Buffer.isBuffer(parent)) return child = Buffer.allocUnsafe ? Buffer.allocUnsafe(parent.length) : new Buffer(parent.length), 
              parent.copy(child), child;
              void 0 === prototype ? (proto = Object.getPrototypeOf(parent), child = Object.create(proto)) : (child = Object.create(prototype), 
              proto = prototype);
            }
            if (circular) {
              var index = allParents.indexOf(parent);
              if (-1 != index) return allChildren[index];
              allParents.push(parent), allChildren.push(child);
            }
            for (var i in parent) {
              var attrs;
              proto && (attrs = Object.getOwnPropertyDescriptor(proto, i)), attrs && null == attrs.set || (child[i] = _clone(parent[i], depth - 1));
            }
            return child;
          }(parent, depth);
        }
        function __objToStr(o) {
          return Object.prototype.toString.call(o);
        }
        function __getRegExpFlags(re) {
          var flags = "";
          return re.global && (flags += "g"), re.ignoreCase && (flags += "i"), re.multiline && (flags += "m"), 
          flags;
        }
        return clone.clonePrototype = function(parent) {
          if (null === parent) return null;
          var c = function() {};
          return c.prototype = parent, new c;
        }, clone.__objToStr = __objToStr, clone.__isDate = function(o) {
          return "object" == typeof o && "[object Date]" === __objToStr(o);
        }, clone.__isArray = function(o) {
          return "object" == typeof o && "[object Array]" === __objToStr(o);
        }, clone.__isRegExp = function(o) {
          return "object" == typeof o && "[object RegExp]" === __objToStr(o);
        }, clone.__getRegExpFlags = __getRegExpFlags, clone;
      }();
      module.exports && (module.exports = clone);
    },
    2138: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = cmdShim, cmdShim.ifExists = function(from, to, cb) {
        fs.stat(from, (function(er) {
          if (er) return cb();
          cmdShim(from, to, cb);
        }));
      };
      var fs = __webpack_require__(59799), mkdir = __webpack_require__(41718), path = __webpack_require__(71017), toBatchSyntax = __webpack_require__(64244), shebangExpr = /^#\!\s*(?:\/usr\/bin\/env)?\s*([^ \t]+=[^ \t]+\s+)*\s*([^ \t]+)(.*)$/;
      function rm(path, cb) {
        fs.unlink(path, (function(er) {
          cb();
        }));
      }
      function cmdShim(from, to, cb) {
        fs.stat(from, (function(er, stat) {
          if (er) return cb(er);
          !function(from, to, cb) {
            var then = times(3, next, cb);
            function next(er) {
              !function(from, to, cb) {
                mkdir(path.dirname(to), (function(er) {
                  if (er) return cb(er);
                  fs.readFile(from, "utf8", (function(er, data) {
                    if (er) return writeShim_(from, to, null, null, null, cb);
                    var shebang = data.trim().split(/\r*\n/)[0].match(shebangExpr);
                    if (!shebang) return writeShim_(from, to, null, null, null, cb);
                    var vars = shebang[1] || "", prog = shebang[2], args = shebang[3] || "";
                    return writeShim_(from, to, prog, args, vars, cb);
                  }));
                }));
              }(from, to, cb);
            }
            rm(to, then), rm(to + ".cmd", then), rm(to + ".ps1", then);
          }(from, to, cb);
        }));
      }
      function writeShim_(from, to, prog, args, variables, cb) {
        var longProg, shLongProg, pwshLongProg, shTarget = path.relative(path.dirname(to), from), target = shTarget.split("/").join("\\"), shProg = prog && prog.split("\\").join("/"), pwshProg = shProg && '"' + shProg + '$exe"';
        shTarget = shTarget.split("\\").join("/"), args = args || "", variables = variables || "", 
        prog ? (longProg = '"%dp0%\\' + prog + '.exe"', shLongProg = '"$basedir/' + prog + '"', 
        pwshLongProg = '"$basedir/' + prog + '$exe"', target = '"%dp0%\\' + target + '"', 
        shTarget = '"$basedir/' + shTarget + '"') : (prog = '"%dp0%\\' + target + '"', pwshProg = shProg = '"$basedir/' + shTarget + '"', 
        args = "", target = "", shTarget = "");
        var cmd, head = '@ECHO off\r\nSETLOCAL\r\nSET "dp0=%~dp0"\r\n';
        longProg ? (shLongProg = shLongProg.trim(), args = args.trim(), cmd = head + toBatchSyntax.convertToSetCommands(variables) + "\r\nIF EXIST " + longProg + ' (\r\n  SET "_prog=' + longProg.replace(/(^")|("$)/g, "") + '"\r\n) ELSE (\r\n  SET "_prog=' + prog.replace(/(^")|("$)/g, "") + '"\r\n  SET "PATHEXT=%PATHEXT:;.JS;=;%"\r\n)\r\n\r\n"%_prog%" ' + args + " " + target + " %*\r\n") : cmd = head + prog + " " + args + " " + target + " %*\r\n";
        var sh = "#!/bin/sh\n";
        sh += 'basedir=$(dirname "$(echo "$0" | sed -e \'s,\\\\,/,g\')")\n\ncase `uname` in\n  *CYGWIN*|*MINGW*|*MSYS*) basedir=`cygpath -w "$basedir"`;;\nesac\n\n', 
        sh = shLongProg ? sh + "_prog=" + shLongProg + '\nif ! [ -x "$_prog" ]; then\n  _prog=' + shProg + "\nfi\n" + variables + '"$_prog" ' + args + " " + shTarget + ' "$@"\n' : sh + shProg + " " + args + " " + shTarget + ' "$@"\n';
        var pwsh = '#!/usr/bin/env pwsh\n$basedir=Split-Path $MyInvocation.MyCommand.Definition -Parent\n\n$exe=""\nif ($PSVersionTable.PSVersion -lt "6.0" -or $IsWindows) {\n  # Fix case when both the Windows and Linux builds of Node\n  # are installed in the same directory\n  $exe=".exe"\n}\n';
        pwsh = shLongProg ? pwsh + "$_prog=" + pwshLongProg + '\nif (!(Test-Path "$_prog")) {\n  $_prog=' + pwshProg + '\n}\n& "$_prog" ' + args + " " + shTarget + " $args\n" : pwsh + "& " + pwshProg + " " + args + " " + shTarget + " $args\n";
        var then = times(3, (function() {
          !function(to, cb) {
            var then = times(3, cb, cb);
            fs.chmod(to, "0755", then), fs.chmod(to + ".cmd", "0755", then), fs.chmod(to + ".ps1", "0755", then);
          }(to, cb);
        }), cb);
        fs.writeFile(to + ".ps1", pwsh, "utf8", then), fs.writeFile(to + ".cmd", cmd, "utf8", then), 
        fs.writeFile(to, sh, "utf8", then);
      }
      function times(n, ok, cb) {
        var errState = null;
        return function(er) {
          errState || (er ? cb(errState = er) : 0 == --n && ok());
        };
      }
    },
    64244: (__unused_webpack_module, exports) => {
      function convertToSetCommand(key, value) {
        var line = "";
        return key = (key = key || "").trim(), value = (value = value || "").trim(), key && value && value.length > 0 && (line = "@SET " + key + "=" + replaceDollarWithPercentPair(value) + "\r\n"), 
        line;
      }
      function replaceDollarWithPercentPair(value) {
        var dollarExpressions = /\$\{?([^\$@#\?\- \t{}:]+)\}?/g, result = "", startIndex = 0;
        do {
          var match = dollarExpressions.exec(value);
          if (match) result += (value.substring(startIndex, match.index) || "") + "%" + match[1] + "%", 
          startIndex = dollarExpressions.lastIndex;
        } while (dollarExpressions.lastIndex > 0);
        return result += value.substr(startIndex);
      }
      exports.replaceDollarWithPercentPair = replaceDollarWithPercentPair, exports.convertToSetCommand = convertToSetCommand, 
      exports.convertToSetCommands = function(variableString) {
        var variableValuePairs = (declarations = variableString.split(" "), pairs = {}, 
        declarations.map((function(declaration) {
          var split = declaration.split("=");
          pairs[split[0]] = split[1];
        })), pairs), variableDeclarationsAsBatch = "";
        var declarations, pairs;
        return Object.keys(variableValuePairs).forEach((function(key) {
          variableDeclarationsAsBatch += convertToSetCommand(key, variableValuePairs[key]);
        })), variableDeclarationsAsBatch;
      };
    },
    13043: (module, __unused_webpack_exports, __webpack_require__) => {
      var colors = {};
      module.exports = colors, colors.themes = {};
      var util = __webpack_require__(73837), ansiStyles = colors.styles = __webpack_require__(7030), defineProps = Object.defineProperties, newLineRegex = new RegExp(/[\r\n]+/g);
      colors.supportsColor = __webpack_require__(74737).supportsColor, void 0 === colors.enabled && (colors.enabled = !1 !== colors.supportsColor()), 
      colors.enable = function() {
        colors.enabled = !0;
      }, colors.disable = function() {
        colors.enabled = !1;
      }, colors.stripColors = colors.strip = function(str) {
        return ("" + str).replace(/\x1B\[\d+m/g, "");
      };
      colors.stylize = function(str, style) {
        return colors.enabled ? ansiStyles[style].open + str + ansiStyles[style].close : str + "";
      };
      var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
      function build(_styles) {
        var builder = function builder() {
          return applyStyle.apply(builder, arguments);
        };
        return builder._styles = _styles, builder.__proto__ = proto, builder;
      }
      var ret, styles = (ret = {}, ansiStyles.grey = ansiStyles.gray, Object.keys(ansiStyles).forEach((function(key) {
        ansiStyles[key].closeRe = new RegExp(function(str) {
          if ("string" != typeof str) throw new TypeError("Expected a string");
          return str.replace(matchOperatorsRe, "\\$&");
        }(ansiStyles[key].close), "g"), ret[key] = {
          get: function() {
            return build(this._styles.concat(key));
          }
        };
      })), ret), proto = defineProps((function() {}), styles);
      function applyStyle() {
        var args = Array.prototype.slice.call(arguments), str = args.map((function(arg) {
          return void 0 !== arg && arg.constructor === String ? arg : util.inspect(arg);
        })).join(" ");
        if (!colors.enabled || !str) return str;
        for (var newLinesPresent = -1 != str.indexOf("\n"), nestedStyles = this._styles, i = nestedStyles.length; i--; ) {
          var code = ansiStyles[nestedStyles[i]];
          str = code.open + str.replace(code.closeRe, code.open) + code.close, newLinesPresent && (str = str.replace(newLineRegex, (function(match) {
            return code.close + match + code.open;
          })));
        }
        return str;
      }
      colors.setTheme = function(theme) {
        if ("string" != typeof theme) for (var style in theme) !function(style) {
          colors[style] = function(str) {
            if ("object" == typeof theme[style]) {
              var out = str;
              for (var i in theme[style]) out = colors[theme[style][i]](out);
              return out;
            }
            return colors[theme[style]](str);
          };
        }(style); else console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
      };
      var sequencer = function(map, str) {
        var exploded = str.split("");
        return (exploded = exploded.map(map)).join("");
      };
      for (var map in colors.trap = __webpack_require__(19855), colors.zalgo = __webpack_require__(23288), 
      colors.maps = {}, colors.maps.america = __webpack_require__(8301)(colors), colors.maps.zebra = __webpack_require__(14695)(colors), 
      colors.maps.rainbow = __webpack_require__(56726)(colors), colors.maps.random = __webpack_require__(15252)(colors), 
      colors.maps) !function(map) {
        colors[map] = function(str) {
          return sequencer(colors.maps[map], str);
        };
      }(map);
      defineProps(colors, function() {
        var ret = {};
        return Object.keys(styles).forEach((function(name) {
          ret[name] = {
            get: function() {
              return build([ name ]);
            }
          };
        })), ret;
      }());
    },
    19855: module => {
      module.exports = function(text, options) {
        var result = "";
        text = (text = text || "Run the trap, drop the bass").split("");
        var trap = {
          a: [ "@", "", "", "", "", "", "" ],
          b: [ "", "", "", "", "", "" ],
          c: [ "", "", "" ],
          d: [ "", "", "", "", "", "" ],
          e: [ "", "", "", "", "", "", "", "" ],
          f: [ "" ],
          g: [ "" ],
          h: [ "", "", "", "", "", "" ],
          i: [ "" ],
          j: [ "" ],
          k: [ "", "", "", "" ],
          l: [ "" ],
          m: [ "", "", "", "", "", "" ],
          n: [ "", "", "", "", "", "" ],
          o: [ "", "", "", "", "", "", "", "", "" ],
          p: [ "", "" ],
          q: [ "" ],
          r: [ "", "", "", "", "", "" ],
          s: [ "", "", "", "" ],
          t: [ "", "", "" ],
          u: [ "", "" ],
          v: [ "" ],
          w: [ "", "", "", "" ],
          x: [ "", "", "", "" ],
          y: [ "", "", "" ],
          z: [ "", "" ]
        };
        return text.forEach((function(c) {
          c = c.toLowerCase();
          var chars = trap[c] || [ " " ], rand = Math.floor(Math.random() * chars.length);
          result += void 0 !== trap[c] ? trap[c][rand] : c;
        })), result;
      };
    },
    23288: module => {
      module.exports = function(text, options) {
        text = text || "   he is here   ";
        var soul = {
          up: [ "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "" ],
          down: [ "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "" ],
          mid: [ "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", " " ]
        }, all = [].concat(soul.up, soul.down, soul.mid);
        function randomNumber(range) {
          return Math.floor(Math.random() * range);
        }
        function isChar(character) {
          var bool = !1;
          return all.filter((function(i) {
            bool = i === character;
          })), bool;
        }
        return function(text, options) {
          var counts, l, result = "";
          for (l in (options = options || {}).up = void 0 === options.up || options.up, options.mid = void 0 === options.mid || options.mid, 
          options.down = void 0 === options.down || options.down, options.size = void 0 !== options.size ? options.size : "maxi", 
          text = text.split("")) if (!isChar(l)) {
            switch (result += text[l], counts = {
              up: 0,
              down: 0,
              mid: 0
            }, options.size) {
             case "mini":
              counts.up = randomNumber(8), counts.mid = randomNumber(2), counts.down = randomNumber(8);
              break;

             case "maxi":
              counts.up = randomNumber(16) + 3, counts.mid = randomNumber(4) + 1, counts.down = randomNumber(64) + 3;
              break;

             default:
              counts.up = randomNumber(8) + 1, counts.mid = randomNumber(6) / 2, counts.down = randomNumber(8) + 1;
            }
            var arr = [ "up", "mid", "down" ];
            for (var d in arr) for (var index = arr[d], i = 0; i <= counts[index]; i++) options[index] && (result += soul[index][randomNumber(soul[index].length)]);
          }
          return result;
        }(text, options);
      };
    },
    8301: module => {
      module.exports = function(colors) {
        return function(letter, i, exploded) {
          if (" " === letter) return letter;
          switch (i % 3) {
           case 0:
            return colors.red(letter);

           case 1:
            return colors.white(letter);

           case 2:
            return colors.blue(letter);
          }
        };
      };
    },
    56726: module => {
      module.exports = function(colors) {
        var rainbowColors = [ "red", "yellow", "green", "blue", "magenta" ];
        return function(letter, i, exploded) {
          return " " === letter ? letter : colors[rainbowColors[i++ % rainbowColors.length]](letter);
        };
      };
    },
    15252: module => {
      module.exports = function(colors) {
        var available = [ "underline", "inverse", "grey", "yellow", "red", "green", "blue", "white", "cyan", "magenta" ];
        return function(letter, i, exploded) {
          return " " === letter ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
        };
      };
    },
    14695: module => {
      module.exports = function(colors) {
        return function(letter, i, exploded) {
          return i % 2 == 0 ? letter : colors.inverse(letter);
        };
      };
    },
    7030: module => {
      var styles = {};
      module.exports = styles;
      var codes = {
        reset: [ 0, 0 ],
        bold: [ 1, 22 ],
        dim: [ 2, 22 ],
        italic: [ 3, 23 ],
        underline: [ 4, 24 ],
        inverse: [ 7, 27 ],
        hidden: [ 8, 28 ],
        strikethrough: [ 9, 29 ],
        black: [ 30, 39 ],
        red: [ 31, 39 ],
        green: [ 32, 39 ],
        yellow: [ 33, 39 ],
        blue: [ 34, 39 ],
        magenta: [ 35, 39 ],
        cyan: [ 36, 39 ],
        white: [ 37, 39 ],
        gray: [ 90, 39 ],
        grey: [ 90, 39 ],
        bgBlack: [ 40, 49 ],
        bgRed: [ 41, 49 ],
        bgGreen: [ 42, 49 ],
        bgYellow: [ 43, 49 ],
        bgBlue: [ 44, 49 ],
        bgMagenta: [ 45, 49 ],
        bgCyan: [ 46, 49 ],
        bgWhite: [ 47, 49 ],
        blackBG: [ 40, 49 ],
        redBG: [ 41, 49 ],
        greenBG: [ 42, 49 ],
        yellowBG: [ 43, 49 ],
        blueBG: [ 44, 49 ],
        magentaBG: [ 45, 49 ],
        cyanBG: [ 46, 49 ],
        whiteBG: [ 47, 49 ]
      };
      Object.keys(codes).forEach((function(key) {
        var val = codes[key], style = styles[key] = [];
        style.open = "[" + val[0] + "m", style.close = "[" + val[1] + "m";
      }));
    },
    64832: module => {
      "use strict";
      module.exports = function(flag, argv) {
        var terminatorPos = (argv = argv || process.argv).indexOf("--"), prefix = /^-{1,2}/.test(flag) ? "" : "--", pos = argv.indexOf(prefix + flag);
        return -1 !== pos && (-1 === terminatorPos || pos < terminatorPos);
      };
    },
    74737: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var os = __webpack_require__(22037), hasFlag = __webpack_require__(64832), env = process.env, forceColor = void 0;
      function getSupportLevel(stream) {
        var level = function(stream) {
          if (!1 === forceColor) return 0;
          if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) return 3;
          if (hasFlag("color=256")) return 2;
          if (stream && !stream.isTTY && !0 !== forceColor) return 0;
          var min = forceColor ? 1 : 0;
          if ("win32" === process.platform) {
            var osRelease = os.release().split(".");
            return Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586 ? Number(osRelease[2]) >= 14931 ? 3 : 2 : 1;
          }
          if ("CI" in env) return [ "TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI" ].some((function(sign) {
            return sign in env;
          })) || "codeship" === env.CI_NAME ? 1 : min;
          if ("TEAMCITY_VERSION" in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
          if ("TERM_PROGRAM" in env) {
            var version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch (env.TERM_PROGRAM) {
             case "iTerm.app":
              return version >= 3 ? 3 : 2;

             case "Hyper":
              return 3;

             case "Apple_Terminal":
              return 2;
            }
          }
          return /-256(color)?$/i.test(env.TERM) ? 2 : /^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM) || "COLORTERM" in env ? 1 : (env.TERM, 
          min);
        }(stream);
        return function(level) {
          return 0 !== level && {
            level,
            hasBasic: !0,
            has256: level >= 2,
            has16m: level >= 3
          };
        }(level);
      }
      hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") ? forceColor = !1 : (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) && (forceColor = !0), 
      "FORCE_COLOR" in env && (forceColor = 0 === env.FORCE_COLOR.length || 0 !== parseInt(env.FORCE_COLOR, 10)), 
      module.exports = {
        supportsColor: getSupportLevel,
        stdout: getSupportLevel(process.stdout),
        stderr: getSupportLevel(process.stderr)
      };
    },
    75231: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var wcwidth = __webpack_require__(36167), _require = __webpack_require__(47771), padRight = _require.padRight, padCenter = _require.padCenter, padLeft = _require.padLeft, splitIntoLines = _require.splitIntoLines, splitLongWords = _require.splitLongWords, truncateString = _require.truncateString, DEFAULT_HEADING_TRANSFORM = function(key) {
        return key.toUpperCase();
      }, DEFAULTS = Object.freeze({
        maxWidth: 1 / 0,
        minWidth: 0,
        columnSplitter: " ",
        truncate: !1,
        truncateMarker: "",
        preserveNewLines: !1,
        paddingChr: " ",
        showHeaders: !0,
        headingTransform: DEFAULT_HEADING_TRANSFORM,
        dataTransform: function(cell, column, index) {
          return cell;
        }
      });
      function createRows(items, columns, columnNames, paddingChr) {
        return items.map((function(item) {
          var row = [], numLines = 0;
          columnNames.forEach((function(columnName) {
            numLines = Math.max(numLines, item[columnName].length);
          }));
          for (var _loop = function(i) {
            row[i] = row[i] || [], columnNames.forEach((function(columnName) {
              var column = columns[columnName], val = item[columnName][i] || "";
              "right" === column.align ? row[i].push(padLeft(val, column.width, paddingChr)) : "center" === column.align || "centre" === column.align ? row[i].push(padCenter(val, column.width, paddingChr)) : row[i].push(padRight(val, column.width, paddingChr));
            }));
          }, i = 0; i < numLines; i++) _loop(i);
          return row;
        }));
      }
      function mixin() {
        var _Object;
        return Object.assign ? (_Object = Object).assign.apply(_Object, arguments) : ObjectAssign.apply(void 0, arguments);
      }
      function ObjectAssign(target, firstSource) {
        if (null == target) throw new TypeError("Cannot convert first argument to object");
        for (var pendingException, to = Object(target), hasPendingException = !1, i = 1; i < arguments.length; i++) {
          var nextSource = arguments[i];
          if (null != nextSource) {
            for (var keysArray = Object.keys(Object(nextSource)), nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
              var nextKey = keysArray[nextIndex];
              try {
                var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                void 0 !== desc && desc.enumerable && (to[nextKey] = nextSource[nextKey]);
              } catch (e) {
                hasPendingException || (hasPendingException = !0, pendingException = e);
              }
            }
            if (hasPendingException) throw pendingException;
          }
        }
        return to;
      }
      function endsWith(target, searchString, position) {
        position = position || target.length, position -= searchString.length;
        var lastIndex = target.lastIndexOf(searchString);
        return -1 !== lastIndex && lastIndex === position;
      }
      function toArray(items, columnNames) {
        if (Array.isArray(items)) return items;
        var rows = [];
        for (var key in items) {
          var item = {};
          item[columnNames[0] || "key"] = key, item[columnNames[1] || "value"] = items[key], 
          rows.push(item);
        }
        return rows;
      }
      module.exports = function(items) {
        var options = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1], columnConfigs = options.config || {};
        delete options.config;
        var maxLineWidth = options.maxLineWidth || 1 / 0;
        "auto" === maxLineWidth && (maxLineWidth = process.stdout.columns || 1 / 0), delete options.maxLineWidth, 
        (options = mixin({}, DEFAULTS, options)).config = options.config || Object.create(null), 
        options.spacing = options.spacing || "\n", options.preserveNewLines = !!options.preserveNewLines, 
        options.showHeaders = !!options.showHeaders, options.columns = options.columns || options.include;
        var columnNames = options.columns || [];
        items = toArray(items, columnNames), columnNames.length || items.forEach((function(item) {
          for (var columnName in item) -1 === columnNames.indexOf(columnName) && columnNames.push(columnName);
        }));
        var columns = columnNames.reduce((function(columns, columnName) {
          var column = Object.create(options);
          return columns[columnName] = mixin(column, columnConfigs[columnName]), columns;
        }), Object.create(null));
        columnNames.forEach((function(columnName) {
          var column = columns[columnName];
          column.name = columnName, column.maxWidth = Math.ceil(column.maxWidth), column.minWidth = Math.ceil(column.minWidth), 
          column.truncate = !!column.truncate, column.align = column.align || "left";
        })), items = items.map((function(item) {
          var result = Object.create(null);
          return columnNames.forEach((function(columnName) {
            result[columnName] = null != item[columnName] ? item[columnName] : "", result[columnName] = "" + result[columnName], 
            columns[columnName].preserveNewLines ? result[columnName] = result[columnName].replace(/[^\S\n]/gim, " ") : result[columnName] = result[columnName].replace(/\s/gim, " ");
          })), result;
        })), columnNames.forEach((function(columnName) {
          var column = columns[columnName];
          items = items.map((function(item, index) {
            var col = Object.create(column);
            item[columnName] = column.dataTransform(item[columnName], col, index);
            var changedKeys = Object.keys(col);
            if (-1 !== changedKeys.indexOf("name")) {
              if (column.headingTransform !== DEFAULT_HEADING_TRANSFORM) return;
              column.headingTransform = function(heading) {
                return heading;
              };
            }
            return changedKeys.forEach((function(key) {
              return column[key] = col[key];
            })), item;
          }));
        }));
        var headers = {};
        options.showHeaders && (columnNames.forEach((function(columnName) {
          var column = columns[columnName];
          column.showHeaders ? headers[columnName] = column.headingTransform(column.name) : headers[columnName] = "";
        })), items.unshift(headers)), columnNames.forEach((function(columnName) {
          var column = columns[columnName];
          column.width = items.map((function(item) {
            return item[columnName];
          })).reduce((function(min, cur) {
            return min >= column.maxWidth ? min : Math.max(min, Math.min(column.maxWidth, Math.max(column.minWidth, wcwidth(cur))));
          }), 0);
        })), columnNames.forEach((function(columnName) {
          var column = columns[columnName];
          items = items.map((function(item) {
            return item[columnName] = splitLongWords(item[columnName], column.width, column.truncateMarker), 
            item;
          }));
        })), columnNames.forEach((function(columnName) {
          var column = columns[columnName];
          items = items.map((function(item, index) {
            var cell = item[columnName];
            (item[columnName] = splitIntoLines(cell, column.width), column.truncate && item[columnName].length > 1) && (item[columnName] = splitIntoLines(cell, column.width - wcwidth(column.truncateMarker)), 
            endsWith(item[columnName][0], column.truncateMarker) || (item[columnName][0] += column.truncateMarker), 
            item[columnName] = item[columnName].slice(0, 1));
            return item;
          }));
        })), columnNames.forEach((function(columnName) {
          var column = columns[columnName];
          column.width = items.map((function(item) {
            return item[columnName].reduce((function(min, cur) {
              return min >= column.maxWidth ? min : Math.max(min, Math.min(column.maxWidth, Math.max(column.minWidth, wcwidth(cur))));
            }), 0);
          })).reduce((function(min, cur) {
            return min >= column.maxWidth ? min : Math.max(min, Math.min(column.maxWidth, Math.max(column.minWidth, cur)));
          }), 0);
        }));
        var rows = createRows(items, columns, columnNames, options.paddingChr);
        return rows.reduce((function(output, row) {
          return output.concat(row.reduce((function(rowOut, line) {
            return rowOut.concat(line.join(options.columnSplitter));
          }), []));
        }), []).map((function(line) {
          return truncateString(line, maxLineWidth);
        })).join(options.spacing);
      };
    },
    47771: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var wcwidth = __webpack_require__(36167);
      function repeatString(str, len) {
        return Array.apply(null, {
          length: len + 1
        }).join(str).slice(0, len);
      }
      module.exports.padRight = function(str, max, chr) {
        str = null != str ? str : "", str = String(str);
        var length = max - wcwidth(str);
        return length <= 0 ? str : str + repeatString(chr || " ", length);
      }, module.exports.padCenter = function(str, max, chr) {
        str = null != str ? str : "", str = String(str);
        var length = max - wcwidth(str);
        if (length <= 0) return str;
        var lengthLeft = Math.floor(length / 2), lengthRight = length - lengthLeft;
        return repeatString(chr || " ", lengthLeft) + str + repeatString(chr || " ", lengthRight);
      }, module.exports.padLeft = function(str, max, chr) {
        str = null != str ? str : "", str = String(str);
        var length = max - wcwidth(str);
        return length <= 0 ? str : repeatString(chr || " ", length) + str;
      }, module.exports.splitIntoLines = function(str, max) {
        return str.split("\n").map((function(str) {
          return function(str, max) {
            return str.trim().split(" ").reduce((function(lines, word) {
              var line = lines[lines.length - 1];
              return line && wcwidth(line.join(" ")) + wcwidth(word) < max ? lines[lines.length - 1].push(word) : lines.push([ word ]), 
              lines;
            }), []).map((function(l) {
              return l.join(" ");
            }));
          }(str, max);
        })).reduce((function(lines, line) {
          return lines.concat(line);
        }), []);
      }, module.exports.splitLongWords = function(str, max, truncationChar) {
        for (var result = [], words = (str = str.trim()).split(" "), remainder = "", truncationWidth = wcwidth(truncationChar); remainder || words.length; ) {
          if (remainder) {
            var word = remainder;
            remainder = "";
          } else word = words.shift();
          if (wcwidth(word) > max) {
            for (var i = 0, wwidth = 0, limit = max - truncationWidth; i < word.length; ) {
              var w = wcwidth(word.charAt(i));
              if (w + wwidth > limit) break;
              wwidth += w, ++i;
            }
            remainder = word.slice(i), word = word.slice(0, i), word += truncationChar;
          }
          result.push(word);
        }
        return result.join(" ");
      }, module.exports.truncateString = function(str, max) {
        if (str = null != str ? str : "", str = String(str), max == 1 / 0) return str;
        for (var i = 0, wwidth = 0; i < str.length; ) {
          var w = wcwidth(str.charAt(i));
          if (w + wwidth > max) break;
          wwidth += w, ++i;
        }
        return str.slice(0, i);
      };
    },
    36167: (module, __unused_webpack_exports, __webpack_require__) => {
      var stripAnsi = __webpack_require__(42935), wcwidth = __webpack_require__(7656);
      module.exports = function(str) {
        return wcwidth(stripAnsi(str));
      };
    },
    16148: module => {
      module.exports = function(xs, fn) {
        for (var res = [], i = 0; i < xs.length; i++) {
          var x = fn(xs[i], i);
          isArray(x) ? res.push.apply(res, x) : res.push(x);
        }
        return res;
      };
      var isArray = Array.isArray || function(xs) {
        return "[object Array]" === Object.prototype.toString.call(xs);
      };
    },
    23671: (module, __unused_webpack_exports, __webpack_require__) => {
      var ProtoList = __webpack_require__(32981), path = __webpack_require__(71017), fs = __webpack_require__(57147), ini = __webpack_require__(8477), EE = __webpack_require__(82361).EventEmitter, url = __webpack_require__(57310), http = __webpack_require__(13685), exports = module.exports = function() {
        for (var args = [].slice.call(arguments), conf = new ConfigChain; args.length; ) {
          var a = args.shift();
          a && conf.push("string" == typeof a ? json(a) : a);
        }
        return conf;
      }, parse = (exports.find = function() {
        var rel = path.join.apply(null, [].slice.call(arguments));
        function find(start, rel) {
          var file = path.join(start, rel);
          try {
            return fs.statSync(file), file;
          } catch (err) {
            if (path.dirname(start) !== start) return find(path.dirname(start), rel);
          }
        }
        return find(__dirname, rel);
      }, exports.parse = function(content, file, type) {
        if (content = "" + content, type) {
          if ("json" !== type) return ini.parse(content);
          if (!this.emit) return JSON.parse(content);
          try {
            return JSON.parse(content);
          } catch (er) {
            this.emit("error", er);
          }
        } else try {
          return JSON.parse(content);
        } catch (er) {
          return ini.parse(content);
        }
      }), json = exports.json = function() {
        var content, args = [].slice.call(arguments).filter((function(arg) {
          return null != arg;
        })), file = path.join.apply(null, args);
        try {
          content = fs.readFileSync(file, "utf-8");
        } catch (err) {
          return;
        }
        return parse(content, file, "json");
      };
      exports.env = function(prefix, env) {
        env = env || process.env;
        var obj = {}, l = prefix.length;
        for (var k in env) 0 === k.indexOf(prefix) && (obj[k.substring(l)] = env[k]);
        return obj;
      };
      function ConfigChain() {
        EE.apply(this), ProtoList.apply(this, arguments), this._awaiting = 0, this._saving = 0, 
        this.sources = {};
      }
      exports.ConfigChain = ConfigChain;
      var extras = {
        constructor: {
          value: ConfigChain
        }
      };
      Object.keys(EE.prototype).forEach((function(k) {
        extras[k] = Object.getOwnPropertyDescriptor(EE.prototype, k);
      })), ConfigChain.prototype = Object.create(ProtoList.prototype, extras), ConfigChain.prototype.del = function(key, where) {
        if (where) {
          var target = this.sources[where];
          if (!(target = target && target.data)) return this.emit("error", new Error("not found " + where));
          delete target[key];
        } else for (var i = 0, l = this.list.length; i < l; i++) delete this.list[i][key];
        return this;
      }, ConfigChain.prototype.set = function(key, value, where) {
        var target;
        if (where) {
          if (!(target = (target = this.sources[where]) && target.data)) return this.emit("error", new Error("not found " + where));
        } else if (!(target = this.list[0])) return this.emit("error", new Error("cannot set, no confs!"));
        return target[key] = value, this;
      }, ConfigChain.prototype.get = function(key, where) {
        return where ? ((where = this.sources[where]) && (where = where.data), where && Object.hasOwnProperty.call(where, key) ? where[key] : void 0) : this.list[0][key];
      }, ConfigChain.prototype.save = function(where, type, cb) {
        "function" == typeof type && (cb = type, type = null);
        var target = this.sources[where];
        if (!target || !target.path && !target.source || !target.data) return this.emit("error", new Error("bad save target: " + where));
        if (target.source) {
          var pref = target.prefix || "";
          return Object.keys(target.data).forEach((function(k) {
            target.source[pref + k] = target.data[k];
          })), this;
        }
        type = type || target.type;
        var data = target.data;
        return data = "json" === target.type ? JSON.stringify(data) : ini.stringify(data), 
        this._saving++, fs.writeFile(target.path, data, "utf8", function(er) {
          if (this._saving--, er) return cb ? cb(er) : this.emit("error", er);
          0 === this._saving && (cb && cb(), this.emit("save"));
        }.bind(this)), this;
      }, ConfigChain.prototype.addFile = function(file, type, name) {
        var marker = {
          __source__: name = name || file
        };
        return this.sources[name] = {
          path: file,
          type
        }, this.push(marker), this._await(), fs.readFile(file, "utf8", function(er, data) {
          er && this.emit("error", er), this.addString(data, file, type, marker);
        }.bind(this)), this;
      }, ConfigChain.prototype.addEnv = function(prefix, env, name) {
        name = name || "env";
        var data = exports.env(prefix, env);
        return this.sources[name] = {
          data,
          source: env,
          prefix
        }, this.add(data, name);
      }, ConfigChain.prototype.addUrl = function(req, type, name) {
        this._await();
        var href = url.format(req), marker = {
          __source__: name = name || href
        };
        return this.sources[name] = {
          href,
          type
        }, this.push(marker), http.request(req, function(res) {
          var c = [], ct = res.headers["content-type"];
          type || (type = -1 !== ct.indexOf("json") ? "json" : -1 !== ct.indexOf("ini") ? "ini" : href.match(/\.json$/) ? "json" : href.match(/\.ini$/) ? "ini" : null, 
          marker.type = type), res.on("data", c.push.bind(c)).on("end", function() {
            this.addString(Buffer.concat(c), href, type, marker);
          }.bind(this)).on("error", this.emit.bind(this, "error"));
        }.bind(this)).on("error", this.emit.bind(this, "error")).end(), this;
      }, ConfigChain.prototype.addString = function(data, file, type, marker) {
        return data = this.parse(data, file, type), this.add(data, marker), this;
      }, ConfigChain.prototype.add = function(data, marker) {
        if (marker && "object" == typeof marker) {
          var i = this.list.indexOf(marker);
          if (-1 === i) return this.emit("error", new Error("bad marker"));
          this.splice(i, 1, data), marker = marker.__source__, this.sources[marker] = this.sources[marker] || {}, 
          this.sources[marker].data = data, this._resolve();
        } else "string" == typeof marker && (this.sources[marker] = this.sources[marker] || {}, 
        this.sources[marker].data = data), this._await(), this.push(data), process.nextTick(this._resolve.bind(this));
        return this;
      }, ConfigChain.prototype.parse = exports.parse, ConfigChain.prototype._await = function() {
        this._awaiting++;
      }, ConfigChain.prototype._resolve = function() {
        this._awaiting--, 0 === this._awaiting && this.emit("load", this);
      };
    },
    34012: (__unused_webpack_module, exports) => {
      "use strict";
      exports.up = function(num) {
        return "[" + (num || "") + "A";
      }, exports.down = function(num) {
        return "[" + (num || "") + "B";
      }, exports.forward = function(num) {
        return "[" + (num || "") + "C";
      }, exports.back = function(num) {
        return "[" + (num || "") + "D";
      }, exports.nextLine = function(num) {
        return "[" + (num || "") + "E";
      }, exports.previousLine = function(num) {
        return "[" + (num || "") + "F";
      }, exports.horizontalAbsolute = function(num) {
        if (null == num) throw new Error("horizontalAboslute requires a column to position to");
        return "[" + num + "G";
      }, exports.eraseData = function() {
        return "[J";
      }, exports.eraseLine = function() {
        return "[K";
      }, exports.goto = function(x, y) {
        return "[" + y + ";" + x + "H";
      }, exports.gotoSOL = function() {
        return "\r";
      }, exports.beep = function() {
        return "";
      }, exports.hideCursor = function() {
        return "[?25l";
      }, exports.showCursor = function() {
        return "[?25h";
      };
      var colors = {
        reset: 0,
        bold: 1,
        italic: 3,
        underline: 4,
        inverse: 7,
        stopBold: 22,
        stopItalic: 23,
        stopUnderline: 24,
        stopInverse: 27,
        white: 37,
        black: 30,
        blue: 34,
        cyan: 36,
        green: 32,
        magenta: 35,
        red: 31,
        yellow: 33,
        bgWhite: 47,
        bgBlack: 40,
        bgBlue: 44,
        bgCyan: 46,
        bgGreen: 42,
        bgMagenta: 45,
        bgRed: 41,
        bgYellow: 43,
        grey: 90,
        brightBlack: 90,
        brightRed: 91,
        brightGreen: 92,
        brightYellow: 93,
        brightBlue: 94,
        brightMagenta: 95,
        brightCyan: 96,
        brightWhite: 97,
        bgGrey: 100,
        bgBrightBlack: 100,
        bgBrightRed: 101,
        bgBrightGreen: 102,
        bgBrightYellow: 103,
        bgBrightBlue: 104,
        bgBrightMagenta: 105,
        bgBrightCyan: 106,
        bgBrightWhite: 107
      };
      function colorNameToCode(color) {
        if (null != colors[color]) return colors[color];
        throw new Error("Unknown color or style name: " + color);
      }
      exports.color = function(colorWith) {
        return 1 === arguments.length && Array.isArray(colorWith) || (colorWith = Array.prototype.slice.call(arguments)), 
        "[" + colorWith.map(colorNameToCode).join(";") + "m";
      };
    },
    1468: (module, exports, __webpack_require__) => {
      var util = __webpack_require__(73837);
      module.exports = util && util.debuglog || function(set) {
        if (set = set.toUpperCase(), !debugs[set]) if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = util.format.apply(exports, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else debugs[set] = function() {};
        return debugs[set];
      };
      var debugs = {}, debugEnviron = process.env.NODE_DEBUG || "";
    },
    50639: module => {
      "use strict";
      var singleMatcher = new RegExp("(%[a-f0-9]{2})|([^%]+?)", "gi"), multiMatcher = new RegExp("(%[a-f0-9]{2})+", "gi");
      function decodeComponents(components, split) {
        try {
          return [ decodeURIComponent(components.join("")) ];
        } catch (err) {}
        if (1 === components.length) return components;
        split = split || 1;
        var left = components.slice(0, split), right = components.slice(split);
        return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
      }
      function decode(input) {
        try {
          return decodeURIComponent(input);
        } catch (err) {
          for (var tokens = input.match(singleMatcher) || [], i = 1; i < tokens.length; i++) tokens = (input = decodeComponents(tokens, i).join("")).match(singleMatcher) || [];
          return input;
        }
      }
      module.exports = function(encodedURI) {
        if ("string" != typeof encodedURI) throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
        try {
          return encodedURI = encodedURI.replace(/\+/g, " "), decodeURIComponent(encodedURI);
        } catch (err) {
          return function(input) {
            for (var replaceMap = {
              "%FE%FF": "",
              "%FF%FE": ""
            }, match = multiMatcher.exec(input); match; ) {
              try {
                replaceMap[match[0]] = decodeURIComponent(match[0]);
              } catch (err) {
                var result = decode(match[0]);
                result !== match[0] && (replaceMap[match[0]] = result);
              }
              match = multiMatcher.exec(input);
            }
            replaceMap["%C2"] = "";
            for (var entries = Object.keys(replaceMap), i = 0; i < entries.length; i++) {
              var key = entries[i];
              input = input.replace(new RegExp(key, "g"), replaceMap[key]);
            }
            return input;
          }(encodedURI);
        }
      };
    },
    21338: (module, __unused_webpack_exports, __webpack_require__) => {
      var clone = __webpack_require__(6120);
      module.exports = function(options, defaults) {
        return options = options || {}, Object.keys(defaults).forEach((function(key) {
          void 0 === options[key] && (options[key] = clone(defaults[key]));
        })), options;
      };
    },
    78632: module => {
      "use strict";
      const INDENT_RE = /^(?:( )+|\t+)/;
      module.exports = str => {
        if ("string" != typeof str) throw new TypeError("Expected a string");
        let tabs = 0, spaces = 0, prev = 0;
        const indents = new Map;
        let current, isIndent;
        for (const line of str.split(/\n/g)) {
          if (!line) continue;
          let indent;
          const matches = line.match(INDENT_RE);
          matches ? (indent = matches[0].length, matches[1] ? spaces++ : tabs++) : indent = 0;
          const diff = indent - prev;
          prev = indent, diff ? (isIndent = diff > 0, current = indents.get(isIndent ? diff : -diff), 
          current ? current[0]++ : (current = [ 1, 0 ], indents.set(diff, current))) : current && (current[1] += Number(isIndent));
        }
        const amount = function(indents) {
          let result = 0, maxUsed = 0, maxWeight = 0;
          for (const entry of indents) {
            const key = entry[0], val = entry[1], u = val[0], w = val[1];
            (u > maxUsed || u === maxUsed && w > maxWeight) && (maxUsed = u, maxWeight = w, 
            result = Number(key));
          }
          return result;
        }(indents);
        let type, indent;
        return amount ? spaces >= tabs ? (type = "space", indent = " ".repeat(amount)) : (type = "tab", 
        indent = "\t".repeat(amount)) : (type = null, indent = ""), {
          amount,
          type,
          indent
        };
      };
    },
    9637: module => {
      "use strict";
      module.exports = function(str) {
        if ("string" != typeof str) throw new TypeError("Expected a string");
        var newlines = str.match(/(?:\r?\n)/g) || [];
        if (0 === newlines.length) return null;
        var crlf = newlines.filter((function(el) {
          return "\r\n" === el;
        })).length;
        return crlf > newlines.length - crlf ? "\r\n" : "\n";
      }, module.exports.graceful = function(str) {
        return module.exports(str) || "\n";
      };
    },
    21248: (module, __unused_webpack_exports, __webpack_require__) => {
      var wrappy = __webpack_require__(68839);
      module.exports = wrappy((function(cb) {
        var sync = !0;
        return asap((function() {
          sync = !1;
        })), function() {
          var args = arguments, me = this;
          sync ? asap((function() {
            cb.apply(me, args);
          })) : cb.apply(me, args);
        };
      }));
      var asap = __webpack_require__(40574);
    },
    59550: (module, __unused_webpack_exports, __webpack_require__) => {
      var spawn = __webpack_require__(32081).spawn;
      module.exports = function(file, opts, cb) {
        "function" == typeof opts && (cb = opts, opts = {}), opts || (opts = {});
        var ed = /^win/.test(process.platform) ? "notepad" : "vim", args = (opts.editor || process.env.VISUAL || process.env.EDITOR || ed).split(/\s+/), bin = args.shift();
        spawn(bin, args.concat([ file ]), {
          stdio: "inherit"
        }).on("exit", (function(code, sig) {
          "function" == typeof cb && cb(code, sig);
        }));
      };
    },
    33446: (module, __unused_webpack_exports, __webpack_require__) => {
      var once = __webpack_require__(38412), noop = function() {}, eos = function(stream, opts, callback) {
        if ("function" == typeof opts) return eos(stream, null, opts);
        opts || (opts = {}), callback = once(callback || noop);
        var ws = stream._writableState, rs = stream._readableState, readable = opts.readable || !1 !== opts.readable && stream.readable, writable = opts.writable || !1 !== opts.writable && stream.writable, onlegacyfinish = function() {
          stream.writable || onfinish();
        }, onfinish = function() {
          writable = !1, readable || callback.call(stream);
        }, onend = function() {
          readable = !1, writable || callback.call(stream);
        }, onexit = function(exitCode) {
          callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
        }, onerror = function(err) {
          callback.call(stream, err);
        }, onclose = function() {
          return (!readable || rs && rs.ended) && (!writable || ws && ws.ended) ? void 0 : callback.call(stream, new Error("premature close"));
        }, onrequest = function() {
          stream.req.on("finish", onfinish);
        };
        return !function(stream) {
          return stream.setHeader && "function" == typeof stream.abort;
        }(stream) ? writable && !ws && (stream.on("end", onlegacyfinish), stream.on("close", onlegacyfinish)) : (stream.on("complete", onfinish), 
        stream.on("abort", onclose), stream.req ? onrequest() : stream.on("request", onrequest)), 
        function(stream) {
          return stream.stdio && Array.isArray(stream.stdio) && 3 === stream.stdio.length;
        }(stream) && stream.on("exit", onexit), stream.on("end", onend), stream.on("finish", onfinish), 
        !1 !== opts.error && stream.on("error", onerror), stream.on("close", onclose), function() {
          stream.removeListener("complete", onfinish), stream.removeListener("abort", onclose), 
          stream.removeListener("request", onrequest), stream.req && stream.req.removeListener("finish", onfinish), 
          stream.removeListener("end", onlegacyfinish), stream.removeListener("close", onlegacyfinish), 
          stream.removeListener("finish", onfinish), stream.removeListener("exit", onexit), 
          stream.removeListener("end", onend), stream.removeListener("error", onerror), stream.removeListener("close", onclose);
        };
      };
      module.exports = eos;
    },
    3242: (module, __unused_webpack_exports, __webpack_require__) => {
      var prr = __webpack_require__(46715);
      function init(type, message, cause) {
        message && "string" != typeof message && (message = message.message || message.name), 
        prr(this, {
          type,
          name: type,
          cause: "string" != typeof message ? message : cause,
          message
        }, "ewr");
      }
      function CustomError(message, cause) {
        Error.call(this), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), 
        init.call(this, "CustomError", message, cause);
      }
      CustomError.prototype = new Error, module.exports = function(errno) {
        var ce = function(type, proto) {
          return function(errno, type, proto) {
            var err = function(message, cause) {
              init.call(this, type, message, cause), "FilesystemError" == type && (this.code = this.cause.code, 
              this.path = this.cause.path, this.errno = this.cause.errno, this.message = (errno.errno[this.cause.errno] ? errno.errno[this.cause.errno].description : this.cause.message) + (this.cause.path ? " [" + this.cause.path + "]" : "")), 
              Error.call(this), Error.captureStackTrace && Error.captureStackTrace(this, err);
            };
            return err.prototype = proto ? new proto : new CustomError, err;
          }(errno, type, proto);
        };
        return {
          CustomError,
          FilesystemError: ce("FilesystemError"),
          createError: ce
        };
      };
    },
    24983: (module, __unused_webpack_exports, __webpack_require__) => {
      var all = module.exports.all = [ {
        errno: -2,
        code: "ENOENT",
        description: "no such file or directory"
      }, {
        errno: -1,
        code: "UNKNOWN",
        description: "unknown error"
      }, {
        errno: 0,
        code: "OK",
        description: "success"
      }, {
        errno: 1,
        code: "EOF",
        description: "end of file"
      }, {
        errno: 2,
        code: "EADDRINFO",
        description: "getaddrinfo error"
      }, {
        errno: 3,
        code: "EACCES",
        description: "permission denied"
      }, {
        errno: 4,
        code: "EAGAIN",
        description: "resource temporarily unavailable"
      }, {
        errno: 5,
        code: "EADDRINUSE",
        description: "address already in use"
      }, {
        errno: 6,
        code: "EADDRNOTAVAIL",
        description: "address not available"
      }, {
        errno: 7,
        code: "EAFNOSUPPORT",
        description: "address family not supported"
      }, {
        errno: 8,
        code: "EALREADY",
        description: "connection already in progress"
      }, {
        errno: 9,
        code: "EBADF",
        description: "bad file descriptor"
      }, {
        errno: 10,
        code: "EBUSY",
        description: "resource busy or locked"
      }, {
        errno: 11,
        code: "ECONNABORTED",
        description: "software caused connection abort"
      }, {
        errno: 12,
        code: "ECONNREFUSED",
        description: "connection refused"
      }, {
        errno: 13,
        code: "ECONNRESET",
        description: "connection reset by peer"
      }, {
        errno: 14,
        code: "EDESTADDRREQ",
        description: "destination address required"
      }, {
        errno: 15,
        code: "EFAULT",
        description: "bad address in system call argument"
      }, {
        errno: 16,
        code: "EHOSTUNREACH",
        description: "host is unreachable"
      }, {
        errno: 17,
        code: "EINTR",
        description: "interrupted system call"
      }, {
        errno: 18,
        code: "EINVAL",
        description: "invalid argument"
      }, {
        errno: 19,
        code: "EISCONN",
        description: "socket is already connected"
      }, {
        errno: 20,
        code: "EMFILE",
        description: "too many open files"
      }, {
        errno: 21,
        code: "EMSGSIZE",
        description: "message too long"
      }, {
        errno: 22,
        code: "ENETDOWN",
        description: "network is down"
      }, {
        errno: 23,
        code: "ENETUNREACH",
        description: "network is unreachable"
      }, {
        errno: 24,
        code: "ENFILE",
        description: "file table overflow"
      }, {
        errno: 25,
        code: "ENOBUFS",
        description: "no buffer space available"
      }, {
        errno: 26,
        code: "ENOMEM",
        description: "not enough memory"
      }, {
        errno: 27,
        code: "ENOTDIR",
        description: "not a directory"
      }, {
        errno: 28,
        code: "EISDIR",
        description: "illegal operation on a directory"
      }, {
        errno: 29,
        code: "ENONET",
        description: "machine is not on the network"
      }, {
        errno: 31,
        code: "ENOTCONN",
        description: "socket is not connected"
      }, {
        errno: 32,
        code: "ENOTSOCK",
        description: "socket operation on non-socket"
      }, {
        errno: 33,
        code: "ENOTSUP",
        description: "operation not supported on socket"
      }, {
        errno: 34,
        code: "ENOENT",
        description: "no such file or directory"
      }, {
        errno: 35,
        code: "ENOSYS",
        description: "function not implemented"
      }, {
        errno: 36,
        code: "EPIPE",
        description: "broken pipe"
      }, {
        errno: 37,
        code: "EPROTO",
        description: "protocol error"
      }, {
        errno: 38,
        code: "EPROTONOSUPPORT",
        description: "protocol not supported"
      }, {
        errno: 39,
        code: "EPROTOTYPE",
        description: "protocol wrong type for socket"
      }, {
        errno: 40,
        code: "ETIMEDOUT",
        description: "connection timed out"
      }, {
        errno: 41,
        code: "ECHARSET",
        description: "invalid Unicode character"
      }, {
        errno: 42,
        code: "EAIFAMNOSUPPORT",
        description: "address family for hostname not supported"
      }, {
        errno: 44,
        code: "EAISERVICE",
        description: "servname not supported for ai_socktype"
      }, {
        errno: 45,
        code: "EAISOCKTYPE",
        description: "ai_socktype not supported"
      }, {
        errno: 46,
        code: "ESHUTDOWN",
        description: "cannot send after transport endpoint shutdown"
      }, {
        errno: 47,
        code: "EEXIST",
        description: "file already exists"
      }, {
        errno: 48,
        code: "ESRCH",
        description: "no such process"
      }, {
        errno: 49,
        code: "ENAMETOOLONG",
        description: "name too long"
      }, {
        errno: 50,
        code: "EPERM",
        description: "operation not permitted"
      }, {
        errno: 51,
        code: "ELOOP",
        description: "too many symbolic links encountered"
      }, {
        errno: 52,
        code: "EXDEV",
        description: "cross-device link not permitted"
      }, {
        errno: 53,
        code: "ENOTEMPTY",
        description: "directory not empty"
      }, {
        errno: 54,
        code: "ENOSPC",
        description: "no space left on device"
      }, {
        errno: 55,
        code: "EIO",
        description: "i/o error"
      }, {
        errno: 56,
        code: "EROFS",
        description: "read-only file system"
      }, {
        errno: 57,
        code: "ENODEV",
        description: "no such device"
      }, {
        errno: 58,
        code: "ESPIPE",
        description: "invalid seek"
      }, {
        errno: 59,
        code: "ECANCELED",
        description: "operation canceled"
      } ];
      module.exports.errno = {}, module.exports.code = {}, all.forEach((function(error) {
        module.exports.errno[error.errno] = error, module.exports.code[error.code] = error;
      })), module.exports.custom = __webpack_require__(3242)(module.exports), module.exports.create = module.exports.custom.createError;
    },
    55212: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      class FiggyPudding {
        constructor(specs, opts, providers) {
          this.__specs = specs || {}, Object.keys(this.__specs).forEach((alias => {
            if ("string" == typeof this.__specs[alias]) {
              const key = this.__specs[alias], realSpec = this.__specs[key];
              if (!realSpec) throw new Error(`Alias refers to invalid key: ${key} -> ${alias}`);
              {
                const aliasArr = realSpec.aliases || [];
                aliasArr.push(alias, key), realSpec.aliases = [ ...new Set(aliasArr) ], this.__specs[alias] = realSpec;
              }
            }
          })), this.__opts = opts || {}, this.__providers = reverse(providers.filter((x => null != x && "object" == typeof x))), 
          this.__isFiggyPudding = !0;
        }
        get(key) {
          return pudGet(this, key, !0);
        }
        get [Symbol.toStringTag]() {
          return "FiggyPudding";
        }
        forEach(fn, thisArg = this) {
          for (let [key, value] of this.entries()) fn.call(thisArg, value, key, this);
        }
        toJSON() {
          const obj = {};
          return this.forEach(((val, key) => {
            obj[key] = val;
          })), obj;
        }
        * entries(_matcher) {
          for (let key of Object.keys(this.__specs)) yield [ key, this.get(key) ];
          const matcher = _matcher || this.__opts.other;
          if (matcher) {
            const seen = new Set;
            for (let p of this.__providers) {
              const iter = p.entries ? p.entries(matcher) : entries(p);
              for (let [key, val] of iter) matcher(key) && !seen.has(key) && (seen.add(key), yield [ key, val ]);
            }
          }
        }
        * [Symbol.iterator]() {
          for (let [key, value] of this.entries()) yield [ key, value ];
        }
        * keys() {
          for (let [key] of this.entries()) yield key;
        }
        * values() {
          for (let [, value] of this.entries()) yield value;
        }
        concat(...moreConfig) {
          return new Proxy(new FiggyPudding(this.__specs, this.__opts, reverse(this.__providers).concat(moreConfig)), proxyHandler);
        }
      }
      try {
        const util = __webpack_require__(73837);
        FiggyPudding.prototype[util.inspect.custom] = function(depth, opts) {
          return this[Symbol.toStringTag] + " " + util.inspect(this.toJSON(), opts);
        };
      } catch (e) {}
      function pudGet(pud, key, validate) {
        let spec = pud.__specs[key];
        if (!validate || spec || pud.__opts.other && pud.__opts.other(key)) {
          let ret;
          spec || (spec = {});
          for (let p of pud.__providers) {
            if (ret = tryGet(key, p), void 0 === ret && spec.aliases && spec.aliases.length) for (let alias of spec.aliases) if (alias !== key && (ret = tryGet(alias, p), 
            void 0 !== ret)) break;
            if (void 0 !== ret) break;
          }
          return void 0 === ret && void 0 !== spec.default ? "function" == typeof spec.default ? spec.default(pud) : spec.default : ret;
        }
        !function(key) {
          throw Object.assign(new Error(`invalid config key requested: ${key}`), {
            code: "EBADKEY"
          });
        }(key);
      }
      function tryGet(key, p) {
        let ret;
        return ret = p.__isFiggyPudding ? pudGet(p, key, !1) : "function" == typeof p.get ? p.get(key) : p[key], 
        ret;
      }
      const proxyHandler = {
        has: (obj, prop) => prop in obj.__specs && void 0 !== pudGet(obj, prop, !1),
        ownKeys: obj => Object.keys(obj.__specs),
        get: (obj, prop) => "symbol" == typeof prop || "__" === prop.slice(0, 2) || prop in FiggyPudding.prototype ? obj[prop] : obj.get(prop),
        set(obj, prop, value) {
          if ("symbol" == typeof prop || "__" === prop.slice(0, 2)) return obj[prop] = value, 
          !0;
          throw new Error("figgyPudding options cannot be modified. Use .concat() instead.");
        },
        deleteProperty() {
          throw new Error("figgyPudding options cannot be deleted. Use .concat() and shadow them instead.");
        }
      };
      function reverse(arr) {
        const ret = [];
        return arr.forEach((x => ret.unshift(x))), ret;
      }
      function entries(obj) {
        return Object.keys(obj).map((k => [ k, obj[k] ]));
      }
      module.exports = function(specs, opts) {
        return function(...providers) {
          return new Proxy(new FiggyPudding(specs, opts, providers), proxyHandler);
        };
      };
    },
    39866: module => {
      "use strict";
      module.exports = function(obj, predicate) {
        for (var ret = {}, keys = Object.keys(obj), isArr = Array.isArray(predicate), i = 0; i < keys.length; i++) {
          var key = keys[i], val = obj[key];
          (isArr ? -1 !== predicate.indexOf(key) : predicate(key, val, obj)) && (ret[key] = val);
        }
        return ret;
      };
    },
    81048: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = function(dir) {
        return new Promise(((resolve, reject) => {
          dir = path.resolve(dir);
          let walkedUp = !1;
          for (;"node_modules" === path.basename(dir); ) dir = path.dirname(dir), walkedUp = !0;
          resolve(walkedUp ? dir : findPrefix_(dir));
        }));
      };
      const fs = __webpack_require__(57147), path = __webpack_require__(71017);
      function findPrefix_(dir, original) {
        original || (original = dir);
        const parent = path.dirname(dir);
        return parent === dir ? Promise.resolve(original) : new Promise(((resolve, reject) => {
          fs.readdir(dir, ((err, files) => {
            err ? err && dir === original && "ENOENT" !== err.code ? reject(err) : resolve(original) : -1 !== files.indexOf("node_modules") || -1 !== files.indexOf("package.json") ? resolve(dir) : resolve(findPrefix_(parent, original));
          }));
        }));
      }
    },
    8127: (module, __unused_webpack_exports, __webpack_require__) => {
      var assert = __webpack_require__(39491), dirname = __webpack_require__(71017).dirname, resolve = __webpack_require__(71017).resolve, isInside = __webpack_require__(13468), rimraf = __webpack_require__(68259), lstat = __webpack_require__(59799).lstat, readdir = __webpack_require__(59799).readdir, rmdir = __webpack_require__(59799).rmdir, unlink = __webpack_require__(59799).unlink;
      module.exports = function(leaf, options, cb) {
        assert("string" == typeof leaf, "must pass in path to remove"), assert("function" == typeof cb, "must pass in callback"), 
        options || (options = {});
        assert("object" == typeof options, "options must be an object");
        var log = options.log ? options.log : function() {};
        leaf = leaf && resolve(leaf);
        var base = options.base && resolve(options.base);
        if (base && !isInside(leaf, base)) return cb(new Error(leaf + " is not a child of " + base));
        function next(branch) {
          if (branch = branch && resolve(branch), base && branch === base || branch === dirname(branch)) return log("finished vacuuming up to", branch), 
          cb(null);
          readdir(branch, (function(error, files) {
            return error ? "ENOENT" === error.code ? cb(null) : (log("unable to check directory", branch, "due to", error.message), 
            cb(error)) : files.length > 0 ? (log("quitting because other entries in", branch), 
            cb(null)) : branch === process.env.HOME ? (log("quitting because cannot remove home directory", branch), 
            cb(null)) : (log("removing", branch), void lstat(branch, (function(error, stat) {
              if (error) return "ENOENT" === error.code ? cb(null) : (log("unable to lstat", branch, "due to", error.message), 
              cb(error));
              (stat.isDirectory() ? rmdir : unlink)(branch, (function(error) {
                if (error) return "ENOENT" === error.code ? (log("quitting because lost the race to remove", branch), 
                cb(null)) : "ENOTEMPTY" === error.code || "EEXIST" === error.code ? (log("quitting because new (racy) entries in", branch), 
                cb(null)) : (log("unable to remove", branch, "due to", error.message), cb(error));
                next(dirname(branch));
              }));
            })));
          }));
        }
        lstat(leaf, (function(error, stat) {
          return error ? "ENOENT" === error.code ? cb(null) : (log(error.stack), cb(error)) : stat && (stat.isDirectory() || stat.isSymbolicLink() || stat.isFile()) ? void (options.purge ? (log("purging", leaf), 
          rimraf(leaf, (function(error) {
            if (error) return cb(error);
            next(dirname(leaf));
          }))) : stat.isDirectory() ? next(leaf) : (log("removing", leaf), unlink(leaf, (function(error) {
            if (error) return cb(error);
            next(dirname(leaf));
          })))) : (log(leaf, "is not a directory, file, or link"), cb(new Error(leaf + " is not a directory, file, or link")));
        }));
      };
    },
    6198: module => {
      "use strict";
      var types = {
        "*": {
          label: "any",
          check: function() {
            return !0;
          }
        },
        A: {
          label: "array",
          check: function(thingy) {
            return Array.isArray(thingy) || function(thingy) {
              return null != thingy && "object" == typeof thingy && thingy.hasOwnProperty("callee");
            }(thingy);
          }
        },
        S: {
          label: "string",
          check: function(thingy) {
            return "string" == typeof thingy;
          }
        },
        N: {
          label: "number",
          check: function(thingy) {
            return "number" == typeof thingy;
          }
        },
        F: {
          label: "function",
          check: function(thingy) {
            return "function" == typeof thingy;
          }
        },
        O: {
          label: "object",
          check: function(thingy) {
            return "object" == typeof thingy && null != thingy && !types.A.check(thingy) && !types.E.check(thingy);
          }
        },
        B: {
          label: "boolean",
          check: function(thingy) {
            return "boolean" == typeof thingy;
          }
        },
        E: {
          label: "error",
          check: function(thingy) {
            return thingy instanceof Error;
          }
        },
        Z: {
          label: "null",
          check: function(thingy) {
            return null == thingy;
          }
        }
      };
      function addSchema(schema, arity) {
        var group = arity[schema.length] = arity[schema.length] || [];
        -1 === group.indexOf(schema) && group.push(schema);
      }
      var validate = module.exports = function(rawSchemas, args) {
        if (2 !== arguments.length) throw wrongNumberOfArgs([ "SA" ], arguments.length);
        if (!rawSchemas) throw missingRequiredArg(0);
        if (!args) throw missingRequiredArg(1);
        if (!types.S.check(rawSchemas)) throw invalidType(0, [ "string" ], rawSchemas);
        if (!types.A.check(args)) throw invalidType(1, [ "array" ], args);
        var schemas = rawSchemas.split("|"), arity = {};
        schemas.forEach((function(schema) {
          for (var ii = 0; ii < schema.length; ++ii) {
            var type = schema[ii];
            if (!types[type]) throw unknownType(ii, type);
          }
          if (/E.*E/.test(schema)) throw moreThanOneError(schema);
          addSchema(schema, arity), /E/.test(schema) && (addSchema(schema.replace(/E.*$/, "E"), arity), 
          addSchema(schema.replace(/E/, "Z"), arity), 1 === schema.length && addSchema("", arity));
        }));
        var matching = arity[args.length];
        if (!matching) throw wrongNumberOfArgs(Object.keys(arity), args.length);
        for (var ii = 0; ii < args.length; ++ii) {
          var newMatching = matching.filter((function(schema) {
            var type = schema[ii];
            return (0, types[type].check)(args[ii]);
          }));
          if (!newMatching.length) {
            var labels = matching.map((function(schema) {
              return types[schema[ii]].label;
            })).filter((function(schema) {
              return null != schema;
            }));
            throw invalidType(ii, labels, args[ii]);
          }
          matching = newMatching;
        }
      };
      function missingRequiredArg(num) {
        return newException("EMISSINGARG", "Missing required argument #" + (num + 1));
      }
      function unknownType(num, type) {
        return newException("EUNKNOWNTYPE", "Unknown type " + type + " in argument #" + (num + 1));
      }
      function invalidType(num, expectedTypes, value) {
        var valueType;
        return Object.keys(types).forEach((function(typeCode) {
          types[typeCode].check(value) && (valueType = types[typeCode].label);
        })), newException("EINVALIDTYPE", "Argument #" + (num + 1) + ": Expected " + englishList(expectedTypes) + " but got " + valueType);
      }
      function englishList(list) {
        return list.join(", ").replace(/, ([^,]+)$/, " or $1");
      }
      function wrongNumberOfArgs(expected, got) {
        return newException("EWRONGARGCOUNT", "Expected " + englishList(expected) + " " + (expected.every((function(ex) {
          return 1 === ex.length;
        })) ? "argument" : "arguments") + " but got " + got);
      }
      function moreThanOneError(schema) {
        return newException("ETOOMANYERRORTYPES", 'Only one error type per argument signature is allowed, more than one found in "' + schema + '"');
      }
      function newException(code, msg) {
        var e = new Error(msg);
        return e.code = code, Error.captureStackTrace && Error.captureStackTrace(e, validate), 
        e;
      }
    },
    33169: (module, exports, __webpack_require__) => {
      "use strict";
      const rm = __webpack_require__(8579), link = __webpack_require__(44196), mkdir = __webpack_require__(47923), binLink = __webpack_require__(44517);
      module.exports = {
        rm,
        link: link.link,
        linkIfExists: link.linkIfExists,
        mkdir,
        binLink
      };
    },
    44517: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const readCmdShim = __webpack_require__(11093), cmdShim = __webpack_require__(2138), {linkIfExists} = __webpack_require__(44196), times = (n, ok, cb) => {
        let errState = null;
        return er => {
          errState || (er ? cb(errState = er) : 0 == --n && ok());
        };
      }, isClobberable = (from, to, opts, cb) => {
        readCmdShim(to, ((er, target) => {
          if (er) switch (er.code) {
           case "ENOENT":
            return cb();

           case "ENOTASHIM":
            return cb(simulateEEXIST(from, to));

           default:
            return cb(er);
          }
          return 0 !== target.indexOf(opts.gently) ? cb(simulateEEXIST(from, to)) : cb();
        }));
      }, simulateEEXIST = (from, to) => {
        const err = new Error("EEXIST: file already exists, cmd shim '" + from + "' -> '" + to + "'");
        return err.code = "EEXIST", err.path = from, err.dest = to, err;
      };
      module.exports = (from, to, opts, cb) => {
        if ("win32" !== (opts._FAKE_PLATFORM_ || process.platform)) return linkIfExists(from, to, opts, cb);
        if (!opts.clobberLinkGently || !0 === opts.force || !opts.gently || "string" != typeof opts.gently) return cmdShim.ifExists(from, to, cb);
        const shimFiles = [ to, to + ".cmd", to + ".ps1" ], then = times(3, (() => cmdShim.ifExists(from, to, cb)), cb);
        shimFiles.forEach((to => isClobberable(from, to, opts, then)));
      };
    },
    75127: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const chownr = __webpack_require__(13159), selfOwner = {
        uid: process.getuid && process.getuid(),
        gid: process.getgid && process.getgid()
      };
      module.exports = (path, uid, gid, cb) => {
        if (0 !== selfOwner.uid || void 0 === uid || void 0 === gid || selfOwner.uid === uid && selfOwner.gid === gid) return cb();
        chownr(path, uid, gid, cb);
      }, module.exports.selfOwner = selfOwner;
    },
    44196: (module, exports, __webpack_require__) => {
      "use strict";
      const path = __webpack_require__(71017), fs = __webpack_require__(59799), chain = __webpack_require__(89009).chain, mkdir = __webpack_require__(47923), rm = __webpack_require__(8579), inferOwner = __webpack_require__(84876), chown = __webpack_require__(75127);
      function ensureFromIsNotSource(from, to, cb) {
        !function(maybeSymlinkPath, cb) {
          fs.lstat(maybeSymlinkPath, (function(err, stat) {
            return err ? cb.apply(this, arguments) : stat.isSymbolicLink() ? void fs.readlink(maybeSymlinkPath, cb) : cb(null, maybeSymlinkPath);
          }));
        }(from, (function(err, fromDestination) {
          return err ? cb.apply(this, arguments) : path.resolve(path.dirname(from), fromDestination) === path.resolve(to) ? cb(new Error("Link target resolves to the same directory as link source: " + to)) : void cb.apply(this, arguments);
        }));
      }
      function link(from, to, opts, cb) {
        to = path.resolve(to), opts.base = path.dirname(to);
        var absTarget = path.resolve(opts.base, from), relativeTarget = path.relative(opts.base, absTarget), target = opts.absolute ? absTarget : relativeTarget;
        const tasks = [ [ ensureFromIsNotSource, absTarget, to ], [ fs, "stat", absTarget ], [ clobberLinkGently, from, to, opts ], [ mkdir, path.dirname(to) ], [ fs, "symlink", target, to, "junction" ] ];
        0 !== chown.selfOwner.uid ? chain(tasks, cb) : inferOwner(to).then((owner => {
          tasks.push([ chown, to, owner.uid, owner.gid ]), chain(tasks, cb);
        }));
      }
      function clobberLinkGently(from, to, opts, cb) {
        return !1 === opts.currentExists ? (opts.log.silly("gently link", "link does not already exist", {
          link: to,
          target: from
        }), cb()) : opts.clobberLinkGently && !0 !== opts.force && opts.gently && "string" == typeof opts.gently ? opts.currentIsLink ? 0 === opts.currentTarget.indexOf(opts.gently) ? (opts.log.silly("gently link", "delete existing link", to), 
        rm(to, opts, cb)) : (opts.log.verbose("gently link", "refusing to delete existing link", {
          link: to,
          currentTarget: opts.currentTarget,
          newTarget: from,
          gently: opts.gently
        }), cb()) : (opts.log.verbose("gently link", "cannot remove, not a link", to), cb()) : (opts.log.silly("gently link", "deleting existing link forcefully", {
          link: to,
          target: from,
          force: opts.force,
          gently: opts.gently,
          clobberLinkGently: opts.clobberLinkGently
        }), rm(to, opts, cb));
      }
      (module.exports = {
        link,
        linkIfExists: function(from, to, opts, cb) {
          opts.currentIsLink = !1, opts.currentExists = !1, fs.stat(from, (function(er) {
            if (er) return cb();
            fs.readlink(to, (function(er, fromOnDisk) {
              if (er && "ENOENT" === er.code || (opts.currentExists = !0), !er) {
                opts.currentIsLink = !0;
                var toDir = path.dirname(to), absoluteFrom = path.resolve(toDir, from), absoluteFromOnDisk = path.resolve(toDir, fromOnDisk);
                if (opts.currentTarget = absoluteFromOnDisk, absoluteFrom === absoluteFromOnDisk) return cb();
              }
              link(from, to, opts, cb);
            }));
          }));
        }
      })._clobberLinkGently = clobberLinkGently;
    },
    47923: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const mkdirp = __webpack_require__(41718), inferOwner = __webpack_require__(84876), chown = __webpack_require__(75127);
      module.exports = (path, cb) => {
        if ("win32" === process.platform || 0 !== chown.selfOwner.uid) return mkdirp(path, cb);
        inferOwner(path).then((owner => {
          mkdirp(path, ((er, made) => {
            er ? cb(er, made) : chown(made || path, owner.uid, owner.gid, cb);
          }));
        }), cb);
      };
    },
    48588: function(module) {
      (function() {
        var exports, iferr, printerr, throwerr, tiferr, __slice = [].slice;
        iferr = function(fail, succ) {
          return function() {
            var a, err;
            return err = arguments[0], a = 2 <= arguments.length ? __slice.call(arguments, 1) : [], 
            null != err ? fail(err) : "function" == typeof succ ? succ.apply(null, a) : void 0;
          };
        }, tiferr = function(fail, succ) {
          return iferr(fail, (function() {
            var a;
            a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            try {
              return succ.apply(null, a);
            } catch (_error) {
              return fail(_error);
            }
          }));
        }, throwerr = iferr.bind(null, (function(err) {
          throw err;
        })), printerr = iferr((function(err) {
          return console.error(err.stack || err);
        })), module.exports = exports = iferr, exports.iferr = iferr, exports.tiferr = tiferr, 
        exports.throwerr = throwerr, exports.printerr = printerr;
      }).call(this);
    },
    44624: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const {PassThrough} = __webpack_require__(12781);
      module.exports = options => {
        options = Object.assign({}, options);
        const {array} = options;
        let {encoding} = options;
        const buffer = "buffer" === encoding;
        let objectMode = !1;
        array ? objectMode = !(encoding || buffer) : encoding = encoding || "utf8", buffer && (encoding = null);
        let len = 0;
        const ret = [], stream = new PassThrough({
          objectMode
        });
        return encoding && stream.setEncoding(encoding), stream.on("data", (chunk => {
          ret.push(chunk), objectMode ? len = ret.length : len += chunk.length;
        })), stream.getBufferedValue = () => array ? ret : buffer ? Buffer.concat(ret, len) : ret.join(""), 
        stream.getBufferedLength = () => len, stream;
      };
    },
    94810: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const pump = __webpack_require__(42048), bufferStream = __webpack_require__(44624);
      class MaxBufferError extends Error {
        constructor() {
          super("maxBuffer exceeded"), this.name = "MaxBufferError";
        }
      }
      function getStream(inputStream, options) {
        if (!inputStream) return Promise.reject(new Error("Expected a stream"));
        options = Object.assign({
          maxBuffer: 1 / 0
        }, options);
        const {maxBuffer} = options;
        let stream;
        return new Promise(((resolve, reject) => {
          const rejectPromise = error => {
            error && (error.bufferedData = stream.getBufferedValue()), reject(error);
          };
          stream = pump(inputStream, bufferStream(options), (error => {
            error ? rejectPromise(error) : resolve();
          })), stream.on("data", (() => {
            stream.getBufferedLength() > maxBuffer && rejectPromise(new MaxBufferError);
          }));
        })).then((() => stream.getBufferedValue()));
      }
      module.exports = getStream, module.exports.buffer = (stream, options) => getStream(stream, Object.assign({}, options, {
        encoding: "buffer"
      })), module.exports.array = (stream, options) => getStream(stream, Object.assign({}, options, {
        array: !0
      })), module.exports.MaxBufferError = MaxBufferError;
    },
    65534: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var os = __webpack_require__(22037);
      module.exports = function() {
        if ("Windows_NT" == os.type()) return !1;
        var ctype = process.env.LC_ALL || process.env.LC_CTYPE || process.env.LANG;
        return /UTF-?8$/i.test(ctype);
      };
    },
    63780: module => {
      "use strict";
      var gitHosts = module.exports = {
        github: {
          protocols: [ "git", "http", "git+ssh", "git+https", "ssh", "https" ],
          domain: "github.com",
          treepath: "tree",
          filetemplate: "https://{auth@}raw.githubusercontent.com/{user}/{project}/{committish}/{path}",
          bugstemplate: "https://{domain}/{user}/{project}/issues",
          gittemplate: "git://{auth@}{domain}/{user}/{project}.git{#committish}",
          tarballtemplate: "https://codeload.{domain}/{user}/{project}/tar.gz/{committish}"
        },
        bitbucket: {
          protocols: [ "git+ssh", "git+https", "ssh", "https" ],
          domain: "bitbucket.org",
          treepath: "src",
          tarballtemplate: "https://{domain}/{user}/{project}/get/{committish}.tar.gz"
        },
        gitlab: {
          protocols: [ "git+ssh", "git+https", "ssh", "https" ],
          domain: "gitlab.com",
          treepath: "tree",
          bugstemplate: "https://{domain}/{user}/{project}/issues",
          httpstemplate: "git+https://{auth@}{domain}/{user}/{projectPath}.git{#committish}",
          tarballtemplate: "https://{domain}/{user}/{project}/repository/archive.tar.gz?ref={committish}",
          pathmatch: /^[/]([^/]+)[/]((?!.*(\/-\/|\/repository\/archive\.tar\.gz\?=.*|\/repository\/[^/]+\/archive.tar.gz$)).*?)(?:[.]git|[/])?$/
        },
        gist: {
          protocols: [ "git", "git+ssh", "git+https", "ssh", "https" ],
          domain: "gist.github.com",
          pathmatch: /^[/](?:([^/]+)[/])?([a-z0-9]{32,})(?:[.]git)?$/,
          filetemplate: "https://gist.githubusercontent.com/{user}/{project}/raw{/committish}/{path}",
          bugstemplate: "https://{domain}/{project}",
          gittemplate: "git://{domain}/{project}.git{#committish}",
          sshtemplate: "git@{domain}:/{project}.git{#committish}",
          sshurltemplate: "git+ssh://git@{domain}/{project}.git{#committish}",
          browsetemplate: "https://{domain}/{project}{/committish}",
          browsefiletemplate: "https://{domain}/{project}{/committish}{#path}",
          docstemplate: "https://{domain}/{project}{/committish}",
          httpstemplate: "git+https://{domain}/{project}.git{#committish}",
          shortcuttemplate: "{type}:{project}{#committish}",
          pathtemplate: "{project}{#committish}",
          tarballtemplate: "https://codeload.github.com/gist/{project}/tar.gz/{committish}",
          hashformat: function(fragment) {
            return "file-" + formatHashFragment(fragment);
          }
        }
      }, gitHostDefaults = {
        sshtemplate: "git@{domain}:{user}/{project}.git{#committish}",
        sshurltemplate: "git+ssh://git@{domain}/{user}/{project}.git{#committish}",
        browsetemplate: "https://{domain}/{user}/{project}{/tree/committish}",
        browsefiletemplate: "https://{domain}/{user}/{project}/{treepath}/{committish}/{path}{#fragment}",
        docstemplate: "https://{domain}/{user}/{project}{/tree/committish}#readme",
        httpstemplate: "git+https://{auth@}{domain}/{user}/{project}.git{#committish}",
        filetemplate: "https://{domain}/{user}/{project}/raw/{committish}/{path}",
        shortcuttemplate: "{type}:{user}/{project}{#committish}",
        pathtemplate: "{user}/{project}{#committish}",
        pathmatch: /^[/]([^/]+)[/]([^/]+?)(?:[.]git|[/])?$/,
        hashformat: formatHashFragment
      };
      function formatHashFragment(fragment) {
        return fragment.toLowerCase().replace(/^\W+|\/|\W+$/g, "").replace(/\W+/g, "-");
      }
      Object.keys(gitHosts).forEach((function(name) {
        Object.keys(gitHostDefaults).forEach((function(key) {
          gitHosts[name][key] || (gitHosts[name][key] = gitHostDefaults[key]);
        })), gitHosts[name].protocols_re = RegExp("^(" + gitHosts[name].protocols.map((function(protocol) {
          return protocol.replace(/([\\+*{}()[\]$^|])/g, "\\$1");
        })).join("|") + "):$");
      }));
    },
    22787: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var gitHosts = __webpack_require__(63780), extend = Object.assign || function(target, source) {
        if (null === source || "object" != typeof source) return target;
        for (var keys = Object.keys(source), i = keys.length; i--; ) target[keys[i]] = source[keys[i]];
        return target;
      };
      function GitHost(type, user, auth, project, committish, defaultRepresentation, opts) {
        var gitHostInfo = this;
        gitHostInfo.type = type, Object.keys(gitHosts[type]).forEach((function(key) {
          gitHostInfo[key] = gitHosts[type][key];
        })), gitHostInfo.user = user, gitHostInfo.auth = auth, gitHostInfo.project = project, 
        gitHostInfo.committish = committish, gitHostInfo.default = defaultRepresentation, 
        gitHostInfo.opts = opts || {};
      }
      module.exports = GitHost, GitHost.prototype.hash = function() {
        return this.committish ? "#" + this.committish : "";
      }, GitHost.prototype._fill = function(template, opts) {
        if (template) {
          var vars = extend({}, opts);
          vars.path = vars.path ? vars.path.replace(/^[/]+/g, "") : "", opts = extend(extend({}, this.opts), opts);
          var self = this;
          Object.keys(this).forEach((function(key) {
            null != self[key] && null == vars[key] && (vars[key] = self[key]);
          }));
          var rawAuth = vars.auth, rawcommittish = vars.committish, rawFragment = vars.fragment, rawPath = vars.path, rawProject = vars.project;
          Object.keys(vars).forEach((function(key) {
            var value = vars[key];
            vars[key] = "path" !== key && "project" !== key || "string" != typeof value ? encodeURIComponent(value) : value.split("/").map((function(pathComponent) {
              return encodeURIComponent(pathComponent);
            })).join("/");
          })), vars["auth@"] = rawAuth ? rawAuth + "@" : "", vars["#fragment"] = rawFragment ? "#" + this.hashformat(rawFragment) : "", 
          vars.fragment = vars.fragment ? vars.fragment : "", vars["#path"] = rawPath ? "#" + this.hashformat(rawPath) : "", 
          vars["/path"] = vars.path ? "/" + vars.path : "", vars.projectPath = rawProject.split("/").map(encodeURIComponent).join("/"), 
          opts.noCommittish ? (vars["#committish"] = "", vars["/tree/committish"] = "", vars["/committish"] = "", 
          vars.committish = "") : (vars["#committish"] = rawcommittish ? "#" + rawcommittish : "", 
          vars["/tree/committish"] = vars.committish ? "/" + vars.treepath + "/" + vars.committish : "", 
          vars["/committish"] = vars.committish ? "/" + vars.committish : "", vars.committish = vars.committish || "master");
          var res = template;
          return Object.keys(vars).forEach((function(key) {
            res = res.replace(new RegExp("[{]" + key + "[}]", "g"), vars[key]);
          })), opts.noGitPlus ? res.replace(/^git[+]/, "") : res;
        }
      }, GitHost.prototype.ssh = function(opts) {
        return this._fill(this.sshtemplate, opts);
      }, GitHost.prototype.sshurl = function(opts) {
        return this._fill(this.sshurltemplate, opts);
      }, GitHost.prototype.browse = function(P, F, opts) {
        return "string" == typeof P ? ("string" != typeof F && (opts = F, F = null), this._fill(this.browsefiletemplate, extend({
          fragment: F,
          path: P
        }, opts))) : this._fill(this.browsetemplate, P);
      }, GitHost.prototype.docs = function(opts) {
        return this._fill(this.docstemplate, opts);
      }, GitHost.prototype.bugs = function(opts) {
        return this._fill(this.bugstemplate, opts);
      }, GitHost.prototype.https = function(opts) {
        return this._fill(this.httpstemplate, opts);
      }, GitHost.prototype.git = function(opts) {
        return this._fill(this.gittemplate, opts);
      }, GitHost.prototype.shortcut = function(opts) {
        return this._fill(this.shortcuttemplate, opts);
      }, GitHost.prototype.path = function(opts) {
        return this._fill(this.pathtemplate, opts);
      }, GitHost.prototype.tarball = function(opts_) {
        var opts = extend({}, opts_, {
          noCommittish: !1
        });
        return this._fill(this.tarballtemplate, opts);
      }, GitHost.prototype.file = function(P, opts) {
        return this._fill(this.filetemplate, extend({
          path: P
        }, opts));
      }, GitHost.prototype.getDefaultRepresentation = function() {
        return this.default;
      }, GitHost.prototype.toString = function(opts) {
        return this.default && "function" == typeof this[this.default] ? this[this.default](opts) : this.sshurl(opts);
      };
    },
    71438: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var url = __webpack_require__(57310), gitHosts = __webpack_require__(63780), GitHost = module.exports = __webpack_require__(22787), protocolToRepresentationMap = {
        "git+ssh:": "sshurl",
        "git+https:": "https",
        "ssh:": "sshurl",
        "git:": "git"
      };
      var authProtocols = {
        "git:": !0,
        "https:": !0,
        "git+https:": !0,
        "http:": !0,
        "git+http:": !0
      }, cache = {};
      function fixupUnqualifiedGist(giturl) {
        var parsed = url.parse(giturl);
        return "gist:" === parsed.protocol && parsed.host && !parsed.path ? parsed.protocol + "/" + parsed.host : giturl;
      }
      function parseGitUrl(giturl) {
        var matched = giturl.match(/^([^@]+)@([^:/]+):[/]?((?:[^/]+[/])?[^/]+?)(?:[.]git)?(#.*)?$/);
        if (!matched) {
          var legacy = url.parse(giturl);
          if (legacy.auth && "function" == typeof url.URL) {
            var authmatch = giturl.match(/[^@]+@[^:/]+/);
            if (authmatch) {
              var whatwg = new url.URL(authmatch[0]);
              legacy.auth = whatwg.username || "", whatwg.password && (legacy.auth += ":" + whatwg.password);
            }
          }
          return legacy;
        }
        return {
          protocol: "git+ssh:",
          slashes: !0,
          auth: matched[1],
          host: matched[2],
          port: null,
          hostname: matched[2],
          hash: matched[4],
          search: null,
          query: null,
          pathname: "/" + matched[3],
          path: "/" + matched[3],
          href: "git+ssh://" + matched[1] + "@" + matched[2] + "/" + matched[3] + (matched[4] || "")
        };
      }
      module.exports.fromUrl = function(giturl, opts) {
        if ("string" == typeof giturl) {
          var key = giturl + JSON.stringify(opts || {});
          return key in cache || (cache[key] = function(giturl, opts) {
            if (null == giturl || "" === giturl) return;
            var url = fixupUnqualifiedGist((arg = giturl, /^[^:@%/\s.-][^:@%/\s]*[/][^:@\s/%]+(?:#.*)?$/.test(arg) ? "github:" + giturl : giturl)), parsed = parseGitUrl(url), shortcutMatch = url.match(/^([^:]+):(?:[^@]+@)?(?:([^/]*)\/)?([^#]+)/), matches = Object.keys(gitHosts).map((function(gitHostName) {
              try {
                var gitHostInfo = gitHosts[gitHostName], auth = null;
                parsed.auth && authProtocols[parsed.protocol] && (auth = parsed.auth);
                var committish = parsed.hash ? decodeURIComponent(parsed.hash.substr(1)) : null, user = null, project = null, defaultRepresentation = null;
                if (shortcutMatch && shortcutMatch[1] === gitHostName) user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2]), 
                project = decodeURIComponent(shortcutMatch[3].replace(/\.git$/, "")), defaultRepresentation = "shortcut"; else {
                  if (parsed.host && parsed.host !== gitHostInfo.domain && parsed.host.replace(/^www[.]/, "") !== gitHostInfo.domain) return;
                  if (!gitHostInfo.protocols_re.test(parsed.protocol)) return;
                  if (!parsed.path) return;
                  var pathmatch = gitHostInfo.pathmatch, matched = parsed.path.match(pathmatch);
                  if (!matched) return;
                  null !== matched[1] && void 0 !== matched[1] && (user = decodeURIComponent(matched[1].replace(/^:/, ""))), 
                  project = decodeURIComponent(matched[2]), protocol = parsed.protocol, defaultRepresentation = protocolToRepresentationMap[protocol] || protocol.slice(0, -1);
                }
                return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts);
              } catch (ex) {
                if (!(ex instanceof URIError)) throw ex;
              }
              var protocol;
            })).filter((function(gitHostInfo) {
              return gitHostInfo;
            }));
            var arg;
            if (1 !== matches.length) return;
            return matches[0];
          }(giturl, opts)), cache[key];
        }
      };
    },
    17367: (module, exports) => {
      const iferr = (fail, succ) => (err, ...a) => err ? fail(err) : succ(...a), throwerr = iferr.bind(null, (err => {
        throw err;
      })), printerr = iferr((err => console.error(err)), (() => {}));
      module.exports = exports = iferr, exports.iferr = iferr, exports.tiferr = (fail, succ) => iferr(fail, ((...a) => {
        try {
          succ(...a);
        } catch (err) {
          fail(err);
        }
      })), exports.throwerr = throwerr, exports.printerr = printerr;
    },
    41834: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const fs = __webpack_require__(57147), path = __webpack_require__(71017), EE = __webpack_require__(82361).EventEmitter, Minimatch = __webpack_require__(42244).Minimatch;
      class Walker extends EE {
        constructor(opts) {
          super(opts = opts || {}), this.path = opts.path || process.cwd(), this.basename = path.basename(this.path), 
          this.ignoreFiles = opts.ignoreFiles || [ ".ignore" ], this.ignoreRules = {}, this.parent = opts.parent || null, 
          this.includeEmpty = !!opts.includeEmpty, this.root = this.parent ? this.parent.root : this.path, 
          this.follow = !!opts.follow, this.result = this.parent ? this.parent.result : new Set, 
          this.entries = null, this.sawError = !1;
        }
        sort(a, b) {
          return a.localeCompare(b);
        }
        emit(ev, data) {
          let ret = !1;
          return this.sawError && "error" === ev || ("error" === ev ? this.sawError = !0 : "done" !== ev || this.parent || (data = Array.from(data).map((e => /^@/.test(e) ? `./${e}` : e)).sort(this.sort), 
          this.result = data), ret = "error" === ev && this.parent ? this.parent.emit("error", data) : super.emit(ev, data)), 
          ret;
        }
        start() {
          return fs.readdir(this.path, ((er, entries) => er ? this.emit("error", er) : this.onReaddir(entries))), 
          this;
        }
        isIgnoreFile(e) {
          return "." !== e && ".." !== e && -1 !== this.ignoreFiles.indexOf(e);
        }
        onReaddir(entries) {
          if (this.entries = entries, 0 === entries.length) this.includeEmpty && this.result.add(this.path.substr(this.root.length + 1)), 
          this.emit("done", this.result); else {
            this.entries.some((e => this.isIgnoreFile(e))) ? this.addIgnoreFiles() : this.filterEntries();
          }
        }
        addIgnoreFiles() {
          const newIg = this.entries.filter((e => this.isIgnoreFile(e)));
          let igCount = newIg.length;
          const then = _ => {
            0 == --igCount && this.filterEntries();
          };
          newIg.forEach((e => this.addIgnoreFile(e, then)));
        }
        addIgnoreFile(file, then) {
          const ig = path.resolve(this.path, file);
          fs.readFile(ig, "utf8", ((er, data) => er ? this.emit("error", er) : this.onReadIgnoreFile(file, data, then)));
        }
        onReadIgnoreFile(file, data, then) {
          const mmopt = {
            matchBase: !0,
            dot: !0,
            flipNegate: !0,
            nocase: !0
          }, rules = data.split(/\r?\n/).filter((line => !/^#|^$/.test(line.trim()))).map((r => new Minimatch(r, mmopt)));
          this.ignoreRules[file] = rules, then();
        }
        filterEntries() {
          const filtered = this.entries.map((entry => {
            const passFile = this.filterEntry(entry), passDir = this.filterEntry(entry, !0);
            return !(!passFile && !passDir) && [ entry, passFile, passDir ];
          })).filter((e => e));
          let entryCount = filtered.length;
          if (0 === entryCount) this.emit("done", this.result); else {
            const then = _ => {
              0 == --entryCount && this.emit("done", this.result);
            };
            filtered.forEach((filt => {
              const entry = filt[0], file = filt[1], dir = filt[2];
              this.stat(entry, file, dir, then);
            }));
          }
        }
        onstat(st, entry, file, dir, then) {
          const abs = this.path + "/" + entry;
          st.isDirectory() ? dir ? this.walker(entry, then) : then() : (file && this.result.add(abs.substr(this.root.length + 1)), 
          then());
        }
        stat(entry, file, dir, then) {
          const abs = this.path + "/" + entry;
          fs[this.follow ? "stat" : "lstat"](abs, ((er, st) => {
            er ? this.emit("error", er) : this.onstat(st, entry, file, dir, then);
          }));
        }
        walkerOpt(entry) {
          return {
            path: this.path + "/" + entry,
            parent: this,
            ignoreFiles: this.ignoreFiles,
            follow: this.follow,
            includeEmpty: this.includeEmpty
          };
        }
        walker(entry, then) {
          new Walker(this.walkerOpt(entry)).on("done", then).start();
        }
        filterEntry(entry, partial) {
          let included = !0;
          if (this.parent && this.parent.filterEntry) {
            var pt = this.basename + "/" + entry;
            included = this.parent.filterEntry(pt, partial);
          }
          return this.ignoreFiles.forEach((f => {
            this.ignoreRules[f] && this.ignoreRules[f].forEach((rule => {
              if (rule.negate !== included) {
                (rule.match("/" + entry) || rule.match(entry) || !!partial && (rule.match("/" + entry + "/") || rule.match(entry + "/")) || !!partial && rule.negate && (rule.match("/" + entry, !0) || rule.match(entry, !0))) && (included = rule.negate);
              }
            }));
          })), included;
        }
      }
      class WalkerSync extends Walker {
        constructor(opt) {
          super(opt);
        }
        start() {
          return this.onReaddir(fs.readdirSync(this.path)), this;
        }
        addIgnoreFile(file, then) {
          const ig = path.resolve(this.path, file);
          this.onReadIgnoreFile(file, fs.readFileSync(ig, "utf8"), then);
        }
        stat(entry, file, dir, then) {
          const abs = this.path + "/" + entry, st = fs[this.follow ? "statSync" : "lstatSync"](abs);
          this.onstat(st, entry, file, dir, then);
        }
        walker(entry, then) {
          new WalkerSync(this.walkerOpt(entry)).start(), then();
        }
      }
      const walk = (options, callback) => {
        const p = new Promise(((resolve, reject) => {
          new Walker(options).on("done", resolve).on("error", reject).start();
        }));
        return callback ? p.then((res => callback(null, res)), callback) : p;
      };
      module.exports = walk, walk.sync = options => new WalkerSync(options).start().result, 
      walk.Walker = Walker, walk.WalkerSync = WalkerSync;
    },
    287: module => {
      !function() {
        var cache;
        function MurmurHash3(key, seed) {
          var m = this instanceof MurmurHash3 ? this : cache;
          if (m.reset(seed), "string" == typeof key && key.length > 0 && m.hash(key), m !== this) return m;
        }
        MurmurHash3.prototype.hash = function(key) {
          var h1, k1, i, top, len;
          switch (len = key.length, this.len += len, k1 = this.k1, i = 0, this.rem) {
           case 0:
            k1 ^= len > i ? 65535 & key.charCodeAt(i++) : 0;

           case 1:
            k1 ^= len > i ? (65535 & key.charCodeAt(i++)) << 8 : 0;

           case 2:
            k1 ^= len > i ? (65535 & key.charCodeAt(i++)) << 16 : 0;

           case 3:
            k1 ^= len > i ? (255 & key.charCodeAt(i)) << 24 : 0, k1 ^= len > i ? (65280 & key.charCodeAt(i++)) >> 8 : 0;
          }
          if (this.rem = len + this.rem & 3, (len -= this.rem) > 0) {
            for (h1 = this.h1; h1 = 5 * (h1 = (h1 ^= k1 = 13715 * (k1 = (k1 = 11601 * k1 + 3432906752 * (65535 & k1) & 4294967295) << 15 | k1 >>> 17) + 461832192 * (65535 & k1) & 4294967295) << 13 | h1 >>> 19) + 3864292196 & 4294967295, 
            !(i >= len); ) k1 = 65535 & key.charCodeAt(i++) ^ (65535 & key.charCodeAt(i++)) << 8 ^ (65535 & key.charCodeAt(i++)) << 16, 
            k1 ^= (255 & (top = key.charCodeAt(i++))) << 24 ^ (65280 & top) >> 8;
            switch (k1 = 0, this.rem) {
             case 3:
              k1 ^= (65535 & key.charCodeAt(i + 2)) << 16;

             case 2:
              k1 ^= (65535 & key.charCodeAt(i + 1)) << 8;

             case 1:
              k1 ^= 65535 & key.charCodeAt(i);
            }
            this.h1 = h1;
          }
          return this.k1 = k1, this;
        }, MurmurHash3.prototype.result = function() {
          var k1, h1;
          return k1 = this.k1, h1 = this.h1, k1 > 0 && (h1 ^= k1 = 13715 * (k1 = (k1 = 11601 * k1 + 3432906752 * (65535 & k1) & 4294967295) << 15 | k1 >>> 17) + 461832192 * (65535 & k1) & 4294967295), 
          h1 ^= this.len, h1 = 51819 * (h1 ^= h1 >>> 16) + 2246770688 * (65535 & h1) & 4294967295, 
          h1 = 44597 * (h1 ^= h1 >>> 13) + 3266445312 * (65535 & h1) & 4294967295, (h1 ^= h1 >>> 16) >>> 0;
        }, MurmurHash3.prototype.reset = function(seed) {
          return this.h1 = "number" == typeof seed ? seed : 0, this.rem = this.k1 = this.len = 0, 
          this;
        }, cache = new MurmurHash3, module.exports = MurmurHash3;
      }();
    },
    84876: (module, __unused_webpack_exports, __webpack_require__) => {
      const cache = new Map, fs = __webpack_require__(57147), {dirname, resolve} = __webpack_require__(71017), inferOwner = path => {
        if (path = resolve(path), cache.has(path)) return Promise.resolve(cache.get(path));
        const parent = dirname(path), parentTrap = parent === path ? null : er => inferOwner(parent).then((owner => (cache.set(path, owner), 
        owner)));
        return (path => new Promise(((res, rej) => fs.lstat(path, ((er, st) => er ? rej(er) : res(st))))))(path).then((st => {
          const {uid, gid} = st;
          return cache.set(path, {
            uid,
            gid
          }), {
            uid,
            gid
          };
        }), parentTrap);
      }, inferOwnerSync = path => {
        if (path = resolve(path), cache.has(path)) return cache.get(path);
        const parent = dirname(path);
        let threw = !0;
        try {
          const st = fs.lstatSync(path);
          threw = !1;
          const {uid, gid} = st;
          return cache.set(path, {
            uid,
            gid
          }), {
            uid,
            gid
          };
        } finally {
          if (threw && parent !== path) {
            const owner = inferOwnerSync(parent);
            return cache.set(path, owner), owner;
          }
        }
      }, inflight = new Map;
      module.exports = path => {
        if (path = resolve(path), inflight.has(path)) return Promise.resolve(inflight.get(path));
        const p = inferOwner(path).then((owner => (inflight.delete(path), owner)));
        return inflight.set(path, p), p;
      }, module.exports.sync = inferOwnerSync, module.exports.clearCache = () => {
        cache.clear(), inflight.clear();
      };
    },
    59956: (module, __unused_webpack_exports, __webpack_require__) => {
      var wrappy = __webpack_require__(68839), reqs = Object.create(null), once = __webpack_require__(38412);
      function slice(args) {
        for (var length = args.length, array = [], i = 0; i < length; i++) array[i] = args[i];
        return array;
      }
      module.exports = wrappy((function(key, cb) {
        return reqs[key] ? (reqs[key].push(cb), null) : (reqs[key] = [ cb ], function(key) {
          return once((function RES() {
            var cbs = reqs[key], len = cbs.length, args = slice(arguments);
            try {
              for (var i = 0; i < len; i++) cbs[i].apply(null, args);
            } finally {
              cbs.length > len ? (cbs.splice(0, len), process.nextTick((function() {
                RES.apply(null, args);
              }))) : delete reqs[key];
            }
          }));
        }(key));
      }));
    },
    90741: (module, __unused_webpack_exports, __webpack_require__) => {
      try {
        var util = __webpack_require__(73837);
        if ("function" != typeof util.inherits) throw "";
        module.exports = util.inherits;
      } catch (e) {
        module.exports = __webpack_require__(59293);
      }
    },
    59293: module => {
      "function" == typeof Object.create ? module.exports = function(ctor, superCtor) {
        superCtor && (ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        }));
      } : module.exports = function(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {};
          TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
        }
      };
    },
    8477: (__unused_webpack_module, exports) => {
      exports.parse = exports.decode = function(str) {
        var out = {}, p = out, section = null, re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
        return str.split(/[\r\n]+/g).forEach((function(line, _, __) {
          if (line && !line.match(/^\s*[;#]/)) {
            var match = line.match(re);
            if (match) {
              if (void 0 !== match[1]) return "__proto__" === (section = unsafe(match[1])) ? void (p = {}) : void (p = out[section] = out[section] || {});
              var key = unsafe(match[2]);
              if ("__proto__" !== key) {
                var value = !match[3] || unsafe(match[4]);
                switch (value) {
                 case "true":
                 case "false":
                 case "null":
                  value = JSON.parse(value);
                }
                if (key.length > 2 && "[]" === key.slice(-2)) {
                  if ("__proto__" === (key = key.substring(0, key.length - 2))) return;
                  p[key] ? Array.isArray(p[key]) || (p[key] = [ p[key] ]) : p[key] = [];
                }
                Array.isArray(p[key]) ? p[key].push(value) : p[key] = value;
              }
            }
          }
        })), Object.keys(out).filter((function(k, _, __) {
          if (!out[k] || "object" != typeof out[k] || Array.isArray(out[k])) return !1;
          var parts = dotSplit(k), p = out, l = parts.pop(), nl = l.replace(/\\\./g, ".");
          return parts.forEach((function(part, _, __) {
            "__proto__" !== part && (p[part] && "object" == typeof p[part] || (p[part] = {}), 
            p = p[part]);
          })), (p !== out || nl !== l) && (p[nl] = out[k], !0);
        })).forEach((function(del, _, __) {
          delete out[del];
        })), out;
      }, exports.stringify = exports.encode = function encode(obj, opt) {
        var children = [], out = "";
        "string" == typeof opt ? opt = {
          section: opt,
          whitespace: !1
        } : (opt = opt || {}).whitespace = !0 === opt.whitespace;
        var separator = opt.whitespace ? " = " : "=";
        Object.keys(obj).forEach((function(k, _, __) {
          var val = obj[k];
          val && Array.isArray(val) ? val.forEach((function(item) {
            out += safe(k + "[]") + separator + safe(item) + "\n";
          })) : val && "object" == typeof val ? children.push(k) : out += safe(k) + separator + safe(val) + eol;
        })), opt.section && out.length && (out = "[" + safe(opt.section) + "]" + eol + out);
        return children.forEach((function(k, _, __) {
          var nk = dotSplit(k).join("\\."), section = (opt.section ? opt.section + "." : "") + nk, child = encode(obj[k], {
            section,
            whitespace: opt.whitespace
          });
          out.length && child.length && (out += eol), out += child;
        })), out;
      }, exports.safe = safe, exports.unsafe = unsafe;
      var eol = "undefined" != typeof process && "win32" === process.platform ? "\r\n" : "\n";
      function dotSplit(str) {
        return str.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map((function(part) {
          return part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "");
        }));
      }
      function isQuoted(val) {
        return '"' === val.charAt(0) && '"' === val.slice(-1) || "'" === val.charAt(0) && "'" === val.slice(-1);
      }
      function safe(val) {
        return "string" != typeof val || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
      }
      function unsafe(val, doUnesc) {
        if (!isQuoted(val = (val || "").trim())) {
          for (var esc = !1, unesc = "", i = 0, l = val.length; i < l; i++) {
            var c = val.charAt(i);
            if (esc) -1 !== "\\;#".indexOf(c) ? unesc += c : unesc += "\\" + c, esc = !1; else {
              if (-1 !== ";#".indexOf(c)) break;
              "\\" === c ? esc = !0 : unesc += c;
            }
          }
          return esc && (unesc += "\\"), unesc.trim();
        }
        "'" === val.charAt(0) && (val = val.substr(1, val.length - 2));
        try {
          val = JSON.parse(val);
        } catch (_) {}
        return val;
      }
    },
    33573: module => {
      "use strict";
      const v4 = "(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])(?:\\.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])){3}", v6seg = "[0-9a-fA-F]{1,4}", v6 = `\n(\n(?:${v6seg}:){7}(?:${v6seg}|:)|                                // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:${v6seg}:){6}(?:${v4}|:${v6seg}|:)|                         // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:${v6seg}:){5}(?::${v4}|(:${v6seg}){1,2}|:)|                 // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:${v6seg}:){4}(?:(:${v6seg}){0,1}:${v4}|(:${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:${v6seg}:){3}(?:(:${v6seg}){0,2}:${v4}|(:${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:${v6seg}:){2}(?:(:${v6seg}){0,3}:${v4}|(:${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:${v6seg}:){1}(?:(:${v6seg}){0,4}:${v4}|(:${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::((?::${v6seg}){0,5}:${v4}|(?::${v6seg}){1,7}|:))           // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(%[0-9a-zA-Z]{1,})?                                           // %eth0            %1\n`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), ip = module.exports = opts => opts && opts.exact ? new RegExp(`(?:^${v4}$)|(?:^${v6}$)`) : new RegExp(`(?:${v4})|(?:${v6})`, "g");
      ip.v4 = opts => opts && opts.exact ? new RegExp(`^${v4}$`) : new RegExp(v4, "g"), 
      ip.v6 = opts => opts && opts.exact ? new RegExp(`^${v6}$`) : new RegExp(v6, "g");
    },
    24173: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const cidrRegex = __webpack_require__(47535), re4 = cidrRegex.v4({
        exact: !0
      }), re6 = cidrRegex.v6({
        exact: !0
      }), isCidr = module.exports = str => re4.test(str) ? 4 : re6.test(str) ? 6 : 0;
      isCidr.v4 = str => re4.test(str), isCidr.v6 = str => re6.test(str);
    },
    20386: module => {
      "use strict";
      module.exports = x => !Number.isNaN(x) && (x >= 4352 && (x <= 4447 || 9001 === x || 9002 === x || 11904 <= x && x <= 12871 && 12351 !== x || 12880 <= x && x <= 19903 || 19968 <= x && x <= 42182 || 43360 <= x && x <= 43388 || 44032 <= x && x <= 55203 || 63744 <= x && x <= 64255 || 65040 <= x && x <= 65049 || 65072 <= x && x <= 65131 || 65281 <= x && x <= 65376 || 65504 <= x && x <= 65510 || 110592 <= x && x <= 110593 || 127488 <= x && x <= 127569 || 131072 <= x && x <= 262141));
    },
    23789: (module, __unused_webpack_exports, __webpack_require__) => {
      var core;
      function isexe(path, options, cb) {
        if ("function" == typeof options && (cb = options, options = {}), !cb) {
          if ("function" != typeof Promise) throw new TypeError("callback not provided");
          return new Promise((function(resolve, reject) {
            isexe(path, options || {}, (function(er, is) {
              er ? reject(er) : resolve(is);
            }));
          }));
        }
        core(path, options || {}, (function(er, is) {
          er && ("EACCES" === er.code || options && options.ignoreErrors) && (er = null, is = !1), 
          cb(er, is);
        }));
      }
      core = "win32" === process.platform || global.TESTING_WINDOWS ? __webpack_require__(34690) : __webpack_require__(62015), 
      module.exports = isexe, isexe.sync = function(path, options) {
        try {
          return core.sync(path, options || {});
        } catch (er) {
          if (options && options.ignoreErrors || "EACCES" === er.code) return !1;
          throw er;
        }
      };
    },
    62015: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = isexe, isexe.sync = function(path, options) {
        return checkStat(fs.statSync(path), options);
      };
      var fs = __webpack_require__(57147);
      function isexe(path, options, cb) {
        fs.stat(path, (function(er, stat) {
          cb(er, !er && checkStat(stat, options));
        }));
      }
      function checkStat(stat, options) {
        return stat.isFile() && function(stat, options) {
          var mod = stat.mode, uid = stat.uid, gid = stat.gid, myUid = void 0 !== options.uid ? options.uid : process.getuid && process.getuid(), myGid = void 0 !== options.gid ? options.gid : process.getgid && process.getgid(), u = parseInt("100", 8), g = parseInt("010", 8), o = parseInt("001", 8), ug = u | g;
          return mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && 0 === myUid;
        }(stat, options);
      }
    },
    34690: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = isexe, isexe.sync = function(path, options) {
        return checkStat(fs.statSync(path), path, options);
      };
      var fs = __webpack_require__(57147);
      function checkStat(stat, path, options) {
        return !(!stat.isSymbolicLink() && !stat.isFile()) && function(path, options) {
          var pathext = void 0 !== options.pathExt ? options.pathExt : process.env.PATHEXT;
          if (!pathext) return !0;
          if (-1 !== (pathext = pathext.split(";")).indexOf("")) return !0;
          for (var i = 0; i < pathext.length; i++) {
            var p = pathext[i].toLowerCase();
            if (p && path.substr(-p.length).toLowerCase() === p) return !0;
          }
          return !1;
        }(path, options);
      }
      function isexe(path, options, cb) {
        fs.stat(path, (function(er, stat) {
          cb(er, !er && checkStat(stat, path, options));
        }));
      }
    },
    15071: module => {
      "use strict";
      module.exports = function(txt, reviver, context) {
        context = context || 20;
        try {
          return JSON.parse(txt, reviver);
        } catch (e) {
          if ("string" != typeof txt) {
            const errorMessage = "Cannot parse " + (Array.isArray(txt) && 0 === txt.length ? "an empty array" : String(txt));
            throw new TypeError(errorMessage);
          }
          const syntaxErr = e.message.match(/^Unexpected token.*position\s+(\d+)/i), errIdx = syntaxErr ? +syntaxErr[1] : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1 : null;
          if (null != errIdx) {
            const start = errIdx <= context ? 0 : errIdx - context, end = errIdx + context >= txt.length ? txt.length : errIdx + context;
            e.message += ` while parsing near '${0 === start ? "" : "..."}${txt.slice(start, end)}${end === txt.length ? "" : "..."}'`;
          } else e.message += ` while parsing '${txt.slice(0, 2 * context)}'`;
          throw e;
        }
      };
    },
    40295: module => {
      "use strict";
      class JSONParseError extends SyntaxError {
        constructor(er, txt, context, caller) {
          const metadata = ((e, txt, context) => {
            if (!txt) return {
              message: e.message + " while parsing empty string",
              position: 0
            };
            const badToken = e.message.match(/^Unexpected token (.) .*position\s+(\d+)/i), errIdx = badToken ? +badToken[2] : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1 : null, msg = badToken ? e.message.replace(/^Unexpected token ./, `Unexpected token ${JSON.stringify(badToken[1])} (${(char => {
              const h = char.charCodeAt(0).toString(16).toUpperCase();
              return "0x" + (h.length % 2 ? "0" : "") + h;
            })(badToken[1])})`) : e.message;
            if (null != errIdx) {
              const start = errIdx <= context ? 0 : errIdx - context, end = errIdx + context >= txt.length ? txt.length : errIdx + context, slice = (0 === start ? "" : "...") + txt.slice(start, end) + (end === txt.length ? "" : "...");
              return {
                message: msg + ` while parsing ${txt === slice ? "" : "near "}${JSON.stringify(slice)}`,
                position: errIdx
              };
            }
            return {
              message: msg + ` while parsing '${txt.slice(0, 2 * context)}'`,
              position: 0
            };
          })(er, txt, context = context || 20);
          super(metadata.message), Object.assign(this, metadata), this.code = "EJSONPARSE", 
          this.systemError = er, Error.captureStackTrace(this, caller || this.constructor);
        }
        get name() {
          return this.constructor.name;
        }
        set name(n) {}
        get [Symbol.toStringTag]() {
          return this.constructor.name;
        }
      }
      const kIndent = Symbol.for("indent"), kNewline = Symbol.for("newline"), formatRE = /^\s*[{\[]((?:\r?\n)+)([\s\t]*)/, emptyRE = /^(?:\{\}|\[\])((?:\r?\n)+)?$/, parseJson = (txt, reviver, context) => {
        const parseText = stripBOM(txt);
        context = context || 20;
        try {
          const [, newline = "\n", indent = "  "] = parseText.match(emptyRE) || parseText.match(formatRE) || [ , "", "" ], result = JSON.parse(parseText, reviver);
          return result && "object" == typeof result && (result[kNewline] = newline, result[kIndent] = indent), 
          result;
        } catch (e) {
          if ("string" != typeof txt && !Buffer.isBuffer(txt)) {
            const isEmptyArray = Array.isArray(txt) && 0 === txt.length;
            throw Object.assign(new TypeError(`Cannot parse ${isEmptyArray ? "an empty array" : String(txt)}`), {
              code: "EJSONPARSE",
              systemError: e
            });
          }
          throw new JSONParseError(e, parseText, context, parseJson);
        }
      }, stripBOM = txt => String(txt).replace(/^\uFEFF/, "");
      module.exports = parseJson, parseJson.JSONParseError = JSONParseError, parseJson.noExceptions = (txt, reviver) => {
        try {
          return JSON.parse(stripBOM(txt), reviver);
        } catch (e) {}
      };
    },
    84105: module => {
      var C = {}, LEFT_BRACE = C.LEFT_BRACE = 1, RIGHT_BRACE = C.RIGHT_BRACE = 2, LEFT_BRACKET = C.LEFT_BRACKET = 3, RIGHT_BRACKET = C.RIGHT_BRACKET = 4, COLON = C.COLON = 5, COMMA = C.COMMA = 6, TRUE = C.TRUE = 7, FALSE = C.FALSE = 8, NULL = C.NULL = 9, STRING = C.STRING = 10, NUMBER = C.NUMBER = 11, START = C.START = 17, STOP = C.STOP = 18, TRUE1 = C.TRUE1 = 33, TRUE2 = C.TRUE2 = 34, TRUE3 = C.TRUE3 = 35, FALSE1 = C.FALSE1 = 49, FALSE2 = C.FALSE2 = 50, FALSE3 = C.FALSE3 = 51, FALSE4 = C.FALSE4 = 52, NULL1 = C.NULL1 = 65, NULL2 = C.NULL2 = 66, NULL3 = C.NULL3 = 67, NUMBER1 = C.NUMBER1 = 81, NUMBER3 = C.NUMBER3 = 83, STRING1 = C.STRING1 = 97, STRING2 = C.STRING2 = 98, STRING3 = C.STRING3 = 99, STRING4 = C.STRING4 = 100, STRING5 = C.STRING5 = 101, STRING6 = C.STRING6 = 102, VALUE = C.VALUE = 113, KEY = C.KEY = 114, OBJECT = C.OBJECT = 129, ARRAY = C.ARRAY = 130, BACK_SLASH = "\\".charCodeAt(0), FORWARD_SLASH = "/".charCodeAt(0), BACKSPACE = "\b".charCodeAt(0), FORM_FEED = "\f".charCodeAt(0), NEWLINE = "\n".charCodeAt(0), CARRIAGE_RETURN = "\r".charCodeAt(0), TAB = "\t".charCodeAt(0);
      function Parser() {
        this.tState = START, this.value = void 0, this.string = void 0, this.stringBuffer = Buffer.alloc ? Buffer.alloc(65536) : new Buffer(65536), 
        this.stringBufferOffset = 0, this.unicode = void 0, this.highSurrogate = void 0, 
        this.key = void 0, this.mode = void 0, this.stack = [], this.state = VALUE, this.bytes_remaining = 0, 
        this.bytes_in_sequence = 0, this.temp_buffs = {
          2: new Buffer(2),
          3: new Buffer(3),
          4: new Buffer(4)
        }, this.offset = -1;
      }
      Parser.toknam = function(code) {
        for (var keys = Object.keys(C), i = 0, l = keys.length; i < l; i++) {
          var key = keys[i];
          if (C[key] === code) return key;
        }
        return code && "0x" + code.toString(16);
      };
      var proto = Parser.prototype;
      proto.onError = function(err) {
        throw err;
      }, proto.charError = function(buffer, i) {
        this.tState = STOP, this.onError(new Error("Unexpected " + JSON.stringify(String.fromCharCode(buffer[i])) + " at position " + i + " in state " + Parser.toknam(this.tState)));
      }, proto.appendStringChar = function(char) {
        this.stringBufferOffset >= 65536 && (this.string += this.stringBuffer.toString("utf8"), 
        this.stringBufferOffset = 0), this.stringBuffer[this.stringBufferOffset++] = char;
      }, proto.appendStringBuf = function(buf, start, end) {
        var size = buf.length;
        "number" == typeof start && (size = "number" == typeof end ? end < 0 ? buf.length - start + end : end - start : buf.length - start), 
        size < 0 && (size = 0), this.stringBufferOffset + size > 65536 && (this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset), 
        this.stringBufferOffset = 0), buf.copy(this.stringBuffer, this.stringBufferOffset, start, end), 
        this.stringBufferOffset += size;
      }, proto.write = function(buffer) {
        var n;
        "string" == typeof buffer && (buffer = new Buffer(buffer));
        for (var i = 0, l = buffer.length; i < l; i++) if (this.tState === START) {
          if (n = buffer[i], this.offset++, 123 === n) this.onToken(LEFT_BRACE, "{"); else if (125 === n) this.onToken(RIGHT_BRACE, "}"); else if (91 === n) this.onToken(LEFT_BRACKET, "["); else if (93 === n) this.onToken(RIGHT_BRACKET, "]"); else if (58 === n) this.onToken(COLON, ":"); else if (44 === n) this.onToken(COMMA, ","); else if (116 === n) this.tState = TRUE1; else if (102 === n) this.tState = FALSE1; else if (110 === n) this.tState = NULL1; else if (34 === n) this.string = "", 
          this.stringBufferOffset = 0, this.tState = STRING1; else if (45 === n) this.string = "-", 
          this.tState = NUMBER1; else if (n >= 48 && n < 64) this.string = String.fromCharCode(n), 
          this.tState = NUMBER3; else if (32 !== n && 9 !== n && 10 !== n && 13 !== n) return this.charError(buffer, i);
        } else if (this.tState === STRING1) if (n = buffer[i], this.bytes_remaining > 0) {
          for (var j = 0; j < this.bytes_remaining; j++) this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = buffer[j];
          this.appendStringBuf(this.temp_buffs[this.bytes_in_sequence]), this.bytes_in_sequence = this.bytes_remaining = 0, 
          i = i + j - 1;
        } else if (0 === this.bytes_remaining && n >= 128) {
          if (n <= 193 || n > 244) return this.onError(new Error("Invalid UTF-8 character at position " + i + " in state " + Parser.toknam(this.tState)));
          if (n >= 194 && n <= 223 && (this.bytes_in_sequence = 2), n >= 224 && n <= 239 && (this.bytes_in_sequence = 3), 
          n >= 240 && n <= 244 && (this.bytes_in_sequence = 4), this.bytes_in_sequence + i > buffer.length) {
            for (var k = 0; k <= buffer.length - 1 - i; k++) this.temp_buffs[this.bytes_in_sequence][k] = buffer[i + k];
            this.bytes_remaining = i + this.bytes_in_sequence - buffer.length, i = buffer.length - 1;
          } else this.appendStringBuf(buffer, i, i + this.bytes_in_sequence), i = i + this.bytes_in_sequence - 1;
        } else if (34 === n) this.tState = START, this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset), 
        this.stringBufferOffset = 0, this.onToken(STRING, this.string), this.offset += Buffer.byteLength(this.string, "utf8") + 1, 
        this.string = void 0; else if (92 === n) this.tState = STRING2; else {
          if (!(n >= 32)) return this.charError(buffer, i);
          this.appendStringChar(n);
        } else if (this.tState === STRING2) if (34 === (n = buffer[i])) this.appendStringChar(n), 
        this.tState = STRING1; else if (92 === n) this.appendStringChar(BACK_SLASH), this.tState = STRING1; else if (47 === n) this.appendStringChar(FORWARD_SLASH), 
        this.tState = STRING1; else if (98 === n) this.appendStringChar(BACKSPACE), this.tState = STRING1; else if (102 === n) this.appendStringChar(FORM_FEED), 
        this.tState = STRING1; else if (110 === n) this.appendStringChar(NEWLINE), this.tState = STRING1; else if (114 === n) this.appendStringChar(CARRIAGE_RETURN), 
        this.tState = STRING1; else if (116 === n) this.appendStringChar(TAB), this.tState = STRING1; else {
          if (117 !== n) return this.charError(buffer, i);
          this.unicode = "", this.tState = STRING3;
        } else if (this.tState === STRING3 || this.tState === STRING4 || this.tState === STRING5 || this.tState === STRING6) {
          if (!((n = buffer[i]) >= 48 && n < 64 || n > 64 && n <= 70 || n > 96 && n <= 102)) return this.charError(buffer, i);
          if (this.unicode += String.fromCharCode(n), this.tState++ === STRING6) {
            var intVal = parseInt(this.unicode, 16);
            this.unicode = void 0, void 0 !== this.highSurrogate && intVal >= 56320 && intVal < 57344 ? (this.appendStringBuf(new Buffer(String.fromCharCode(this.highSurrogate, intVal))), 
            this.highSurrogate = void 0) : void 0 === this.highSurrogate && intVal >= 55296 && intVal < 56320 ? this.highSurrogate = intVal : (void 0 !== this.highSurrogate && (this.appendStringBuf(new Buffer(String.fromCharCode(this.highSurrogate))), 
            this.highSurrogate = void 0), this.appendStringBuf(new Buffer(String.fromCharCode(intVal)))), 
            this.tState = STRING1;
          }
        } else if (this.tState === NUMBER1 || this.tState === NUMBER3) switch (n = buffer[i]) {
         case 48:
         case 49:
         case 50:
         case 51:
         case 52:
         case 53:
         case 54:
         case 55:
         case 56:
         case 57:
         case 46:
         case 101:
         case 69:
         case 43:
         case 45:
          this.string += String.fromCharCode(n), this.tState = NUMBER3;
          break;

         default:
          this.tState = START;
          var result = Number(this.string);
          if (isNaN(result)) return this.charError(buffer, i);
          this.string.match(/[0-9]+/) == this.string && result.toString() != this.string ? this.onToken(STRING, this.string) : this.onToken(NUMBER, result), 
          this.offset += this.string.length - 1, this.string = void 0, i--;
        } else if (this.tState === TRUE1) {
          if (114 !== buffer[i]) return this.charError(buffer, i);
          this.tState = TRUE2;
        } else if (this.tState === TRUE2) {
          if (117 !== buffer[i]) return this.charError(buffer, i);
          this.tState = TRUE3;
        } else if (this.tState === TRUE3) {
          if (101 !== buffer[i]) return this.charError(buffer, i);
          this.tState = START, this.onToken(TRUE, !0), this.offset += 3;
        } else if (this.tState === FALSE1) {
          if (97 !== buffer[i]) return this.charError(buffer, i);
          this.tState = FALSE2;
        } else if (this.tState === FALSE2) {
          if (108 !== buffer[i]) return this.charError(buffer, i);
          this.tState = FALSE3;
        } else if (this.tState === FALSE3) {
          if (115 !== buffer[i]) return this.charError(buffer, i);
          this.tState = FALSE4;
        } else if (this.tState === FALSE4) {
          if (101 !== buffer[i]) return this.charError(buffer, i);
          this.tState = START, this.onToken(FALSE, !1), this.offset += 4;
        } else if (this.tState === NULL1) {
          if (117 !== buffer[i]) return this.charError(buffer, i);
          this.tState = NULL2;
        } else if (this.tState === NULL2) {
          if (108 !== buffer[i]) return this.charError(buffer, i);
          this.tState = NULL3;
        } else if (this.tState === NULL3) {
          if (108 !== buffer[i]) return this.charError(buffer, i);
          this.tState = START, this.onToken(NULL, null), this.offset += 3;
        }
      }, proto.onToken = function(token, value) {}, proto.parseError = function(token, value) {
        this.tState = STOP, this.onError(new Error("Unexpected " + Parser.toknam(token) + (value ? "(" + JSON.stringify(value) + ")" : "") + " in state " + Parser.toknam(this.state)));
      }, proto.push = function() {
        this.stack.push({
          value: this.value,
          key: this.key,
          mode: this.mode
        });
      }, proto.pop = function() {
        var value = this.value, parent = this.stack.pop();
        this.value = parent.value, this.key = parent.key, this.mode = parent.mode, this.emit(value), 
        this.mode || (this.state = VALUE);
      }, proto.emit = function(value) {
        this.mode && (this.state = COMMA), this.onValue(value);
      }, proto.onValue = function(value) {}, proto.onToken = function(token, value) {
        if (this.state === VALUE) if (token === STRING || token === NUMBER || token === TRUE || token === FALSE || token === NULL) this.value && (this.value[this.key] = value), 
        this.emit(value); else if (token === LEFT_BRACE) this.push(), this.value ? this.value = this.value[this.key] = {} : this.value = {}, 
        this.key = void 0, this.state = KEY, this.mode = OBJECT; else if (token === LEFT_BRACKET) this.push(), 
        this.value ? this.value = this.value[this.key] = [] : this.value = [], this.key = 0, 
        this.mode = ARRAY, this.state = VALUE; else if (token === RIGHT_BRACE) {
          if (this.mode !== OBJECT) return this.parseError(token, value);
          this.pop();
        } else {
          if (token !== RIGHT_BRACKET) return this.parseError(token, value);
          if (this.mode !== ARRAY) return this.parseError(token, value);
          this.pop();
        } else if (this.state === KEY) if (token === STRING) this.key = value, this.state = COLON; else {
          if (token !== RIGHT_BRACE) return this.parseError(token, value);
          this.pop();
        } else if (this.state === COLON) {
          if (token !== COLON) return this.parseError(token, value);
          this.state = VALUE;
        } else {
          if (this.state !== COMMA) return this.parseError(token, value);
          if (token === COMMA) this.mode === ARRAY ? (this.key++, this.state = VALUE) : this.mode === OBJECT && (this.state = KEY); else {
            if (!(token === RIGHT_BRACKET && this.mode === ARRAY || token === RIGHT_BRACE && this.mode === OBJECT)) return this.parseError(token, value);
            this.pop();
          }
        }
      }, Parser.C = C, module.exports = Parser;
    },
    33890: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const BB = __webpack_require__(41142), binLink = __webpack_require__(82503), buildLogicalTree = __webpack_require__(64257), extract = __webpack_require__(340), figgyPudding = __webpack_require__(55212), fs = __webpack_require__(59799), getPrefix = __webpack_require__(81048), lifecycle = __webpack_require__(38175), lockVerify = __webpack_require__(92263), mkdirp = BB.promisify(__webpack_require__(41718)), npa = __webpack_require__(19932), path = __webpack_require__(71017), readPkgJson = BB.promisify(__webpack_require__(92200)), rimraf = BB.promisify(__webpack_require__(68259)), readFileAsync = BB.promisify(fs.readFile), statAsync = BB.promisify(fs.stat), symlinkAsync = BB.promisify(fs.symlink), writeFileAsync = BB.promisify(fs.writeFile), LifecycleOpts = figgyPudding({
        config: {},
        "script-shell": {},
        scriptShell: "script-shell",
        "ignore-scripts": {},
        ignoreScripts: "ignore-scripts",
        "ignore-prepublish": {},
        ignorePrepublish: "ignore-prepublish",
        "scripts-prepend-node-path": {},
        scriptsPrependNodePath: "scripts-prepend-node-path",
        "unsafe-perm": {},
        unsafePerm: "unsafe-perm",
        prefix: {},
        dir: "prefix",
        failOk: {
          default: !1
        }
      }, {
        other: () => !0
      });
      function readJson(jsonPath, name, ignoreMissing) {
        return readFileAsync(path.join(jsonPath, name), "utf8").then((str => JSON.parse(function(str) {
          return str.replace(/^\uFEFF/, "");
        }(str)))).catch({
          code: "ENOENT"
        }, (err => {
          if (!ignoreMissing) throw err;
        }));
      }
      module.exports = class {
        constructor(opts) {
          this.opts = opts, this.startTime = Date.now(), this.runTime = 0, this.timings = {
            scripts: 0
          }, this.pkgCount = 0, this.log = this.opts.log || __webpack_require__(99176), this.pkg = null, 
          this.tree = null, this.failedDeps = new Set;
        }
        timedStage(name) {
          const start = Date.now();
          return BB.resolve(this[name].apply(this, [].slice.call(arguments, 1))).tap((() => {
            this.timings[name] = Date.now() - start, this.log.info(name, `Done in ${this.timings[name] / 1e3}s`);
          }));
        }
        run() {
          return this.timedStage("prepare").then((() => this.timedStage("extractTree", this.tree))).then((() => this.timedStage("updateJson", this.tree))).then((pkgJsons => this.timedStage("buildTree", this.tree, pkgJsons))).then((() => this.timedStage("garbageCollect", this.tree))).then((() => this.timedStage("runScript", "prepublish", this.pkg, this.prefix))).then((() => this.timedStage("runScript", "prepare", this.pkg, this.prefix))).then((() => this.timedStage("teardown"))).then((() => {
            this.runTime = Date.now() - this.startTime, this.log.info("run-scripts", `total script time: ${this.timings.scripts / 1e3}s`), 
            this.log.info("run-time", `total run time: ${this.runTime / 1e3}s`);
          })).catch((err => {
            throw this.timedStage("teardown"), err.message.match(/aggregate error/) ? err[0] : err;
          })).then((() => this));
        }
        prepare() {
          return this.log.info("prepare", "initializing installer"), this.log.level = this.opts.loglevel, 
          this.log.verbose("prepare", "starting workers"), extract.startWorkers(), (this.opts.prefix && this.opts.global || process.argv.some((arg => arg.match(/^\s*--prefix\s*/i))) ? BB.resolve(this.opts.prefix) : getPrefix(process.cwd())).then((prefix => (this.prefix = prefix, 
          this.log.verbose("prepare", "installation prefix: " + prefix), BB.join(readJson(prefix, "package.json"), readJson(prefix, "package-lock.json", !0), readJson(prefix, "npm-shrinkwrap.json", !0), ((pkg, lock, shrink) => {
            shrink ? this.log.verbose("prepare", "using npm-shrinkwrap.json") : lock && this.log.verbose("prepare", "using package-lock.json"), 
            pkg._shrinkwrap = shrink || lock, this.pkg = pkg;
          }))))).then((() => statAsync(path.join(this.prefix, "node_modules")).catch((err => {
            if ("ENOENT" !== err.code) throw err;
          })))).then((stat => (stat && this.log.warn("prepare", "removing existing node_modules/ before installation"), 
          BB.join(this.checkLock(), stat && rimraf(path.join(this.prefix, "node_modules/*")))))).then((() => {
            this.tree = buildLogicalTree(this.pkg, this.pkg._shrinkwrap), this.log.silly("tree", this.tree), 
            this.expectedTotal = 0, this.tree.forEach(((dep, next) => {
              this.expectedTotal++, next();
            }));
          }));
        }
        teardown() {
          return this.log.verbose("teardown", "shutting down workers."), extract.stopWorkers();
        }
        checkLock() {
          this.log.verbose("checkLock", "verifying package-lock data");
          const pkg = this.pkg, prefix = this.prefix;
          return pkg._shrinkwrap && pkg._shrinkwrap.lockfileVersion ? lockVerify(prefix).then((result => {
            if (!result.status) throw new Error("cipm can only install packages when your package.json and package-lock.json or npm-shrinkwrap.json are in sync. Please update your lock file with `npm install` before continuing.\n\n" + result.warnings.map((w => "Warning: " + w)).join("\n") + "\n" + result.errors.join("\n") + "\n");
            result.warnings.forEach((w => this.log.warn("lockfile", w)));
          })).catch((err => {
            throw err;
          })) : BB.reject(new Error("cipm can only install packages with an existing package-lock.json or npm-shrinkwrap.json with lockfileVersion >= 1. Run an install with npm@5 or later to generate it, then try again."));
        }
        extractTree(tree) {
          this.log.verbose("extractTree", "extracting dependencies to node_modules/");
          const cg = this.log.newItem("extractTree", this.expectedTotal);
          return tree.forEachAsync(((dep, next) => {
            if (!this.checkDepEnv(dep)) return;
            const depPath = dep.path(this.prefix), spec = npa.resolve(dep.name, dep.version, this.prefix);
            if (dep.isRoot) return next();
            if ("directory" === spec.type) {
              const relative = path.relative(path.dirname(depPath), spec.fetchSpec);
              return this.log.silly("extractTree", `${dep.name}@${spec.fetchSpec} -> ${depPath} (symlink)`), 
              mkdirp(path.dirname(depPath)).then((() => symlinkAsync(relative, depPath, "junction"))).catch((() => rimraf(depPath).then((() => symlinkAsync(relative, depPath, "junction"))))).then((() => next())).then((() => {
                this.pkgCount++, cg.completeWork(1);
              }));
            }
            return this.log.silly("extractTree", `${dep.name}@${dep.version} -> ${depPath}`), 
            (dep.bundled ? statAsync(path.join(depPath, "package.json")).catch((err => {
              if ("ENOENT" !== err.code) throw err;
            })) : BB.resolve(!1)).then((wasBundled => wasBundled ? (cg.completeWork(1), next()) : BB.resolve(extract.child(dep.name, dep, depPath, this.opts)).then((() => cg.completeWork(1))).then((() => {
              this.pkgCount++;
            })).then(next)));
          }), {
            concurrency: 50,
            Promise: BB
          }).then((() => cg.finish()));
        }
        checkDepEnv(dep) {
          const includeDev = this.opts.dev || !/^prod(uction)?$/.test(this.opts.only) && !this.opts.production || /^dev(elopment)?$/.test(this.opts.only) || /^dev(elopment)?$/.test(this.opts.also), includeProd = !/^dev(elopment)?$/.test(this.opts.only), includeOptional = includeProd && this.opts.optional;
          return dep.dev && includeDev || dep.optional && includeOptional || !dep.dev && !dep.optional && includeProd;
        }
        updateJson(tree) {
          this.log.verbose("updateJson", "updating json deps to include _from");
          const pkgJsons = new Map;
          return tree.forEachAsync(((dep, next) => {
            if (!this.checkDepEnv(dep)) return;
            const spec = npa.resolve(dep.name, dep.version), depPath = dep.path(this.prefix);
            return next().then((() => readJson(depPath, "package.json"))).then((pkg => spec.registry || "directory" === spec.type ? pkg : this.updateFromField(dep, pkg).then((() => pkg)))).then((pkg => pkg.scripts && pkg.scripts.install ? pkg : this.updateInstallScript(dep, pkg).then((() => pkg)))).tap((pkg => {
              pkgJsons.set(dep, pkg);
            }));
          }), {
            concurrency: 100,
            Promise: BB
          }).then((() => pkgJsons));
        }
        buildTree(tree, pkgJsons) {
          return this.log.verbose("buildTree", "finalizing tree and running scripts"), tree.forEachAsync(((dep, next) => {
            if (!this.checkDepEnv(dep)) return;
            const spec = npa.resolve(dep.name, dep.version), depPath = dep.path(this.prefix), pkg = pkgJsons.get(dep);
            return this.log.silly("buildTree", `linking ${spec}`), this.runScript("preinstall", pkg, depPath).then(next).then((() => {
              if (!dep.isRoot && (pkg.bin || pkg.man || pkg.directories && pkg.directories.bin)) return readPkgJson(path.join(depPath, "package.json")).then((pkg => binLink(pkg, depPath, !1, {
                force: this.opts.force,
                ignoreScripts: this.opts["ignore-scripts"],
                log: Object.assign({}, this.log, {
                  info: () => {}
                }),
                name: pkg.name,
                pkgId: pkg.name + "@" + pkg.version,
                prefix: this.prefix,
                prefixes: [ this.prefix ],
                umask: this.opts.umask
              })), (e => {
                this.log.verbose("buildTree", `error linking ${spec}: ${e.message} ${e.stack}`);
              }));
            })).then((() => this.runScript("install", pkg, depPath))).then((() => this.runScript("postinstall", pkg, depPath))).then((() => this)).catch((e => {
              if (!dep.optional) throw e;
              this.failedDeps.add(dep);
            }));
          }), {
            concurrency: 1,
            Promise: BB
          });
        }
        updateFromField(dep, pkg) {
          const depPath = dep.path(this.prefix), depPkgPath = path.join(depPath, "package.json");
          return readJson(dep.requiredBy.values().next().value.path(this.prefix), "package.json").then((ppkg => ppkg.dependencies && ppkg.dependencies[dep.name] || ppkg.devDependencies && ppkg.devDependencies[dep.name] || ppkg.optionalDependencies && ppkg.optionalDependencies[dep.name])).then((from => npa.resolve(dep.name, from))).then((from => {
            pkg._from = from.toString();
          })).then((() => writeFileAsync(depPkgPath, JSON.stringify(pkg, null, 2)))).then((() => pkg));
        }
        updateInstallScript(dep, pkg) {
          const depPath = dep.path(this.prefix);
          return statAsync(path.join(depPath, "binding.gyp")).catch((err => {
            if ("ENOENT" !== err.code) throw err;
          })).then((stat => {
            stat && (pkg.scripts || (pkg.scripts = {}), pkg.scripts.install = "node-gyp rebuild");
          })).then((() => pkg));
        }
        garbageCollect(tree) {
          if (this.failedDeps.size) return function(tree, prefix, liveDeps) {
            const purged = new Set;
            return tree.forEachAsync(((dep, next) => next().then((() => {
              if (!dep.isRoot && !liveDeps.has(dep) && !purged.has(dep)) return purged.add(dep), 
              rimraf(dep.path(prefix));
            }))), {
              concurrency: 50,
              Promise: BB
            }).then((() => purged));
          }(tree, this.prefix, function(tree, failed) {
            const liveDeps = new Set;
            return tree.forEach(((dep, next) => {
              failed.has(dep) || (liveDeps.add(dep), next());
            })), liveDeps;
          }(tree, this.failedDeps)).then((purged => {
            this.purgedDeps = purged, this.pkgCount -= purged.size;
          }));
        }
        runScript(stage, pkg, pkgPath) {
          const start = Date.now();
          return this.opts["ignore-scripts"] ? BB.resolve() : (pkg._id = pkg.name + "@" + pkg.version, 
          BB.resolve(lifecycle(pkg, stage, pkgPath, LifecycleOpts(this.opts).concat({
            config: Object.assign({}, this.opts, {
              log: null,
              dirPacker: null
            }),
            dir: this.prefix
          }))).tap((() => {
            this.timings.scripts += Date.now() - start;
          })));
        }
      }, module.exports._readJson = readJson;
    },
    99176: module => {
      "use strict";
      const noop = Function.prototype;
      module.exports = {
        error: noop,
        warn: noop,
        info: noop,
        verbose: noop,
        silly: noop,
        http: noop,
        pause: noop,
        resume: noop
      };
    },
    87878: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = __webpack_require__(15688);
    },
    27382: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = __webpack_require__(11527);
    },
    67879: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = __webpack_require__(70728);
    },
    11043: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = __webpack_require__(33938);
    },
    4422: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = __webpack_require__(19932);
    },
    44421: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = __webpack_require__(41142).promisify(__webpack_require__(92200));
    },
    44323: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = __webpack_require__(30178);
    },
    37805: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = __webpack_require__(68582).unpublish;
    },
    15688: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const figgyPudding = __webpack_require__(55212), getStream = __webpack_require__(94810), npa = __webpack_require__(19932), npmFetch = __webpack_require__(11527), {PassThrough} = __webpack_require__(12781), validate = __webpack_require__(95073), AccessConfig = figgyPudding({
        Promise: {
          default: () => Promise
        }
      }), eu = encodeURIComponent, npar = spec => {
        if (!(spec = npa(spec)).registry) throw new Error("`spec` must be a registry spec");
        return spec;
      }, cmd = module.exports = {};
      function setAccess(spec, access, opts) {
        return pwrap(opts = AccessConfig(opts), (() => {
          spec = npar(spec), validate("OSO", [ spec, access, opts ]);
          const uri = `/-/package/${eu(spec.name)}/access`;
          return npmFetch(uri, opts.concat({
            method: "POST",
            body: {
              access
            },
            spec
          }));
        })).then((res => res.body.resume() && !0));
      }
      function setRequires2fa(spec, required, opts) {
        return new ((opts = AccessConfig(opts)).Promise)(((resolve, reject) => {
          spec = npar(spec), validate("OBO", [ spec, required, opts ]);
          const uri = `/-/package/${eu(spec.name)}/access`;
          return npmFetch(uri, opts.concat({
            method: "POST",
            body: {
              publish_requires_tfa: required
            },
            spec,
            ignoreBody: !0
          })).then(resolve, reject);
        })).then((() => !0));
      }
      function splitEntity(entity = "") {
        let [, scope, team] = entity.match(/^@?([^:]+)(?::(.*))?$/) || [];
        return {
          scope,
          team
        };
      }
      function pwrap(opts, fn) {
        return new opts.Promise(((resolve, reject) => {
          fn().then(resolve, reject);
        }));
      }
      cmd.public = (spec, opts) => setAccess(spec, "public", opts), cmd.restricted = (spec, opts) => setAccess(spec, "restricted", opts), 
      cmd.grant = (spec, entity, permissions, opts) => pwrap(opts = AccessConfig(opts), (() => {
        spec = npar(spec);
        const {scope, team} = splitEntity(entity);
        if (validate("OSSSO", [ spec, scope, team, permissions, opts ]), "read-write" !== permissions && "read-only" !== permissions) throw new Error("`permissions` must be `read-write` or `read-only`. Got `" + permissions + "` instead");
        const uri = `/-/team/${eu(scope)}/${eu(team)}/package`;
        return npmFetch(uri, opts.concat({
          method: "PUT",
          body: {
            package: spec.name,
            permissions
          },
          scope,
          spec,
          ignoreBody: !0
        }));
      })).then((() => !0)), cmd.revoke = (spec, entity, opts) => pwrap(opts = AccessConfig(opts), (() => {
        spec = npar(spec);
        const {scope, team} = splitEntity(entity);
        validate("OSSO", [ spec, scope, team, opts ]);
        const uri = `/-/team/${eu(scope)}/${eu(team)}/package`;
        return npmFetch(uri, opts.concat({
          method: "DELETE",
          body: {
            package: spec.name
          },
          scope,
          spec,
          ignoreBody: !0
        }));
      })).then((() => !0)), cmd.lsPackages = (entity, opts) => pwrap(opts = AccessConfig(opts), (() => getStream.array(cmd.lsPackages.stream(entity, opts)).then((data => data.reduce(((acc, [key, val]) => (acc || (acc = {}), 
      acc[key] = val, acc)), null))))), cmd.lsPackages.stream = (entity, opts) => {
        validate("SO|SZ", [ entity, opts ]), opts = AccessConfig(opts);
        const {scope, team} = splitEntity(entity);
        let uri;
        uri = team ? `/-/team/${eu(scope)}/${eu(team)}/package` : `/-/org/${eu(scope)}/package`, 
        opts = opts.concat({
          query: {
            format: "cli"
          },
          mapJson: (value, [key]) => "read" === value ? [ key, "read-only" ] : "write" === value ? [ key, "read-write" ] : [ key, value ]
        });
        const ret = new PassThrough({
          objectMode: !0
        });
        return npmFetch.json.stream(uri, "*", opts).on("error", (err => {
          "E404" !== err.code || team ? ret.emit("error", err) : (uri = `/-/user/${eu(scope)}/package`, 
          npmFetch.json.stream(uri, "*", opts).on("error", (err => ret.emit("error", err))).pipe(ret));
        })).pipe(ret), ret;
      }, cmd.lsCollaborators = (spec, user, opts) => ("object" != typeof user || opts || (opts = user, 
      user = void 0), pwrap(opts = AccessConfig(opts), (() => getStream.array(cmd.lsCollaborators.stream(spec, user, opts)).then((data => data.reduce(((acc, [key, val]) => (acc || (acc = {}), 
      acc[key] = val, acc)), null)))))), cmd.lsCollaborators.stream = (spec, user, opts) => {
        "object" != typeof user || opts || (opts = user, user = void 0), opts = AccessConfig(opts), 
        spec = npar(spec), validate("OSO|OZO", [ spec, user, opts ]);
        const uri = `/-/package/${eu(spec.name)}/collaborators`;
        return npmFetch.json.stream(uri, "*", opts.concat({
          query: {
            format: "cli",
            user: user || void 0
          },
          mapJson: (value, [key]) => "read" === value ? [ key, "read-only" ] : "write" === value ? [ key, "read-write" ] : [ key, value ]
        }));
      }, cmd.tfaRequired = (spec, opts) => setRequires2fa(spec, !0, opts), cmd.tfaNotRequired = (spec, opts) => setRequires2fa(spec, !1, opts), 
      cmd.edit = () => {
        throw new Error("Not implemented yet");
      };
    },
    70728: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const fetch = __webpack_require__(11527), figgyPudding = __webpack_require__(55212), getStream = __webpack_require__(94810), validate = __webpack_require__(95073), HooksConfig = figgyPudding({
        package: {},
        limit: {},
        offset: {},
        Promise: {
          default: () => Promise
        }
      }), eu = encodeURIComponent, cmd = module.exports = {};
      cmd.add = (name, endpoint, secret, opts) => {
        opts = HooksConfig(opts), validate("SSSO", [ name, endpoint, secret, opts ]);
        let type = "package";
        return name.match(/^@[^/]+$/) && (type = "scope"), "~" === name[0] && (type = "owner", 
        name = name.substr(1)), fetch.json("/-/npm/v1/hooks/hook", opts.concat({
          method: "POST",
          body: {
            type,
            name,
            endpoint,
            secret
          }
        }));
      }, cmd.rm = (id, opts) => (opts = HooksConfig(opts), validate("SO", [ id, opts ]), 
      fetch.json(`/-/npm/v1/hooks/hook/${eu(id)}`, opts.concat({
        method: "DELETE"
      }, opts)).catch((err => {
        if ("E404" === err.code) return null;
        throw err;
      }))), cmd.update = (id, endpoint, secret, opts) => (opts = HooksConfig(opts), validate("SSSO", [ id, endpoint, secret, opts ]), 
      fetch.json(`/-/npm/v1/hooks/hook/${eu(id)}`, opts.concat({
        method: "PUT",
        body: {
          endpoint,
          secret
        }
      }, opts))), cmd.find = (id, opts) => (opts = HooksConfig(opts), validate("SO", [ id, opts ]), 
      fetch.json(`/-/npm/v1/hooks/hook/${eu(id)}`, opts)), cmd.ls = opts => getStream.array(cmd.ls.stream(opts)), 
      cmd.ls.stream = opts => {
        opts = HooksConfig(opts);
        const {package: pkg, limit, offset} = opts;
        return validate("S|Z", [ pkg ]), validate("N|Z", [ limit ]), validate("N|Z", [ offset ]), 
        fetch.json.stream("/-/npm/v1/hooks", "objects.*", opts.concat({
          query: {
            package: pkg,
            limit,
            offset
          }
        }));
      };
    },
    33938: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const eu = encodeURIComponent, fetch = __webpack_require__(11527), figgyPudding = __webpack_require__(55212), getStream = __webpack_require__(94810), validate = __webpack_require__(95073), OrgConfig = figgyPudding({
        Promise: {
          default: () => Promise
        }
      }), cmd = module.exports = {};
      class MembershipDetail {}
      cmd.set = (org, user, role, opts) => ("object" != typeof role || opts || (opts = role, 
      role = void 0), new ((opts = OrgConfig(opts)).Promise)(((resolve, reject) => {
        validate("SSSO|SSZO", [ org, user, role, opts ]), user = user.replace(/^@?/, ""), 
        org = org.replace(/^@?/, ""), fetch.json(`/-/org/${eu(org)}/user`, opts.concat({
          method: "PUT",
          body: {
            user,
            role
          }
        })).then(resolve, reject);
      })).then((ret => Object.assign(new MembershipDetail, ret)))), cmd.rm = (org, user, opts) => new ((opts = OrgConfig(opts)).Promise)(((resolve, reject) => {
        validate("SSO", [ org, user, opts ]), user = user.replace(/^@?/, ""), org = org.replace(/^@?/, ""), 
        fetch(`/-/org/${eu(org)}/user`, opts.concat({
          method: "DELETE",
          body: {
            user
          },
          ignoreBody: !0
        })).then(resolve, reject);
      })).then((() => null));
      class Roster {}
      cmd.ls = (org, opts) => new ((opts = OrgConfig(opts)).Promise)(((resolve, reject) => {
        getStream.array(cmd.ls.stream(org, opts)).then((entries => {
          const obj = {};
          for (let [key, val] of entries) obj[key] = val;
          return obj;
        })).then(resolve, reject);
      })).then((ret => Object.assign(new Roster, ret))), cmd.ls.stream = (org, opts) => (opts = OrgConfig(opts), 
      validate("SO", [ org, opts ]), org = org.replace(/^@?/, ""), fetch.json.stream(`/-/org/${eu(org)}/user`, "*", opts.concat({
        mapJson: (value, [key]) => [ key, value ]
      })));
    },
    68582: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = {
        publish: __webpack_require__(33814),
        unpublish: __webpack_require__(35197)
      };
    },
    33814: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const cloneDeep = __webpack_require__(1259), figgyPudding = __webpack_require__(55212), {fixer} = __webpack_require__(17770), getStream = __webpack_require__(94810), npa = __webpack_require__(19932), npmAuth = __webpack_require__(59505), npmFetch = __webpack_require__(11527), semver = __webpack_require__(73107), ssri = __webpack_require__(87783), url = __webpack_require__(57310), validate = __webpack_require__(95073), PublishConfig = figgyPudding({
        access: {},
        algorithms: {
          default: [ "sha512" ]
        },
        npmVersion: {},
        tag: {
          default: "latest"
        },
        Promise: {
          default: () => Promise
        }
      });
      module.exports = function(manifest, tarball, opts) {
        return new ((opts = PublishConfig(opts)).Promise)((resolve => resolve())).then((() => {
          if (validate("OSO|OOO", [ manifest, tarball, opts ]), manifest.private) throw Object.assign(new Error("This package has been marked as private\nRemove the 'private' field from the package.json to publish it."), {
            code: "EPRIVATE"
          });
          const spec = npa.resolve(manifest.name, manifest.version);
          opts = opts.concat(manifest.publishConfig, {
            spec
          });
          const reg = npmFetch.pickRegistry(spec, opts), auth = npmAuth(reg, opts), pubManifest = function(spec, auth, base, opts) {
            const manifest = cloneDeep(base);
            manifest._nodeVersion = process.versions.node, opts.npmVersion && (manifest._npmVersion = opts.npmVersion);
            (auth.username || auth.email) && (manifest._npmUser = {
              name: auth.username,
              email: auth.email
            });
            fixer.fixNameField(manifest, {
              strict: !0,
              allowLegacyCase: !0
            });
            const version = semver.clean(manifest.version);
            if (!version) throw Object.assign(new Error("invalid semver: " + manifest.version), {
              code: "EBADSEMVER"
            });
            return manifest.version = version, manifest;
          }(0, auth, manifest, opts);
          if (!spec.scope && "restricted" === opts.access) throw Object.assign(new Error("Can't restrict access to unscoped packages."), {
            code: "EUNSCOPED"
          });
          return function(tarSrc, opts) {
            return Buffer.isBuffer(tarSrc) ? opts.Promise.resolve(tarSrc) : "string" == typeof tarSrc ? opts.Promise.resolve(Buffer.from(tarSrc, "base64")) : "function" == typeof tarSrc.pipe ? getStream.buffer(tarSrc) : opts.Promise.reject(Object.assign(new Error("invalid tarball argument. Must be a Buffer, a base64 string, or a binary stream"), {
              code: "EBADTAR"
            }));
          }(tarball, opts).then((tardata => {
            const metadata = function(spec, auth, registry, manifest, tardata, opts) {
              const root = {
                _id: manifest.name,
                name: manifest.name,
                description: manifest.description,
                "dist-tags": {},
                versions: {},
                readme: manifest.readme || ""
              };
              opts.access && (root.access = opts.access);
              auth.token || (root.maintainers = [ {
                name: auth.username,
                email: auth.email
              } ], manifest.maintainers = JSON.parse(JSON.stringify(root.maintainers)));
              root.versions[manifest.version] = manifest;
              const tag = manifest.tag || opts.tag;
              root["dist-tags"][tag] = manifest.version;
              const tbName = manifest.name + "-" + manifest.version + ".tgz", tbURI = manifest.name + "/-/" + tbName, integrity = ssri.fromData(tardata, {
                algorithms: [ ...new Set([ "sha1" ].concat(opts.algorithms)) ]
              });
              return manifest._id = manifest.name + "@" + manifest.version, manifest.dist = manifest.dist || {}, 
              manifest.dist.integrity = integrity.sha512[0].toString(), manifest.dist.shasum = integrity.sha1[0].hexDigest(), 
              manifest.dist.tarball = url.resolve(registry, tbURI).replace(/^https:\/\//, "http://"), 
              root._attachments = {}, root._attachments[tbName] = {
                content_type: "application/octet-stream",
                data: tardata.toString("base64"),
                length: tardata.length
              }, root;
            }(0, auth, reg, pubManifest, tardata, opts);
            return npmFetch(spec.escapedName, opts.concat({
              method: "PUT",
              body: metadata,
              ignoreBody: !0
            })).catch((err => {
              if ("E409" !== err.code) throw err;
              return npmFetch.json(spec.escapedName, opts.concat({
                query: {
                  write: !0
                }
              })).then((current => function(current, newData, opts) {
                const curVers = Object.keys(current.versions || {}).map((v => semver.clean(v, !0))).concat(Object.keys(current.time || {}).map((v => {
                  if (semver.valid(v, !0)) return semver.clean(v, !0);
                }))).filter((v => v)), newVersion = Object.keys(newData.versions)[0];
                if (-1 !== curVers.indexOf(newVersion)) throw pkgid = newData.name, version = newData.version, 
                Object.assign(new Error(`Cannot publish ${pkgid}@${version} over existing version.`), {
                  code: "EPUBLISHCONFLICT",
                  pkgid,
                  version
                });
                var pkgid, version;
                for (var i in current.versions = current.versions || {}, current.versions[newVersion] = newData.versions[newVersion], 
                newData) switch (i) {
                 case "dist-tags":
                 case "versions":
                 case "_attachments":
                  for (var j in newData[i]) current[i] = current[i] || {}, current[i][j] = newData[i][j];
                  break;

                 case "maintainers":
                  break;

                 default:
                  current[i] = newData[i];
                }
                const maint = newData.maintainers && JSON.parse(JSON.stringify(newData.maintainers));
                return newData.versions[newVersion].maintainers = maint, current;
              }(current, metadata))).then((newMetadata => npmFetch(spec.escapedName, opts.concat({
                method: "PUT",
                body: newMetadata,
                ignoreBody: !0
              }))));
            }));
          }));
        })).then((() => !0));
      };
    },
    35197: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const figgyPudding = __webpack_require__(55212), npa = __webpack_require__(19932), npmFetch = __webpack_require__(11527), semver = __webpack_require__(73107), url = __webpack_require__(57310), UnpublishConfig = figgyPudding({
        force: {
          default: !1
        },
        Promise: {
          default: () => Promise
        }
      });
      module.exports = function(spec, opts) {
        return new ((opts = UnpublishConfig(opts)).Promise)((resolve => resolve())).then((() => {
          spec = npa(spec), opts = opts.concat({
            spec
          });
          const pkgUri = spec.escapedName;
          return npmFetch.json(pkgUri, opts.concat({
            query: {
              write: !0
            }
          })).then((pkg => {
            if (!spec.rawSpec || "*" === spec.rawSpec) return npmFetch(`${pkgUri}/-rev/${pkg._rev}`, opts.concat({
              method: "DELETE",
              ignoreBody: !0
            }));
            {
              const version = spec.rawSpec, allVersions = pkg.versions || {}, versionPublic = allVersions[version];
              let dist;
              if (versionPublic && (dist = allVersions[version].dist), delete allVersions[version], 
              !Object.keys(allVersions).length) return npmFetch(`${pkgUri}/-rev/${pkg._rev}`, opts.concat({
                method: "DELETE",
                ignoreBody: !0
              }));
              if (versionPublic) {
                const latestVer = pkg["dist-tags"].latest;
                return Object.keys(pkg["dist-tags"]).forEach((tag => {
                  pkg["dist-tags"][tag] === version && delete pkg["dist-tags"][tag];
                })), latestVer === version && (pkg["dist-tags"].latest = Object.keys(allVersions).sort(semver.compareLoose).pop()), 
                delete pkg._revisions, delete pkg._attachments, npmFetch(`${pkgUri}/-rev/${pkg._rev}`, opts.concat({
                  method: "PUT",
                  body: pkg,
                  ignoreBody: !0
                })).then((() => npmFetch.json(pkgUri, opts.concat({
                  query: {
                    write: !0
                  }
                })).then((({_rev, _id}) => {
                  const tarballUrl = url.parse(dist.tarball).pathname.substr(1);
                  return npmFetch(`${tarballUrl}/-rev/${_rev}`, opts.concat({
                    method: "DELETE",
                    ignoreBody: !0
                  }));
                }))));
              }
            }
          }), (err => {
            if ("E404" !== err.code) throw err;
          }));
        })).then((() => !0));
      };
    },
    30178: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const figgyPudding = __webpack_require__(55212), getStream = __webpack_require__(94810), npmFetch = __webpack_require__(11527), SearchOpts = figgyPudding({
        detailed: {
          default: !1
        },
        limit: {
          default: 20
        },
        from: {
          default: 0
        },
        quality: {
          default: .65
        },
        popularity: {
          default: .98
        },
        maintenance: {
          default: .5
        },
        sortBy: {}
      });
      function search(query, opts) {
        return getStream.array(search.stream(query, opts));
      }
      module.exports = search, search.stream = function(query, opts) {
        switch ((opts = SearchOpts(opts)).sortBy) {
         case "optimal":
          opts = opts.concat({
            quality: .65,
            popularity: .98,
            maintenance: .5
          });
          break;

         case "quality":
          opts = opts.concat({
            quality: 1,
            popularity: 0,
            maintenance: 0
          });
          break;

         case "popularity":
          opts = opts.concat({
            quality: 0,
            popularity: 1,
            maintenance: 0
          });
          break;

         case "maintenance":
          opts = opts.concat({
            quality: 0,
            popularity: 0,
            maintenance: 1
          });
        }
        return npmFetch.json.stream("/-/v1/search", "objects.*", opts.concat({
          query: {
            text: Array.isArray(query) ? query.join(" ") : query,
            size: opts.limit,
            from: opts.from,
            quality: opts.quality,
            popularity: opts.popularity,
            maintenance: opts.maintenance
          },
          mapJson: obj => (obj.package.date && (obj.package.date = new Date(obj.package.date)), 
          opts.detailed ? obj : obj.package)
        }));
      };
    },
    34053: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const eu = encodeURIComponent, figgyPudding = __webpack_require__(55212), getStream = __webpack_require__(94810), npmFetch = __webpack_require__(11527), validate = __webpack_require__(95073), TeamConfig = figgyPudding({
        description: {},
        Promise: {
          default: () => Promise
        }
      }), cmd = module.exports = {};
      function splitEntity(entity = "") {
        let [, scope, team] = entity.match(/^@?([^:]+):(.*)$/) || [];
        return {
          scope,
          team
        };
      }
      function pwrap(opts, fn) {
        return new opts.Promise(((resolve, reject) => {
          fn().then(resolve, reject);
        }));
      }
      cmd.create = (entity, opts) => pwrap(opts = TeamConfig(opts), (() => {
        const {scope, team} = splitEntity(entity);
        return validate("SSO", [ scope, team, opts ]), npmFetch.json(`/-/org/${eu(scope)}/team`, opts.concat({
          method: "PUT",
          scope,
          body: {
            name: team,
            description: opts.description
          }
        }));
      })), cmd.destroy = (entity, opts) => pwrap(opts = TeamConfig(opts), (() => {
        const {scope, team} = splitEntity(entity);
        return validate("SSO", [ scope, team, opts ]), npmFetch.json(`/-/team/${eu(scope)}/${eu(team)}`, opts.concat({
          method: "DELETE",
          scope
        }));
      })), cmd.add = (user, entity, opts) => pwrap(opts = TeamConfig(opts), (() => {
        const {scope, team} = splitEntity(entity);
        return validate("SSO", [ scope, team, opts ]), npmFetch.json(`/-/team/${eu(scope)}/${eu(team)}/user`, opts.concat({
          method: "PUT",
          scope,
          body: {
            user
          }
        }));
      })), cmd.rm = (user, entity, opts) => pwrap(opts = TeamConfig(opts), (() => {
        const {scope, team} = splitEntity(entity);
        return validate("SSO", [ scope, team, opts ]), npmFetch.json(`/-/team/${eu(scope)}/${eu(team)}/user`, opts.concat({
          method: "DELETE",
          scope,
          body: {
            user
          }
        }));
      })), cmd.lsTeams = (scope, opts) => pwrap(opts = TeamConfig(opts), (() => getStream.array(cmd.lsTeams.stream(scope, opts)))), 
      cmd.lsTeams.stream = (scope, opts) => (opts = TeamConfig(opts), validate("SO", [ scope, opts ]), 
      npmFetch.json.stream(`/-/org/${eu(scope)}/team`, ".*", opts.concat({
        query: {
          format: "cli"
        }
      }))), cmd.lsUsers = (entity, opts) => pwrap(opts = TeamConfig(opts), (() => getStream.array(cmd.lsUsers.stream(entity, opts)))), 
      cmd.lsUsers.stream = (entity, opts) => {
        opts = TeamConfig(opts);
        const {scope, team} = splitEntity(entity);
        validate("SSO", [ scope, team, opts ]);
        const uri = `/-/team/${eu(scope)}/${eu(team)}/user`;
        return npmFetch.json.stream(uri, ".*", opts.concat({
          query: {
            format: "cli"
          }
        }));
      }, cmd.edit = () => {
        throw new Error("edit is not implemented yet");
      };
    },
    92263: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = function(check) {
        check || (check = ".");
        const pjson = readJson(`${check}/package.json`);
        let plock = readJson(`${check}/npm-shrinkwrap.json`).catch((() => readJson(`${check}/package-lock.json`)));
        return Promise.all([ pjson, plock ]).then((result => {
          const pjson = result[0], plock = result[1];
          let warnings = [], errors = [];
          for (let type of [ [ "dependencies" ], [ "devDependencies" ], [ "optionalDependencies", !0 ] ]) {
            const deps = pjson[type[0]];
            if (!deps) continue;
            const isOptional = type[1];
            Object.keys(deps).forEach((name => {
              const spec = npa.resolve(name, deps[name]), lock = plock.dependencies[name];
              if (lock) if (spec.registry) {
                if ("tag" === spec.type) return;
                if ("alias" === spec.type) {
                  const lockSpec = npa.resolve(name, lock.version);
                  if (!semver.satisfies(lockSpec.subSpec.fetchSpec, spec.subSpec.fetchSpec)) return void errors.push("Invalid: lock file's " + name + "@" + lock.version + " does not satisfy " + name + "@" + spec.rawSpec);
                } else if (!semver.satisfies(lock.version, spec.fetchSpec)) return void errors.push("Invalid: lock file's " + name + "@" + lock.version + " does not satisfy " + name + "@" + spec.fetchSpec);
              } else {
                if ("git" === spec.type) return;
                if ("remote" === spec.type) {
                  if (lock.version !== spec.fetchSpec) return void errors.push("Invalid: lock file's " + name + "@" + lock.version + " does not satisfy " + name + "@" + spec.fetchSpec);
                } else if ("file" === spec.type || "directory" === spec.type) {
                  const lockSpec = npa.resolve(name, lock.version);
                  if (spec.fetchSpec !== lockSpec.fetchSpec) return void errors.push("Invalid: lock file's " + name + "@" + lock.version + " does not satisfy " + name + "@" + deps[name]);
                } else console.log(spec);
              } else isOptional ? warnings.push("Optional missing: " + name + "@" + deps[name]) : errors.push("Missing: " + name + "@" + deps[name]);
            }));
          }
          return Promise.resolve({
            status: 0 === errors.length,
            warnings,
            errors
          });
        }));
      };
      const fs = __webpack_require__(57147), npa = (__webpack_require__(71017), __webpack_require__(19932)), semver = __webpack_require__(73107);
      function readJson(file) {
        return new Promise(((resolve, reject) => {
          fs.readFile(file, ((err, content) => err ? reject(err) : resolve(JSON.parse(content))));
        }));
      }
    },
    84174: (__unused_webpack_module, exports, __webpack_require__) => {
      var fs = __webpack_require__(57147), wx = "wx";
      if (process.version.match(/^v0\.[0-6]/)) {
        var c = __webpack_require__(22057);
        wx = c.O_TRUNC | c.O_CREAT | c.O_WRONLY | c.O_EXCL;
      }
      var debug, os = __webpack_require__(22037);
      exports.filetime = "ctime", "win32" == os.platform() && (exports.filetime = "mtime");
      var util = __webpack_require__(73837);
      debug = util.debuglog ? util.debuglog("LOCKFILE") : /\blockfile\b/i.test(process.env.NODE_DEBUG) ? function() {
        var msg = util.format.apply(util, arguments);
        console.error("LOCKFILE %d %s", process.pid, msg);
      } : function() {};
      var locks = {};
      __webpack_require__(20459)((function() {
        debug("exit listener"), Object.keys(locks).forEach(exports.unlockSync);
      })), /^v0\.[0-8]\./.test(process.version) && (debug("uncaughtException, version = %s", process.version), 
      process.on("uncaughtException", (function H(er) {
        if (debug("uncaughtException"), !process.listeners("uncaughtException").filter((function(h) {
          return h !== H;
        })).length) {
          try {
            Object.keys(locks).forEach(exports.unlockSync);
          } catch (e) {}
          throw process.removeListener("uncaughtException", H), er;
        }
      }))), exports.unlock = function(path, cb) {
        debug("unlock", path), delete locks[path], fs.unlink(path, (function(unlinkEr) {
          cb && cb();
        }));
      }, exports.unlockSync = function(path) {
        debug("unlockSync", path);
        try {
          fs.unlinkSync(path);
        } catch (er) {}
        delete locks[path];
      }, exports.check = function(path, opts, cb) {
        "function" == typeof opts && (cb = opts, opts = {}), debug("check", path, opts), 
        fs.open(path, "r", (function(er, fd) {
          return er ? "ENOENT" !== er.code ? cb(er) : cb(null, !1) : opts.stale ? void fs.fstat(fd, (function(er, st) {
            if (er) return fs.close(fd, (function(er2) {
              return cb(er);
            }));
            fs.close(fd, (function(er) {
              var age = Date.now() - st[exports.filetime].getTime();
              return cb(er, age <= opts.stale);
            }));
          })) : fs.close(fd, (function(er) {
            return cb(er, !0);
          }));
        }));
      }, exports.checkSync = function(path, opts) {
        if (debug("checkSync", path, opts = opts || {}), opts.wait) throw new Error("opts.wait not supported sync for obvious reasons");
        try {
          var fd = fs.openSync(path, "r");
        } catch (er) {
          if ("ENOENT" !== er.code) throw er;
          return !1;
        }
        if (!opts.stale) {
          try {
            fs.closeSync(fd);
          } catch (er) {}
          return !0;
        }
        if (opts.stale) {
          try {
            var st = fs.fstatSync(fd);
          } finally {
            fs.closeSync(fd);
          }
          return Date.now() - st[exports.filetime].getTime() <= opts.stale;
        }
      };
      var req = 1;
      function maybeStale(originalEr, path, opts, hasStaleLock, cb) {
        fs.stat(path, (function(statEr, st) {
          return statEr ? "ENOENT" === statEr.code ? (opts.stale = !1, debug("lock stale enoent retry", path, opts), 
          void exports.lock(path, opts, cb)) : cb(statEr) : Date.now() - st[exports.filetime].getTime() <= opts.stale ? notStale(originalEr, path, opts, cb) : (debug("lock stale", path, opts), 
          void (hasStaleLock ? exports.unlock(path, (function(er) {
            if (er) return cb(er);
            debug("lock stale retry", path, opts), fs.link(path + ".STALE", path, (function(er) {
              fs.unlink(path + ".STALE", (function() {
                cb(er);
              }));
            }));
          })) : (debug("acquire .STALE file lock", opts), exports.lock(path + ".STALE", opts, (function(er) {
            if (er) return cb(er);
            maybeStale(originalEr, path, opts, !0, cb);
          })))));
        }));
      }
      function notStale(er, path, opts, cb) {
        if (debug("notStale", path, opts), "number" != typeof opts.wait || opts.wait <= 0) return debug("notStale, wait is not a number"), 
        cb(er);
        var now = Date.now(), start = opts.start || now, end = start + opts.wait;
        if (end <= now) return cb(er);
        debug("now=%d, wait until %d (delta=%d)", start, end, end - start);
        var wait = Math.min(end - start, opts.pollPeriod || 100);
        setTimeout((function() {
          debug("notStale, polling", path, opts), exports.lock(path, opts, cb);
        }), wait);
      }
      function retryThrow(path, opts, er) {
        if ("number" == typeof opts.retries && opts.retries > 0) {
          var newRT = opts.retries - 1;
          return debug("retryThrow", path, opts, newRT), opts.retries = newRT, exports.lockSync(path, opts);
        }
        throw er;
      }
      exports.lock = function(path, opts, cb) {
        if ("function" == typeof opts && (cb = opts, opts = {}), opts.req = opts.req || req++, 
        debug("lock", path, opts), opts.start = opts.start || Date.now(), "number" == typeof opts.retries && opts.retries > 0) {
          debug("has retries", opts.retries);
          var retries = opts.retries;
          opts.retries = 0, orig = cb, cb = function cb(er, fd) {
            if (debug("retry-mutated callback"), retries -= 1, !er || retries < 0) return orig(er, fd);
            function retry() {
              opts.start = Date.now(), debug("retrying", opts.start), exports.lock(path, opts, cb);
            }
            debug("lock retry", path, opts), opts.retryWait ? setTimeout(retry, opts.retryWait) : retry();
          };
        }
        var orig;
        fs.open(path, wx, (function(er, fd) {
          return er ? (debug("failed to acquire lock", er), "EEXIST" !== er.code ? (debug("not EEXIST error", er), 
          cb(er)) : opts.stale ? maybeStale(er, path, opts, !1, cb) : notStale(er, path, opts, cb)) : (debug("locked", path, fd), 
          locks[path] = fd, fs.close(fd, (function() {
            return cb();
          })));
        })), debug("lock return");
      }, exports.lockSync = function(path, opts) {
        if ((opts = opts || {}).req = opts.req || req++, debug("lockSync", path, opts), 
        opts.wait || opts.retryWait) throw new Error("opts.wait not supported sync for obvious reasons");
        try {
          var fd = fs.openSync(path, wx);
          locks[path] = fd;
          try {
            fs.closeSync(fd);
          } catch (er) {}
          return void debug("locked sync!", path, fd);
        } catch (er) {
          if ("EEXIST" !== er.code) return retryThrow(path, opts, er);
          if (opts.stale) {
            var ct = fs.statSync(path)[exports.filetime].getTime();
            !(ct % 1e3) && opts.stale % 1e3 && (opts.stale = 1e3 * Math.ceil(opts.stale / 1e3));
            var age = Date.now() - ct;
            if (age > opts.stale) return debug("lockSync stale", path, opts, age), exports.unlockSync(path), 
            exports.lockSync(path, opts);
          }
          return debug("failed to lock", path, opts, er), retryThrow(path, opts, er);
        }
      };
    },
    1259: (module, exports, __webpack_require__) => {
      module = __webpack_require__.nmd(module);
      var argsTag = "[object Arguments]", boolTag = "[object Boolean]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", setTag = "[object Set]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", reFlags = /\w*$/, reIsHostCtor = /^\[object .+?Constructor\]$/, reIsUint = /^(?:0|[1-9]\d*)$/, cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags["[object Array]"] = cloneableTags["[object ArrayBuffer]"] = cloneableTags["[object DataView]"] = cloneableTags["[object Boolean]"] = cloneableTags["[object Date]"] = cloneableTags["[object Float32Array]"] = cloneableTags["[object Float64Array]"] = cloneableTags["[object Int8Array]"] = cloneableTags["[object Int16Array]"] = cloneableTags["[object Int32Array]"] = cloneableTags[mapTag] = cloneableTags["[object Number]"] = cloneableTags["[object Object]"] = cloneableTags["[object RegExp]"] = cloneableTags[setTag] = cloneableTags["[object String]"] = cloneableTags["[object Symbol]"] = cloneableTags["[object Uint8Array]"] = cloneableTags["[object Uint8ClampedArray]"] = cloneableTags["[object Uint16Array]"] = cloneableTags["[object Uint32Array]"] = !0, 
      cloneableTags["[object Error]"] = cloneableTags[funcTag] = cloneableTags["[object WeakMap]"] = !1;
      var freeGlobal = "object" == typeof global && global && global.Object === Object && global, freeSelf = "object" == typeof self && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), freeExports = exports && !exports.nodeType && exports, freeModule = freeExports && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports;
      function addMapEntry(map, pair) {
        return map.set(pair[0], pair[1]), map;
      }
      function addSetEntry(set, value) {
        return set.add(value), set;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array ? array.length : 0;
        for (initAccum && length && (accumulator = array[++index]); ++index < length; ) accumulator = iteratee(accumulator, array[index], index, array);
        return accumulator;
      }
      function isHostObject(value) {
        var result = !1;
        if (null != value && "function" != typeof value.toString) try {
          result = !!(value + "");
        } catch (e) {}
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        return map.forEach((function(value, key) {
          result[++index] = [ key, value ];
        })), result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        return set.forEach((function(value) {
          result[++index] = value;
        })), result;
      }
      var uid, arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype, coreJsData = root["__core-js_shared__"], maskSrcKey = (uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "")) ? "Symbol(src)_1." + uid : "", funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, objectToString = objectProto.toString, reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Buffer = moduleExports ? root.Buffer : void 0, Symbol = root.Symbol, Uint8Array = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object), DataView = getNative(root, "DataView"), Map = getNative(root, "Map"), Promise = getNative(root, "Promise"), Set = getNative(root, "Set"), WeakMap = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create"), dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap), symbolProto = Symbol ? Symbol.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function Hash(entries) {
        var index = -1, length = entries ? entries.length : 0;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function ListCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function MapCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function Stack(entries) {
        this.__data__ = new ListCache(entries);
      }
      function arrayLikeKeys(value, inherited) {
        var result = isArray(value) || function(value) {
          return function(value) {
            return function(value) {
              return !!value && "object" == typeof value;
            }(value) && isArrayLike(value);
          }(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
        }(value) ? function(n, iteratee) {
          for (var index = -1, result = Array(n); ++index < n; ) result[index] = iteratee(index);
          return result;
        }(value.length, String) : [], length = result.length, skipIndexes = !!length;
        for (var key in value) !inherited && !hasOwnProperty.call(value, key) || skipIndexes && ("length" == key || isIndex(key, length)) || result.push(key);
        return result;
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        hasOwnProperty.call(object, key) && eq(objValue, value) && (void 0 !== value || key in object) || (object[key] = value);
      }
      function assocIndexOf(array, key) {
        for (var length = array.length; length--; ) if (eq(array[length][0], key)) return length;
        return -1;
      }
      function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
        var result;
        if (customizer && (result = object ? customizer(value, key, object, stack) : customizer(value)), 
        void 0 !== result) return result;
        if (!isObject(value)) return value;
        var isArr = isArray(value);
        if (isArr) {
          if (result = function(array) {
            var length = array.length, result = array.constructor(length);
            length && "string" == typeof array[0] && hasOwnProperty.call(array, "index") && (result.index = array.index, 
            result.input = array.input);
            return result;
          }(value), !isDeep) return function(source, array) {
            var index = -1, length = source.length;
            array || (array = Array(length));
            for (;++index < length; ) array[index] = source[index];
            return array;
          }(value, result);
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) return function(buffer, isDeep) {
            if (isDeep) return buffer.slice();
            var result = new buffer.constructor(buffer.length);
            return buffer.copy(result), result;
          }(value, isDeep);
          if ("[object Object]" == tag || tag == argsTag || isFunc && !object) {
            if (isHostObject(value)) return object ? value : {};
            if (result = function(object) {
              return "function" != typeof object.constructor || isPrototype(object) ? {} : (proto = getPrototype(object), 
              isObject(proto) ? objectCreate(proto) : {});
              var proto;
            }(isFunc ? {} : value), !isDeep) return function(source, object) {
              return copyObject(source, getSymbols(source), object);
            }(value, function(object, source) {
              return object && copyObject(source, keys(source), object);
            }(result, value));
          } else {
            if (!cloneableTags[tag]) return object ? value : {};
            result = function(object, tag, cloneFunc, isDeep) {
              var Ctor = object.constructor;
              switch (tag) {
               case "[object ArrayBuffer]":
                return cloneArrayBuffer(object);

               case boolTag:
               case "[object Date]":
                return new Ctor(+object);

               case dataViewTag:
                return function(dataView, isDeep) {
                  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
                }(object, isDeep);

               case float32Tag:
               case float64Tag:
               case int8Tag:
               case int16Tag:
               case int32Tag:
               case uint8Tag:
               case "[object Uint8ClampedArray]":
               case uint16Tag:
               case uint32Tag:
                return function(typedArray, isDeep) {
                  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
                }(object, isDeep);

               case mapTag:
                return function(map, isDeep, cloneFunc) {
                  return arrayReduce(isDeep ? cloneFunc(mapToArray(map), !0) : mapToArray(map), addMapEntry, new map.constructor);
                }(object, isDeep, cloneFunc);

               case "[object Number]":
               case "[object String]":
                return new Ctor(object);

               case "[object RegExp]":
                return function(regexp) {
                  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                  return result.lastIndex = regexp.lastIndex, result;
                }(object);

               case setTag:
                return function(set, isDeep, cloneFunc) {
                  return arrayReduce(isDeep ? cloneFunc(setToArray(set), !0) : setToArray(set), addSetEntry, new set.constructor);
                }(object, isDeep, cloneFunc);

               case "[object Symbol]":
                return symbol = object, symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
              }
              var symbol;
            }(value, tag, baseClone, isDeep);
          }
        }
        stack || (stack = new Stack);
        var stacked = stack.get(value);
        if (stacked) return stacked;
        if (stack.set(value, result), !isArr) var props = isFull ? function(object) {
          return function(object, keysFunc, symbolsFunc) {
            var result = keysFunc(object);
            return isArray(object) ? result : function(array, values) {
              for (var index = -1, length = values.length, offset = array.length; ++index < length; ) array[offset + index] = values[index];
              return array;
            }(result, symbolsFunc(object));
          }(object, keys, getSymbols);
        }(value) : keys(value);
        return function(array, iteratee) {
          for (var index = -1, length = array ? array.length : 0; ++index < length && !1 !== iteratee(array[index], index, array); ) ;
        }(props || value, (function(subValue, key) {
          props && (subValue = value[key = subValue]), assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
        })), result;
      }
      function baseIsNative(value) {
        return !(!isObject(value) || (func = value, maskSrcKey && maskSrcKey in func)) && (isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor).test(toSource(value));
        var func;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        return new Uint8Array(result).set(new Uint8Array(arrayBuffer)), result;
      }
      function copyObject(source, props, object, customizer) {
        object || (object = {});
        for (var index = -1, length = props.length; ++index < length; ) {
          var key = props[index], newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
          assignValue(object, key, void 0 === newValue ? source[key] : newValue);
        }
        return object;
      }
      function getMapData(map, key) {
        var value, type, data = map.__data__;
        return ("string" == (type = typeof (value = key)) || "number" == type || "symbol" == type || "boolean" == type ? "__proto__" !== value : null === value) ? data["string" == typeof key ? "string" : "hash"] : data.map;
      }
      function getNative(object, key) {
        var value = function(object, key) {
          return null == object ? void 0 : object[key];
        }(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      Hash.prototype.clear = function() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
      }, Hash.prototype.delete = function(key) {
        return this.has(key) && delete this.__data__[key];
      }, Hash.prototype.get = function(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return "__lodash_hash_undefined__" === result ? void 0 : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : void 0;
      }, Hash.prototype.has = function(key) {
        var data = this.__data__;
        return nativeCreate ? void 0 !== data[key] : hasOwnProperty.call(data, key);
      }, Hash.prototype.set = function(key, value) {
        return this.__data__[key] = nativeCreate && void 0 === value ? "__lodash_hash_undefined__" : value, 
        this;
      }, ListCache.prototype.clear = function() {
        this.__data__ = [];
      }, ListCache.prototype.delete = function(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return !(index < 0) && (index == data.length - 1 ? data.pop() : splice.call(data, index, 1), 
        !0);
      }, ListCache.prototype.get = function(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }, ListCache.prototype.has = function(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }, ListCache.prototype.set = function(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? data.push([ key, value ]) : data[index][1] = value, this;
      }, MapCache.prototype.clear = function() {
        this.__data__ = {
          hash: new Hash,
          map: new (Map || ListCache),
          string: new Hash
        };
      }, MapCache.prototype.delete = function(key) {
        return getMapData(this, key).delete(key);
      }, MapCache.prototype.get = function(key) {
        return getMapData(this, key).get(key);
      }, MapCache.prototype.has = function(key) {
        return getMapData(this, key).has(key);
      }, MapCache.prototype.set = function(key, value) {
        return getMapData(this, key).set(key, value), this;
      }, Stack.prototype.clear = function() {
        this.__data__ = new ListCache;
      }, Stack.prototype.delete = function(key) {
        return this.__data__.delete(key);
      }, Stack.prototype.get = function(key) {
        return this.__data__.get(key);
      }, Stack.prototype.has = function(key) {
        return this.__data__.has(key);
      }, Stack.prototype.set = function(key, value) {
        var cache = this.__data__;
        if (cache instanceof ListCache) {
          var pairs = cache.__data__;
          if (!Map || pairs.length < 199) return pairs.push([ key, value ]), this;
          cache = this.__data__ = new MapCache(pairs);
        }
        return cache.set(key, value), this;
      };
      var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : function() {
        return [];
      }, getTag = function(value) {
        return objectToString.call(value);
      };
      function isIndex(value, length) {
        return !!(length = null == length ? 9007199254740991 : length) && ("number" == typeof value || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
      }
      function isPrototype(value) {
        var Ctor = value && value.constructor;
        return value === ("function" == typeof Ctor && Ctor.prototype || objectProto);
      }
      function toSource(func) {
        if (null != func) {
          try {
            return funcToString.call(func);
          } catch (e) {}
          try {
            return func + "";
          } catch (e) {}
        }
        return "";
      }
      function eq(value, other) {
        return value === other || value != value && other != other;
      }
      (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && "[object Promise]" != getTag(Promise.resolve()) || Set && getTag(new Set) != setTag || WeakMap && "[object WeakMap]" != getTag(new WeakMap)) && (getTag = function(value) {
        var result = objectToString.call(value), Ctor = "[object Object]" == result ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) switch (ctorString) {
         case dataViewCtorString:
          return dataViewTag;

         case mapCtorString:
          return mapTag;

         case promiseCtorString:
          return "[object Promise]";

         case setCtorString:
          return setTag;

         case weakMapCtorString:
          return "[object WeakMap]";
        }
        return result;
      });
      var isArray = Array.isArray;
      function isArrayLike(value) {
        return null != value && function(value) {
          return "number" == typeof value && value > -1 && value % 1 == 0 && value <= 9007199254740991;
        }(value.length) && !isFunction(value);
      }
      var isBuffer = nativeIsBuffer || function() {
        return !1;
      };
      function isFunction(value) {
        var tag = isObject(value) ? objectToString.call(value) : "";
        return tag == funcTag || tag == genTag;
      }
      function isObject(value) {
        var type = typeof value;
        return !!value && ("object" == type || "function" == type);
      }
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : function(object) {
          if (!isPrototype(object)) return nativeKeys(object);
          var result = [];
          for (var key in Object(object)) hasOwnProperty.call(object, key) && "constructor" != key && result.push(key);
          return result;
        }(object);
      }
      module.exports = function(value) {
        return baseClone(value, !0, !0);
      };
    },
    59232: module => {
      var reIsHostCtor = /^\[object .+?Constructor\]$/, freeGlobal = "object" == typeof global && global && global.Object === Object && global, freeSelf = "object" == typeof self && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")();
      function apply(func, thisArg, args) {
        switch (args.length) {
         case 0:
          return func.call(thisArg);

         case 1:
          return func.call(thisArg, args[0]);

         case 2:
          return func.call(thisArg, args[0], args[1]);

         case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayIncludes(array, value) {
        return !!(array ? array.length : 0) && function(array, value, fromIndex) {
          if (value != value) return function(array, predicate, fromIndex, fromRight) {
            var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
            for (;fromRight ? index-- : ++index < length; ) if (predicate(array[index], index, array)) return index;
            return -1;
          }(array, baseIsNaN, fromIndex);
          var index = fromIndex - 1, length = array.length;
          for (;++index < length; ) if (array[index] === value) return index;
          return -1;
        }(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        for (var index = -1, length = array ? array.length : 0; ++index < length; ) if (comparator(value, array[index])) return !0;
        return !1;
      }
      function arrayPush(array, values) {
        for (var index = -1, length = values.length, offset = array.length; ++index < length; ) array[offset + index] = values[index];
        return array;
      }
      function baseIsNaN(value) {
        return value != value;
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        return set.forEach((function(value) {
          result[++index] = value;
        })), result;
      }
      var uid, arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype, coreJsData = root["__core-js_shared__"], maskSrcKey = (uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "")) ? "Symbol(src)_1." + uid : "", funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, objectToString = objectProto.toString, reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Symbol = root.Symbol, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : void 0, nativeMax = Math.max, Map = getNative(root, "Map"), Set = getNative(root, "Set"), nativeCreate = getNative(Object, "create");
      function Hash(entries) {
        var index = -1, length = entries ? entries.length : 0;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function ListCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function MapCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function SetCache(values) {
        var index = -1, length = values ? values.length : 0;
        for (this.__data__ = new MapCache; ++index < length; ) this.add(values[index]);
      }
      function assocIndexOf(array, key) {
        for (var value, other, length = array.length; length--; ) if ((value = array[length][0]) === (other = key) || value != value && other != other) return length;
        return -1;
      }
      function baseFlatten(array, depth, predicate, isStrict, result) {
        var index = -1, length = array.length;
        for (predicate || (predicate = isFlattenable), result || (result = []); ++index < length; ) {
          var value = array[index];
          depth > 0 && predicate(value) ? depth > 1 ? baseFlatten(value, depth - 1, predicate, isStrict, result) : arrayPush(result, value) : isStrict || (result[result.length] = value);
        }
        return result;
      }
      function baseIsNative(value) {
        if (!isObject(value) || (func = value, maskSrcKey && maskSrcKey in func)) return !1;
        var func, pattern = isFunction(value) || function(value) {
          var result = !1;
          if (null != value && "function" != typeof value.toString) try {
            result = !!(value + "");
          } catch (e) {}
          return result;
        }(value) ? reIsNative : reIsHostCtor;
        return pattern.test(function(func) {
          if (null != func) {
            try {
              return funcToString.call(func);
            } catch (e) {}
            try {
              return func + "";
            } catch (e) {}
          }
          return "";
        }(value));
      }
      Hash.prototype.clear = function() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
      }, Hash.prototype.delete = function(key) {
        return this.has(key) && delete this.__data__[key];
      }, Hash.prototype.get = function(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return "__lodash_hash_undefined__" === result ? void 0 : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : void 0;
      }, Hash.prototype.has = function(key) {
        var data = this.__data__;
        return nativeCreate ? void 0 !== data[key] : hasOwnProperty.call(data, key);
      }, Hash.prototype.set = function(key, value) {
        return this.__data__[key] = nativeCreate && void 0 === value ? "__lodash_hash_undefined__" : value, 
        this;
      }, ListCache.prototype.clear = function() {
        this.__data__ = [];
      }, ListCache.prototype.delete = function(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return !(index < 0) && (index == data.length - 1 ? data.pop() : splice.call(data, index, 1), 
        !0);
      }, ListCache.prototype.get = function(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }, ListCache.prototype.has = function(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }, ListCache.prototype.set = function(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? data.push([ key, value ]) : data[index][1] = value, this;
      }, MapCache.prototype.clear = function() {
        this.__data__ = {
          hash: new Hash,
          map: new (Map || ListCache),
          string: new Hash
        };
      }, MapCache.prototype.delete = function(key) {
        return getMapData(this, key).delete(key);
      }, MapCache.prototype.get = function(key) {
        return getMapData(this, key).get(key);
      }, MapCache.prototype.has = function(key) {
        return getMapData(this, key).has(key);
      }, MapCache.prototype.set = function(key, value) {
        return getMapData(this, key).set(key, value), this;
      }, SetCache.prototype.add = SetCache.prototype.push = function(value) {
        return this.__data__.set(value, "__lodash_hash_undefined__"), this;
      }, SetCache.prototype.has = function(value) {
        return this.__data__.has(value);
      };
      var createSet = Set && 1 / setToArray(new Set([ , -0 ]))[1] == 1 / 0 ? function(values) {
        return new Set(values);
      } : function() {};
      function getMapData(map, key) {
        var value, type, data = map.__data__;
        return ("string" == (type = typeof (value = key)) || "number" == type || "symbol" == type || "boolean" == type ? "__proto__" !== value : null === value) ? data["string" == typeof key ? "string" : "hash"] : data.map;
      }
      function getNative(object, key) {
        var value = function(object, key) {
          return null == object ? void 0 : object[key];
        }(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      function isFlattenable(value) {
        return isArray(value) || function(value) {
          return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || "[object Arguments]" == objectToString.call(value));
        }(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      var func, start, union = (func = function(arrays) {
        return function(array, iteratee, comparator) {
          var index = -1, includes = arrayIncludes, length = array.length, isCommon = !0, result = [], seen = result;
          if (comparator) isCommon = !1, includes = arrayIncludesWith; else if (length >= 200) {
            var set = iteratee ? null : createSet(array);
            if (set) return setToArray(set);
            isCommon = !1, includes = cacheHas, seen = new SetCache;
          } else seen = iteratee ? [] : result;
          outer: for (;++index < length; ) {
            var value = array[index], computed = iteratee ? iteratee(value) : value;
            if (value = comparator || 0 !== value ? value : 0, isCommon && computed == computed) {
              for (var seenIndex = seen.length; seenIndex--; ) if (seen[seenIndex] === computed) continue outer;
              iteratee && seen.push(computed), result.push(value);
            } else includes(seen, computed, comparator) || (seen !== result && seen.push(computed), 
            result.push(value));
          }
          return result;
        }(baseFlatten(arrays, 1, isArrayLikeObject, !0));
      }, start = nativeMax(void 0 === start ? func.length - 1 : start, 0), function() {
        for (var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length); ++index < length; ) array[index] = args[start + index];
        index = -1;
        for (var otherArgs = Array(start + 1); ++index < start; ) otherArgs[index] = args[index];
        return otherArgs[start] = array, apply(func, this, otherArgs);
      });
      var isArray = Array.isArray;
      function isArrayLike(value) {
        return null != value && function(value) {
          return "number" == typeof value && value > -1 && value % 1 == 0 && value <= 9007199254740991;
        }(value.length) && !isFunction(value);
      }
      function isArrayLikeObject(value) {
        return function(value) {
          return !!value && "object" == typeof value;
        }(value) && isArrayLike(value);
      }
      function isFunction(value) {
        var tag = isObject(value) ? objectToString.call(value) : "";
        return "[object Function]" == tag || "[object GeneratorFunction]" == tag;
      }
      function isObject(value) {
        var type = typeof value;
        return !!value && ("object" == type || "function" == type);
      }
      module.exports = union;
    },
    67900: module => {
      var genTag = "[object GeneratorFunction]", reIsHostCtor = /^\[object .+?Constructor\]$/, freeGlobal = "object" == typeof global && global && global.Object === Object && global, freeSelf = "object" == typeof self && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")();
      function arrayIncludes(array, value) {
        return !!(array ? array.length : 0) && function(array, value, fromIndex) {
          if (value != value) return function(array, predicate, fromIndex, fromRight) {
            var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
            for (;fromRight ? index-- : ++index < length; ) if (predicate(array[index], index, array)) return index;
            return -1;
          }(array, baseIsNaN, fromIndex);
          var index = fromIndex - 1, length = array.length;
          for (;++index < length; ) if (array[index] === value) return index;
          return -1;
        }(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        for (var index = -1, length = array ? array.length : 0; ++index < length; ) if (comparator(value, array[index])) return !0;
        return !1;
      }
      function baseIsNaN(value) {
        return value != value;
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        return set.forEach((function(value) {
          result[++index] = value;
        })), result;
      }
      var uid, arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype, coreJsData = root["__core-js_shared__"], maskSrcKey = (uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "")) ? "Symbol(src)_1." + uid : "", funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, objectToString = objectProto.toString, reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), splice = arrayProto.splice, Map = getNative(root, "Map"), Set = getNative(root, "Set"), nativeCreate = getNative(Object, "create");
      function Hash(entries) {
        var index = -1, length = entries ? entries.length : 0;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function ListCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function MapCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function SetCache(values) {
        var index = -1, length = values ? values.length : 0;
        for (this.__data__ = new MapCache; ++index < length; ) this.add(values[index]);
      }
      function assocIndexOf(array, key) {
        for (var value, other, length = array.length; length--; ) if ((value = array[length][0]) === (other = key) || value != value && other != other) return length;
        return -1;
      }
      function baseIsNative(value) {
        if (!isObject(value) || (func = value, maskSrcKey && maskSrcKey in func)) return !1;
        var func, pattern = function(value) {
          var tag = isObject(value) ? objectToString.call(value) : "";
          return "[object Function]" == tag || tag == genTag;
        }(value) || function(value) {
          var result = !1;
          if (null != value && "function" != typeof value.toString) try {
            result = !!(value + "");
          } catch (e) {}
          return result;
        }(value) ? reIsNative : reIsHostCtor;
        return pattern.test(function(func) {
          if (null != func) {
            try {
              return funcToString.call(func);
            } catch (e) {}
            try {
              return func + "";
            } catch (e) {}
          }
          return "";
        }(value));
      }
      Hash.prototype.clear = function() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
      }, Hash.prototype.delete = function(key) {
        return this.has(key) && delete this.__data__[key];
      }, Hash.prototype.get = function(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return "__lodash_hash_undefined__" === result ? void 0 : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : void 0;
      }, Hash.prototype.has = function(key) {
        var data = this.__data__;
        return nativeCreate ? void 0 !== data[key] : hasOwnProperty.call(data, key);
      }, Hash.prototype.set = function(key, value) {
        return this.__data__[key] = nativeCreate && void 0 === value ? "__lodash_hash_undefined__" : value, 
        this;
      }, ListCache.prototype.clear = function() {
        this.__data__ = [];
      }, ListCache.prototype.delete = function(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return !(index < 0) && (index == data.length - 1 ? data.pop() : splice.call(data, index, 1), 
        !0);
      }, ListCache.prototype.get = function(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }, ListCache.prototype.has = function(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }, ListCache.prototype.set = function(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? data.push([ key, value ]) : data[index][1] = value, this;
      }, MapCache.prototype.clear = function() {
        this.__data__ = {
          hash: new Hash,
          map: new (Map || ListCache),
          string: new Hash
        };
      }, MapCache.prototype.delete = function(key) {
        return getMapData(this, key).delete(key);
      }, MapCache.prototype.get = function(key) {
        return getMapData(this, key).get(key);
      }, MapCache.prototype.has = function(key) {
        return getMapData(this, key).has(key);
      }, MapCache.prototype.set = function(key, value) {
        return getMapData(this, key).set(key, value), this;
      }, SetCache.prototype.add = SetCache.prototype.push = function(value) {
        return this.__data__.set(value, "__lodash_hash_undefined__"), this;
      }, SetCache.prototype.has = function(value) {
        return this.__data__.has(value);
      };
      var createSet = Set && 1 / setToArray(new Set([ , -0 ]))[1] == 1 / 0 ? function(values) {
        return new Set(values);
      } : function() {};
      function getMapData(map, key) {
        var value, type, data = map.__data__;
        return ("string" == (type = typeof (value = key)) || "number" == type || "symbol" == type || "boolean" == type ? "__proto__" !== value : null === value) ? data["string" == typeof key ? "string" : "hash"] : data.map;
      }
      function getNative(object, key) {
        var value = function(object, key) {
          return null == object ? void 0 : object[key];
        }(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      function isObject(value) {
        var type = typeof value;
        return !!value && ("object" == type || "function" == type);
      }
      module.exports = function(array) {
        return array && array.length ? function(array, iteratee, comparator) {
          var index = -1, includes = arrayIncludes, length = array.length, isCommon = !0, result = [], seen = result;
          if (comparator) isCommon = !1, includes = arrayIncludesWith; else if (length >= 200) {
            var set = iteratee ? null : createSet(array);
            if (set) return setToArray(set);
            isCommon = !1, includes = cacheHas, seen = new SetCache;
          } else seen = iteratee ? [] : result;
          outer: for (;++index < length; ) {
            var value = array[index], computed = iteratee ? iteratee(value) : value;
            if (value = comparator || 0 !== value ? value : 0, isCommon && computed == computed) {
              for (var seenIndex = seen.length; seenIndex--; ) if (seen[seenIndex] === computed) continue outer;
              iteratee && seen.push(computed), result.push(value);
            } else includes(seen, computed, comparator) || (seen !== result && seen.push(computed), 
            result.push(value));
          }
          return result;
        }(array) : [];
      };
    },
    78400: module => {
      var reIsHostCtor = /^\[object .+?Constructor\]$/, freeGlobal = "object" == typeof global && global && global.Object === Object && global, freeSelf = "object" == typeof self && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")();
      function apply(func, thisArg, args) {
        switch (args.length) {
         case 0:
          return func.call(thisArg);

         case 1:
          return func.call(thisArg, args[0]);

         case 2:
          return func.call(thisArg, args[0], args[1]);

         case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayIncludes(array, value) {
        return !!(array ? array.length : 0) && function(array, value, fromIndex) {
          if (value != value) return function(array, predicate, fromIndex, fromRight) {
            var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
            for (;fromRight ? index-- : ++index < length; ) if (predicate(array[index], index, array)) return index;
            return -1;
          }(array, baseIsNaN, fromIndex);
          var index = fromIndex - 1, length = array.length;
          for (;++index < length; ) if (array[index] === value) return index;
          return -1;
        }(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        for (var index = -1, length = array ? array.length : 0; ++index < length; ) if (comparator(value, array[index])) return !0;
        return !1;
      }
      function baseIsNaN(value) {
        return value != value;
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      var uid, arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype, coreJsData = root["__core-js_shared__"], maskSrcKey = (uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "")) ? "Symbol(src)_1." + uid : "", funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, objectToString = objectProto.toString, reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), splice = arrayProto.splice, nativeMax = Math.max, Map = getNative(root, "Map"), nativeCreate = getNative(Object, "create");
      function Hash(entries) {
        var index = -1, length = entries ? entries.length : 0;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function ListCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function MapCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function SetCache(values) {
        var index = -1, length = values ? values.length : 0;
        for (this.__data__ = new MapCache; ++index < length; ) this.add(values[index]);
      }
      function assocIndexOf(array, key) {
        for (var value, other, length = array.length; length--; ) if ((value = array[length][0]) === (other = key) || value != value && other != other) return length;
        return -1;
      }
      function baseDifference(array, values, iteratee, comparator) {
        var func, index = -1, includes = arrayIncludes, isCommon = !0, length = array.length, result = [], valuesLength = values.length;
        if (!length) return result;
        iteratee && (values = function(array, iteratee) {
          for (var index = -1, length = array ? array.length : 0, result = Array(length); ++index < length; ) result[index] = iteratee(array[index], index, array);
          return result;
        }(values, (func = iteratee, function(value) {
          return func(value);
        }))), comparator ? (includes = arrayIncludesWith, isCommon = !1) : values.length >= 200 && (includes = cacheHas, 
        isCommon = !1, values = new SetCache(values));
        outer: for (;++index < length; ) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          if (value = comparator || 0 !== value ? value : 0, isCommon && computed == computed) {
            for (var valuesIndex = valuesLength; valuesIndex--; ) if (values[valuesIndex] === computed) continue outer;
            result.push(value);
          } else includes(values, computed, comparator) || result.push(value);
        }
        return result;
      }
      function baseIsNative(value) {
        if (!isObject(value) || (func = value, maskSrcKey && maskSrcKey in func)) return !1;
        var func, pattern = isFunction(value) || function(value) {
          var result = !1;
          if (null != value && "function" != typeof value.toString) try {
            result = !!(value + "");
          } catch (e) {}
          return result;
        }(value) ? reIsNative : reIsHostCtor;
        return pattern.test(function(func) {
          if (null != func) {
            try {
              return funcToString.call(func);
            } catch (e) {}
            try {
              return func + "";
            } catch (e) {}
          }
          return "";
        }(value));
      }
      function getMapData(map, key) {
        var value, type, data = map.__data__;
        return ("string" == (type = typeof (value = key)) || "number" == type || "symbol" == type || "boolean" == type ? "__proto__" !== value : null === value) ? data["string" == typeof key ? "string" : "hash"] : data.map;
      }
      function getNative(object, key) {
        var value = function(object, key) {
          return null == object ? void 0 : object[key];
        }(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      Hash.prototype.clear = function() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
      }, Hash.prototype.delete = function(key) {
        return this.has(key) && delete this.__data__[key];
      }, Hash.prototype.get = function(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return "__lodash_hash_undefined__" === result ? void 0 : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : void 0;
      }, Hash.prototype.has = function(key) {
        var data = this.__data__;
        return nativeCreate ? void 0 !== data[key] : hasOwnProperty.call(data, key);
      }, Hash.prototype.set = function(key, value) {
        return this.__data__[key] = nativeCreate && void 0 === value ? "__lodash_hash_undefined__" : value, 
        this;
      }, ListCache.prototype.clear = function() {
        this.__data__ = [];
      }, ListCache.prototype.delete = function(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return !(index < 0) && (index == data.length - 1 ? data.pop() : splice.call(data, index, 1), 
        !0);
      }, ListCache.prototype.get = function(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }, ListCache.prototype.has = function(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }, ListCache.prototype.set = function(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? data.push([ key, value ]) : data[index][1] = value, this;
      }, MapCache.prototype.clear = function() {
        this.__data__ = {
          hash: new Hash,
          map: new (Map || ListCache),
          string: new Hash
        };
      }, MapCache.prototype.delete = function(key) {
        return getMapData(this, key).delete(key);
      }, MapCache.prototype.get = function(key) {
        return getMapData(this, key).get(key);
      }, MapCache.prototype.has = function(key) {
        return getMapData(this, key).has(key);
      }, MapCache.prototype.set = function(key, value) {
        return getMapData(this, key).set(key, value), this;
      }, SetCache.prototype.add = SetCache.prototype.push = function(value) {
        return this.__data__.set(value, "__lodash_hash_undefined__"), this;
      }, SetCache.prototype.has = function(value) {
        return this.__data__.has(value);
      };
      var func, start, without = (func = function(array, values) {
        return function(value) {
          return !!value && "object" == typeof value;
        }(value = array) && function(value) {
          return null != value && function(value) {
            return "number" == typeof value && value > -1 && value % 1 == 0 && value <= 9007199254740991;
          }(value.length) && !isFunction(value);
        }(value) ? baseDifference(array, values) : [];
        var value;
      }, start = nativeMax(void 0 === start ? func.length - 1 : start, 0), function() {
        for (var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length); ++index < length; ) array[index] = args[start + index];
        index = -1;
        for (var otherArgs = Array(start + 1); ++index < start; ) otherArgs[index] = args[index];
        return otherArgs[start] = array, apply(func, this, otherArgs);
      });
      function isFunction(value) {
        var tag = isObject(value) ? objectToString.call(value) : "";
        return "[object Function]" == tag || "[object GeneratorFunction]" == tag;
      }
      function isObject(value) {
        var type = typeof value;
        return !!value && ("object" == type || "function" == type);
      }
      module.exports = without;
    },
    36941: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const Yallist = __webpack_require__(33836), MAX = Symbol("max"), LENGTH = Symbol("length"), LENGTH_CALCULATOR = Symbol("lengthCalculator"), ALLOW_STALE = Symbol("allowStale"), MAX_AGE = Symbol("maxAge"), DISPOSE = Symbol("dispose"), NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet"), LRU_LIST = Symbol("lruList"), CACHE = Symbol("cache"), UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet"), naiveLength = () => 1;
      const get = (self, key, doUse) => {
        const node = self[CACHE].get(key);
        if (node) {
          const hit = node.value;
          if (isStale(self, hit)) {
            if (del(self, node), !self[ALLOW_STALE]) return;
          } else doUse && (self[UPDATE_AGE_ON_GET] && (node.value.now = Date.now()), self[LRU_LIST].unshiftNode(node));
          return hit.value;
        }
      }, isStale = (self, hit) => {
        if (!hit || !hit.maxAge && !self[MAX_AGE]) return !1;
        const diff = Date.now() - hit.now;
        return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
      }, trim = self => {
        if (self[LENGTH] > self[MAX]) for (let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && null !== walker; ) {
          const prev = walker.prev;
          del(self, walker), walker = prev;
        }
      }, del = (self, node) => {
        if (node) {
          const hit = node.value;
          self[DISPOSE] && self[DISPOSE](hit.key, hit.value), self[LENGTH] -= hit.length, 
          self[CACHE].delete(hit.key), self[LRU_LIST].removeNode(node);
        }
      };
      class Entry {
        constructor(key, value, length, now, maxAge) {
          this.key = key, this.value = value, this.length = length, this.now = now, this.maxAge = maxAge || 0;
        }
      }
      const forEachStep = (self, fn, node, thisp) => {
        let hit = node.value;
        isStale(self, hit) && (del(self, node), self[ALLOW_STALE] || (hit = void 0)), hit && fn.call(thisp, hit.value, hit.key, self);
      };
      module.exports = class {
        constructor(options) {
          if ("number" == typeof options && (options = {
            max: options
          }), options || (options = {}), options.max && ("number" != typeof options.max || options.max < 0)) throw new TypeError("max must be a non-negative number");
          this[MAX] = options.max || 1 / 0;
          const lc = options.length || naiveLength;
          if (this[LENGTH_CALCULATOR] = "function" != typeof lc ? naiveLength : lc, this[ALLOW_STALE] = options.stale || !1, 
          options.maxAge && "number" != typeof options.maxAge) throw new TypeError("maxAge must be a number");
          this[MAX_AGE] = options.maxAge || 0, this[DISPOSE] = options.dispose, this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || !1, 
          this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || !1, this.reset();
        }
        set max(mL) {
          if ("number" != typeof mL || mL < 0) throw new TypeError("max must be a non-negative number");
          this[MAX] = mL || 1 / 0, trim(this);
        }
        get max() {
          return this[MAX];
        }
        set allowStale(allowStale) {
          this[ALLOW_STALE] = !!allowStale;
        }
        get allowStale() {
          return this[ALLOW_STALE];
        }
        set maxAge(mA) {
          if ("number" != typeof mA) throw new TypeError("maxAge must be a non-negative number");
          this[MAX_AGE] = mA, trim(this);
        }
        get maxAge() {
          return this[MAX_AGE];
        }
        set lengthCalculator(lC) {
          "function" != typeof lC && (lC = naiveLength), lC !== this[LENGTH_CALCULATOR] && (this[LENGTH_CALCULATOR] = lC, 
          this[LENGTH] = 0, this[LRU_LIST].forEach((hit => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key), this[LENGTH] += hit.length;
          }))), trim(this);
        }
        get lengthCalculator() {
          return this[LENGTH_CALCULATOR];
        }
        get length() {
          return this[LENGTH];
        }
        get itemCount() {
          return this[LRU_LIST].length;
        }
        rforEach(fn, thisp) {
          thisp = thisp || this;
          for (let walker = this[LRU_LIST].tail; null !== walker; ) {
            const prev = walker.prev;
            forEachStep(this, fn, walker, thisp), walker = prev;
          }
        }
        forEach(fn, thisp) {
          thisp = thisp || this;
          for (let walker = this[LRU_LIST].head; null !== walker; ) {
            const next = walker.next;
            forEachStep(this, fn, walker, thisp), walker = next;
          }
        }
        keys() {
          return this[LRU_LIST].toArray().map((k => k.key));
        }
        values() {
          return this[LRU_LIST].toArray().map((k => k.value));
        }
        reset() {
          this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length && this[LRU_LIST].forEach((hit => this[DISPOSE](hit.key, hit.value))), 
          this[CACHE] = new Map, this[LRU_LIST] = new Yallist, this[LENGTH] = 0;
        }
        dump() {
          return this[LRU_LIST].map((hit => !isStale(this, hit) && {
            k: hit.key,
            v: hit.value,
            e: hit.now + (hit.maxAge || 0)
          })).toArray().filter((h => h));
        }
        dumpLru() {
          return this[LRU_LIST];
        }
        set(key, value, maxAge) {
          if ((maxAge = maxAge || this[MAX_AGE]) && "number" != typeof maxAge) throw new TypeError("maxAge must be a number");
          const now = maxAge ? Date.now() : 0, len = this[LENGTH_CALCULATOR](value, key);
          if (this[CACHE].has(key)) {
            if (len > this[MAX]) return del(this, this[CACHE].get(key)), !1;
            const item = this[CACHE].get(key).value;
            return this[DISPOSE] && (this[NO_DISPOSE_ON_SET] || this[DISPOSE](key, item.value)), 
            item.now = now, item.maxAge = maxAge, item.value = value, this[LENGTH] += len - item.length, 
            item.length = len, this.get(key), trim(this), !0;
          }
          const hit = new Entry(key, value, len, now, maxAge);
          return hit.length > this[MAX] ? (this[DISPOSE] && this[DISPOSE](key, value), !1) : (this[LENGTH] += hit.length, 
          this[LRU_LIST].unshift(hit), this[CACHE].set(key, this[LRU_LIST].head), trim(this), 
          !0);
        }
        has(key) {
          if (!this[CACHE].has(key)) return !1;
          const hit = this[CACHE].get(key).value;
          return !isStale(this, hit);
        }
        get(key) {
          return get(this, key, !0);
        }
        peek(key) {
          return get(this, key, !1);
        }
        pop() {
          const node = this[LRU_LIST].tail;
          return node ? (del(this, node), node.value) : null;
        }
        del(key) {
          del(this, this[CACHE].get(key));
        }
        load(arr) {
          this.reset();
          const now = Date.now();
          for (let l = arr.length - 1; l >= 0; l--) {
            const hit = arr[l], expiresAt = hit.e || 0;
            if (0 === expiresAt) this.set(hit.k, hit.v); else {
              const maxAge = expiresAt - now;
              maxAge > 0 && this.set(hit.k, hit.v, maxAge);
            }
          }
        }
        prune() {
          this[CACHE].forEach(((value, key) => get(this, key, !1)));
        }
      };
    },
    75935: module => {
      module.exports = function(scmd, commands) {
        var d = [], bestSimilarity = [];
        return commands.forEach((function(cmd, i) {
          var item = {};
          item[function(s1, s2) {
            var d = [], i = 0;
            for (i = 0; i <= s1.length; i++) d[i] = [ i ];
            for (i = 0; i <= s2.length; i++) d[0][i] = i;
            return s2.split("").forEach((function(c2, j) {
              s1.split("").forEach((function(c1, i) {
                d[i + 1][j + 1] = c1 !== c2 ? Math.min(d[i][j + 1] + 1, d[i + 1][j] + 1, d[i][j] + 1) : d[i][j];
              }));
            })), d[s1.length][s2.length];
          }(scmd, cmd)] = i, d.push(item);
        })), d.sort((function(a, b) {
          return Number(Object.keys(a)[0]) - Number(Object.keys(b)[0]);
        })), d.forEach((function(item) {
          var key = Number(Object.keys(item)[0]);
          scmd.length / 2 >= key && bestSimilarity.push(commands[item[key]]);
        })), bestSimilarity;
      };
    },
    42244: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = minimatch, minimatch.Minimatch = Minimatch;
      var path = function() {
        try {
          return __webpack_require__(71017);
        } catch (e) {}
      }() || {
        sep: "/"
      };
      minimatch.sep = path.sep;
      var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}, expand = __webpack_require__(21901), plTypes = {
        "!": {
          open: "(?:(?!(?:",
          close: "))[^/]*?)"
        },
        "?": {
          open: "(?:",
          close: ")?"
        },
        "+": {
          open: "(?:",
          close: ")+"
        },
        "*": {
          open: "(?:",
          close: ")*"
        },
        "@": {
          open: "(?:",
          close: ")"
        }
      }, reSpecials = "().*{}+?[]^$\\!".split("").reduce((function(set, c) {
        return set[c] = !0, set;
      }), {});
      var slashSplit = /\/+/;
      function ext(a, b) {
        b = b || {};
        var t = {};
        return Object.keys(a).forEach((function(k) {
          t[k] = a[k];
        })), Object.keys(b).forEach((function(k) {
          t[k] = b[k];
        })), t;
      }
      function minimatch(p, pattern, options) {
        return assertValidPattern(pattern), options || (options = {}), !(!options.nocomment && "#" === pattern.charAt(0)) && new Minimatch(pattern, options).match(p);
      }
      function Minimatch(pattern, options) {
        if (!(this instanceof Minimatch)) return new Minimatch(pattern, options);
        assertValidPattern(pattern), options || (options = {}), pattern = pattern.trim(), 
        options.allowWindowsEscape || "/" === path.sep || (pattern = pattern.split(path.sep).join("/")), 
        this.options = options, this.set = [], this.pattern = pattern, this.regexp = null, 
        this.negate = !1, this.comment = !1, this.empty = !1, this.partial = !!options.partial, 
        this.make();
      }
      function braceExpand(pattern, options) {
        return options || (options = this instanceof Minimatch ? this.options : {}), pattern = void 0 === pattern ? this.pattern : pattern, 
        assertValidPattern(pattern), options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern) ? [ pattern ] : expand(pattern);
      }
      minimatch.filter = function(pattern, options) {
        return options = options || {}, function(p, i, list) {
          return minimatch(p, pattern, options);
        };
      }, minimatch.defaults = function(def) {
        if (!def || "object" != typeof def || !Object.keys(def).length) return minimatch;
        var orig = minimatch, m = function(p, pattern, options) {
          return orig(p, pattern, ext(def, options));
        };
        return (m.Minimatch = function(pattern, options) {
          return new orig.Minimatch(pattern, ext(def, options));
        }).defaults = function(options) {
          return orig.defaults(ext(def, options)).Minimatch;
        }, m.filter = function(pattern, options) {
          return orig.filter(pattern, ext(def, options));
        }, m.defaults = function(options) {
          return orig.defaults(ext(def, options));
        }, m.makeRe = function(pattern, options) {
          return orig.makeRe(pattern, ext(def, options));
        }, m.braceExpand = function(pattern, options) {
          return orig.braceExpand(pattern, ext(def, options));
        }, m.match = function(list, pattern, options) {
          return orig.match(list, pattern, ext(def, options));
        }, m;
      }, Minimatch.defaults = function(def) {
        return minimatch.defaults(def).Minimatch;
      }, Minimatch.prototype.debug = function() {}, Minimatch.prototype.make = function() {
        var pattern = this.pattern, options = this.options;
        if (!options.nocomment && "#" === pattern.charAt(0)) return void (this.comment = !0);
        if (!pattern) return void (this.empty = !0);
        this.parseNegate();
        var set = this.globSet = this.braceExpand();
        options.debug && (this.debug = function() {
          console.error.apply(console, arguments);
        });
        this.debug(this.pattern, set), set = this.globParts = set.map((function(s) {
          return s.split(slashSplit);
        })), this.debug(this.pattern, set), set = set.map((function(s, si, set) {
          return s.map(this.parse, this);
        }), this), this.debug(this.pattern, set), set = set.filter((function(s) {
          return -1 === s.indexOf(!1);
        })), this.debug(this.pattern, set), this.set = set;
      }, Minimatch.prototype.parseNegate = function() {
        var pattern = this.pattern, negate = !1, options = this.options, negateOffset = 0;
        if (options.nonegate) return;
        for (var i = 0, l = pattern.length; i < l && "!" === pattern.charAt(i); i++) negate = !negate, 
        negateOffset++;
        negateOffset && (this.pattern = pattern.substr(negateOffset));
        this.negate = negate;
      }, minimatch.braceExpand = function(pattern, options) {
        return braceExpand(pattern, options);
      }, Minimatch.prototype.braceExpand = braceExpand;
      var assertValidPattern = function(pattern) {
        if ("string" != typeof pattern) throw new TypeError("invalid pattern");
        if (pattern.length > 65536) throw new TypeError("pattern is too long");
      };
      Minimatch.prototype.parse = function(pattern, isSub) {
        assertValidPattern(pattern);
        var options = this.options;
        if ("**" === pattern) {
          if (!options.noglobstar) return GLOBSTAR;
          pattern = "*";
        }
        if ("" === pattern) return "";
        var stateChar, re = "", hasMagic = !!options.nocase, escaping = !1, patternListStack = [], negativeLists = [], inClass = !1, reClassStart = -1, classStart = -1, patternStart = "." === pattern.charAt(0) ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", self = this;
        function clearStateChar() {
          if (stateChar) {
            switch (stateChar) {
             case "*":
              re += "[^/]*?", hasMagic = !0;
              break;

             case "?":
              re += "[^/]", hasMagic = !0;
              break;

             default:
              re += "\\" + stateChar;
            }
            self.debug("clearStateChar %j %j", stateChar, re), stateChar = !1;
          }
        }
        for (var c, i = 0, len = pattern.length; i < len && (c = pattern.charAt(i)); i++) if (this.debug("%s\t%s %s %j", pattern, i, re, c), 
        escaping && reSpecials[c]) re += "\\" + c, escaping = !1; else switch (c) {
         case "/":
          return !1;

         case "\\":
          clearStateChar(), escaping = !0;
          continue;

         case "?":
         case "*":
         case "+":
         case "@":
         case "!":
          if (this.debug("%s\t%s %s %j <-- stateChar", pattern, i, re, c), inClass) {
            this.debug("  in class"), "!" === c && i === classStart + 1 && (c = "^"), re += c;
            continue;
          }
          self.debug("call clearStateChar %j", stateChar), clearStateChar(), stateChar = c, 
          options.noext && clearStateChar();
          continue;

         case "(":
          if (inClass) {
            re += "(";
            continue;
          }
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          }), re += "!" === stateChar ? "(?:(?!(?:" : "(?:", this.debug("plType %j %j", stateChar, re), 
          stateChar = !1;
          continue;

         case ")":
          if (inClass || !patternListStack.length) {
            re += "\\)";
            continue;
          }
          clearStateChar(), hasMagic = !0;
          var pl = patternListStack.pop();
          re += pl.close, "!" === pl.type && negativeLists.push(pl), pl.reEnd = re.length;
          continue;

         case "|":
          if (inClass || !patternListStack.length || escaping) {
            re += "\\|", escaping = !1;
            continue;
          }
          clearStateChar(), re += "|";
          continue;

         case "[":
          if (clearStateChar(), inClass) {
            re += "\\" + c;
            continue;
          }
          inClass = !0, classStart = i, reClassStart = re.length, re += c;
          continue;

         case "]":
          if (i === classStart + 1 || !inClass) {
            re += "\\" + c, escaping = !1;
            continue;
          }
          var cs = pattern.substring(classStart + 1, i);
          try {
            RegExp("[" + cs + "]");
          } catch (er) {
            var sp = this.parse(cs, SUBPARSE);
            re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]", hasMagic = hasMagic || sp[1], 
            inClass = !1;
            continue;
          }
          hasMagic = !0, inClass = !1, re += c;
          continue;

         default:
          clearStateChar(), escaping ? escaping = !1 : !reSpecials[c] || "^" === c && inClass || (re += "\\"), 
          re += c;
        }
        inClass && (cs = pattern.substr(classStart + 1), sp = this.parse(cs, SUBPARSE), 
        re = re.substr(0, reClassStart) + "\\[" + sp[0], hasMagic = hasMagic || sp[1]);
        for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
          var tail = re.slice(pl.reStart + pl.open.length);
          this.debug("setting tail", re, pl), tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (function(_, $1, $2) {
            return $2 || ($2 = "\\"), $1 + $1 + $2 + "|";
          })), this.debug("tail=%j\n   %s", tail, tail, pl, re);
          var t = "*" === pl.type ? "[^/]*?" : "?" === pl.type ? "[^/]" : "\\" + pl.type;
          hasMagic = !0, re = re.slice(0, pl.reStart) + t + "\\(" + tail;
        }
        clearStateChar(), escaping && (re += "\\\\");
        var addPatternStart = !1;
        switch (re.charAt(0)) {
         case "[":
         case ".":
         case "(":
          addPatternStart = !0;
        }
        for (var n = negativeLists.length - 1; n > -1; n--) {
          var nl = negativeLists[n], nlBefore = re.slice(0, nl.reStart), nlFirst = re.slice(nl.reStart, nl.reEnd - 8), nlLast = re.slice(nl.reEnd - 8, nl.reEnd), nlAfter = re.slice(nl.reEnd);
          nlLast += nlAfter;
          var openParensBefore = nlBefore.split("(").length - 1, cleanAfter = nlAfter;
          for (i = 0; i < openParensBefore; i++) cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
          var dollar = "";
          "" === (nlAfter = cleanAfter) && isSub !== SUBPARSE && (dollar = "$"), re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        }
        "" !== re && hasMagic && (re = "(?=.)" + re);
        addPatternStart && (re = patternStart + re);
        if (isSub === SUBPARSE) return [ re, hasMagic ];
        if (!hasMagic) return function(s) {
          return s.replace(/\\(.)/g, "$1");
        }(pattern);
        var flags = options.nocase ? "i" : "";
        try {
          var regExp = new RegExp("^" + re + "$", flags);
        } catch (er) {
          return new RegExp("$.");
        }
        return regExp._glob = pattern, regExp._src = re, regExp;
      };
      var SUBPARSE = {};
      minimatch.makeRe = function(pattern, options) {
        return new Minimatch(pattern, options || {}).makeRe();
      }, Minimatch.prototype.makeRe = function() {
        if (this.regexp || !1 === this.regexp) return this.regexp;
        var set = this.set;
        if (!set.length) return this.regexp = !1, this.regexp;
        var options = this.options, twoStar = options.noglobstar ? "[^/]*?" : options.dot ? "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?" : "(?:(?!(?:\\/|^)\\.).)*?", flags = options.nocase ? "i" : "", re = set.map((function(pattern) {
          return pattern.map((function(p) {
            return p === GLOBSTAR ? twoStar : "string" == typeof p ? function(s) {
              return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
            }(p) : p._src;
          })).join("\\/");
        })).join("|");
        re = "^(?:" + re + ")$", this.negate && (re = "^(?!" + re + ").*$");
        try {
          this.regexp = new RegExp(re, flags);
        } catch (ex) {
          this.regexp = !1;
        }
        return this.regexp;
      }, minimatch.match = function(list, pattern, options) {
        var mm = new Minimatch(pattern, options = options || {});
        return list = list.filter((function(f) {
          return mm.match(f);
        })), mm.options.nonull && !list.length && list.push(pattern), list;
      }, Minimatch.prototype.match = function(f, partial) {
        if (void 0 === partial && (partial = this.partial), this.debug("match", f, this.pattern), 
        this.comment) return !1;
        if (this.empty) return "" === f;
        if ("/" === f && partial) return !0;
        var options = this.options;
        "/" !== path.sep && (f = f.split(path.sep).join("/")), f = f.split(slashSplit), 
        this.debug(this.pattern, "split", f);
        var filename, i, set = this.set;
        for (this.debug(this.pattern, "set", set), i = f.length - 1; i >= 0 && !(filename = f[i]); i--) ;
        for (i = 0; i < set.length; i++) {
          var pattern = set[i], file = f;
          if (options.matchBase && 1 === pattern.length && (file = [ filename ]), this.matchOne(file, pattern, partial)) return !!options.flipNegate || !this.negate;
        }
        return !options.flipNegate && this.negate;
      }, Minimatch.prototype.matchOne = function(file, pattern, partial) {
        var options = this.options;
        this.debug("matchOne", {
          this: this,
          file,
          pattern
        }), this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, 
        pi++) {
          this.debug("matchOne loop");
          var hit, p = pattern[pi], f = file[fi];
          if (this.debug(pattern, p, f), !1 === p) return !1;
          if (p === GLOBSTAR) {
            this.debug("GLOBSTAR", [ pattern, p, f ]);
            var fr = fi, pr = pi + 1;
            if (pr === pl) {
              for (this.debug("** at the end"); fi < fl; fi++) if ("." === file[fi] || ".." === file[fi] || !options.dot && "." === file[fi].charAt(0)) return !1;
              return !0;
            }
            for (;fr < fl; ) {
              var swallowee = file[fr];
              if (this.debug("\nglobstar while", file, fr, pattern, pr, swallowee), this.matchOne(file.slice(fr), pattern.slice(pr), partial)) return this.debug("globstar found match!", fr, fl, swallowee), 
              !0;
              if ("." === swallowee || ".." === swallowee || !options.dot && "." === swallowee.charAt(0)) {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue"), fr++;
            }
            return !(!partial || (this.debug("\n>>> no match, partial?", file, fr, pattern, pr), 
            fr !== fl));
          }
          if ("string" == typeof p ? (hit = f === p, this.debug("string match", p, f, hit)) : (hit = f.match(p), 
          this.debug("pattern match", p, f, hit)), !hit) return !1;
        }
        if (fi === fl && pi === pl) return !0;
        if (fi === fl) return partial;
        if (pi === pl) return fi === fl - 1 && "" === file[fi];
        throw new Error("wtf?");
      };
    },
    41718: (module, __unused_webpack_exports, __webpack_require__) => {
      var path = __webpack_require__(71017), fs = __webpack_require__(57147), _0777 = parseInt("0777", 8);
      function mkdirP(p, opts, f, made) {
        "function" == typeof opts ? (f = opts, opts = {}) : opts && "object" == typeof opts || (opts = {
          mode: opts
        });
        var mode = opts.mode, xfs = opts.fs || fs;
        void 0 === mode && (mode = _0777), made || (made = null);
        var cb = f || function() {};
        p = path.resolve(p), xfs.mkdir(p, mode, (function(er) {
          if (!er) return cb(null, made = made || p);
          if ("ENOENT" === er.code) {
            if (path.dirname(p) === p) return cb(er);
            mkdirP(path.dirname(p), opts, (function(er, made) {
              er ? cb(er, made) : mkdirP(p, opts, cb, made);
            }));
          } else xfs.stat(p, (function(er2, stat) {
            er2 || !stat.isDirectory() ? cb(er, made) : cb(null, made);
          }));
        }));
      }
      module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP, mkdirP.sync = function sync(p, opts, made) {
        opts && "object" == typeof opts || (opts = {
          mode: opts
        });
        var mode = opts.mode, xfs = opts.fs || fs;
        void 0 === mode && (mode = _0777), made || (made = null), p = path.resolve(p);
        try {
          xfs.mkdirSync(p, mode), made = made || p;
        } catch (err0) {
          if ("ENOENT" === err0.code) made = sync(path.dirname(p), opts, made), sync(p, opts, made); else {
            var stat;
            try {
              stat = xfs.statSync(p);
            } catch (err1) {
              throw err0;
            }
            if (!stat.isDirectory()) throw err0;
          }
        }
        return made;
      };
    },
    94464: (module, __unused_webpack_exports, __webpack_require__) => {
      var Stream = __webpack_require__(12781);
      function MuteStream(opts) {
        Stream.apply(this), opts = opts || {}, this.writable = this.readable = !0, this.muted = !1, 
        this.on("pipe", this._onpipe), this.replace = opts.replace, this._prompt = opts.prompt || null, 
        this._hadControl = !1;
      }
      function proxy(fn) {
        return function() {
          var d = this._dest, s = this._src;
          d && d[fn] && d[fn].apply(d, arguments), s && s[fn] && s[fn].apply(s, arguments);
        };
      }
      module.exports = MuteStream, MuteStream.prototype = Object.create(Stream.prototype), 
      Object.defineProperty(MuteStream.prototype, "constructor", {
        value: MuteStream,
        enumerable: !1
      }), MuteStream.prototype.mute = function() {
        this.muted = !0;
      }, MuteStream.prototype.unmute = function() {
        this.muted = !1;
      }, Object.defineProperty(MuteStream.prototype, "_onpipe", {
        value: function(src) {
          this._src = src;
        },
        enumerable: !1,
        writable: !0,
        configurable: !0
      }), Object.defineProperty(MuteStream.prototype, "isTTY", {
        get: function() {
          return this._dest ? this._dest.isTTY : !!this._src && this._src.isTTY;
        },
        set: function(isTTY) {
          Object.defineProperty(this, "isTTY", {
            value: isTTY,
            enumerable: !0,
            writable: !0,
            configurable: !0
          });
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(MuteStream.prototype, "rows", {
        get: function() {
          return this._dest ? this._dest.rows : this._src ? this._src.rows : void 0;
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(MuteStream.prototype, "columns", {
        get: function() {
          return this._dest ? this._dest.columns : this._src ? this._src.columns : void 0;
        },
        enumerable: !0,
        configurable: !0
      }), MuteStream.prototype.pipe = function(dest, options) {
        return this._dest = dest, Stream.prototype.pipe.call(this, dest, options);
      }, MuteStream.prototype.pause = function() {
        if (this._src) return this._src.pause();
      }, MuteStream.prototype.resume = function() {
        if (this._src) return this._src.resume();
      }, MuteStream.prototype.write = function(c) {
        if (this.muted) {
          if (!this.replace) return !0;
          if (c.match(/^\u001b/)) return 0 === c.indexOf(this._prompt) && (c = (c = c.substr(this._prompt.length)).replace(/./g, this.replace), 
          c = this._prompt + c), this._hadControl = !0, this.emit("data", c);
          this._prompt && this._hadControl && 0 === c.indexOf(this._prompt) && (this._hadControl = !1, 
          this.emit("data", this._prompt), c = c.substr(this._prompt.length)), c = c.toString().replace(/./g, this.replace);
        }
        this.emit("data", c);
      }, MuteStream.prototype.end = function(c) {
        this.muted && (c = c && this.replace ? c.toString().replace(/./g, this.replace) : null), 
        c && this.emit("data", c), this.emit("end");
      }, MuteStream.prototype.destroy = proxy("destroy"), MuteStream.prototype.destroySoon = proxy("destroySoon"), 
      MuteStream.prototype.close = proxy("close");
    },
    82156: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const reporters = {
        install: __webpack_require__(69680),
        parseable: __webpack_require__(26784),
        detail: __webpack_require__(26675),
        json: __webpack_require__(83520),
        quiet: __webpack_require__(64915)
      };
      module.exports = function(data, options) {
        const config = Object.assign({}, {
          reporter: "install",
          withColor: !0,
          withUnicode: !0
        }, options);
        return new Promise((resolve => resolve(reporters[config.reporter](data, config))));
      };
    },
    10359: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.severityLabel = function(sev, withColor, bold) {
        if (!(sev in severityColors)) return sev.charAt(0).toUpperCase() + sev.substr(1).toLowerCase();
        let colorName = severityColors[sev].color;
        bold && (colorName = [ colorName, "bold" ]);
        return color(severityColors[sev].label, colorName, withColor);
      }, exports.color = color, exports.totalVulnCount = function(vulns) {
        return Object.keys(vulns).reduce(((accumulator, key) => accumulator += vulns[key]), 0);
      }, exports.severities = function(vulns) {
        return Object.keys(vulns).reduce(((accumulator, severity) => {
          const vulnCount = vulns[severity];
          return vulnCount > 0 && accumulator.push([ severity, vulnCount ]), accumulator;
        }), []);
      };
      const ccs = __webpack_require__(34012), severityColors = {
        critical: {
          color: "brightMagenta",
          label: "Critical"
        },
        high: {
          color: "brightRed",
          label: "High"
        },
        moderate: {
          color: "brightYellow",
          label: "Moderate"
        },
        low: {
          color: "bold",
          label: "Low"
        },
        info: {
          color: "",
          label: "Info"
        }
      };
      function color(value, colorName, withColor) {
        return colorName && withColor ? ccs.color(colorName) + value + ccs.color("reset") : value;
      }
    },
    26675: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const summary = __webpack_require__(69680).summary, Table = __webpack_require__(27275), Utils = __webpack_require__(10359), getRecommendation = function(action, config) {
        if ("install" === action.action) {
          return {
            cmd: `npm install ${action.resolves[0].dev ? "--save-dev " : ""}${action.module}@${action.target}`,
            isBreaking: action.isMajor
          };
        }
        return {
          cmd: `npm update ${action.module} --depth ${action.depth}`,
          isBreaking: !1
        };
      };
      module.exports = function(data, options) {
        const blankChars = {
          top: " ",
          "top-mid": " ",
          "top-left": " ",
          "top-right": " ",
          bottom: " ",
          "bottom-mid": " ",
          "bottom-left": " ",
          "bottom-right": " ",
          left: " ",
          "left-mid": " ",
          mid: " ",
          "mid-mid": " ",
          right: " ",
          "right-mid": " ",
          middle: " "
        }, config = Object.assign({}, {
          severityThreshold: "info"
        }, options);
        let output = "", exit = 0;
        const log = function(value) {
          output = output + value + "\n";
        };
        return function(data, config) {
          if (function() {
            const tableOptions = {
              colWidths: [ 78 ]
            };
            tableOptions.chars = blankChars;
            const table = new Table(tableOptions);
            table.push([ {
              content: "=== npm audit security report ===",
              vAlign: "center",
              hAlign: "center"
            } ]), log(table.toString());
          }(), 0 !== Object.keys(data.advisories).length) {
            let reviewFlag = !1;
            data.actions.forEach((action => {
              if ("update" === action.action || "install" === action.action) {
                const recommendation = getRecommendation(action, config), label = 1 === action.resolves.length ? "vulnerability" : "vulnerabilities";
                log(`# Run ${Utils.color(" " + recommendation.cmd + " ", "inverse", config.withColor)} to resolve ${action.resolves.length} ${label}`), 
                recommendation.isBreaking && log("SEMVER WARNING: Recommended action is a potentially breaking change"), 
                action.resolves.forEach((resolution => {
                  const advisory = data.advisories[resolution.id], tableOptions = {
                    colWidths: [ 15, 62 ],
                    wordWrap: !0
                  };
                  config.withUnicode || (tableOptions.chars = blankChars);
                  const table = new Table(tableOptions);
                  table.push({
                    [Utils.severityLabel(advisory.severity, config.withColor, !0)]: Utils.color(advisory.title, "bold", config.withColor)
                  }, {
                    Package: advisory.module_name
                  }, {
                    "Dependency of": `${resolution.path.split(">")[0]} ${resolution.dev ? "[dev]" : ""}`
                  }, {
                    Path: `${resolution.path.split(">").join(Utils.color(" > ", "grey", config.withColor))}`
                  }, {
                    "More info": advisory.url || `https://www.npmjs.com/advisories/${advisory.id}`
                  }), log(table.toString() + "\n\n");
                }));
              }
              if ("review" === action.action) {
                if (!reviewFlag) {
                  const tableOptions = {
                    colWidths: [ 78 ]
                  };
                  config.withUnicode || (tableOptions.chars = blankChars);
                  const table = new Table(tableOptions);
                  table.push([ {
                    content: "Manual Review\nSome vulnerabilities require your attention to resolve\n\nVisit https://go.npm.me/audit-guide for additional guidance",
                    vAlign: "center",
                    hAlign: "center"
                  } ]), log(table.toString());
                }
                reviewFlag = !0, action.resolves.forEach((resolution => {
                  const advisory = data.advisories[resolution.id], tableOptions = {
                    colWidths: [ 15, 62 ],
                    wordWrap: !0
                  };
                  config.withUnicode || (tableOptions.chars = blankChars);
                  const table = new Table(tableOptions), patchedIn = "<0.0.0" === advisory.patched_versions.replace(" ", "") ? "No patch available" : advisory.patched_versions;
                  table.push({
                    [Utils.severityLabel(advisory.severity, config.withColor, !0)]: Utils.color(advisory.title, "bold", config.withColor)
                  }, {
                    Package: advisory.module_name
                  }, {
                    "Patched in": patchedIn
                  }, {
                    "Dependency of": `${resolution.path.split(">")[0]} ${resolution.dev ? "[dev]" : ""}`
                  }, {
                    Path: `${resolution.path.split(">").join(Utils.color(" > ", "grey", config.withColor))}`
                  }, {
                    "More info": advisory.url || `https://www.npmjs.com/advisories/${advisory.id}`
                  }), log(table.toString());
                }));
              }
            }));
          }
        }(data, config), function(data) {
          const total = Utils.totalVulnCount(data.metadata.vulnerabilities);
          if (total > 0 && (exit = 1), log(`${summary(data, config)} in ${data.metadata.totalDependencies} scanned package${1 === data.metadata.totalDependencies ? "" : "s"}`), 
          total) {
            const counts = data.actions.reduce(((acc, {action, isMajor, resolves}) => (("update" === action || "install" === action && !isMajor) && resolves.forEach((({id, path}) => acc.advisories.add(`${id}::${path}`))), 
            isMajor && resolves.forEach((({id, path}) => acc.major.add(`${id}::${path}`))), 
            "review" === action && resolves.forEach((({id, path}) => acc.review.add(`${id}::${path}`))), 
            acc)), {
              advisories: new Set,
              major: new Set,
              review: new Set
            });
            if (counts.advisories.size && log(`  run \`npm audit fix\` to fix ${counts.advisories.size} of them.`), 
            counts.major.size) {
              const maj = counts.major.size;
              log(`  ${maj} vulnerabilit${1 === maj ? "y" : "ies"} require${1 === maj ? "s" : ""} semver-major dependency updates.`);
            }
            if (counts.review.size) {
              const rev = counts.review.size;
              log(`  ${rev} vulnerabilit${1 === rev ? "y" : "ies"} require${1 === rev ? "s" : ""} manual review. See the full report for details.`);
            }
          }
        }(data), {
          report: output.trim(),
          exitCode: exit
        };
      };
    },
    69680: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const Utils = __webpack_require__(10359);
      function summary(data, options) {
        const config = Object.assign({}, {
          severityThreshold: "info"
        }, options);
        function clr(str, clr) {
          return Utils.color(str, clr, config.withColor);
        }
        let output = "";
        const log = function(value) {
          output = output + value + "\n";
        };
        if (output += "found ", 0 === Object.keys(data.advisories).length) return log(`${str = "0", 
        clr(str, "brightGreen")} vulnerabilities`), output;
        {
          const total = Utils.totalVulnCount(data.metadata.vulnerabilities), sev = Utils.severities(data.metadata.vulnerabilities);
          if (sev.length > 1) {
            const severities = sev.map((value => `${value[1]} ${Utils.severityLabel(value[0], config.withColor).toLowerCase()}`)).join(", ");
            log(`${function(str) {
              return clr(str, "brightRed");
            }(total)} vulnerabilities (${severities})`);
          } else {
            const vulnCount = sev[0][1];
            log(`${vulnCount} ${Utils.severityLabel(sev[0][0], config.withColor).toLowerCase()} severity vulnerabilit${1 === vulnCount ? "y" : "ies"}`);
          }
        }
        var str;
        return output.trim();
      }
      module.exports = function(data, options) {
        let msg = summary(data, options);
        return Object.keys(data.advisories).length ? (msg += "\n  run `npm audit fix` to fix them, or `npm audit` for details", 
        {
          report: msg,
          exitCode: 1
        }) : {
          report: msg,
          exitCode: 0
        };
      }, module.exports.summary = summary;
    },
    83520: module => {
      "use strict";
      module.exports = function(data, options) {
        const config = Object.assign({}, {
          indent: 2
        }, options);
        return {
          report: JSON.stringify(data, null, config.indent),
          exitCode: 0
        };
      };
    },
    26784: module => {
      "use strict";
      const getRecommendation = function(action, config) {
        if ("install" === action.action) {
          return {
            cmd: `npm install ${action.resolves[0].dev ? "--save-dev " : ""}${action.module}@${action.target}`,
            isBreaking: action.isMajor
          };
        }
        return {
          cmd: `npm update ${action.module} --depth ${action.depth}`,
          isBreaking: !1
        };
      };
      module.exports = function(data, options) {
        const config = Object.assign({}, {
          severityThreshold: "info"
        }, options);
        let exit = 0;
        return function(metadata) {
          let total = 0;
          const keys = Object.keys(metadata.vulnerabilities);
          for (let key of keys) {
            total += metadata.vulnerabilities[key];
          }
          total > 0 && (exit = 1);
        }(data.metadata), {
          report: function(data, config) {
            let accumulator = {
              critical: "",
              high: "",
              moderate: "",
              low: ""
            };
            return 0 !== Object.keys(data.advisories).length && data.actions.forEach((action => {
              let l = {};
              if ("update" === action.action || "install" === action.action) {
                const recommendation = getRecommendation(action, config);
                l.recommendation = recommendation.cmd, l.breaking = recommendation.isBreaking ? "Y" : "N", 
                action.resolves.forEach((resolution => {
                  const advisory = data.advisories[resolution.id];
                  l.sevLevel = advisory.severity, l.severity = advisory.title, l.package = advisory.module_name, 
                  l.moreInfo = advisory.url || `https://www.npmjs.com/advisories/${advisory.id}`, 
                  l.path = resolution.path, accumulator[advisory.severity] += [ action.action, l.package, l.sevLevel, l.recommendation, l.severity, l.moreInfo, l.path, l.breaking ].join("\t") + "\n";
                }));
              }
              "review" === action.action && action.resolves.forEach((resolution => {
                const advisory = data.advisories[resolution.id];
                l.sevLevel = advisory.severity, l.severity = advisory.title, l.package = advisory.module_name, 
                l.moreInfo = advisory.url || `https://www.npmjs.com/advisories/${advisory.id}`, 
                l.patchedIn = "<0.0.0" === advisory.patched_versions.replace(" ", "") ? "No patch available" : advisory.patched_versions, 
                l.path = resolution.path, accumulator[advisory.severity] += [ action.action, l.package, l.sevLevel, l.patchedIn, l.severity, l.moreInfo, l.path ].join("\t") + "\n";
              }));
            })), accumulator.critical + accumulator.high + accumulator.moderate + accumulator.low;
          }(data, config),
          exitCode: exit
        };
      };
    },
    64915: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const Utils = __webpack_require__(10359);
      module.exports = function(data) {
        return {
          report: "",
          exitCode: 0 === Utils.totalVulnCount(data.metadata.vulnerabilities) ? 0 : 1
        };
      };
    },
    84245: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const fs = __webpack_require__(57147), path = __webpack_require__(71017), EE = __webpack_require__(82361).EventEmitter, normalizePackageBin = __webpack_require__(71921);
      class BundleWalker extends EE {
        constructor(opt) {
          if (super(opt = opt || {}), this.path = path.resolve(opt.path || process.cwd()), 
          this.parent = opt.parent || null, this.parent) {
            if (this.result = this.parent.result, !this.parent.parent) {
              const base = path.basename(this.path), scope = path.basename(path.dirname(this.path));
              this.result.add(/^@/.test(scope) ? scope + "/" + base : base);
            }
            this.root = this.parent.root, this.packageJsonCache = this.parent.packageJsonCache;
          } else this.result = new Set, this.root = this.path, this.packageJsonCache = opt.packageJsonCache || new Map;
          this.seen = new Set, this.didDone = !1, this.children = 0, this.node_modules = [], 
          this.package = null, this.bundle = null;
        }
        addListener(ev, fn) {
          return this.on(ev, fn);
        }
        on(ev, fn) {
          const ret = super.on(ev, fn);
          return "done" === ev && this.didDone && this.emit("done", this.result), ret;
        }
        done() {
          if (!this.didDone) if (this.didDone = !0, this.parent) this.emit("done"); else {
            const res = Array.from(this.result);
            this.result = res, this.emit("done", res);
          }
        }
        start() {
          const pj = path.resolve(this.path, "package.json");
          return this.packageJsonCache.has(pj) ? this.onPackage(this.packageJsonCache.get(pj)) : this.readPackageJson(pj), 
          this;
        }
        readPackageJson(pj) {
          fs.readFile(pj, ((er, data) => er ? this.done() : this.onPackageJson(pj, data)));
        }
        onPackageJson(pj, data) {
          try {
            this.package = normalizePackageBin(JSON.parse(data + ""));
          } catch (er) {
            return this.done();
          }
          this.packageJsonCache.set(pj, this.package), this.onPackage(this.package);
        }
        allDepsBundled(pkg) {
          return Object.keys(pkg.dependencies || {}).concat(Object.keys(pkg.optionalDependencies || {}));
        }
        onPackage(pkg) {
          const bdRaw = this.parent ? this.allDepsBundled(pkg) : pkg.bundleDependencies || pkg.bundledDependencies || [], bd = Array.from(new Set(Array.isArray(bdRaw) ? bdRaw : !0 === bdRaw ? this.allDepsBundled(pkg) : Object.keys(bdRaw)));
          if (!bd.length) return this.done();
          this.bundle = bd;
          this.path;
          this.readModules();
        }
        readModules() {
          readdirNodeModules(this.path + "/node_modules", ((er, nm) => er ? this.onReaddir([]) : this.onReaddir(nm)));
        }
        onReaddir(nm) {
          this.node_modules = nm, this.bundle.forEach((dep => this.childDep(dep))), 0 === this.children && this.done();
        }
        childDep(dep) {
          -1 === this.node_modules.indexOf(dep) || this.seen.has(dep) ? this.parent && this.parent.childDep(dep) : (this.seen.add(dep), 
          this.child(dep));
        }
        child(dep) {
          const p = this.path + "/node_modules/" + dep;
          this.children += 1;
          const child = new BundleWalker({
            path: p,
            parent: this
          });
          child.on("done", (_ => {
            0 == --this.children && this.done();
          })), child.start();
        }
      }
      class BundleWalkerSync extends BundleWalker {
        constructor(opt) {
          super(opt);
        }
        start() {
          return super.start(), this.done(), this;
        }
        readPackageJson(pj) {
          try {
            this.onPackageJson(pj, fs.readFileSync(pj));
          } catch (er) {}
          return this;
        }
        readModules() {
          try {
            this.onReaddir(readdirNodeModulesSync(this.path + "/node_modules"));
          } catch (er) {
            this.onReaddir([]);
          }
        }
        child(dep) {
          new BundleWalkerSync({
            path: this.path + "/node_modules/" + dep,
            parent: this
          }).start();
        }
      }
      const readdirNodeModules = (nm, cb) => {
        fs.readdir(nm, ((er, set) => {
          if (er) cb(er); else {
            const scopes = set.filter((f => /^@/.test(f)));
            if (scopes.length) {
              const unscoped = set.filter((f => !/^@/.test(f)));
              let count = scopes.length;
              scopes.forEach((scope => {
                fs.readdir(nm + "/" + scope, ((er, pkgs) => {
                  er || !pkgs.length ? unscoped.push(scope) : unscoped.push.apply(unscoped, pkgs.map((p => scope + "/" + p))), 
                  0 == --count && cb(null, unscoped);
                }));
              }));
            } else cb(null, set);
          }
        }));
      }, readdirNodeModulesSync = nm => {
        const set = fs.readdirSync(nm), unscoped = set.filter((f => !/^@/.test(f))), scopes = set.filter((f => /^@/.test(f))).map((scope => {
          try {
            const pkgs = fs.readdirSync(nm + "/" + scope);
            return pkgs.length ? pkgs.map((p => scope + "/" + p)) : [ scope ];
          } catch (er) {
            return [ scope ];
          }
        })).reduce(((a, b) => a.concat(b)), []);
        return unscoped.concat(scopes);
      }, walk = (options, callback) => {
        const p = new Promise(((resolve, reject) => {
          new BundleWalker(options).on("done", resolve).on("error", reject).start();
        }));
        return callback ? p.then((res => callback(null, res)), callback) : p;
      };
      module.exports = walk, walk.sync = options => new BundleWalkerSync(options).start().result, 
      walk.BundleWalker = BundleWalker, walk.BundleWalkerSync = BundleWalkerSync;
    },
    79831: (module, __unused_webpack_exports, __webpack_require__) => {
      var url = __webpack_require__(57310), path = __webpack_require__(71017);
      module.exports = function cf(root, u) {
        if (!u) return cf.bind(null, root);
        var h = (u = url.parse(u)).host.replace(/:/g, "_"), parts = u.path.replace(/(\?rev=|\?.*?&rev=|\/-rev\/).*$/, "").split("/").slice(1);
        u.hash && u.hash.length > 1 && parts.push(u.hash.slice(1));
        var p = [ root, h ].concat(parts.map((function(part) {
          return encodeURIComponent(part).replace(/%/g, "_");
        })));
        return path.join.apply(path, p);
      };
    },
    27809: (__unused_webpack_module, exports, __webpack_require__) => {
      var fs = __webpack_require__(57147), path = __webpack_require__(71017), util = __webpack_require__(73837), semver = __webpack_require__(73107);
      function checkList(value, list) {
        var tmp, match = !1, blc = 0;
        if ("string" == typeof list && (list = [ list ]), 1 === list.length && "any" === list[0]) return !0;
        for (var i = 0; i < list.length; ++i) if ("!" === (tmp = list[i])[0]) {
          if ((tmp = tmp.slice(1)) === value) return !1;
          ++blc;
        } else match = match || tmp === value;
        return match || blc === list.length;
      }
      exports.checkEngine = function(target, npmVer, nodeVer, force, strict, cb) {
        var nodev = force ? null : nodeVer, eng = target.engines, opt = {
          includePrerelease: !0
        };
        if (!eng) return cb();
        if (nodev && eng.node && !semver.satisfies(nodev, eng.node, opt) || eng.npm && !semver.satisfies(npmVer, eng.npm, opt)) {
          var er = new Error(util.format("Unsupported engine for %s: wanted: %j (current: %j)", target._id, eng, {
            node: nodev,
            npm: npmVer
          }));
          return er.code = "ENOTSUP", er.required = eng, er.pkgid = target._id, strict ? cb(er) : cb(null, er);
        }
        return cb();
      }, exports.checkPlatform = function(target, force, cb) {
        var platform = process.platform, arch = process.arch, osOk = !0, cpuOk = !0;
        if (force) return cb();
        target.os && (osOk = checkList(platform, target.os));
        target.cpu && (cpuOk = checkList(arch, target.cpu));
        if (!osOk || !cpuOk) {
          var er = new Error(util.format("Unsupported platform for %s: wanted %j (current: %j)", target._id, target, {
            os: platform,
            cpu: arch
          }));
          return er.code = "EBADPLATFORM", er.os = target.os || [ "any" ], er.cpu = target.cpu || [ "any" ], 
          er.pkgid = target._id, cb(er);
        }
        return cb();
      }, exports.checkCycle = function(target, ancestors, cb) {
        var p = Object.getPrototypeOf(Object.getPrototypeOf(ancestors)), name = target.name, version = target.version;
        for (;p && p !== Object.prototype && p[name] !== version; ) p = Object.getPrototypeOf(p);
        if (p[name] !== version) return cb();
        var er = new Error(target._id + ": Unresolvable cycle detected"), tree = [ target._id, JSON.parse(JSON.stringify(ancestors)) ], t = Object.getPrototypeOf(ancestors);
        for (;t && t !== Object.prototype; ) t === p && (t.THIS_IS_P = !0), tree.push(JSON.parse(JSON.stringify(t))), 
        t = Object.getPrototypeOf(t);
        return er.pkgid = target._id, er.code = "ECYCLE", cb(er);
      }, exports.checkGit = function(folder, cb) {
        fs.lstat(folder, (function(er, s) {
          if (er || !s.isDirectory()) return cb();
          !function(folder, cb) {
            fs.stat(path.resolve(folder, ".git"), (function(er, s) {
              if (!er && s.isDirectory()) {
                var e = new Error(folder + ": Appears to be a git repo or submodule.");
                return e.path = folder, e.code = "EISGIT", cb(e);
              }
              cb();
            }));
          }(folder, cb);
        }));
      };
    },
    2567: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = function(cmd, args, options, log) {
        const cmdWillOutput = function(stdio) {
          if ("inherit" === stdio) return !0;
          if (!Array.isArray(stdio)) return !1;
          for (let fh = 1; fh <= 2; ++fh) {
            if ("inherit" === stdio[fh]) return !0;
            if (1 === stdio[fh] || 2 === stdio[fh]) return !0;
          }
          return !1;
        }(options && options.stdio);
        cmdWillOutput && function(log) {
          null == progressEnabled && (progressEnabled = log.progressEnabled);
          progressEnabled && log.disableProgress();
          ++running;
        }(log);
        const raw = _spawn(cmd, args, options), cooked = new EventEmitter;
        return raw.on("error", (function(er) {
          cmdWillOutput && stopRunning(log), er.file = cmd, cooked.emit("error", er);
        })).on("close", (function(code, signal) {
          if (cmdWillOutput && stopRunning(log), 127 === code) {
            const er = new Error("spawn ENOENT");
            er.code = "ENOENT", er.errno = "ENOENT", er.syscall = "spawn", er.file = cmd, cooked.emit("error", er);
          } else cooked.emit("close", code, signal);
        })), cooked.stdin = raw.stdin, cooked.stdout = raw.stdout, cooked.stderr = raw.stderr, 
        cooked.kill = function(sig) {
          return raw.kill(sig);
        }, cooked;
      };
      const _spawn = __webpack_require__(32081).spawn, EventEmitter = __webpack_require__(82361).EventEmitter;
      let progressEnabled, running = 0;
      function stopRunning(log) {
        --running, progressEnabled && 0 === running && log.enableProgress();
      }
    },
    64257: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      let path;
      class LogicalTree {
        constructor(name, address, opts) {
          this.name = name, this.version = opts.version, this.address = address || "", this.optional = !!opts.optional, 
          this.dev = !!opts.dev, this.bundled = !!opts.bundled, this.resolved = opts.resolved, 
          this.integrity = opts.integrity, this.dependencies = new Map, this.requiredBy = new Set;
        }
        get isRoot() {
          return !this.requiredBy.size;
        }
        addDep(dep) {
          return this.dependencies.set(dep.name, dep), dep.requiredBy.add(this), this;
        }
        delDep(dep) {
          return this.dependencies.delete(dep.name), dep.requiredBy.delete(this), this;
        }
        getDep(name) {
          return this.dependencies.get(name);
        }
        path(prefix) {
          return this.isRoot ? prefix || "" : (path || (path = __webpack_require__(71017)), 
          path.join(prefix || "", "node_modules", this.address.replace(/:/g, "/node_modules/")));
        }
        hasCycle(_seen, _from) {
          _seen || (_seen = new Set), _from || (_from = this);
          for (let dep of this.dependencies.values()) if (!_seen.has(dep) && (_seen.add(dep), 
          dep === _from || dep.hasCycle(_seen, _from))) return !0;
          return !1;
        }
        forEachAsync(fn, opts, _pending) {
          opts || (opts = _pending || {}), _pending || (_pending = new Map);
          const P = opts.Promise || Promise;
          if (_pending.has(this)) return P.resolve(this.hasCycle() || _pending.get(this));
          const pending = P.resolve().then((() => fn(this, (() => promiseMap(this.dependencies.values(), (dep => dep.forEachAsync(fn, opts, _pending)), opts)))));
          return _pending.set(this, pending), pending;
        }
        forEach(fn, _seen) {
          _seen || (_seen = new Set), _seen.has(this) || (_seen.add(this), fn(this, (() => {
            for (let dep of this.dependencies.values()) dep.forEach(fn, _seen);
          })));
        }
      }
      function makeNode(name, address, opts) {
        return new LogicalTree(name, address, opts || {});
      }
      function addChild(dep, tree, allDeps, pkgLock) {
        tree.addDep(dep), allDeps.set(dep.address, dep);
        const addr = dep.address, lockNode = atAddr(pkgLock, addr);
        Object.keys(lockNode.requires || {}).forEach((name => {
          const tdepAddr = reqAddr(pkgLock, name, addr);
          let tdep = allDeps.get(tdepAddr);
          tdep ? dep.addDep(tdep) : (tdep = makeNode(name, tdepAddr, atAddr(pkgLock, tdepAddr)), 
          addChild(tdep, dep, allDeps, pkgLock));
        }));
      }
      function reqAddr(pkgLock, name, fromAddr) {
        if ((atAddr(pkgLock, fromAddr).dependencies || {})[name]) return `${fromAddr}:${name}`;
        {
          const parts = fromAddr.split(":");
          for (;parts.length; ) {
            parts.pop();
            const joined = parts.join(":"), parent = atAddr(pkgLock, joined);
            if (parent) {
              if ((parent.dependencies || {})[name]) return `${joined}${parts.length ? ":" : ""}${name}`;
            }
          }
          const err = new Error(`${name} not accessible from ${fromAddr}`);
          throw err.pkgLock = pkgLock, err.target = name, err.from = fromAddr, err;
        }
      }
      function atAddr(pkgLock, addr) {
        if (!addr.length) return pkgLock;
        return addr.split(":").reduce(((acc, next) => acc && (acc.dependencies || {})[next]), pkgLock);
      }
      function promiseMap(arr, fn, opts, _index) {
        _index = _index || 0;
        const P = opts && opts.Promise || Promise;
        return P.map ? P.map(arr, fn, opts) : (arr instanceof Array || (arr = Array.from(arr)), 
        _index >= arr.length ? P.resolve() : P.resolve(fn(arr[_index], _index, arr)).then((() => promiseMap(arr, fn, opts, _index + 1))));
      }
      module.exports = function(pkg, pkgLock, opts) {
        const tree = makeNode(pkg.name, null, pkg), allDeps = new Map;
        return Array.from(new Set(Object.keys(pkg.devDependencies || {}).concat(Object.keys(pkg.optionalDependencies || {})).concat(Object.keys(pkg.dependencies || {})))).forEach((name => {
          let dep = allDeps.get(name);
          if (!dep) {
            dep = makeNode(name, name, (pkgLock.dependencies || {})[name]);
          }
          addChild(dep, tree, allDeps, pkgLock);
        })), tree;
      }, module.exports.node = makeNode, module.exports._reqAddr = reqAddr, module.exports._atAddr = atAddr;
    },
    71921: (module, __unused_webpack_exports, __webpack_require__) => {
      const {join, basename} = __webpack_require__(71017), normalizeString = pkg => pkg.name ? (pkg.bin = {
        [pkg.name]: pkg.bin
      }, normalizeObject(pkg)) : removeBin(pkg), normalizeArray = pkg => (pkg.bin = pkg.bin.reduce(((acc, k) => (acc[basename(k)] = k, 
      acc)), {}), normalizeObject(pkg)), removeBin = pkg => (delete pkg.bin, pkg), normalizeObject = pkg => {
        const orig = pkg.bin, clean = {};
        let hasBins = !1;
        return Object.keys(orig).forEach((binKey => {
          const base = join("/", basename(binKey.replace(/\\|:/g, "/"))).substr(1);
          if ("string" != typeof orig[binKey] || !base) return;
          const binTarget = join("/", orig[binKey]).replace(/\\/g, "/").substr(1);
          binTarget && (clean[base] = binTarget, hasBins = !0);
        })), hasBins ? pkg.bin = clean : delete pkg.bin, pkg;
      };
      module.exports = pkg => pkg.bin ? "string" == typeof pkg.bin ? normalizeString(pkg) : Array.isArray(pkg.bin) ? normalizeArray(pkg) : "object" == typeof pkg.bin ? normalizeObject(pkg) : removeBin(pkg) : removeBin(pkg);
    },
    68749: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const bundleWalk = __webpack_require__(84245), BundleWalker = bundleWalk.BundleWalker, BundleWalkerSync = bundleWalk.BundleWalkerSync, ignoreWalk = __webpack_require__(41834), IgnoreWalker = ignoreWalk.Walker, IgnoreWalkerSync = ignoreWalk.WalkerSync, rootBuiltinRules = Symbol("root-builtin-rules"), packageNecessaryRules = Symbol("package-necessary-rules"), path = __webpack_require__(71017), normalizePackageBin = __webpack_require__(71921), defaultRules = [ ".npmignore", ".gitignore", "**/.git", "**/.svn", "**/.hg", "**/CVS", "**/.git/**", "**/.svn/**", "**/.hg/**", "**/CVS/**", "/.lock-wscript", "/.wafpickle-*", "/build/config.gypi", "npm-debug.log", "**/.npmrc", ".*.swp", ".DS_Store", "**/.DS_Store/**", "._*", "**/._*/**", "*.orig", "/package-lock.json", "/yarn.lock", "archived-packages/**", "core", "!core/", "!**/core/", "*.core", "*.vgcore", "vgcore.*", "core.+([0-9])" ], npmWalker = Class => class extends Class {
        constructor(opt) {
          (opt = opt || {}).ignoreFiles = [ rootBuiltinRules, "package.json", ".npmignore", ".gitignore", packageNecessaryRules ], 
          opt.includeEmpty = !1, opt.path = opt.path || process.cwd();
          const dirName = path.basename(opt.path), parentName = path.basename(path.dirname(opt.path));
          if (opt.follow = "node_modules" === dirName || "node_modules" === parentName && /^@/.test(dirName), 
          super(opt), this.parent) this.bundled = [], this.bundledScopes = [], this.packageJsonCache = this.parent.packageJsonCache; else {
            this.bundled = opt.bundled || [], this.bundledScopes = Array.from(new Set(this.bundled.filter((f => /^@/.test(f))).map((f => f.split("/")[0]))));
            const rules = defaultRules.join("\n") + "\n";
            this.packageJsonCache = opt.packageJsonCache || new Map, super.onReadIgnoreFile(rootBuiltinRules, rules, (_ => _));
          }
        }
        onReaddir(entries) {
          return this.parent || (entries = entries.filter((e => ".git" !== e && !("node_modules" === e && 0 === this.bundled.length)))), 
          super.onReaddir(entries);
        }
        filterEntry(entry, partial) {
          const p = this.path.substr(this.root.length + 1), pkgre = /^node_modules\/(@[^\/]+\/?[^\/]+|[^\/]+)(\/.*)?$/, isRoot = !this.parent, pkg = isRoot && pkgre.test(entry) ? entry.replace(pkgre, "$1") : null, rootNM = isRoot && "node_modules" === entry, rootPJ = isRoot && "package.json" === entry;
          return /^node_modules($|\/)/i.test(p) ? this.parent.filterEntry(this.basename + "/" + entry, partial) : pkg ? -1 !== this.bundled.indexOf(pkg) || -1 !== this.bundledScopes.indexOf(pkg) : rootNM ? !!this.bundled.length : !!rootPJ || super.filterEntry(entry, partial);
        }
        filterEntries() {
          this.ignoreRules["package.json"] ? this.ignoreRules[".gitignore"] = this.ignoreRules[".npmignore"] = null : this.ignoreRules[".npmignore"] && (this.ignoreRules[".gitignore"] = null), 
          this.filterEntries = super.filterEntries, super.filterEntries();
        }
        addIgnoreFile(file, then) {
          const ig = path.resolve(this.path, file);
          this.packageJsonCache.has(ig) ? this.onPackageJson(ig, this.packageJsonCache.get(ig), then) : super.addIgnoreFile(file, then);
        }
        onPackageJson(ig, pkg, then) {
          this.packageJsonCache.set(ig, pkg);
          const rules = [ pkg.browser ? "!" + pkg.browser : "", pkg.main ? "!" + pkg.main : "", "!package.json", "!npm-shrinkwrap.json", "!@(readme|copying|license|licence|notice|changes|changelog|history){,.*[^~$]}" ];
          if (pkg.bin) for (const key in pkg.bin) rules.push("!" + pkg.bin[key]);
          const data = rules.filter((f => f)).join("\n") + "\n";
          super.onReadIgnoreFile(packageNecessaryRules, data, (_ => _)), Array.isArray(pkg.files) ? super.onReadIgnoreFile("package.json", "*\n" + pkg.files.map((f => "!" + f + "\n!" + f.replace(/\/+$/, "") + "/**")).join("\n") + "\n", then) : then();
        }
        stat(entry, file, dir, then) {
          (file => /\*/.test(file))(entry) ? then() : super.stat(entry, file, dir, then);
        }
        onstat(st, entry, file, dir, then) {
          st.isSymbolicLink() ? then() : super.onstat(st, entry, file, dir, then);
        }
        onReadIgnoreFile(file, data, then) {
          if ("package.json" === file) try {
            const ig = path.resolve(this.path, file);
            this.onPackageJson(ig, normalizePackageBin(JSON.parse(data)), then);
          } catch (er) {
            then();
          } else super.onReadIgnoreFile(file, data, then);
        }
        sort(a, b) {
          return sort(a, b);
        }
      };
      class Walker extends(npmWalker(IgnoreWalker)){
        walker(entry, then) {
          new Walker(this.walkerOpt(entry)).on("done", then).start();
        }
      }
      class WalkerSync extends(npmWalker(IgnoreWalkerSync)){
        walker(entry, then) {
          new WalkerSync(this.walkerOpt(entry)).start(), then();
        }
      }
      const walk = (options, callback) => {
        options = options || {};
        const p = new Promise(((resolve, reject) => {
          const bw = new BundleWalker(options);
          bw.on("done", (bundled => {
            options.bundled = bundled, options.packageJsonCache = bw.packageJsonCache, new Walker(options).on("done", resolve).on("error", reject).start();
          })), bw.start();
        }));
        return callback ? p.then((res => callback(null, res)), callback) : p;
      }, sort = (a, b) => {
        const exta = path.extname(a).toLowerCase(), extb = path.extname(b).toLowerCase(), basea = path.basename(a).toLowerCase(), baseb = path.basename(b).toLowerCase();
        return exta.localeCompare(extb) || basea.localeCompare(baseb) || a.localeCompare(b);
      };
      module.exports = walk, walk.sync = options => {
        const bw = new BundleWalkerSync(options = options || {}).start();
        options.bundled = bw.result, options.packageJsonCache = bw.packageJsonCache;
        const walker = new WalkerSync(options);
        return walker.start(), walker.result;
      }, walk.Walker = Walker, walk.WalkerSync = WalkerSync;
    },
    90346: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const figgyPudding = __webpack_require__(55212), npa = __webpack_require__(19932), semver = __webpack_require__(73107), PickerOpts = figgyPudding({
        defaultTag: {
          default: "latest"
        },
        enjoyBy: {},
        includeDeprecated: {
          default: !1
        }
      });
      module.exports = function(packument, wanted, opts) {
        const time = (opts = PickerOpts(opts)).enjoyBy && packument.time && +new Date(opts.enjoyBy), type = npa.resolve(packument.name, wanted).type;
        "version" !== type && "range" !== type || (wanted = semver.clean(wanted, !0) || wanted);
        const distTags = packument["dist-tags"] || {}, versions = Object.keys(packument.versions || {}).filter((v => semver.valid(v, !0))), policyRestrictions = packument.policyRestrictions, restrictedVersions = policyRestrictions ? Object.keys(policyRestrictions.versions) : [];
        function enjoyableBy(v) {
          return !time || packument.time[v] && time >= +new Date(packument.time[v]);
        }
        let err, target;
        if (!versions.length && !restrictedVersions.length) throw err = new Error(`No valid versions available for ${packument.name}`), 
        err.code = "ENOVERSIONS", err.name = packument.name, err.type = type, err.wanted = wanted, 
        err;
        if ("tag" === type && enjoyableBy(distTags[wanted])) target = distTags[wanted]; else if ("version" === type) target = wanted; else if ("range" !== type && enjoyableBy(distTags[wanted])) throw new Error("Only tag, version, and range are supported");
        const tagVersion = distTags[opts.defaultTag];
        !target && tagVersion && packument.versions[tagVersion] && enjoyableBy(tagVersion) && semver.satisfies(tagVersion, wanted, !0) && (target = tagVersion);
        if (!target && !opts.includeDeprecated) {
          const undeprecated = versions.filter((v => !packument.versions[v].deprecated && enjoyableBy(v)));
          target = semver.maxSatisfying(undeprecated, wanted, !0);
        }
        if (!target) {
          const stillFresh = versions.filter(enjoyableBy);
          target = semver.maxSatisfying(stillFresh, wanted, !0);
        }
        !target && "*" === wanted && enjoyableBy(tagVersion) && (target = tagVersion);
        if (!target && time && "tag" === type && distTags[wanted] && !enjoyableBy(distTags[wanted])) {
          const stillFresh = versions.filter((v => enjoyableBy(v) && semver.lte(v, distTags[wanted], !0))).sort(semver.rcompare);
          target = stillFresh[0];
        }
        !target && restrictedVersions && (target = semver.maxSatisfying(restrictedVersions, wanted, !0));
        const manifest = target && packument.versions[target];
        if (manifest) return manifest;
        {
          const isForbidden = target && policyRestrictions && policyRestrictions.versions[target], pckg = `${packument.name}@${wanted}${opts.enjoyBy ? ` with an Enjoy By date of ${new Date(opts.enjoyBy).toLocaleString()}. Maybe try a different date?` : ""}`;
          throw isForbidden ? (err = new Error(`Could not download ${pckg} due to policy violations.\n${policyRestrictions.message}\n`), 
          err.code = "E403") : (err = new Error(`No matching version found for ${pckg}.`), 
          err.code = "ETARGET"), err.name = packument.name, err.type = type, err.wanted = wanted, 
          err.versions = versions, err.distTags = distTags, err.defaultTag = opts.defaultTag, 
          err;
        }
      };
    },
    27306: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      const fetch = __webpack_require__(11527), {HttpErrorBase} = __webpack_require__(79729), os = __webpack_require__(22037), pudding = __webpack_require__(55212), validate = __webpack_require__(95073);
      exports.adduserCouch = adduserCouch, exports.loginCouch = loginCouch, exports.adduserWeb = adduserWeb, 
      exports.loginWeb = loginWeb, exports.login = function(opener, prompter, opts) {
        return validate("FFO", arguments), opts = ProfileConfig(opts), loginWeb(opener, opts).catch((er => {
          if (er instanceof WebLoginNotSupported) return process.emit("log", "verbose", "web login not supported, trying couch"), 
          prompter(opts.creds).then((data => loginCouch(data.username, data.password, opts)));
          throw er;
        }));
      }, exports.adduser = function(opener, prompter, opts) {
        return validate("FFO", arguments), opts = ProfileConfig(opts), adduserWeb(opener, opts).catch((er => {
          if (er instanceof WebLoginNotSupported) return process.emit("log", "verbose", "web adduser not supported, trying couch"), 
          prompter(opts.creds).then((data => adduserCouch(data.username, data.email, data.password, opts)));
          throw er;
        }));
      }, exports.get = function(opts) {
        return validate("O", arguments), fetch.json("/-/npm/v1/user", opts);
      }, exports.set = function(profile, opts) {
        return validate("OO", arguments), Object.keys(profile).forEach((key => {
          "" === profile[key] && (profile[key] = null);
        })), fetch.json("/-/npm/v1/user", ProfileConfig(opts, {
          method: "POST",
          body: profile
        }));
      }, exports.listTokens = function(opts) {
        return validate("O", arguments), opts = ProfileConfig(opts), untilLastPage("/-/npm/v1/tokens");
        function untilLastPage(href, objects) {
          return fetch.json(href, opts).then((result => (objects = objects ? objects.concat(result.objects) : result.objects, 
          result.urls.next ? untilLastPage(result.urls.next, objects) : objects)));
        }
      }, exports.removeToken = function(tokenKey, opts) {
        validate("SO", arguments);
        const target = `/-/npm/v1/tokens/token/${tokenKey}`;
        return fetch(target, ProfileConfig(opts, {
          method: "DELETE",
          ignoreBody: !0
        })).then((() => null));
      }, exports.createToken = function(password, readonly, cidrs, opts) {
        return validate("SBAO", arguments), fetch.json("/-/npm/v1/tokens", ProfileConfig(opts, {
          method: "POST",
          body: {
            password,
            readonly,
            cidr_whitelist: cidrs
          }
        }));
      };
      const url = __webpack_require__(57310), isValidUrl = u => {
        if (u && "string" == typeof u) {
          const p = url.parse(u);
          return p.slashes && p.host && p.path && /^https?:$/.test(p.protocol);
        }
        return !1;
      }, ProfileConfig = pudding({
        creds: {},
        hostname: {},
        otp: {}
      });
      function adduserWeb(opener, opts) {
        validate("FO", arguments);
        const body = {
          create: !0
        };
        return process.emit("log", "verbose", "web adduser", "before first POST"), webAuth(opener, opts, body);
      }
      function loginWeb(opener, opts) {
        return validate("FO", arguments), process.emit("log", "verbose", "web login", "before first POST"), 
        webAuth(opener, opts, {});
      }
      function webAuth(opener, opts, body) {
        opts = ProfileConfig(opts), body.hostname = opts.hostname || os.hostname();
        return fetch("/-/v1/login", opts.concat({
          method: "POST",
          body
        })).then((res => Promise.all([ res, res.json() ]))).then((([res, content]) => {
          const {doneUrl, loginUrl} = content;
          if (process.emit("log", "verbose", "web auth", "got response", content), !isValidUrl(doneUrl) || !isValidUrl(loginUrl)) throw new WebLoginInvalidResponse("POST", res, content);
          return content;
        })).then((({doneUrl, loginUrl}) => (process.emit("log", "verbose", "web auth", "opening url pair"), 
        opener(loginUrl).then((() => webAuthCheckLogin(doneUrl, opts.concat({
          cache: !1
        }))))))).catch((er => {
          throw er.statusCode >= 400 && er.statusCode <= 499 || 500 === er.statusCode ? new WebLoginNotSupported("POST", {
            status: er.statusCode,
            headers: {
              raw: () => er.headers
            }
          }, er.body) : er;
        }));
      }
      function webAuthCheckLogin(doneUrl, opts) {
        return fetch(doneUrl, opts).then((res => Promise.all([ res, res.json() ]))).then((([res, content]) => {
          if (200 === res.status) {
            if (content.token) return content;
            throw new WebLoginInvalidResponse("GET", res, content);
          }
          if (202 === res.status) {
            const retry = 1e3 * +res.headers.get("retry-after");
            return retry > 0 ? (ms = retry, new Promise(((resolve, reject) => setTimeout(resolve, ms)))).then((() => webAuthCheckLogin(doneUrl, opts))) : webAuthCheckLogin(doneUrl, opts);
          }
          throw new WebLoginInvalidResponse("GET", res, content);
          var ms;
        }));
      }
      function adduserCouch(username, email, password, opts) {
        validate("SSSO", arguments), opts = ProfileConfig(opts);
        const body = {
          _id: "org.couchdb.user:" + username,
          name: username,
          password,
          email,
          type: "user",
          roles: [],
          date: (new Date).toISOString()
        }, logObj = {};
        Object.keys(body).forEach((k => {
          logObj[k] = "password" === k ? "XXXXX" : body[k];
        })), process.emit("log", "verbose", "adduser", "before first PUT", logObj);
        const target = "/-/user/org.couchdb.user:" + encodeURIComponent(username);
        return fetch.json(target, opts.concat({
          method: "PUT",
          body
        })).then((result => (result.username = username, result)));
      }
      function loginCouch(username, password, opts) {
        validate("SSO", arguments), opts = ProfileConfig(opts);
        const body = {
          _id: "org.couchdb.user:" + username,
          name: username,
          password,
          type: "user",
          roles: [],
          date: (new Date).toISOString()
        }, logObj = {};
        Object.keys(body).forEach((k => {
          logObj[k] = "password" === k ? "XXXXX" : body[k];
        })), process.emit("log", "verbose", "login", "before first PUT", logObj);
        const target = "-/user/org.couchdb.user:" + encodeURIComponent(username);
        return fetch.json(target, opts.concat({
          method: "PUT",
          body
        })).catch((err => {
          if ("E400" === err.code) throw err.message = `There is no user with the username "${username}".`, 
          err;
          if ("E409" !== err.code) throw err;
          return fetch.json(target, opts.concat({
            query: {
              write: !0
            }
          })).then((result => (Object.keys(result).forEach((function(k) {
            body[k] && "roles" !== k || (body[k] = result[k]);
          })), fetch.json(`${target}/-rev/${body._rev}`, opts.concat({
            method: "PUT",
            body,
            forceAuth: {
              username,
              password: Buffer.from(password, "utf8").toString("base64"),
              otp: opts.otp
            }
          })))));
        })).then((result => (result.username = username, result)));
      }
      class WebLoginInvalidResponse extends HttpErrorBase {
        constructor(method, res, body) {
          super(method, res, body), this.message = "Invalid response from web login endpoint", 
          Error.captureStackTrace(this, WebLoginInvalidResponse);
        }
      }
      class WebLoginNotSupported extends HttpErrorBase {
        constructor(method, res, body) {
          super(method, res, body), this.message = "Web login not supported", this.code = "ENYI", 
          Error.captureStackTrace(this, WebLoginNotSupported);
        }
      }
    },
    59505: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const config = __webpack_require__(30342), url = __webpack_require__(57310);
      module.exports = function(registry, opts) {
        if (!registry) throw new Error("registry is required");
        opts = config(opts);
        let AUTH = {};
        const regKey = registry && function(registry) {
          const parsed = url.parse(registry), formatted = url.format({
            host: parsed.host,
            pathname: parsed.pathname,
            slashes: parsed.slashes
          });
          return url.resolve(formatted, ".");
        }(registry);
        opts.forceAuth && (opts = opts.forceAuth);
        const doKey = (key, alias) => function(opts, obj, scope, key, objKey) {
          opts[key] && (obj[objKey || key] = opts[key]);
          scope && opts[`${scope}:${key}`] && (obj[objKey || key] = opts[`${scope}:${key}`]);
        }(opts, AUTH, regKey, key, alias);
        doKey("token"), doKey("_authToken", "token"), doKey("username"), doKey("password"), 
        doKey("_password", "password"), doKey("email"), doKey("_auth"), doKey("otp"), doKey("always-auth", "alwaysAuth"), 
        AUTH.password && (AUTH.password = Buffer.from(AUTH.password, "base64").toString("utf8"));
        if (AUTH._auth && (!AUTH.username || !AUTH.password)) {
          let auth = Buffer.from(AUTH._auth, "base64").toString();
          auth = auth.split(":"), AUTH.username = auth.shift(), AUTH.password = auth.join(":");
        }
        return AUTH.alwaysAuth = "false" !== AUTH.alwaysAuth && !!AUTH.alwaysAuth, AUTH;
      };
    },
    83163: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const config = __webpack_require__(30342), errors = __webpack_require__(79729), LRU = __webpack_require__(36941);
      function logRequest(method, res, startTime, opts) {
        const elapsedTime = Date.now() - startTime, attempt = res.headers.get("x-fetch-attempts"), attemptStr = attempt && attempt > 1 ? ` attempt #${attempt}` : "", cacheStr = res.headers.get("x-local-cache") ? " (from cache)" : "";
        let urlStr;
        try {
          const url = new (0, __webpack_require__(57310).URL)(res.url);
          url.password && (url.password = "***"), urlStr = url.toString();
        } catch (er) {
          urlStr = res.url;
        }
        opts.log.http("fetch", `${method.toUpperCase()} ${res.status} ${urlStr} ${elapsedTime}ms${attemptStr}${cacheStr}`);
      }
      module.exports = function(method, res, registry, startTime, opts) {
        opts = config(opts), res.headers.has("npm-notice") && !res.headers.has("x-local-cache") && opts.log.notice("", res.headers.get("npm-notice"));
        return function(res, registry, opts) {
          if (res.headers.has("warning") && !BAD_HOSTS.has(registry)) {
            const warnings = {};
            res.headers.raw().warning.forEach((w => {
              const match = w.match(WARNING_REGEXP);
              match && (warnings[match[1]] = {
                code: match[1],
                host: match[2],
                message: match[3],
                date: new Date(match[4])
              });
            })), BAD_HOSTS.set(registry, !0), warnings[199] && (warnings[199].message.match(/ENOTFOUND/) ? opts.log.warn("registry", `Using stale data from ${registry} because the host is inaccessible -- are you offline?`) : opts.log.warn("registry", `Unexpected warning for ${registry}: ${warnings[199].message}`)), 
            warnings[111] && opts.log.warn("registry", `Using stale data from ${registry} due to a request error during revalidation.`);
          }
        }(res, registry, opts), res.status >= 400 ? (logRequest(method, res, startTime, opts), 
        function(method, res, startTime, opts) {
          return res.buffer().catch((() => null)).then((body => {
            let parsed = body;
            try {
              parsed = JSON.parse(body.toString("utf8"));
            } catch (e) {}
            if (401 === res.status && res.headers.get("www-authenticate")) {
              const auth = res.headers.get("www-authenticate").split(/,\s*/).map((s => s.toLowerCase()));
              throw -1 !== auth.indexOf("ipaddress") ? new errors.HttpErrorAuthIPAddress(method, res, parsed, opts.spec) : -1 !== auth.indexOf("otp") ? new errors.HttpErrorAuthOTP(method, res, parsed, opts.spec) : new errors.HttpErrorAuthUnknown(method, res, parsed, opts.spec);
            }
            throw 401 === res.status && null != body && /one-time pass/.test(body.toString("utf8")) ? new errors.HttpErrorAuthOTP(method, res, parsed, opts.spec) : new errors.HttpErrorGeneral(method, res, parsed, opts.spec);
          }));
        }(method, res, 0, opts)) : (res.body.on("end", (() => logRequest(method, res, startTime, opts))), 
        opts.ignoreBody && (res.body.resume(), res.body = null), res);
      };
      const WARNING_REGEXP = /^\s*(\d{3})\s+(\S+)\s+"(.*)"\s+"([^"]+)"/, BAD_HOSTS = new LRU({
        max: 50
      });
    },
    30342: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const pkg = __webpack_require__(9762), figgyPudding = __webpack_require__(55212), silentLog = __webpack_require__(63235), AUTH_REGEX = /^(?:.*:)?(token|_authToken|username|_password|password|email|always-auth|_auth|otp)$/, SCOPE_REGISTRY_REGEX = /@.*:registry$/gi;
      module.exports = figgyPudding({
        agent: {},
        algorithms: {},
        body: {},
        ca: {},
        cache: {},
        cert: {},
        "fetch-retries": {},
        "fetch-retry-factor": {},
        "fetch-retry-maxtimeout": {},
        "fetch-retry-mintimeout": {},
        "force-auth": {},
        forceAuth: "force-auth",
        gzip: {},
        headers: {},
        "https-proxy": {},
        "ignore-body": {},
        ignoreBody: "ignore-body",
        integrity: {},
        "is-from-ci": "isFromCI",
        isFromCI: {
          default: () => "true" === process.env.CI || process.env.TDDIUM || process.env.JENKINS_URL || process.env["bamboo.buildKey"] || process.env.GO_PIPELINE_NAME
        },
        key: {},
        "local-address": {},
        log: {
          default: silentLog
        },
        "map-json": "mapJson",
        mapJSON: "mapJson",
        mapJson: {},
        "max-sockets": "maxsockets",
        maxsockets: {
          default: 12
        },
        memoize: {},
        method: {
          default: "GET"
        },
        "no-proxy": {},
        noproxy: {},
        "npm-session": "npmSession",
        npmSession: {},
        offline: {},
        otp: {},
        "prefer-offline": {},
        "prefer-online": {},
        projectScope: {},
        "project-scope": "projectScope",
        Promise: {
          default: () => Promise
        },
        proxy: {},
        query: {},
        refer: {},
        referer: "refer",
        registry: {
          default: "https://registry.npmjs.org/"
        },
        retry: {},
        scope: {},
        spec: {},
        "strict-ssl": {},
        timeout: {
          default: 0
        },
        "user-agent": {
          default: `${pkg.name}@${pkg.version}/node@${process.version}+${process.arch} (${process.platform})`
        }
      }, {
        other: key => key.match(AUTH_REGEX) || key.match(SCOPE_REGISTRY_REGEX)
      });
    },
    79729: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const url = __webpack_require__(57310);
      class HttpErrorBase extends Error {
        constructor(method, res, body, spec) {
          super(), this.headers = res.headers.raw(), this.statusCode = res.status, this.code = `E${res.status}`, 
          this.method = method, this.uri = res.url, this.body = body, this.pkgid = spec ? spec.toString() : function(href) {
            try {
              let basePath = url.parse(href).pathname.substr(1);
              if (!basePath.match(/^-/)) {
                basePath = basePath.split("/");
                var index = basePath.indexOf("_rewrite");
                return -1 === index ? index = basePath.length - 1 : index++, decodeURIComponent(basePath[index]);
              }
            } catch (_) {}
          }(res.url);
        }
      }
      module.exports.HttpErrorBase = HttpErrorBase;
      class HttpErrorGeneral extends HttpErrorBase {
        constructor(method, res, body, spec) {
          super(method, res, body, spec), this.message = `${res.status} ${res.statusText} - ${this.method.toUpperCase()} ${this.spec || this.uri}${body && body.error ? " - " + body.error : ""}`, 
          Error.captureStackTrace(this, HttpErrorGeneral);
        }
      }
      module.exports.HttpErrorGeneral = HttpErrorGeneral;
      class HttpErrorAuthOTP extends HttpErrorBase {
        constructor(method, res, body, spec) {
          super(method, res, body, spec), this.message = "OTP required for authentication", 
          this.code = "EOTP", Error.captureStackTrace(this, HttpErrorAuthOTP);
        }
      }
      module.exports.HttpErrorAuthOTP = HttpErrorAuthOTP;
      class HttpErrorAuthIPAddress extends HttpErrorBase {
        constructor(method, res, body, spec) {
          super(method, res, body, spec), this.message = "Login is not allowed from your IP address", 
          this.code = "EAUTHIP", Error.captureStackTrace(this, HttpErrorAuthIPAddress);
        }
      }
      module.exports.HttpErrorAuthIPAddress = HttpErrorAuthIPAddress;
      class HttpErrorAuthUnknown extends HttpErrorBase {
        constructor(method, res, body, spec) {
          super(method, res, body, spec), this.message = "Unable to authenticate, need: " + res.headers.get("www-authenticate"), 
          Error.captureStackTrace(this, HttpErrorAuthUnknown);
        }
      }
      module.exports.HttpErrorAuthUnknown = HttpErrorAuthUnknown;
    },
    11527: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const Buffer = __webpack_require__(28618).Buffer, checkResponse = __webpack_require__(83163), config = __webpack_require__(30342), getAuth = __webpack_require__(59505), fetch = __webpack_require__(72564), JSONStream = __webpack_require__(93012), npa = __webpack_require__(19932), {PassThrough} = __webpack_require__(12781), qs = __webpack_require__(63477), url = __webpack_require__(57310), zlib = __webpack_require__(59796);
      function regFetch(uri, opts) {
        const registry = (opts = config(opts)).spec && pickRegistry(opts.spec, opts) || opts.registry || "https://registry.npmjs.org/";
        uri = url.parse(uri).protocol ? uri : `${registry.trim().replace(/\/?$/g, "")}/${uri.trim().replace(/^\//, "")}`;
        const startTime = Date.now(), headers = function(registry, uri, opts) {
          const headers = Object.assign({
            "npm-in-ci": !!(opts["is-from-ci"] || "true" === process.env.CI || process.env.TDDIUM || process.env.JENKINS_URL || process.env["bamboo.buildKey"] || process.env.GO_PIPELINE_NAME),
            "npm-scope": opts["project-scope"],
            "npm-session": opts["npm-session"],
            "user-agent": opts["user-agent"],
            referer: opts.refer
          }, opts.headers), auth = getAuth(registry, opts), shouldAuth = auth.alwaysAuth || url.parse(uri).host === url.parse(registry).host;
          if (shouldAuth && auth.token) headers.authorization = `Bearer ${auth.token}`; else if (shouldAuth && auth.username && auth.password) {
            const encoded = Buffer.from(`${auth.username}:${auth.password}`, "utf8").toString("base64");
            headers.authorization = `Basic ${encoded}`;
          } else shouldAuth && auth._auth && (headers.authorization = `Basic ${auth._auth}`);
          shouldAuth && auth.otp && (headers["npm-otp"] = auth.otp);
          return headers;
        }(registry, uri, opts);
        let body = opts.body;
        const bodyIsStream = body && "object" == typeof body && "function" == typeof body.pipe;
        if (!body || bodyIsStream || "string" == typeof body || Buffer.isBuffer(body) ? body && !headers["content-type"] && (headers["content-type"] = "application/octet-stream") : (headers["content-type"] = headers["content-type"] || "application/json", 
        body = JSON.stringify(body)), opts.gzip) if (headers["content-encoding"] = "gzip", 
        bodyIsStream) {
          const gz = zlib.createGzip();
          body.on("error", (err => gz.emit("error", err))), body = body.pipe(gz);
        } else body = new opts.Promise(((resolve, reject) => {
          zlib.gzip(body, ((err, gz) => err ? reject(err) : resolve(gz)));
        }));
        let q = opts.query;
        if (q) {
          if ("string" == typeof q) q = qs.parse(q); else if ("object" != typeof q) throw new TypeError("invalid query option, must be string or object");
          Object.keys(q).forEach((key => {
            void 0 === q[key] && delete q[key];
          }));
        }
        const parsed = url.parse(uri), query = parsed.query ? Object.assign(qs.parse(parsed.query), q || {}) : Object.keys(q || {}).length ? q : null;
        return query && ("true" === String(query.write) && "GET" === opts.method && (opts = opts.concat({
          offline: !1,
          "prefer-offline": !1,
          "prefer-online": !0
        })), parsed.search = "?" + qs.stringify(query), uri = url.format(parsed)), opts.Promise.resolve(body).then((body => fetch(uri, {
          agent: opts.agent,
          algorithms: opts.algorithms,
          body,
          cache: getCacheMode(opts),
          cacheManager: opts.cache,
          ca: opts.ca,
          cert: opts.cert,
          headers,
          integrity: opts.integrity,
          key: opts.key,
          localAddress: opts["local-address"],
          maxSockets: opts.maxsockets,
          memoize: opts.memoize,
          method: opts.method || "GET",
          noProxy: opts["no-proxy"] || opts.noproxy,
          Promise: opts.Promise,
          proxy: opts["https-proxy"] || opts.proxy,
          referer: opts.refer,
          retry: null != opts.retry ? opts.retry : {
            retries: opts["fetch-retries"],
            factor: opts["fetch-retry-factor"],
            minTimeout: opts["fetch-retry-mintimeout"],
            maxTimeout: opts["fetch-retry-maxtimeout"]
          },
          strictSSL: !!opts["strict-ssl"],
          timeout: opts.timeout
        }).then((res => checkResponse(opts.method || "GET", res, registry, startTime, opts)))));
      }
      function pickRegistry(spec, opts) {
        spec = npa(spec), opts = config(opts);
        let registry = spec.scope && opts[spec.scope.replace(/^@?/, "@") + ":registry"];
        return !registry && opts.scope && (registry = opts[opts.scope.replace(/^@?/, "@") + ":registry"]), 
        registry || (registry = opts.registry || "https://registry.npmjs.org/"), registry;
      }
      function getCacheMode(opts) {
        return opts.offline ? "only-if-cached" : opts["prefer-offline"] ? "force-cache" : opts["prefer-online"] ? "no-cache" : "default";
      }
      module.exports = regFetch, module.exports.json = function(uri, opts) {
        return regFetch(uri, opts).then((res => res.json()));
      }, module.exports.json.stream = function(uri, jsonPath, opts) {
        opts = config(opts);
        const parser = JSONStream.parse(jsonPath, opts.mapJson), pt = parser.pipe(new PassThrough({
          objectMode: !0
        }));
        return parser.on("error", (err => pt.emit("error", err))), regFetch(uri, opts).then((res => {
          res.body.on("error", (err => parser.emit("error", err))), res.body.pipe(parser);
        }), (err => pt.emit("error", err))), pt;
      }, module.exports.pickRegistry = pickRegistry;
    },
    63235: module => {
      "use strict";
      const noop = Function.prototype;
      module.exports = {
        error: noop,
        warn: noop,
        notice: noop,
        info: noop,
        verbose: noop,
        silly: noop,
        http: noop,
        pause: noop,
        resume: noop
      };
    },
    49598: (__unused_webpack_module, exports) => {
      exports.email = function(em) {
        if (em.length > 254) return new Error(requirements.email.length);
        if (!em.match(/^[^@]+@.+\..+$/)) return new Error(requirements.email.valid);
        return null;
      }, exports.pw = function(pw) {
        return null;
      }, exports.username = function(un) {
        if (un !== un.toLowerCase()) return new Error(requirements.username.lowerCase);
        if (un !== encodeURIComponent(un)) return new Error(requirements.username.urlSafe);
        if ("." === un.charAt(0)) return new Error(requirements.username.dot);
        if (un.length > 214) return new Error(requirements.username.length);
        var illegal = un.match(illegalCharacterRe);
        if (illegal) return new Error(requirements.username.illegal + ' "' + illegal[0] + '"');
        return null;
      };
      var requirements = exports.requirements = {
        username: {
          length: "Name length must be less than or equal to 214 characters long",
          lowerCase: "Name must be lowercase",
          urlSafe: "Name may not contain non-url-safe chars",
          dot: 'Name may not start with "."',
          illegal: "Name may not contain illegal character"
        },
        password: {},
        email: {
          length: "Email length must be less then or equal to 254 characters long",
          valid: "Email must be an email address"
        }
      }, illegalCharacterRe = new RegExp("([" + [ "'" ].join() + "])");
    },
    22799: module => {
      "use strict";
      var getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty = Object.prototype.hasOwnProperty, propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val) {
        if (null == val) throw new TypeError("Object.assign cannot be called with null or undefined");
        return Object(val);
      }
      module.exports = function() {
        try {
          if (!Object.assign) return !1;
          var test1 = new String("abc");
          if (test1[5] = "de", "5" === Object.getOwnPropertyNames(test1)[0]) return !1;
          for (var test2 = {}, i = 0; i < 10; i++) test2["_" + String.fromCharCode(i)] = i;
          if ("0123456789" !== Object.getOwnPropertyNames(test2).map((function(n) {
            return test2[n];
          })).join("")) return !1;
          var test3 = {};
          return "abcdefghijklmnopqrst".split("").forEach((function(letter) {
            test3[letter] = letter;
          })), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, test3)).join("");
        } catch (err) {
          return !1;
        }
      }() ? Object.assign : function(target, source) {
        for (var from, symbols, to = toObject(target), s = 1; s < arguments.length; s++) {
          for (var key in from = Object(arguments[s])) hasOwnProperty.call(from, key) && (to[key] = from[key]);
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) propIsEnumerable.call(from, symbols[i]) && (to[symbols[i]] = from[symbols[i]]);
          }
        }
        return to;
      };
    },
    38412: (module, __unused_webpack_exports, __webpack_require__) => {
      var wrappy = __webpack_require__(68839);
      function once(fn) {
        var f = function() {
          return f.called ? f.value : (f.called = !0, f.value = fn.apply(this, arguments));
        };
        return f.called = !1, f;
      }
      function onceStrict(fn) {
        var f = function() {
          if (f.called) throw new Error(f.onceError);
          return f.called = !0, f.value = fn.apply(this, arguments);
        }, name = fn.name || "Function wrapped with `once`";
        return f.onceError = name + " shouldn't be called more than once", f.called = !1, 
        f;
      }
      module.exports = wrappy(once), module.exports.strict = wrappy(onceStrict), once.proto = once((function() {
        Object.defineProperty(Function.prototype, "once", {
          value: function() {
            return once(this);
          },
          configurable: !0
        }), Object.defineProperty(Function.prototype, "onceStrict", {
          value: function() {
            return onceStrict(this);
          },
          configurable: !0
        });
      }));
    },
    95815: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var childProcess = __webpack_require__(32081), os = __webpack_require__(22037);
      module.exports = function(args, options, callback) {
        var command, platform = process.platform;
        switch ("linux" === platform && -1 !== os.release().indexOf("Microsoft") && (platform = "win32"), 
        platform) {
         case "win32":
          command = "cmd.exe";
          break;

         case "darwin":
          command = "open";
          break;

         default:
          command = "xdg-open";
        }
        return "string" == typeof args && (args = [ args ]), "function" == typeof options && (callback = options, 
        options = {}), options && "object" == typeof options && options.command && ("win32" === platform ? args = [ options.command ].concat(args) : command = options.command), 
        "win32" === platform && (args = args.map((function(value) {
          return value.replace(/[&^]/g, "^$&");
        })), args = [ "/c", "start", '""' ].concat(args)), childProcess.execFile(command, args, options, callback);
      };
    },
    40107: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var os = __webpack_require__(22037);
      module.exports = "function" == typeof os.homedir ? os.homedir : function() {
        var env = process.env, home = env.HOME, user = env.LOGNAME || env.USER || env.LNAME || env.USERNAME;
        return "win32" === process.platform ? env.USERPROFILE || env.HOMEDRIVE + env.HOMEPATH || home || null : "darwin" === process.platform ? home || (user ? "/Users/" + user : null) : "linux" === process.platform ? home || (0 === process.getuid() ? "/root" : user ? "/home/" + user : null) : home || null;
      };
    },
    75848: module => {
      "use strict";
      var isWindows = "win32" === process.platform, trailingSlashRe = isWindows ? /[^:]\\$/ : /.\/$/;
      module.exports = function() {
        var path;
        return path = isWindows ? process.env.TEMP || process.env.TMP || (process.env.SystemRoot || process.env.windir) + "\\temp" : process.env.TMPDIR || process.env.TMP || process.env.TEMP || "/tmp", 
        trailingSlashRe.test(path) && (path = path.slice(0, -1)), path;
      };
    },
    20396: (__unused_webpack_module, exports, __webpack_require__) => {
      var isWindows = "win32" === process.platform, exec = (__webpack_require__(71017), 
      __webpack_require__(32081).exec), osTmpdir = __webpack_require__(75848), osHomedir = __webpack_require__(40107);
      function memo(key, lookup, fallback) {
        var fell = !1, falling = !1;
        exports[key] = function(cb) {
          var val = lookup();
          return val || fell || falling || !fallback || (fell = !0, falling = !0, exec(fallback, (function(er, output, stderr) {
            falling = !1, er || (val = output.trim());
          }))), exports[key] = function(cb) {
            return cb && process.nextTick(cb.bind(null, null, val)), val;
          }, cb && !falling && process.nextTick(cb.bind(null, null, val)), val;
        };
      }
      memo("user", (function() {
        return isWindows ? process.env.USERDOMAIN + "\\" + process.env.USERNAME : process.env.USER;
      }), "whoami"), memo("prompt", (function() {
        return isWindows ? process.env.PROMPT : process.env.PS1;
      })), memo("hostname", (function() {
        return isWindows ? process.env.COMPUTERNAME : process.env.HOSTNAME;
      }), "hostname"), memo("tmpdir", (function() {
        return osTmpdir();
      })), memo("home", (function() {
        return osHomedir();
      })), memo("path", (function() {
        return (process.env.PATH || process.env.Path || process.env.path).split(isWindows ? ";" : ":");
      })), memo("editor", (function() {
        return process.env.EDITOR || process.env.VISUAL || (isWindows ? "notepad.exe" : "vi");
      })), memo("shell", (function() {
        return isWindows ? process.env.ComSpec || "cmd" : process.env.SHELL || "bash";
      }));
    },
    13468: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var path = __webpack_require__(71017);
      function stripTrailingSep(thePath) {
        return thePath[thePath.length - 1] === path.sep ? thePath.slice(0, -1) : thePath;
      }
      module.exports = function(thePath, potentialParent) {
        return thePath = stripTrailingSep(thePath), potentialParent = stripTrailingSep(potentialParent), 
        "win32" === process.platform && (thePath = thePath.toLowerCase(), potentialParent = potentialParent.toLowerCase()), 
        0 === thePath.lastIndexOf(potentialParent, 0) && (thePath[potentialParent.length] === path.sep || void 0 === thePath[potentialParent.length]);
      };
    },
    10978: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      let Bluebird;
      module.exports = inflight;
      try {
        Bluebird = __webpack_require__(41142);
      } catch (_) {
        Bluebird = Promise;
      }
      const active = {};
      function inflight(unique, doFly) {
        return Bluebird.all([ unique, doFly ]).then((function(args) {
          const unique = args[0], doFly = args[1];
          return Array.isArray(unique) ? Bluebird.all(unique).then((function(uniqueArr) {
            return _inflight(uniqueArr.join(""), doFly);
          })) : _inflight(unique, doFly);
        }));
        function _inflight(unique, doFly) {
          if (!active[unique]) {
            function cleanup() {
              delete active[unique];
            }
            active[unique] = new Bluebird((function(resolve) {
              return resolve(doFly());
            })), active[unique].then(cleanup, cleanup);
          }
          return active[unique];
        }
      }
      inflight.active = active;
    },
    854: (module, exports, __webpack_require__) => {
      (module = __webpack_require__.nmd(module)).exports = promzard, promzard.PromZard = PromZard;
      var fs = __webpack_require__(57147), vm = __webpack_require__(26144), util = __webpack_require__(73837), files = {}, crypto = __webpack_require__(6113), EventEmitter = __webpack_require__(82361).EventEmitter, read = __webpack_require__(9547), Module = __webpack_require__(98188).Module, path = __webpack_require__(71017);
      function promzard(file, ctx, cb) {
        "function" == typeof ctx && (cb = ctx, ctx = null), ctx || (ctx = {});
        var pz = new PromZard(file, ctx);
        pz.on("error", cb), pz.on("data", (function(data) {
          cb(null, data);
        }));
      }
      function PromZard(file, ctx) {
        if (!(this instanceof PromZard)) return new PromZard(file, ctx);
        EventEmitter.call(this), this.file = file, this.ctx = ctx, this.unique = crypto.randomBytes(8).toString("hex"), 
        this.load();
      }
      promzard.fromBuffer = function(buf, ctx, cb) {
        var filename = 0;
        do {
          filename = "\0" + Math.random();
        } while (files[filename]);
        files[filename] = buf;
        var ret = promzard(filename, ctx, cb);
        return delete files[filename], ret;
      }, PromZard.prototype = Object.create(EventEmitter.prototype, {
        constructor: {
          value: PromZard,
          readable: !0,
          configurable: !0,
          writable: !0,
          enumerable: !1
        }
      }), PromZard.prototype.load = function() {
        if (files[this.file]) return this.loaded();
        fs.readFile(this.file, "utf8", function(er, d) {
          return er && this.backupFile ? (this.file = this.backupFile, delete this.backupFile, 
          this.load()) : er ? this.emit("error", this.error = er) : (files[this.file] = d, 
          void this.loaded());
        }.bind(this));
      }, PromZard.prototype.loaded = function() {
        this.ctx.prompt = this.makePrompt(), this.ctx.__filename = this.file, this.ctx.__dirname = path.dirname(this.file), 
        this.ctx.__basename = path.basename(this.file);
        var mod = this.ctx.module = this.makeModule();
        this.ctx.require = function(path) {
          return mod.require(path);
        }, this.ctx.require.resolve = function(path) {
          return Module._resolveFilename(path, mod);
        }, this.ctx.exports = mod.exports, this.script = this.wrap(files[this.file]);
        var fn = vm.runInThisContext(this.script, this.file), args = Object.keys(this.ctx).map(function(k) {
          return this.ctx[k];
        }.bind(this));
        try {
          var res = fn.apply(this.ctx, args);
        } catch (er) {
          this.emit("error", er);
        }
        res && "object" == typeof res && exports === mod.exports && 1 === Object.keys(exports).length ? this.result = res : this.result = mod.exports, 
        this.walk();
      }, PromZard.prototype.makeModule = function() {
        var mod = new Module(this.file, module);
        return mod.loaded = !0, mod.filename = this.file, mod.id = this.file, mod.paths = Module._nodeModulePaths(path.dirname(this.file)), 
        mod;
      }, PromZard.prototype.wrap = function(body) {
        var args = Object.keys(this.ctx).join(", ");
        return util.format("(function( %s ) { %s\n })", args, body);
      }, PromZard.prototype.makePrompt = function() {
        return this.prompts = [], function() {
          for (var p, d, t, i = 0; i < arguments.length; i++) {
            var a = arguments[i];
            "string" == typeof a && p ? d = a : "string" == typeof a ? p = a : "function" == typeof a ? t = a : a && "object" == typeof a && (p = a.prompt || p, 
            d = a.default || d, t = a.transform || t);
          }
          try {
            return this.unique + "-" + this.prompts.length;
          } finally {
            this.prompts.push([ p, d, t ]);
          }
        }.bind(this);
      }, PromZard.prototype.walk = function(o, cb) {
        o = o || this.result, cb = (cb = cb || function(er, res) {
          return er ? this.emit("error", this.error = er) : (this.result = res, this.emit("data", res));
        }).bind(this);
        var keys = Object.keys(o), i = 0, len = keys.length;
        (function L() {
          if (this.error) return;
          for (;i < len; ) {
            var k = keys[i], v = o[k];
            if (i++, v && "object" == typeof v) return this.walk(v, function(er, res) {
              if (er) return cb(er);
              o[k] = res, L.call(this);
            }.bind(this));
            if (v && "string" == typeof v && 0 === v.indexOf(this.unique)) {
              var n = +v.substr(this.unique.length + 1), prompt = this.prompts[n];
              if (isNaN(n) || !prompt) continue;
              return void 0 === prompt[0] && (prompt[0] = k), void 0 === prompt[1] && (prompt[1] = this.ctx[k]), 
              this.prompt(prompt, function(er, res) {
                if (er) return er.notValid ? (console.log(er.message), i--, L.call(this)) : this.emit("error", this.error = er);
                o[k] = res, L.call(this);
              }.bind(this));
            }
            if ("function" == typeof v) try {
              return v.call(this.ctx, function(er, res) {
                if (er) return this.emit("error", this.error = er);
                o[k] = res, i--, L.call(this);
              }.bind(this));
            } catch (er) {
              this.emit("error", er);
            }
          }
          if (i >= len) return cb(null, o);
        }).call(this);
      }, PromZard.prototype.prompt = function(pdt, cb) {
        var prompt = pdt[0], def = pdt[1], tx = pdt[2];
        tx && (cb = function(cb) {
          return function(er, data) {
            try {
              var res = tx(data);
              return !er && res instanceof Error && res.notValid ? cb(res, null) : cb(er, res);
            } catch (er) {
              this.emit("error", er);
            }
          };
        }(cb).bind(this)), read({
          prompt: prompt + ":",
          default: def
        }, cb);
      };
    },
    32981: module => {
      function setProto(obj, proto) {
        if ("function" == typeof Object.setPrototypeOf) return Object.setPrototypeOf(obj, proto);
        obj.__proto__ = proto;
      }
      function ProtoList() {
        this.list = [];
        var root = null;
        Object.defineProperty(this, "root", {
          get: function() {
            return root;
          },
          set: function(r) {
            root = r, this.list.length && setProto(this.list[this.list.length - 1], r);
          },
          enumerable: !0,
          configurable: !0
        });
      }
      module.exports = ProtoList, ProtoList.prototype = {
        get length() {
          return this.list.length;
        },
        get keys() {
          var k = [];
          for (var i in this.list[0]) k.push(i);
          return k;
        },
        get snapshot() {
          var o = {};
          return this.keys.forEach((function(k) {
            o[k] = this.get(k);
          }), this), o;
        },
        get store() {
          return this.list[0];
        },
        push: function(obj) {
          return "object" != typeof obj && (obj = {
            valueOf: obj
          }), this.list.length >= 1 && setProto(this.list[this.list.length - 1], obj), setProto(obj, this.root), 
          this.list.push(obj);
        },
        pop: function() {
          return this.list.length >= 2 && setProto(this.list[this.list.length - 2], this.root), 
          this.list.pop();
        },
        unshift: function(obj) {
          return setProto(obj, this.list[0] || this.root), this.list.unshift(obj);
        },
        shift: function() {
          return 1 === this.list.length && setProto(this.list[0], this.root), this.list.shift();
        },
        get: function(key) {
          return this.list[0][key];
        },
        set: function(key, val, save) {
          return this.length || this.push({}), save && this.list[0].hasOwnProperty(key) && this.push({}), 
          this.list[0][key] = val;
        },
        forEach: function(fn, thisp) {
          for (var key in this.list[0]) fn.call(thisp, key, this.list[0][key]);
        },
        slice: function() {
          return this.list.slice.apply(this.list, arguments);
        },
        splice: function() {
          for (var ret = this.list.splice.apply(this.list, arguments), i = 0, l = this.list.length; i < l; i++) setProto(this.list[i], this.list[i + 1] || this.root);
          return ret;
        }
      };
    },
    46715: function(module) {
      var context, definition;
      context = this, definition = function() {
        var setProperty = "function" == typeof Object.defineProperty ? function(obj, key, options) {
          return Object.defineProperty(obj, key, options), obj;
        } : function(obj, key, options) {
          return obj[key] = options.value, obj;
        };
        return function(obj, key, value, options) {
          var k;
          if (options = function(value, options) {
            var oo = "object" == typeof options, os = !oo && "string" == typeof options, op = function(p) {
              return oo ? !!options[p] : !!os && options.indexOf(p[0]) > -1;
            };
            return {
              enumerable: op("enumerable"),
              configurable: op("configurable"),
              writable: op("writable"),
              value
            };
          }(value, options), "object" == typeof key) {
            for (k in key) Object.hasOwnProperty.call(key, k) && (options.value = key[k], setProperty(obj, k, options));
            return obj;
          }
          return setProperty(obj, key, options);
        };
      }, module.exports ? module.exports = definition() : context.prr = definition();
    },
    42048: (module, __unused_webpack_exports, __webpack_require__) => {
      var once = __webpack_require__(38412), eos = __webpack_require__(33446), fs = __webpack_require__(57147), noop = function() {}, ancient = /^v?\.0/.test(process.version), isFn = function(fn) {
        return "function" == typeof fn;
      }, destroyer = function(stream, reading, writing, callback) {
        callback = once(callback);
        var closed = !1;
        stream.on("close", (function() {
          closed = !0;
        })), eos(stream, {
          readable: reading,
          writable: writing
        }, (function(err) {
          if (err) return callback(err);
          closed = !0, callback();
        }));
        var destroyed = !1;
        return function(err) {
          if (!closed && !destroyed) return destroyed = !0, function(stream) {
            return !!ancient && !!fs && (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close);
          }(stream) ? stream.close(noop) : function(stream) {
            return stream.setHeader && isFn(stream.abort);
          }(stream) ? stream.abort() : isFn(stream.destroy) ? stream.destroy() : void callback(err || new Error("stream was destroyed"));
        };
      }, call = function(fn) {
        fn();
      }, pipe = function(from, to) {
        return from.pipe(to);
      };
      module.exports = function() {
        var error, streams = Array.prototype.slice.call(arguments), callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
        if (Array.isArray(streams[0]) && (streams = streams[0]), streams.length < 2) throw new Error("pump requires two streams per minimum");
        var destroys = streams.map((function(stream, i) {
          var reading = i < streams.length - 1;
          return destroyer(stream, reading, i > 0, (function(err) {
            error || (error = err), err && destroys.forEach(call), reading || (destroys.forEach(call), 
            callback(error));
          }));
        }));
        return streams.reduce(pipe);
      };
    },
    50860: (module, __unused_webpack_exports, __webpack_require__) => {
      var QRCode = __webpack_require__(93245), QRErrorCorrectLevel = __webpack_require__(51434), white = "[47m  [0m", toCell = function(isBlack) {
        return isBlack ? "[40m  [0m" : white;
      }, repeat = function(color) {
        return {
          times: function(count) {
            return new Array(count).join(color);
          }
        };
      };
      module.exports = {
        error: QRErrorCorrectLevel.L,
        generate: function(input, opts, cb) {
          "function" == typeof opts && (cb = opts, opts = {});
          var qrcode = new QRCode(-1, this.error);
          qrcode.addData(input), qrcode.make();
          var output = "";
          if (opts && opts.small) {
            var moduleCount = qrcode.getModuleCount(), moduleData = qrcode.modules.slice(), oddRow = moduleCount % 2 == 1;
            oddRow && moduleData.push(function(length, value) {
              for (var arr = new Array(length), i = 0; i < length; i++) arr[i] = value;
              return arr;
            }(moduleCount, false));
            var platte = {
              WHITE_ALL: "",
              WHITE_BLACK: "",
              BLACK_WHITE: "",
              BLACK_ALL: " "
            }, borderTop = repeat(platte.BLACK_WHITE).times(moduleCount + 3), borderBottom = repeat(platte.WHITE_BLACK).times(moduleCount + 3);
            output += borderTop + "\n";
            for (var row = 0; row < moduleCount; row += 2) {
              output += platte.WHITE_ALL;
              for (var col = 0; col < moduleCount; col++) false === moduleData[row][col] && false === moduleData[row + 1][col] ? output += platte.WHITE_ALL : false === moduleData[row][col] && true === moduleData[row + 1][col] ? output += platte.WHITE_BLACK : true === moduleData[row][col] && false === moduleData[row + 1][col] ? output += platte.BLACK_WHITE : output += platte.BLACK_ALL;
              output += platte.WHITE_ALL + "\n";
            }
            oddRow || (output += borderBottom);
          } else {
            var border = repeat(white).times(qrcode.getModuleCount() + 3);
            output += border + "\n", qrcode.modules.forEach((function(row) {
              output += white, output += row.map(toCell).join(""), output += white + "\n";
            })), output += border;
          }
          cb ? cb(output) : console.log(output);
        },
        setErrorLevel: function(error) {
          this.error = QRErrorCorrectLevel[error] || this.error;
        }
      };
    },
    31861: (module, __unused_webpack_exports, __webpack_require__) => {
      var QRMode = __webpack_require__(59280);
      function QR8bitByte(data) {
        this.mode = QRMode.MODE_8BIT_BYTE, this.data = data;
      }
      QR8bitByte.prototype = {
        getLength: function() {
          return this.data.length;
        },
        write: function(buffer) {
          for (var i = 0; i < this.data.length; i++) buffer.put(this.data.charCodeAt(i), 8);
        }
      }, module.exports = QR8bitByte;
    },
    99727: module => {
      function QRBitBuffer() {
        this.buffer = [], this.length = 0;
      }
      QRBitBuffer.prototype = {
        get: function(index) {
          var bufIndex = Math.floor(index / 8);
          return 1 == (this.buffer[bufIndex] >>> 7 - index % 8 & 1);
        },
        put: function(num, length) {
          for (var i = 0; i < length; i++) this.putBit(1 == (num >>> length - i - 1 & 1));
        },
        getLengthInBits: function() {
          return this.length;
        },
        putBit: function(bit) {
          var bufIndex = Math.floor(this.length / 8);
          this.buffer.length <= bufIndex && this.buffer.push(0), bit && (this.buffer[bufIndex] |= 128 >>> this.length % 8), 
          this.length++;
        }
      }, module.exports = QRBitBuffer;
    },
    51434: module => {
      module.exports = {
        L: 1,
        M: 0,
        Q: 3,
        H: 2
      };
    },
    54556: module => {
      module.exports = {
        PATTERN000: 0,
        PATTERN001: 1,
        PATTERN010: 2,
        PATTERN011: 3,
        PATTERN100: 4,
        PATTERN101: 5,
        PATTERN110: 6,
        PATTERN111: 7
      };
    },
    57889: module => {
      for (var QRMath = {
        glog: function(n) {
          if (n < 1) throw new Error("glog(" + n + ")");
          return QRMath.LOG_TABLE[n];
        },
        gexp: function(n) {
          for (;n < 0; ) n += 255;
          for (;n >= 256; ) n -= 255;
          return QRMath.EXP_TABLE[n];
        },
        EXP_TABLE: new Array(256),
        LOG_TABLE: new Array(256)
      }, i = 0; i < 8; i++) QRMath.EXP_TABLE[i] = 1 << i;
      for (i = 8; i < 256; i++) QRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4] ^ QRMath.EXP_TABLE[i - 5] ^ QRMath.EXP_TABLE[i - 6] ^ QRMath.EXP_TABLE[i - 8];
      for (i = 0; i < 255; i++) QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;
      module.exports = QRMath;
    },
    59280: module => {
      module.exports = {
        MODE_NUMBER: 1,
        MODE_ALPHA_NUM: 2,
        MODE_8BIT_BYTE: 4,
        MODE_KANJI: 8
      };
    },
    98977: (module, __unused_webpack_exports, __webpack_require__) => {
      var QRMath = __webpack_require__(57889);
      function QRPolynomial(num, shift) {
        if (void 0 === num.length) throw new Error(num.length + "/" + shift);
        for (var offset = 0; offset < num.length && 0 === num[offset]; ) offset++;
        this.num = new Array(num.length - offset + shift);
        for (var i = 0; i < num.length - offset; i++) this.num[i] = num[i + offset];
      }
      QRPolynomial.prototype = {
        get: function(index) {
          return this.num[index];
        },
        getLength: function() {
          return this.num.length;
        },
        multiply: function(e) {
          for (var num = new Array(this.getLength() + e.getLength() - 1), i = 0; i < this.getLength(); i++) for (var j = 0; j < e.getLength(); j++) num[i + j] ^= QRMath.gexp(QRMath.glog(this.get(i)) + QRMath.glog(e.get(j)));
          return new QRPolynomial(num, 0);
        },
        mod: function(e) {
          if (this.getLength() - e.getLength() < 0) return this;
          for (var ratio = QRMath.glog(this.get(0)) - QRMath.glog(e.get(0)), num = new Array(this.getLength()), i = 0; i < this.getLength(); i++) num[i] = this.get(i);
          for (var x = 0; x < e.getLength(); x++) num[x] ^= QRMath.gexp(QRMath.glog(e.get(x)) + ratio);
          return new QRPolynomial(num, 0).mod(e);
        }
      }, module.exports = QRPolynomial;
    },
    6685: (module, __unused_webpack_exports, __webpack_require__) => {
      var QRErrorCorrectLevel = __webpack_require__(51434);
      function QRRSBlock(totalCount, dataCount) {
        this.totalCount = totalCount, this.dataCount = dataCount;
      }
      QRRSBlock.RS_BLOCK_TABLE = [ [ 1, 26, 19 ], [ 1, 26, 16 ], [ 1, 26, 13 ], [ 1, 26, 9 ], [ 1, 44, 34 ], [ 1, 44, 28 ], [ 1, 44, 22 ], [ 1, 44, 16 ], [ 1, 70, 55 ], [ 1, 70, 44 ], [ 2, 35, 17 ], [ 2, 35, 13 ], [ 1, 100, 80 ], [ 2, 50, 32 ], [ 2, 50, 24 ], [ 4, 25, 9 ], [ 1, 134, 108 ], [ 2, 67, 43 ], [ 2, 33, 15, 2, 34, 16 ], [ 2, 33, 11, 2, 34, 12 ], [ 2, 86, 68 ], [ 4, 43, 27 ], [ 4, 43, 19 ], [ 4, 43, 15 ], [ 2, 98, 78 ], [ 4, 49, 31 ], [ 2, 32, 14, 4, 33, 15 ], [ 4, 39, 13, 1, 40, 14 ], [ 2, 121, 97 ], [ 2, 60, 38, 2, 61, 39 ], [ 4, 40, 18, 2, 41, 19 ], [ 4, 40, 14, 2, 41, 15 ], [ 2, 146, 116 ], [ 3, 58, 36, 2, 59, 37 ], [ 4, 36, 16, 4, 37, 17 ], [ 4, 36, 12, 4, 37, 13 ], [ 2, 86, 68, 2, 87, 69 ], [ 4, 69, 43, 1, 70, 44 ], [ 6, 43, 19, 2, 44, 20 ], [ 6, 43, 15, 2, 44, 16 ], [ 4, 101, 81 ], [ 1, 80, 50, 4, 81, 51 ], [ 4, 50, 22, 4, 51, 23 ], [ 3, 36, 12, 8, 37, 13 ], [ 2, 116, 92, 2, 117, 93 ], [ 6, 58, 36, 2, 59, 37 ], [ 4, 46, 20, 6, 47, 21 ], [ 7, 42, 14, 4, 43, 15 ], [ 4, 133, 107 ], [ 8, 59, 37, 1, 60, 38 ], [ 8, 44, 20, 4, 45, 21 ], [ 12, 33, 11, 4, 34, 12 ], [ 3, 145, 115, 1, 146, 116 ], [ 4, 64, 40, 5, 65, 41 ], [ 11, 36, 16, 5, 37, 17 ], [ 11, 36, 12, 5, 37, 13 ], [ 5, 109, 87, 1, 110, 88 ], [ 5, 65, 41, 5, 66, 42 ], [ 5, 54, 24, 7, 55, 25 ], [ 11, 36, 12 ], [ 5, 122, 98, 1, 123, 99 ], [ 7, 73, 45, 3, 74, 46 ], [ 15, 43, 19, 2, 44, 20 ], [ 3, 45, 15, 13, 46, 16 ], [ 1, 135, 107, 5, 136, 108 ], [ 10, 74, 46, 1, 75, 47 ], [ 1, 50, 22, 15, 51, 23 ], [ 2, 42, 14, 17, 43, 15 ], [ 5, 150, 120, 1, 151, 121 ], [ 9, 69, 43, 4, 70, 44 ], [ 17, 50, 22, 1, 51, 23 ], [ 2, 42, 14, 19, 43, 15 ], [ 3, 141, 113, 4, 142, 114 ], [ 3, 70, 44, 11, 71, 45 ], [ 17, 47, 21, 4, 48, 22 ], [ 9, 39, 13, 16, 40, 14 ], [ 3, 135, 107, 5, 136, 108 ], [ 3, 67, 41, 13, 68, 42 ], [ 15, 54, 24, 5, 55, 25 ], [ 15, 43, 15, 10, 44, 16 ], [ 4, 144, 116, 4, 145, 117 ], [ 17, 68, 42 ], [ 17, 50, 22, 6, 51, 23 ], [ 19, 46, 16, 6, 47, 17 ], [ 2, 139, 111, 7, 140, 112 ], [ 17, 74, 46 ], [ 7, 54, 24, 16, 55, 25 ], [ 34, 37, 13 ], [ 4, 151, 121, 5, 152, 122 ], [ 4, 75, 47, 14, 76, 48 ], [ 11, 54, 24, 14, 55, 25 ], [ 16, 45, 15, 14, 46, 16 ], [ 6, 147, 117, 4, 148, 118 ], [ 6, 73, 45, 14, 74, 46 ], [ 11, 54, 24, 16, 55, 25 ], [ 30, 46, 16, 2, 47, 17 ], [ 8, 132, 106, 4, 133, 107 ], [ 8, 75, 47, 13, 76, 48 ], [ 7, 54, 24, 22, 55, 25 ], [ 22, 45, 15, 13, 46, 16 ], [ 10, 142, 114, 2, 143, 115 ], [ 19, 74, 46, 4, 75, 47 ], [ 28, 50, 22, 6, 51, 23 ], [ 33, 46, 16, 4, 47, 17 ], [ 8, 152, 122, 4, 153, 123 ], [ 22, 73, 45, 3, 74, 46 ], [ 8, 53, 23, 26, 54, 24 ], [ 12, 45, 15, 28, 46, 16 ], [ 3, 147, 117, 10, 148, 118 ], [ 3, 73, 45, 23, 74, 46 ], [ 4, 54, 24, 31, 55, 25 ], [ 11, 45, 15, 31, 46, 16 ], [ 7, 146, 116, 7, 147, 117 ], [ 21, 73, 45, 7, 74, 46 ], [ 1, 53, 23, 37, 54, 24 ], [ 19, 45, 15, 26, 46, 16 ], [ 5, 145, 115, 10, 146, 116 ], [ 19, 75, 47, 10, 76, 48 ], [ 15, 54, 24, 25, 55, 25 ], [ 23, 45, 15, 25, 46, 16 ], [ 13, 145, 115, 3, 146, 116 ], [ 2, 74, 46, 29, 75, 47 ], [ 42, 54, 24, 1, 55, 25 ], [ 23, 45, 15, 28, 46, 16 ], [ 17, 145, 115 ], [ 10, 74, 46, 23, 75, 47 ], [ 10, 54, 24, 35, 55, 25 ], [ 19, 45, 15, 35, 46, 16 ], [ 17, 145, 115, 1, 146, 116 ], [ 14, 74, 46, 21, 75, 47 ], [ 29, 54, 24, 19, 55, 25 ], [ 11, 45, 15, 46, 46, 16 ], [ 13, 145, 115, 6, 146, 116 ], [ 14, 74, 46, 23, 75, 47 ], [ 44, 54, 24, 7, 55, 25 ], [ 59, 46, 16, 1, 47, 17 ], [ 12, 151, 121, 7, 152, 122 ], [ 12, 75, 47, 26, 76, 48 ], [ 39, 54, 24, 14, 55, 25 ], [ 22, 45, 15, 41, 46, 16 ], [ 6, 151, 121, 14, 152, 122 ], [ 6, 75, 47, 34, 76, 48 ], [ 46, 54, 24, 10, 55, 25 ], [ 2, 45, 15, 64, 46, 16 ], [ 17, 152, 122, 4, 153, 123 ], [ 29, 74, 46, 14, 75, 47 ], [ 49, 54, 24, 10, 55, 25 ], [ 24, 45, 15, 46, 46, 16 ], [ 4, 152, 122, 18, 153, 123 ], [ 13, 74, 46, 32, 75, 47 ], [ 48, 54, 24, 14, 55, 25 ], [ 42, 45, 15, 32, 46, 16 ], [ 20, 147, 117, 4, 148, 118 ], [ 40, 75, 47, 7, 76, 48 ], [ 43, 54, 24, 22, 55, 25 ], [ 10, 45, 15, 67, 46, 16 ], [ 19, 148, 118, 6, 149, 119 ], [ 18, 75, 47, 31, 76, 48 ], [ 34, 54, 24, 34, 55, 25 ], [ 20, 45, 15, 61, 46, 16 ] ], 
      QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
        var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
        if (void 0 === rsBlock) throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
        for (var length = rsBlock.length / 3, list = [], i = 0; i < length; i++) for (var count = rsBlock[3 * i + 0], totalCount = rsBlock[3 * i + 1], dataCount = rsBlock[3 * i + 2], j = 0; j < count; j++) list.push(new QRRSBlock(totalCount, dataCount));
        return list;
      }, QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {
        switch (errorCorrectLevel) {
         case QRErrorCorrectLevel.L:
          return QRRSBlock.RS_BLOCK_TABLE[4 * (typeNumber - 1) + 0];

         case QRErrorCorrectLevel.M:
          return QRRSBlock.RS_BLOCK_TABLE[4 * (typeNumber - 1) + 1];

         case QRErrorCorrectLevel.Q:
          return QRRSBlock.RS_BLOCK_TABLE[4 * (typeNumber - 1) + 2];

         case QRErrorCorrectLevel.H:
          return QRRSBlock.RS_BLOCK_TABLE[4 * (typeNumber - 1) + 3];

         default:
          return;
        }
      }, module.exports = QRRSBlock;
    },
    38588: (module, __unused_webpack_exports, __webpack_require__) => {
      var QRMode = __webpack_require__(59280), QRPolynomial = __webpack_require__(98977), QRMath = __webpack_require__(57889), QRMaskPattern = __webpack_require__(54556), QRUtil = {
        PATTERN_POSITION_TABLE: [ [], [ 6, 18 ], [ 6, 22 ], [ 6, 26 ], [ 6, 30 ], [ 6, 34 ], [ 6, 22, 38 ], [ 6, 24, 42 ], [ 6, 26, 46 ], [ 6, 28, 50 ], [ 6, 30, 54 ], [ 6, 32, 58 ], [ 6, 34, 62 ], [ 6, 26, 46, 66 ], [ 6, 26, 48, 70 ], [ 6, 26, 50, 74 ], [ 6, 30, 54, 78 ], [ 6, 30, 56, 82 ], [ 6, 30, 58, 86 ], [ 6, 34, 62, 90 ], [ 6, 28, 50, 72, 94 ], [ 6, 26, 50, 74, 98 ], [ 6, 30, 54, 78, 102 ], [ 6, 28, 54, 80, 106 ], [ 6, 32, 58, 84, 110 ], [ 6, 30, 58, 86, 114 ], [ 6, 34, 62, 90, 118 ], [ 6, 26, 50, 74, 98, 122 ], [ 6, 30, 54, 78, 102, 126 ], [ 6, 26, 52, 78, 104, 130 ], [ 6, 30, 56, 82, 108, 134 ], [ 6, 34, 60, 86, 112, 138 ], [ 6, 30, 58, 86, 114, 142 ], [ 6, 34, 62, 90, 118, 146 ], [ 6, 30, 54, 78, 102, 126, 150 ], [ 6, 24, 50, 76, 102, 128, 154 ], [ 6, 28, 54, 80, 106, 132, 158 ], [ 6, 32, 58, 84, 110, 136, 162 ], [ 6, 26, 54, 82, 110, 138, 166 ], [ 6, 30, 58, 86, 114, 142, 170 ] ],
        G15: 1335,
        G18: 7973,
        G15_MASK: 21522,
        getBCHTypeInfo: function(data) {
          for (var d = data << 10; QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0; ) d ^= QRUtil.G15 << QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15);
          return (data << 10 | d) ^ QRUtil.G15_MASK;
        },
        getBCHTypeNumber: function(data) {
          for (var d = data << 12; QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0; ) d ^= QRUtil.G18 << QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18);
          return data << 12 | d;
        },
        getBCHDigit: function(data) {
          for (var digit = 0; 0 !== data; ) digit++, data >>>= 1;
          return digit;
        },
        getPatternPosition: function(typeNumber) {
          return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
        },
        getMask: function(maskPattern, i, j) {
          switch (maskPattern) {
           case QRMaskPattern.PATTERN000:
            return (i + j) % 2 == 0;

           case QRMaskPattern.PATTERN001:
            return i % 2 == 0;

           case QRMaskPattern.PATTERN010:
            return j % 3 == 0;

           case QRMaskPattern.PATTERN011:
            return (i + j) % 3 == 0;

           case QRMaskPattern.PATTERN100:
            return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;

           case QRMaskPattern.PATTERN101:
            return i * j % 2 + i * j % 3 == 0;

           case QRMaskPattern.PATTERN110:
            return (i * j % 2 + i * j % 3) % 2 == 0;

           case QRMaskPattern.PATTERN111:
            return (i * j % 3 + (i + j) % 2) % 2 == 0;

           default:
            throw new Error("bad maskPattern:" + maskPattern);
          }
        },
        getErrorCorrectPolynomial: function(errorCorrectLength) {
          for (var a = new QRPolynomial([ 1 ], 0), i = 0; i < errorCorrectLength; i++) a = a.multiply(new QRPolynomial([ 1, QRMath.gexp(i) ], 0));
          return a;
        },
        getLengthInBits: function(mode, type) {
          if (1 <= type && type < 10) switch (mode) {
           case QRMode.MODE_NUMBER:
            return 10;

           case QRMode.MODE_ALPHA_NUM:
            return 9;

           case QRMode.MODE_8BIT_BYTE:
           case QRMode.MODE_KANJI:
            return 8;

           default:
            throw new Error("mode:" + mode);
          } else if (type < 27) switch (mode) {
           case QRMode.MODE_NUMBER:
            return 12;

           case QRMode.MODE_ALPHA_NUM:
            return 11;

           case QRMode.MODE_8BIT_BYTE:
            return 16;

           case QRMode.MODE_KANJI:
            return 10;

           default:
            throw new Error("mode:" + mode);
          } else {
            if (!(type < 41)) throw new Error("type:" + type);
            switch (mode) {
             case QRMode.MODE_NUMBER:
              return 14;

             case QRMode.MODE_ALPHA_NUM:
              return 13;

             case QRMode.MODE_8BIT_BYTE:
              return 16;

             case QRMode.MODE_KANJI:
              return 12;

             default:
              throw new Error("mode:" + mode);
            }
          }
        },
        getLostPoint: function(qrCode) {
          var moduleCount = qrCode.getModuleCount(), lostPoint = 0, row = 0, col = 0;
          for (row = 0; row < moduleCount; row++) for (col = 0; col < moduleCount; col++) {
            for (var sameCount = 0, dark = qrCode.isDark(row, col), r = -1; r <= 1; r++) if (!(row + r < 0 || moduleCount <= row + r)) for (var c = -1; c <= 1; c++) col + c < 0 || moduleCount <= col + c || 0 === r && 0 === c || dark === qrCode.isDark(row + r, col + c) && sameCount++;
            sameCount > 5 && (lostPoint += 3 + sameCount - 5);
          }
          for (row = 0; row < moduleCount - 1; row++) for (col = 0; col < moduleCount - 1; col++) {
            var count = 0;
            qrCode.isDark(row, col) && count++, qrCode.isDark(row + 1, col) && count++, qrCode.isDark(row, col + 1) && count++, 
            qrCode.isDark(row + 1, col + 1) && count++, 0 !== count && 4 !== count || (lostPoint += 3);
          }
          for (row = 0; row < moduleCount; row++) for (col = 0; col < moduleCount - 6; col++) qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) && qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) && qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) && qrCode.isDark(row, col + 6) && (lostPoint += 40);
          for (col = 0; col < moduleCount; col++) for (row = 0; row < moduleCount - 6; row++) qrCode.isDark(row, col) && !qrCode.isDark(row + 1, col) && qrCode.isDark(row + 2, col) && qrCode.isDark(row + 3, col) && qrCode.isDark(row + 4, col) && !qrCode.isDark(row + 5, col) && qrCode.isDark(row + 6, col) && (lostPoint += 40);
          var darkCount = 0;
          for (col = 0; col < moduleCount; col++) for (row = 0; row < moduleCount; row++) qrCode.isDark(row, col) && darkCount++;
          return lostPoint += 10 * (Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5);
        }
      };
      module.exports = QRUtil;
    },
    93245: (module, __unused_webpack_exports, __webpack_require__) => {
      var QR8bitByte = __webpack_require__(31861), QRUtil = __webpack_require__(38588), QRPolynomial = __webpack_require__(98977), QRRSBlock = __webpack_require__(6685), QRBitBuffer = __webpack_require__(99727);
      function QRCode(typeNumber, errorCorrectLevel) {
        this.typeNumber = typeNumber, this.errorCorrectLevel = errorCorrectLevel, this.modules = null, 
        this.moduleCount = 0, this.dataCache = null, this.dataList = [];
      }
      QRCode.prototype = {
        addData: function(data) {
          var newData = new QR8bitByte(data);
          this.dataList.push(newData), this.dataCache = null;
        },
        isDark: function(row, col) {
          if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) throw new Error(row + "," + col);
          return this.modules[row][col];
        },
        getModuleCount: function() {
          return this.moduleCount;
        },
        make: function() {
          if (this.typeNumber < 1) {
            var typeNumber = 1;
            for (typeNumber = 1; typeNumber < 40; typeNumber++) {
              for (var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, this.errorCorrectLevel), buffer = new QRBitBuffer, totalDataCount = 0, i = 0; i < rsBlocks.length; i++) totalDataCount += rsBlocks[i].dataCount;
              for (var x = 0; x < this.dataList.length; x++) {
                var data = this.dataList[x];
                buffer.put(data.mode, 4), buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber)), 
                data.write(buffer);
              }
              if (buffer.getLengthInBits() <= 8 * totalDataCount) break;
            }
            this.typeNumber = typeNumber;
          }
          this.makeImpl(!1, this.getBestMaskPattern());
        },
        makeImpl: function(test, maskPattern) {
          this.moduleCount = 4 * this.typeNumber + 17, this.modules = new Array(this.moduleCount);
          for (var row = 0; row < this.moduleCount; row++) {
            this.modules[row] = new Array(this.moduleCount);
            for (var col = 0; col < this.moduleCount; col++) this.modules[row][col] = null;
          }
          this.setupPositionProbePattern(0, 0), this.setupPositionProbePattern(this.moduleCount - 7, 0), 
          this.setupPositionProbePattern(0, this.moduleCount - 7), this.setupPositionAdjustPattern(), 
          this.setupTimingPattern(), this.setupTypeInfo(test, maskPattern), this.typeNumber >= 7 && this.setupTypeNumber(test), 
          null === this.dataCache && (this.dataCache = QRCode.createData(this.typeNumber, this.errorCorrectLevel, this.dataList)), 
          this.mapData(this.dataCache, maskPattern);
        },
        setupPositionProbePattern: function(row, col) {
          for (var r = -1; r <= 7; r++) if (!(row + r <= -1 || this.moduleCount <= row + r)) for (var c = -1; c <= 7; c++) col + c <= -1 || this.moduleCount <= col + c || (this.modules[row + r][col + c] = 0 <= r && r <= 6 && (0 === c || 6 === c) || 0 <= c && c <= 6 && (0 === r || 6 === r) || 2 <= r && r <= 4 && 2 <= c && c <= 4);
        },
        getBestMaskPattern: function() {
          for (var minLostPoint = 0, pattern = 0, i = 0; i < 8; i++) {
            this.makeImpl(!0, i);
            var lostPoint = QRUtil.getLostPoint(this);
            (0 === i || minLostPoint > lostPoint) && (minLostPoint = lostPoint, pattern = i);
          }
          return pattern;
        },
        createMovieClip: function(target_mc, instance_name, depth) {
          var qr_mc = target_mc.createEmptyMovieClip(instance_name, depth);
          this.make();
          for (var row = 0; row < this.modules.length; row++) for (var y = 1 * row, col = 0; col < this.modules[row].length; col++) {
            var x = 1 * col;
            this.modules[row][col] && (qr_mc.beginFill(0, 100), qr_mc.moveTo(x, y), qr_mc.lineTo(x + 1, y), 
            qr_mc.lineTo(x + 1, y + 1), qr_mc.lineTo(x, y + 1), qr_mc.endFill());
          }
          return qr_mc;
        },
        setupTimingPattern: function() {
          for (var r = 8; r < this.moduleCount - 8; r++) null === this.modules[r][6] && (this.modules[r][6] = r % 2 == 0);
          for (var c = 8; c < this.moduleCount - 8; c++) null === this.modules[6][c] && (this.modules[6][c] = c % 2 == 0);
        },
        setupPositionAdjustPattern: function() {
          for (var pos = QRUtil.getPatternPosition(this.typeNumber), i = 0; i < pos.length; i++) for (var j = 0; j < pos.length; j++) {
            var row = pos[i], col = pos[j];
            if (null === this.modules[row][col]) for (var r = -2; r <= 2; r++) for (var c = -2; c <= 2; c++) 2 === Math.abs(r) || 2 === Math.abs(c) || 0 === r && 0 === c ? this.modules[row + r][col + c] = !0 : this.modules[row + r][col + c] = !1;
          }
        },
        setupTypeNumber: function(test) {
          for (var mod, bits = QRUtil.getBCHTypeNumber(this.typeNumber), i = 0; i < 18; i++) mod = !test && 1 == (bits >> i & 1), 
          this.modules[Math.floor(i / 3)][i % 3 + this.moduleCount - 8 - 3] = mod;
          for (var x = 0; x < 18; x++) mod = !test && 1 == (bits >> x & 1), this.modules[x % 3 + this.moduleCount - 8 - 3][Math.floor(x / 3)] = mod;
        },
        setupTypeInfo: function(test, maskPattern) {
          for (var mod, data = this.errorCorrectLevel << 3 | maskPattern, bits = QRUtil.getBCHTypeInfo(data), v = 0; v < 15; v++) mod = !test && 1 == (bits >> v & 1), 
          v < 6 ? this.modules[v][8] = mod : v < 8 ? this.modules[v + 1][8] = mod : this.modules[this.moduleCount - 15 + v][8] = mod;
          for (var h = 0; h < 15; h++) mod = !test && 1 == (bits >> h & 1), h < 8 ? this.modules[8][this.moduleCount - h - 1] = mod : h < 9 ? this.modules[8][15 - h - 1 + 1] = mod : this.modules[8][15 - h - 1] = mod;
          this.modules[this.moduleCount - 8][8] = !test;
        },
        mapData: function(data, maskPattern) {
          for (var inc = -1, row = this.moduleCount - 1, bitIndex = 7, byteIndex = 0, col = this.moduleCount - 1; col > 0; col -= 2) for (6 === col && col--; ;) {
            for (var c = 0; c < 2; c++) if (null === this.modules[row][col - c]) {
              var dark = !1;
              byteIndex < data.length && (dark = 1 == (data[byteIndex] >>> bitIndex & 1)), QRUtil.getMask(maskPattern, row, col - c) && (dark = !dark), 
              this.modules[row][col - c] = dark, -1 === --bitIndex && (byteIndex++, bitIndex = 7);
            }
            if ((row += inc) < 0 || this.moduleCount <= row) {
              row -= inc, inc = -inc;
              break;
            }
          }
        }
      }, QRCode.PAD0 = 236, QRCode.PAD1 = 17, QRCode.createData = function(typeNumber, errorCorrectLevel, dataList) {
        for (var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel), buffer = new QRBitBuffer, i = 0; i < dataList.length; i++) {
          var data = dataList[i];
          buffer.put(data.mode, 4), buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber)), 
          data.write(buffer);
        }
        for (var totalDataCount = 0, x = 0; x < rsBlocks.length; x++) totalDataCount += rsBlocks[x].dataCount;
        if (buffer.getLengthInBits() > 8 * totalDataCount) throw new Error("code length overflow. (" + buffer.getLengthInBits() + ">" + 8 * totalDataCount + ")");
        for (buffer.getLengthInBits() + 4 <= 8 * totalDataCount && buffer.put(0, 4); buffer.getLengthInBits() % 8 != 0; ) buffer.putBit(!1);
        for (;!(buffer.getLengthInBits() >= 8 * totalDataCount || (buffer.put(QRCode.PAD0, 8), 
        buffer.getLengthInBits() >= 8 * totalDataCount)); ) buffer.put(QRCode.PAD1, 8);
        return QRCode.createBytes(buffer, rsBlocks);
      }, QRCode.createBytes = function(buffer, rsBlocks) {
        for (var offset = 0, maxDcCount = 0, maxEcCount = 0, dcdata = new Array(rsBlocks.length), ecdata = new Array(rsBlocks.length), r = 0; r < rsBlocks.length; r++) {
          var dcCount = rsBlocks[r].dataCount, ecCount = rsBlocks[r].totalCount - dcCount;
          maxDcCount = Math.max(maxDcCount, dcCount), maxEcCount = Math.max(maxEcCount, ecCount), 
          dcdata[r] = new Array(dcCount);
          for (var i = 0; i < dcdata[r].length; i++) dcdata[r][i] = 255 & buffer.buffer[i + offset];
          offset += dcCount;
          var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount), modPoly = new QRPolynomial(dcdata[r], rsPoly.getLength() - 1).mod(rsPoly);
          ecdata[r] = new Array(rsPoly.getLength() - 1);
          for (var x = 0; x < ecdata[r].length; x++) {
            var modIndex = x + modPoly.getLength() - ecdata[r].length;
            ecdata[r][x] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
          }
        }
        for (var totalCodeCount = 0, y = 0; y < rsBlocks.length; y++) totalCodeCount += rsBlocks[y].totalCount;
        for (var data = new Array(totalCodeCount), index = 0, z = 0; z < maxDcCount; z++) for (var s = 0; s < rsBlocks.length; s++) z < dcdata[s].length && (data[index++] = dcdata[s][z]);
        for (var xx = 0; xx < maxEcCount; xx++) for (var t = 0; t < rsBlocks.length; t++) xx < ecdata[t].length && (data[index++] = ecdata[t][xx]);
        return data;
      }, module.exports = QRCode;
    },
    75781: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      const strictUriEncode = __webpack_require__(45278), decodeComponent = __webpack_require__(50639), splitOnFirst = __webpack_require__(74615), filterObject = __webpack_require__(39866);
      function validateArrayFormatSeparator(value) {
        if ("string" != typeof value || 1 !== value.length) throw new TypeError("arrayFormatSeparator must be single character string");
      }
      function encode(value, options) {
        return options.encode ? options.strict ? strictUriEncode(value) : encodeURIComponent(value) : value;
      }
      function decode(value, options) {
        return options.decode ? decodeComponent(value) : value;
      }
      function keysSorter(input) {
        return Array.isArray(input) ? input.sort() : "object" == typeof input ? keysSorter(Object.keys(input)).sort(((a, b) => Number(a) - Number(b))).map((key => input[key])) : input;
      }
      function removeHash(input) {
        const hashStart = input.indexOf("#");
        return -1 !== hashStart && (input = input.slice(0, hashStart)), input;
      }
      function extract(input) {
        const queryStart = (input = removeHash(input)).indexOf("?");
        return -1 === queryStart ? "" : input.slice(queryStart + 1);
      }
      function parseValue(value, options) {
        return options.parseNumbers && !Number.isNaN(Number(value)) && "string" == typeof value && "" !== value.trim() ? value = Number(value) : !options.parseBooleans || null === value || "true" !== value.toLowerCase() && "false" !== value.toLowerCase() || (value = "true" === value.toLowerCase()), 
        value;
      }
      function parse(query, options) {
        validateArrayFormatSeparator((options = Object.assign({
          decode: !0,
          sort: !0,
          arrayFormat: "none",
          arrayFormatSeparator: ",",
          parseNumbers: !1,
          parseBooleans: !1
        }, options)).arrayFormatSeparator);
        const formatter = function(options) {
          let result;
          switch (options.arrayFormat) {
           case "index":
            return (key, value, accumulator) => {
              result = /\[(\d*)\]$/.exec(key), key = key.replace(/\[\d*\]$/, ""), result ? (void 0 === accumulator[key] && (accumulator[key] = {}), 
              accumulator[key][result[1]] = value) : accumulator[key] = value;
            };

           case "bracket":
            return (key, value, accumulator) => {
              result = /(\[\])$/.exec(key), key = key.replace(/\[\]$/, ""), result ? void 0 !== accumulator[key] ? accumulator[key] = [].concat(accumulator[key], value) : accumulator[key] = [ value ] : accumulator[key] = value;
            };

           case "comma":
           case "separator":
            return (key, value, accumulator) => {
              const isArray = "string" == typeof value && value.includes(options.arrayFormatSeparator), isEncodedArray = "string" == typeof value && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
              value = isEncodedArray ? decode(value, options) : value;
              const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item => decode(item, options))) : null === value ? value : decode(value, options);
              accumulator[key] = newValue;
            };

           default:
            return (key, value, accumulator) => {
              void 0 !== accumulator[key] ? accumulator[key] = [].concat(accumulator[key], value) : accumulator[key] = value;
            };
          }
        }(options), ret = Object.create(null);
        if ("string" != typeof query) return ret;
        if (!(query = query.trim().replace(/^[?#&]/, ""))) return ret;
        for (const param of query.split("&")) {
          if ("" === param) continue;
          let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
          value = void 0 === value ? null : [ "comma", "separator" ].includes(options.arrayFormat) ? value : decode(value, options), 
          formatter(decode(key, options), value, ret);
        }
        for (const key of Object.keys(ret)) {
          const value = ret[key];
          if ("object" == typeof value && null !== value) for (const k of Object.keys(value)) value[k] = parseValue(value[k], options); else ret[key] = parseValue(value, options);
        }
        return !1 === options.sort ? ret : (!0 === options.sort ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce(((result, key) => {
          const value = ret[key];
          return Boolean(value) && "object" == typeof value && !Array.isArray(value) ? result[key] = keysSorter(value) : result[key] = value, 
          result;
        }), Object.create(null));
      }
      exports.extract = extract, exports.parse = parse, exports.stringify = (object, options) => {
        if (!object) return "";
        validateArrayFormatSeparator((options = Object.assign({
          encode: !0,
          strict: !0,
          arrayFormat: "none",
          arrayFormatSeparator: ","
        }, options)).arrayFormatSeparator);
        const shouldFilter = key => options.skipNull && null == object[key] || options.skipEmptyString && "" === object[key], formatter = function(options) {
          switch (options.arrayFormat) {
           case "index":
            return key => (result, value) => {
              const index = result.length;
              return void 0 === value || options.skipNull && null === value || options.skipEmptyString && "" === value ? result : null === value ? [ ...result, [ encode(key, options), "[", index, "]" ].join("") ] : [ ...result, [ encode(key, options), "[", encode(index, options), "]=", encode(value, options) ].join("") ];
            };

           case "bracket":
            return key => (result, value) => void 0 === value || options.skipNull && null === value || options.skipEmptyString && "" === value ? result : null === value ? [ ...result, [ encode(key, options), "[]" ].join("") ] : [ ...result, [ encode(key, options), "[]=", encode(value, options) ].join("") ];

           case "comma":
           case "separator":
            return key => (result, value) => null == value || 0 === value.length ? result : 0 === result.length ? [ [ encode(key, options), "=", encode(value, options) ].join("") ] : [ [ result, encode(value, options) ].join(options.arrayFormatSeparator) ];

           default:
            return key => (result, value) => void 0 === value || options.skipNull && null === value || options.skipEmptyString && "" === value ? result : null === value ? [ ...result, encode(key, options) ] : [ ...result, [ encode(key, options), "=", encode(value, options) ].join("") ];
          }
        }(options), objectCopy = {};
        for (const key of Object.keys(object)) shouldFilter(key) || (objectCopy[key] = object[key]);
        const keys = Object.keys(objectCopy);
        return !1 !== options.sort && keys.sort(options.sort), keys.map((key => {
          const value = object[key];
          return void 0 === value ? "" : null === value ? encode(key, options) : Array.isArray(value) ? value.reduce(formatter(key), []).join("&") : encode(key, options) + "=" + encode(value, options);
        })).filter((x => x.length > 0)).join("&");
      }, exports.parseUrl = (url, options) => {
        options = Object.assign({
          decode: !0
        }, options);
        const [url_, hash] = splitOnFirst(url, "#");
        return Object.assign({
          url: url_.split("?")[0] || "",
          query: parse(extract(url), options)
        }, options && options.parseFragmentIdentifier && hash ? {
          fragmentIdentifier: decode(hash, options)
        } : {});
      }, exports.stringifyUrl = (object, options) => {
        options = Object.assign({
          encode: !0,
          strict: !0
        }, options);
        const url = removeHash(object.url).split("?")[0] || "", queryFromUrl = exports.extract(object.url), parsedQueryFromUrl = exports.parse(queryFromUrl, {
          sort: !1
        }), query = Object.assign(parsedQueryFromUrl, object.query);
        let queryString = exports.stringify(query, options);
        queryString && (queryString = `?${queryString}`);
        let hash = function(url) {
          let hash = "";
          const hashStart = url.indexOf("#");
          return -1 !== hashStart && (hash = url.slice(hashStart)), hash;
        }(object.url);
        return object.fragmentIdentifier && (hash = `#${encode(object.fragmentIdentifier, options)}`), 
        `${url}${queryString}${hash}`;
      }, exports.pick = (input, filter, options) => {
        options = Object.assign({
          parseFragmentIdentifier: !0
        }, options);
        const {url, query, fragmentIdentifier} = exports.parseUrl(input, options);
        return exports.stringifyUrl({
          url,
          query: filterObject(query, filter),
          fragmentIdentifier
        }, options);
      }, exports.exclude = (input, filter, options) => {
        const exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);
        return exports.pick(input, exclusionFilter, options);
      };
    },
    63191: module => {
      "use strict";
      function appendLast(arr, str) {
        var last = arr.length - 1;
        if (!(last < 0)) {
          var lastValue = String(arr[last]);
          return arr[last] = lastValue + String(str);
        }
        arr.push(str);
      }
      module.exports = function() {
        if (!arguments[0].raw) throw new Error("qw is only usable as a tagged template literal");
        const args = Object.assign([], arguments[0]), values = [].slice.call(arguments, 1), words = [];
        let lastWordWasValue = !1;
        for (;args.length; ) {
          const arg = args.shift(), concatValue = 0 === arg.length || " " !== arg.slice(-1);
          if ("" !== arg.trim()) {
            const theseWords = arg.replace(/^\s+|\s+$/g, "").replace(/\s+/g, " ").split(/ /);
            lastWordWasValue && " " !== arg[0] && appendLast(words, theseWords.shift()), words.push.apply(words, theseWords);
          }
          if (values.length) {
            const val = values.shift();
            concatValue ? appendLast(words, val) : words.push(val), lastWordWasValue = !0;
          } else lastWordWasValue = !1;
        }
        return words;
      };
    },
    11093: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var fs = __webpack_require__(59799);
      function extractPath(path, cmdshimContents) {
        return /[.]cmd$/.test(path) ? function(cmdshimContents) {
          var matches = cmdshimContents.match(/"%(?:~dp0|dp0%)\\([^"]+?)"\s+%[*]/);
          return matches && matches[1];
        }(cmdshimContents) : /[.]ps1$/.test(path) ? function(cmdshimContents) {
          var matches = cmdshimContents.match(/"[$]basedir[/]([^"]+?)"\s+[$]args/);
          return matches && matches[1];
        }(cmdshimContents) : function(cmdshimContents) {
          var matches = cmdshimContents.match(/"[$]basedir[/]([^"]+?)"\s+"[$]@"/);
          return matches && matches[1];
        }(cmdshimContents);
      }
      function notaShim(path, er) {
        return er || (er = new Error, Error.captureStackTrace(er, notaShim)), er.code = "ENOTASHIM", 
        er.message = "Can't read shim path from '" + path + "', it doesn't appear to be a cmd-shim", 
        er;
      }
      var readCmdShim = module.exports = function(path, cb) {
        var er = new Error;
        Error.captureStackTrace(er, readCmdShim), fs.readFile(path, (function(readFileEr, contents) {
          if (readFileEr) return cb((thrown = readFileEr, (newError = er).message = thrown.message, 
          newError.code = thrown.code, newError));
          var thrown, newError, destination = extractPath(path, contents.toString());
          return destination ? cb(null, destination) : cb(notaShim(path, er));
        }));
      };
      module.exports.sync = function(path) {
        var destination = extractPath(path, fs.readFileSync(path).toString());
        if (!destination) throw notaShim(path);
        return destination;
      };
    },
    6576: (module, __unused_webpack_exports, __webpack_require__) => {
      try {
        var fs = __webpack_require__(59799);
      } catch (er) {
        fs = __webpack_require__(57147);
      }
      var path = __webpack_require__(71017), asyncMap = __webpack_require__(89009).asyncMap, semver = __webpack_require__(73107), readJson = __webpack_require__(92200), extend = (__webpack_require__(57310), 
      __webpack_require__(73837), __webpack_require__(36719)), debug = __webpack_require__(1468)("read-installed"), readdir = __webpack_require__(51981), ANY = {};
      function readInstalled_(folder, parent, name, reqver, depth, opts, cb) {
        var installed, obj, real, link, realpathSeen = opts.realpathSeen;
        readdir(path.resolve(folder, "node_modules"), (function(er, i) {
          er && (i = []), installed = i.filter((function(f) {
            return "." !== f.charAt(0);
          })), next();
        })), readJson(path.resolve(folder, "package.json"), (function(er, data) {
          return obj = copy(data), parent || (obj = obj || !0, er = null), next(er);
        })), fs.lstat(folder, (function(er, st) {
          if (er) return parent || (real = !0), next(er);
          fs.realpath(folder, (function(er, rp) {
            debug("realpath(%j) = %j", folder, rp), real = rp, st.isSymbolicLink() && (link = rp), 
            next(er);
          }));
        }));
        var errState = null, called = !1;
        function next(er) {
          if (!errState) {
            if (er) return errState = er, cb(null, []);
            if (debug("next", installed, obj && typeof obj, name, real), installed && obj && real && !called) {
              if (called = !0, realpathSeen[real]) return cb(null, realpathSeen[real]);
              !0 === obj && (obj = {
                dependencies: {},
                path: folder
              }, installed.forEach((function(i) {
                obj.dependencies[i] = ANY;
              }))), name && obj.name !== name && (obj.invalid = !0), obj.realName = name || obj.name, 
              obj.dependencies = obj.dependencies || {}, obj._dependencies = copy(obj.dependencies), 
              reqver === ANY && (reqver = obj.version), reqver && semver.validRange(reqver, !0) && !semver.satisfies(obj.version, reqver, !0) && (obj.invalid = !0), 
              obj.extraneous = !0, obj.path = obj.path || folder, obj.realPath = real, obj.link = link, 
              parent && !obj.link && (obj.parent = parent), realpathSeen[real] = obj, obj.depth = depth, 
              asyncMap(installed, (function(pkg, cb) {
                var rv = obj.dependencies[pkg];
                if (!rv && obj.devDependencies && opts.dev && (rv = obj.devDependencies[pkg]), depth > opts.depth) return obj.dependencies = {}, 
                cb(null, obj);
                readInstalled_(path.resolve(folder, "node_modules/" + pkg), obj, pkg, obj.dependencies[pkg], depth + 1, opts, cb);
              }), (function(er, installedData) {
                return er ? cb(er) : (installedData.forEach((function(dep) {
                  obj.dependencies[dep.realName] = dep;
                })), obj.optionalDependencies && Object.keys(obj.optionalDependencies).forEach((function(dep) {
                  "string" == typeof obj.dependencies[dep] && delete obj.dependencies[dep];
                })), cb(null, obj));
              }));
            }
          }
        }
      }
      module.exports = function(folder, opts, cb) {
        "function" == typeof opts ? (cb = opts, opts = {}) : opts = extend({}, opts);
        "number" != typeof opts.depth && (opts.depth = 1 / 0);
        opts.depth = Math.max(0, opts.depth), "function" != typeof opts.log && (opts.log = function() {});
        opts.dev = !!opts.dev, opts.realpathSeen = {}, opts.findUnmetSeen = [], readInstalled_(folder, null, null, null, 0, opts, (function(er, obj) {
          if (er) return cb(er);
          resolveInheritance(obj, opts), obj.root = !0, unmarkExtraneous(obj, opts), cb(null, obj);
        }));
      };
      var riSeen = [];
      function resolveInheritance(obj, opts) {
        "object" == typeof obj && -1 === riSeen.indexOf(obj) && (riSeen.push(obj), "object" != typeof obj.dependencies && (obj.dependencies = {}), 
        Object.keys(obj.dependencies).forEach((function(dep) {
          findUnmet(obj.dependencies[dep], opts);
        })), Object.keys(obj.dependencies).forEach((function(dep) {
          "object" == typeof obj.dependencies[dep] ? resolveInheritance(obj.dependencies[dep], opts) : debug("unmet dep! %s %s@%s", obj.name, dep, obj.dependencies[dep]);
        })), findUnmet(obj, opts));
      }
      function findUnmet(obj, opts) {
        var findUnmetSeen = opts.findUnmetSeen;
        if (-1 === findUnmetSeen.indexOf(obj)) {
          findUnmetSeen.push(obj), debug("find unmet parent=%s obj=", obj.parent && obj.parent.name, obj.name || obj);
          var deps = obj.dependencies = obj.dependencies || {};
          debug(deps), Object.keys(deps).filter((function(d) {
            return "string" == typeof deps[d];
          })).forEach((function(d) {
            var found = findDep(obj, d);
            debug("finding dep %j", d, found && found.name || found), "string" == typeof deps[d] && semver.validRange(deps[d], !0) && found && !semver.satisfies(found.version, deps[d], !0) && (opts.log("unmet dependency", obj.path + " requires " + d + "@'" + deps[d] + "' but will load\n" + found.path + ",\nwhich is version " + found.version), 
            found.invalid = !0), found && (deps[d] = found);
          }));
          var peerDeps = obj.peerDependencies = obj.peerDependencies || {};
          return Object.keys(peerDeps).forEach((function(d) {
            var dependency;
            if (obj.parent) for (var r = obj.parent; r && !dependency; ) dependency = r.dependencies && r.dependencies[d], 
            r = r.link ? null : r.parent; else (dependency = obj.dependencies[d]) || (obj.dependencies[d] = peerDeps[d]);
            dependency ? semver.satisfies(dependency.version, peerDeps[d], !0) || (dependency.peerInvalid = !0) : obj.dependencies[d] = peerDeps[d];
          })), obj;
        }
      }
      function unmarkExtraneous(obj, opts) {
        obj.extraneous = !1;
        var deps = obj._dependencies || [];
        opts.dev && obj.devDependencies && (obj.root || obj.link) && Object.keys(obj.devDependencies).forEach((function(k) {
          deps[k] = obj.devDependencies[k];
        })), obj.peerDependencies && Object.keys(obj.peerDependencies).forEach((function(k) {
          deps[k] = obj.peerDependencies[k];
        })), debug("not extraneous", obj._id, deps), Object.keys(deps).forEach((function(d) {
          var dep = findDep(obj, d);
          dep && dep.extraneous && unmarkExtraneous(dep, opts);
        }));
      }
      function findDep(obj, d) {
        for (var r = obj, found = null; r && !found; ) "object" == typeof r.dependencies[d] && (found = r.dependencies[d]), 
        found || r.realName !== d || (found = r), r = r.link ? null : r.parent;
        return found;
      }
      function copy(obj) {
        if (!obj || "object" != typeof obj) return obj;
        if (Array.isArray(obj)) return obj.map(copy);
        var o = {};
        for (var i in obj) o[i] = copy(obj[i]);
        return o;
      }
    },
    92200: (module, __unused_webpack_exports, __webpack_require__) => {
      var fs = __webpack_require__(57147), path = __webpack_require__(71017), glob = __webpack_require__(34436), normalizeData = __webpack_require__(17770), safeJSON = __webpack_require__(40295), util = __webpack_require__(73837), normalizePackageBin = __webpack_require__(71921);
      module.exports = readJson, readJson.extraSet = [ function(file, data, cb) {
        var bd = "bundleDependencies", bdd = "bundledDependencies";
        void 0 !== data[bdd] && (void 0 === data[bd] && (data[bd] = data[bdd]), delete data[bdd]);
        !1 === data[bd] ? delete data[bd] : !0 === data[bd] ? data[bd] = Object.keys(data.dependencies || {}) : void 0 === data[bd] || Array.isArray(data[bd]) || delete data[bd];
        return cb(null, data);
      }, function(file, data, cb) {
        var dir = path.dirname(file), s = data.scripts || {};
        if (s.install || s.preinstall) return cb(null, data);
        glob("*.gyp", {
          cwd: dir
        }, (function(er, files) {
          return er ? cb(er) : !1 === data.gypfile ? cb(null, data) : void function(file, data, files, cb) {
            if (!files.length) return cb(null, data);
            var s = data.scripts || {};
            s.install = "node-gyp rebuild", data.scripts = s, data.gypfile = !0, cb(null, data);
          }(0, data, files, cb);
        }));
      }, function(file, data, cb) {
        var dir = path.dirname(file);
        if ((data.scripts || {}).start) return cb(null, data);
        glob("server.js", {
          cwd: dir
        }, (function(er, files) {
          if (er) return cb(er);
          !function(file, data, files, cb) {
            if (!files.length) return cb(null, data);
            var s = data.scripts || {};
            s.start = "node server.js", data.scripts = s, cb(null, data);
          }(0, data, files, cb);
        }));
      }, function(file, data, cb) {
        if (!data.scripts) return cb(null, data);
        Object.keys(data.scripts).forEach(scriptpath_, data.scripts), cb(null, data);
      }, function(file, data, cb) {
        if (data.contributors) return cb(null, data);
        var af = path.resolve(path.dirname(file), "AUTHORS");
        fs.readFile(af, "utf8", (function(er, ad) {
          if (er) return cb(null, data);
          !function(file, data, ad, cb) {
            ad = ad.split(/\r?\n/g).map((function(line) {
              return line.replace(/^\s*#.*$/, "").trim();
            })).filter((function(line) {
              return line;
            })), data.contributors = ad, cb(null, data);
          }(0, data, ad, cb);
        }));
      }, function(file, data, cb) {
        if (data.readme) return cb(null, data);
        var dir = path.dirname(file);
        glob("{README,README.*}", {
          cwd: dir,
          nocase: !0,
          mark: !0
        }, (function(er, files) {
          if (er) return cb(er);
          if (files = files.filter((function(file) {
            return !file.match(/\/$/);
          })), !files.length) return cb();
          var fn = function(files) {
            for (var fallback = 0, re = /\.m?a?r?k?d?o?w?n?$/i, i = 0; i < files.length; i++) {
              if (files[i].match(re)) return files[i];
              files[i].match(/README$/) && (fallback = i);
            }
            return files[fallback];
          }(files), rm = path.resolve(dir, fn);
          !function(file, data, rm, cb) {
            var rmfn = path.basename(rm);
            fs.readFile(rm, "utf8", (function(er, rm) {
              return er ? cb() : (data.readme = rm, data.readmeFilename = rmfn, cb(er, data));
            }));
          }(0, data, rm, cb);
        }));
      }, function(file, data, cb) {
        var m = data.directories && data.directories.man;
        if (data.man || !m) return cb(null, data);
        m = path.resolve(path.dirname(file), m), glob("**/*.[0-9]", {
          cwd: m
        }, (function(er, mans) {
          if (er) return cb(er);
          !function(file, data, mans, cb) {
            var m = data.directories && data.directories.man;
            data.man = mans.map((function(mf) {
              return path.resolve(path.dirname(file), m, mf);
            })), cb(null, data);
          }(file, data, mans, cb);
        }));
      }, function(file, data, cb) {
        var m = (data = normalizePackageBin(data)).directories && data.directories.bin;
        if (data.bin || !m) return cb(null, data);
        m = path.resolve(path.dirname(file), m), glob("**", {
          cwd: m
        }, (function(er, bins) {
          if (er) return cb(er);
          !function(file, data, bins, cb) {
            var m = data.directories && data.directories.bin || ".";
            data.bin = bins.reduce((function(acc, mf) {
              mf && "." !== mf.charAt(0) && (acc[path.basename(mf)] = path.join(m, mf));
              return acc;
            }), {}), cb(null, normalizePackageBin(data));
          }(0, data, bins, cb);
        }));
      }, function(file, data, cb) {
        if (data.gitHead) return cb(null, data);
        var dir = path.dirname(file), head = path.resolve(dir, ".git/HEAD");
        fs.readFile(head, "utf8", (function(er, head) {
          if (er) return cb(null, data);
          !function(file, data, dir, head, cb) {
            if (!head.match(/^ref: /)) return data.gitHead = head.trim(), cb(null, data);
            var headRef = head.replace(/^ref: /, "").trim(), headFile = path.resolve(dir, ".git", headRef);
            fs.readFile(headFile, "utf8", (function(er, head) {
              if (er || !head) {
                var packFile = path.resolve(dir, ".git/packed-refs");
                return fs.readFile(packFile, "utf8", (function(er, refs) {
                  if (er || !refs) return cb(null, data);
                  refs = refs.split("\n");
                  for (var i = 0; i < refs.length; i++) {
                    var match = refs[i].match(/^([0-9a-f]{40}) (.+)$/);
                    if (match && match[2].trim() === headRef) {
                      data.gitHead = match[1];
                      break;
                    }
                  }
                  return cb(null, data);
                }));
              }
              return head = head.replace(/^ref: /, "").trim(), data.gitHead = head, cb(null, data);
            }));
          }(0, data, dir, head, cb);
        }));
      } ];
      var typoWarned = {}, cache = {};
      function readJson(file, log_, strict_, cb_) {
        for (var log, strict, i = 1; i < arguments.length - 1; i++) "boolean" == typeof arguments[i] ? strict = arguments[i] : "function" == typeof arguments[i] && (log = arguments[i]);
        log || (log = function() {}), readJson_(file, log, strict, arguments[arguments.length - 1]);
      }
      function readJson_(file, log, strict, cb) {
        fs.readFile(file, "utf8", (function(er, d) {
          !function(file, er, d, log, strict, cb) {
            if (er && "ENOENT" === er.code) return fs.stat(path.dirname(file), (function(err, stat) {
              return err || !stat || stat.isDirectory() ? function(file, er, log, strict, cb) {
                if ("index.js" === path.basename(file)) return cb(er);
                var index = path.resolve(path.dirname(file), "index.js");
                fs.readFile(index, "utf8", (function(er2, d) {
                  if (er2) return cb(er);
                  if (cache[d]) return cb(null, cache[d]);
                  var data = parseIndex(d);
                  if (!data) return cb(er);
                  extrasCached(file, d, data, log, strict, cb);
                }));
              }(file, er, log, strict, cb) : ((er = Object.create(er)).code = "ENOTDIR", cb(er));
            }));
            if (er) return cb(er);
            if (cache[d]) return cb(null, jsonClone(cache[d]));
            var data;
            try {
              data = safeJSON(function(content) {
                65279 === content.charCodeAt(0) && (content = content.slice(1));
                return content;
              }(d));
            } catch (er) {
              if (!(data = parseIndex(d))) return cb(function(ex, file) {
                var e = new Error("Failed to parse json\n" + ex.message);
                return e.code = "EJSONPARSE", e.file = file, e;
              }(er, file));
            }
            extrasCached(file, d, data, log, strict, cb);
          }(file, er, d, log, strict, cb);
        }));
      }
      function jsonClone(obj) {
        if (null == obj) return obj;
        if (Array.isArray(obj)) {
          var newarr = new Array(obj.length);
          for (var ii in obj) newarr[ii] = obj[ii];
        } else {
          if ("object" != typeof obj) return obj;
          var newobj = {};
          for (var kk in obj) newobj[kk] = jsonClone[kk];
        }
      }
      function extrasCached(file, d, data, log, strict, cb) {
        extras(file, data, log, strict, (function(err, data) {
          err || (cache[d] = jsonClone(data)), cb(err, data);
        }));
      }
      function extras(file, data, log_, strict_, cb_) {
        for (var log, strict, cb, i = 2; i < arguments.length - 1; i++) "boolean" == typeof arguments[i] ? strict = arguments[i] : "function" == typeof arguments[i] && (log = arguments[i]);
        log || (log = function() {}), cb = arguments[i];
        var set = readJson.extraSet, n = set.length, errState = null;
        function then(er) {
          if (!errState) return er ? cb(errState = er) : void (--n > 0 || final(file, data, log, strict, cb));
        }
        set.forEach((function(fn) {
          fn(file, data, then);
        }));
      }
      function scriptpath_(key) {
        var s = this[key];
        if ("string" != typeof s) return delete this[key];
        var spre = /^(\.[/\\])?node_modules[/\\].bin[\\/]/;
        s.match(spre) && (this[key] = this[key].replace(spre, ""));
      }
      function final(file, data, log, strict, cb) {
        var pId = function(data) {
          var name = cleanString(data.name), ver = cleanString(data.version);
          return name + "@" + ver;
        }(data);
        function warn(msg) {
          typoWarned[pId] || log && log("package.json", pId, msg);
        }
        try {
          normalizeData(data, warn, strict);
        } catch (error) {
          return cb(error);
        }
        !function(file, data, warn, cb) {
          if (!(data.bin instanceof Object)) return cb();
          var keys = Object.keys(data.bin), keysLeft = keys.length;
          if (!keysLeft) return cb();
          function handleExists(relName, result) {
            keysLeft--, result || warn("No bin file found at " + relName), keysLeft || cb();
          }
          keys.forEach((function(key) {
            var dirName = path.dirname(file), relName = data.bin[key];
            if ("string" != typeof relName) {
              var msg = "Bin filename for " + key + " is not a string: " + util.inspect(relName);
              return warn(msg), delete data.bin[key], void handleExists(relName, !0);
            }
            var binPath = path.resolve(dirName, relName);
            fs.stat(binPath, (err => handleExists(relName, !err)));
          }));
        }(file, data, warn, (function() {
          typoWarned[pId] = !0, cb(null, data);
        }));
      }
      function cleanString(str) {
        return str && "string" == typeof str ? str.trim() : "";
      }
      function parseIndex(data) {
        if ((data = data.split(/^\/\*\*package(?:\s|$)/m)).length < 2) return null;
        if ((data = (data = data[1]).split(/\*\*\/$/m)).length < 2) return null;
        data = (data = data[0]).replace(/^\s*\*/gm, "");
        try {
          return safeJSON(data);
        } catch (er) {
          return null;
        }
      }
      readJson.extras = extras;
    },
    94032: (module, __unused_webpack_exports, __webpack_require__) => {
      const fs = __webpack_require__(57147), promisify = __webpack_require__(73837).promisify || __webpack_require__(28429), readlink = promisify(fs.readlink), lstat = promisify(fs.lstat), {resolve, basename, dirname} = __webpack_require__(71017), realpathCached = (path, rpcache, stcache, depth) => {
        if (depth > 2e3) throw eloop(path);
        if (path = resolve(path), rpcache.has(path)) return Promise.resolve(rpcache.get(path));
        const dir = dirname(path), base = basename(path);
        return base && rpcache.has(dir) ? realpathChild(dir, base, rpcache, stcache, depth) : base ? realpathCached(dir, rpcache, stcache, depth + 1).then((() => realpathCached(path, rpcache, stcache, depth + 1))) : (rpcache.set(dir, dir), 
        Promise.resolve(dir));
      }, eloop = path => Object.assign(new Error(`ELOOP: too many symbolic links encountered, stat '${path}'`), {
        errno: -62,
        syscall: "stat",
        code: "ELOOP",
        path
      }), realpathChild = (dir, base, rpcache, stcache, depth) => {
        const realdir = rpcache.get(dir);
        if (void 0 === realdir) throw new Error("in realpathChild without parent being in realpath cache");
        const realish = resolve(realdir, base);
        return ((path, stcache) => {
          if (stcache.has(path)) return Promise.resolve(stcache.get(path));
          const p = lstat(path).then((st => (stcache.set(path, st), st)));
          return stcache.set(path, p), p;
        })(realish, stcache).then((st => {
          if (!st.isSymbolicLink()) return rpcache.set(resolve(dir, base), realish), realish;
          let res;
          return readlink(realish).then((target => {
            const resolved = res = resolve(realdir, target);
            if (realish === resolved) throw eloop(realish);
            return realpathCached(resolved, rpcache, stcache, depth + 1);
          })).then((real => (rpcache.set(resolve(dir, base), real), real)));
        }));
      };
      module.exports = realpathCached;
    },
    7338: (module, __unused_webpack_exports, __webpack_require__) => {
      const promisify = __webpack_require__(73837).promisify || __webpack_require__(28429), {resolve, basename, dirname, join} = __webpack_require__(71017), rpj = promisify(__webpack_require__(92200)), readdir = promisify(__webpack_require__(51981)), realpath = __webpack_require__(94032);
      let ID = 0;
      class Node {
        constructor(pkg, logical, physical, er, cache) {
          const cached = cache.get(physical);
          if (cached && !cached.then) throw new Error("re-creating already instantiated node");
          cache.set(physical, this);
          const parent = basename(dirname(logical));
          "@" === parent.charAt(0) ? this.name = `${parent}/${basename(logical)}` : this.name = basename(logical), 
          this.path = logical, this.realpath = physical, this.error = er, this.id = ID++, 
          this.package = pkg || {}, this.parent = null, this.isLink = !1, this.children = [];
        }
      }
      class Link extends Node {
        constructor(pkg, logical, physical, realpath, er, cache) {
          super(pkg, logical, physical, er, cache);
          const cachedTarget = cache.get(realpath);
          cachedTarget && cachedTarget.then && cachedTarget.then((node => {
            this.target = node, this.children = node.children;
          })), this.target = cachedTarget || new Node(pkg, logical, realpath, er, cache), 
          this.realpath = realpath, this.isLink = !0, this.error = er, this.children = this.target.children;
        }
      }
      const loadNode = (logical, physical, cache, rpcache, stcache) => {
        const cached = cache.get(physical);
        if (cached) return Promise.resolve(cached);
        const p = realpath(physical, rpcache, stcache, 0).then((real => rpj(join(real, "package.json")).then((pkg => [ pkg, null ]), (er => [ null, er ])).then((([pkg, er]) => physical === real ? ((pkg, logical, physical, er, cache) => "1" === process.env._TEST_RPT_SLOW_LINK_TARGET_ ? new Promise((res => setTimeout((() => res(new Node(pkg, logical, physical, er, cache))), 10))) : new Node(pkg, logical, physical, er, cache))(pkg, logical, physical, er, cache) : new Link(pkg, logical, physical, real, er, cache)))), (er => new Node(null, logical, physical, er, cache)));
        return cache.set(physical, p), p;
      }, loadTree = (node, did, cache, filterWith, rpcache, stcache) => did.has(node.realpath) ? Promise.resolve(node) : (did.add(node.realpath), 
      ((node, cache, filterWith, rpcache, stcache) => {
        const nm = join(node.path, "node_modules");
        return realpath(nm, rpcache, stcache, 0).then((rm => readdir(rm).then((kids => [ rm, kids ])))).then((([rm, kids]) => Promise.all(kids.filter((kid => "." !== kid.charAt(0) && (!filterWith || filterWith(node, kid)))).map((kid => loadNode(join(nm, kid), join(rm, kid), cache, rpcache, stcache)))))).then((kidNodes => (kidNodes.forEach((k => k.parent = node)), 
        node.children.push.apply(node.children, kidNodes.sort(((a, b) => (a.package.name ? a.package.name.toLowerCase() : a.path).localeCompare(b.package.name ? b.package.name.toLowerCase() : b.path)))), 
        node))).catch((() => node));
      })(node, cache, filterWith, rpcache, stcache).then((node => Promise.all(node.children.filter((kid => !did.has(kid.realpath))).map((kid => loadTree(kid, did, cache, filterWith, rpcache, stcache)))))).then((() => node))), rpt = (root, filterWith, cb) => {
        cb || "function" != typeof filterWith || (cb = filterWith, filterWith = null);
        const cache = new Map, cwd = process.cwd(), rpcache = new Map([ [ cwd, cwd ] ]), stcache = new Map, p = realpath(root, rpcache, stcache, 0).then((realRoot => loadNode(root, realRoot, cache, rpcache, stcache))).then((node => loadTree(node, new Set, cache, filterWith, rpcache, stcache)));
        return "function" == typeof cb && p.then((tree => cb(null, tree)), cb), p;
      };
      rpt.Node = Node, rpt.Link = Link, module.exports = rpt;
    },
    9547: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = function(opts, cb) {
        if (opts.num) throw new Error("read() no longer accepts a char number limit");
        if (void 0 !== opts.default && "string" != typeof opts.default && "number" != typeof opts.default) throw new Error("default value must be string or number");
        var input = opts.input || process.stdin, output = opts.output || process.stdout, prompt = (opts.prompt || "").trim() + " ", silent = opts.silent, editDef = !1, timeout = opts.timeout, def = opts.default || "";
        def && (silent ? prompt += "(<default hidden>) " : opts.edit ? editDef = !0 : prompt += "(" + def + ") ");
        var terminal = !(!opts.terminal && !output.isTTY), m = new Mute({
          replace: opts.replace,
          prompt
        });
        m.pipe(output, {
          end: !1
        });
        var rlOpts = {
          input,
          output: output = m,
          terminal
        };
        if (process.version.match(/^v0\.6/)) var rl = readline.createInterface(rlOpts.input, rlOpts.output); else rl = readline.createInterface(rlOpts);
        output.unmute(), rl.setPrompt(prompt), rl.prompt(), silent ? output.mute() : editDef && (rl.line = def, 
        rl.cursor = def.length, rl._refreshLine());
        var timer, called = !1;
        rl.on("line", (function(line) {
          if (called) return;
          silent && terminal && (output.unmute(), output.write("\r\n"));
          done(), line = line.replace(/\r?\n$/, "");
          var isDefault = !(!editDef || line !== def);
          def && !line && (isDefault = !0, line = def);
          cb(null, line, isDefault);
        })), rl.on("error", onError), rl.on("SIGINT", (function() {
          rl.close(), onError(new Error("canceled"));
        })), timeout && (timer = setTimeout((function() {
          onError(new Error("timed out"));
        }), timeout));
        function done() {
          called = !0, rl.close(), process.version.match(/^v0\.6/) && (rl.input.removeAllListeners("data"), 
          rl.input.removeAllListeners("keypress"), rl.input.pause()), clearTimeout(timer), 
          output.mute(), output.end();
        }
        function onError(er) {
          if (!called) return done(), cb(er);
        }
      };
      var readline = __webpack_require__(14521), Mute = __webpack_require__(94464);
    },
    51981: (module, __unused_webpack_exports, __webpack_require__) => {
      var fs = __webpack_require__(59799), dz = __webpack_require__(21248), once = __webpack_require__(38412), path = __webpack_require__(71017), debug = __webpack_require__(1468)("rds");
      function readdir(dir, cb) {
        fs.readdir(dir, (function(er, kids) {
          if (er) return cb(er);
          debug("dir=%j, kids=%j", dir, kids), function(root, kids, cb) {
            var scopes = kids.filter((function(kid) {
              return "@" === kid.charAt(0);
            }));
            kids = kids.filter((function(kid) {
              return "@" !== kid.charAt(0);
            })), debug("scopes=%j", scopes), 0 === scopes.length && dz(cb)(null, kids);
            cb = once(cb);
            var l = scopes.length;
            function then(scope, er, scopekids) {
              if (er) return cb(er);
              scopekids = scopekids.filter((function(scopekid) {
                return !("." === scopekid || ".." === scopekid || !scopekid);
              })), kids.push.apply(kids, scopekids.map((function(scopekid) {
                return scope + "/" + scopekid;
              }))), debug("scope=%j scopekids=%j kids=%j", scope, scopekids, kids), 0 == --l && cb(null, kids);
            }
            scopes.forEach((function(scope) {
              var scopedir = path.resolve(root, scope);
              debug("root=%j scope=%j scopedir=%j", root, scope, scopedir), fs.readdir(scopedir, then.bind(null, scope));
            }));
          }(dir, kids, (function(er, data) {
            return er ? cb(er) : (data = data.sort((function(a, b) {
              return a > b ? 1 : -1;
            })), cb(null, data));
          }));
        }));
      }
      module.exports = readdir, readdir.sync = function(dir) {
        var kids = fs.readdirSync(dir);
        debug("dir=%j, kids=%j", dir, kids);
        var data = function(root, kids) {
          var scopes = kids.filter((function(kid) {
            return "@" === kid.charAt(0);
          }));
          if (kids = kids.filter((function(kid) {
            return "@" !== kid.charAt(0);
          })), debug("scopes=%j", scopes), 0 === scopes.length) return kids;
          scopes.length;
          function then(scope, scopekids) {
            scopekids = scopekids.filter((function(scopekid) {
              return !("." === scopekid || ".." === scopekid || !scopekid);
            })), kids.push.apply(kids, scopekids.map((function(scopekid) {
              return scope + "/" + scopekid;
            }))), debug("scope=%j scopekids=%j kids=%j", scope, scopekids, kids);
          }
          return scopes.forEach((function(scope) {
            var scopedir = path.resolve(root, scope);
            debug("root=%j scope=%j scopedir=%j", root, scope, scopedir), then(scope, fs.readdirSync(scopedir));
          })), kids;
        }(dir, kids);
        return data = data.sort((function(a, b) {
          return a > b ? 1 : -1;
        }));
      };
    },
    68259: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = rimraf, rimraf.sync = rimrafSync;
      var assert = __webpack_require__(39491), path = __webpack_require__(71017), fs = __webpack_require__(57147), glob = void 0;
      try {
        glob = __webpack_require__(34436);
      } catch (_err) {}
      var _0666 = parseInt("666", 8), defaultGlobOpts = {
        nosort: !0,
        silent: !0
      }, timeout = 0, isWindows = "win32" === process.platform;
      function defaults(options) {
        if ([ "unlink", "chmod", "stat", "lstat", "rmdir", "readdir" ].forEach((function(m) {
          options[m] = options[m] || fs[m], options[m += "Sync"] = options[m] || fs[m];
        })), options.maxBusyTries = options.maxBusyTries || 3, options.emfileWait = options.emfileWait || 1e3, 
        !1 === options.glob && (options.disableGlob = !0), !0 !== options.disableGlob && void 0 === glob) throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
        options.disableGlob = options.disableGlob || !1, options.glob = options.glob || defaultGlobOpts;
      }
      function rimraf(p, options, cb) {
        "function" == typeof options && (cb = options, options = {}), assert(p, "rimraf: missing path"), 
        assert.equal(typeof p, "string", "rimraf: path should be a string"), assert.equal(typeof cb, "function", "rimraf: callback function required"), 
        assert(options, "rimraf: invalid options argument provided"), assert.equal(typeof options, "object", "rimraf: options should be object"), 
        defaults(options);
        var busyTries = 0, errState = null, n = 0;
        if (options.disableGlob || !glob.hasMagic(p)) return afterGlob(null, [ p ]);
        function afterGlob(er, results) {
          return er ? cb(er) : 0 === (n = results.length) ? cb() : void results.forEach((function(p) {
            rimraf_(p, options, (function CB(er) {
              if (er) {
                if (("EBUSY" === er.code || "ENOTEMPTY" === er.code || "EPERM" === er.code) && busyTries < options.maxBusyTries) return busyTries++, 
                setTimeout((function() {
                  rimraf_(p, options, CB);
                }), 100 * busyTries);
                if ("EMFILE" === er.code && timeout < options.emfileWait) return setTimeout((function() {
                  rimraf_(p, options, CB);
                }), timeout++);
                "ENOENT" === er.code && (er = null);
              }
              timeout = 0, function(er) {
                errState = errState || er, 0 == --n && cb(errState);
              }(er);
            }));
          }));
        }
        options.lstat(p, (function(er, stat) {
          if (!er) return afterGlob(null, [ p ]);
          glob(p, options.glob, afterGlob);
        }));
      }
      function rimraf_(p, options, cb) {
        assert(p), assert(options), assert("function" == typeof cb), options.lstat(p, (function(er, st) {
          return er && "ENOENT" === er.code ? cb(null) : (er && "EPERM" === er.code && isWindows && fixWinEPERM(p, options, er, cb), 
          st && st.isDirectory() ? rmdir(p, options, er, cb) : void options.unlink(p, (function(er) {
            if (er) {
              if ("ENOENT" === er.code) return cb(null);
              if ("EPERM" === er.code) return isWindows ? fixWinEPERM(p, options, er, cb) : rmdir(p, options, er, cb);
              if ("EISDIR" === er.code) return rmdir(p, options, er, cb);
            }
            return cb(er);
          })));
        }));
      }
      function fixWinEPERM(p, options, er, cb) {
        assert(p), assert(options), assert("function" == typeof cb), er && assert(er instanceof Error), 
        options.chmod(p, _0666, (function(er2) {
          er2 ? cb("ENOENT" === er2.code ? null : er) : options.stat(p, (function(er3, stats) {
            er3 ? cb("ENOENT" === er3.code ? null : er) : stats.isDirectory() ? rmdir(p, options, er, cb) : options.unlink(p, cb);
          }));
        }));
      }
      function fixWinEPERMSync(p, options, er) {
        assert(p), assert(options), er && assert(er instanceof Error);
        try {
          options.chmodSync(p, _0666);
        } catch (er2) {
          if ("ENOENT" === er2.code) return;
          throw er;
        }
        try {
          var stats = options.statSync(p);
        } catch (er3) {
          if ("ENOENT" === er3.code) return;
          throw er;
        }
        stats.isDirectory() ? rmdirSync(p, options, er) : options.unlinkSync(p);
      }
      function rmdir(p, options, originalEr, cb) {
        assert(p), assert(options), originalEr && assert(originalEr instanceof Error), assert("function" == typeof cb), 
        options.rmdir(p, (function(er) {
          !er || "ENOTEMPTY" !== er.code && "EEXIST" !== er.code && "EPERM" !== er.code ? er && "ENOTDIR" === er.code ? cb(originalEr) : cb(er) : function(p, options, cb) {
            assert(p), assert(options), assert("function" == typeof cb), options.readdir(p, (function(er, files) {
              if (er) return cb(er);
              var errState, n = files.length;
              if (0 === n) return options.rmdir(p, cb);
              files.forEach((function(f) {
                rimraf(path.join(p, f), options, (function(er) {
                  if (!errState) return er ? cb(errState = er) : void (0 == --n && options.rmdir(p, cb));
                }));
              }));
            }));
          }(p, options, cb);
        }));
      }
      function rimrafSync(p, options) {
        var results;
        if (defaults(options = options || {}), assert(p, "rimraf: missing path"), assert.equal(typeof p, "string", "rimraf: path should be a string"), 
        assert(options, "rimraf: missing options"), assert.equal(typeof options, "object", "rimraf: options should be object"), 
        options.disableGlob || !glob.hasMagic(p)) results = [ p ]; else try {
          options.lstatSync(p), results = [ p ];
        } catch (er) {
          results = glob.sync(p, options.glob);
        }
        if (results.length) for (var i = 0; i < results.length; i++) {
          p = results[i];
          try {
            var st = options.lstatSync(p);
          } catch (er) {
            if ("ENOENT" === er.code) return;
            "EPERM" === er.code && isWindows && fixWinEPERMSync(p, options, er);
          }
          try {
            st && st.isDirectory() ? rmdirSync(p, options, null) : options.unlinkSync(p);
          } catch (er) {
            if ("ENOENT" === er.code) return;
            if ("EPERM" === er.code) return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
            if ("EISDIR" !== er.code) throw er;
            rmdirSync(p, options, er);
          }
        }
      }
      function rmdirSync(p, options, originalEr) {
        assert(p), assert(options), originalEr && assert(originalEr instanceof Error);
        try {
          options.rmdirSync(p);
        } catch (er) {
          if ("ENOENT" === er.code) return;
          if ("ENOTDIR" === er.code) throw originalEr;
          "ENOTEMPTY" !== er.code && "EEXIST" !== er.code && "EPERM" !== er.code || function(p, options) {
            assert(p), assert(options), options.readdirSync(p).forEach((function(f) {
              rimrafSync(path.join(p, f), options);
            }));
            var retries = isWindows ? 100 : 1, i = 0;
            for (;;) {
              var threw = !0;
              try {
                var ret = options.rmdirSync(p, options);
                return threw = !1, ret;
              } finally {
                if (++i < retries && threw) continue;
              }
            }
          }(p, options);
        }
      }
    },
    28618: (module, exports, __webpack_require__) => {
      var buffer = __webpack_require__(14300), Buffer = buffer.Buffer;
      function copyProps(src, dst) {
        for (var key in src) dst[key] = src[key];
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer(arg, encodingOrOffset, length);
      }
      Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow ? module.exports = buffer : (copyProps(buffer, exports), 
      exports.Buffer = SafeBuffer), SafeBuffer.prototype = Object.create(Buffer.prototype), 
      copyProps(Buffer, SafeBuffer), SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if ("number" == typeof arg) throw new TypeError("Argument must not be a number");
        return Buffer(arg, encodingOrOffset, length);
      }, SafeBuffer.alloc = function(size, fill, encoding) {
        if ("number" != typeof size) throw new TypeError("Argument must be a number");
        var buf = Buffer(size);
        return void 0 !== fill ? "string" == typeof encoding ? buf.fill(fill, encoding) : buf.fill(fill) : buf.fill(0), 
        buf;
      }, SafeBuffer.allocUnsafe = function(size) {
        if ("number" != typeof size) throw new TypeError("Argument must be a number");
        return Buffer(size);
      }, SafeBuffer.allocUnsafeSlow = function(size) {
        if ("number" != typeof size) throw new TypeError("Argument must be a number");
        return buffer.SlowBuffer(size);
      };
    },
    20459: (module, __unused_webpack_exports, __webpack_require__) => {
      var emitter, assert = __webpack_require__(39491), signals = __webpack_require__(56126), EE = __webpack_require__(82361);
      function unload() {
        loaded && (loaded = !1, signals.forEach((function(sig) {
          try {
            process.removeListener(sig, sigListeners[sig]);
          } catch (er) {}
        })), process.emit = originalProcessEmit, process.reallyExit = originalProcessReallyExit, 
        emitter.count -= 1);
      }
      function emit(event, code, signal) {
        emitter.emitted[event] || (emitter.emitted[event] = !0, emitter.emit(event, code, signal));
      }
      "function" != typeof EE && (EE = EE.EventEmitter), process.__signal_exit_emitter__ ? emitter = process.__signal_exit_emitter__ : ((emitter = process.__signal_exit_emitter__ = new EE).count = 0, 
      emitter.emitted = {}), emitter.infinite || (emitter.setMaxListeners(1 / 0), emitter.infinite = !0), 
      module.exports = function(cb, opts) {
        assert.equal(typeof cb, "function", "a callback must be provided for exit handler"), 
        !1 === loaded && load();
        var ev = "exit";
        opts && opts.alwaysLast && (ev = "afterexit");
        return emitter.on(ev, cb), function() {
          emitter.removeListener(ev, cb), 0 === emitter.listeners("exit").length && 0 === emitter.listeners("afterexit").length && unload();
        };
      }, module.exports.unload = unload;
      var sigListeners = {};
      signals.forEach((function(sig) {
        sigListeners[sig] = function() {
          process.listeners(sig).length === emitter.count && (unload(), emit("exit", null, sig), 
          emit("afterexit", null, sig), process.kill(process.pid, sig));
        };
      })), module.exports.signals = function() {
        return signals;
      }, module.exports.load = load;
      var loaded = !1;
      function load() {
        loaded || (loaded = !0, emitter.count += 1, signals = signals.filter((function(sig) {
          try {
            return process.on(sig, sigListeners[sig]), !0;
          } catch (er) {
            return !1;
          }
        })), process.emit = processEmit, process.reallyExit = processReallyExit);
      }
      var originalProcessReallyExit = process.reallyExit;
      function processReallyExit(code) {
        process.exitCode = code || 0, emit("exit", process.exitCode, null), emit("afterexit", process.exitCode, null), 
        originalProcessReallyExit.call(process, process.exitCode);
      }
      var originalProcessEmit = process.emit;
      function processEmit(ev, arg) {
        if ("exit" === ev) {
          void 0 !== arg && (process.exitCode = arg);
          var ret = originalProcessEmit.apply(this, arguments);
          return emit("exit", process.exitCode, null), emit("afterexit", process.exitCode, null), 
          ret;
        }
        return originalProcessEmit.apply(this, arguments);
      }
    },
    56126: module => {
      module.exports = [ "SIGABRT", "SIGALRM", "SIGHUP", "SIGINT", "SIGTERM" ], "win32" !== process.platform && module.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT"), 
      "linux" === process.platform && module.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
    },
    60504: module => {
      module.exports = function() {
        var steps = Array.prototype.slice.call(arguments), list = steps.shift() || [], cb_ = steps.pop();
        if ("function" != typeof cb_) throw new Error("No callback provided to asyncMap");
        if (!list) return cb_(null, []);
        Array.isArray(list) || (list = [ list ]);
        var n = steps.length, data = [], errState = null, l = list.length, a = l * n;
        if (!a) return cb_(null, []);
        function cb(er) {
          er && !errState && (errState = er);
          for (var argLen = arguments.length, i = 1; i < argLen; i++) void 0 !== arguments[i] && (data[i - 1] = (data[i - 1] || []).concat(arguments[i]));
          if (list.length > l) {
            var newList = list.slice(l);
            a += (list.length - l) * n, l = list.length, process.nextTick((function() {
              newList.forEach((function(ar) {
                steps.forEach((function(fn) {
                  fn(ar, cb);
                }));
              }));
            }));
          }
          0 == --a && cb_.apply(null, [ errState ].concat(data));
        }
        list.forEach((function(ar) {
          steps.forEach((function(fn) {
            fn(ar, cb);
          }));
        }));
      };
    },
    78113: module => {
      module.exports = function() {
        var fn, args = Array.prototype.slice.call(arguments), obj = null;
        "object" == typeof args[0] ? (obj = args.shift(), "string" == typeof (fn = args.shift()) && (fn = obj[fn])) : fn = args.shift();
        return function(cb) {
          fn.apply(obj, args.concat(cb));
        };
      };
    },
    59249: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = chain;
      var bindActor = __webpack_require__(78113);
      function chain(things, cb) {
        var res = [];
        !function LOOP(i, len) {
          return i >= len ? cb(null, res) : (Array.isArray(things[i]) && (things[i] = bindActor.apply(null, things[i].map((function(i) {
            return i === chain.first ? res[0] : i === chain.last ? res[res.length - 1] : i;
          })))), things[i] ? void things[i]((function(er, data) {
            if (er) return cb(er, res);
            void 0 !== data && (res = res.concat(data)), LOOP(i + 1, len);
          })) : LOOP(i + 1, len));
        }(0, things.length);
      }
      chain.first = {}, chain.last = {};
    },
    89009: (__unused_webpack_module, exports, __webpack_require__) => {
      exports.asyncMap = __webpack_require__(60504), __webpack_require__(78113), exports.chain = __webpack_require__(59249);
    },
    37713: module => {
      "use strict";
      module.exports = function(input) {
        var output = {};
        return Object.keys(input).sort().forEach((function(key) {
          output[key] = input[key];
        })), output;
      };
    },
    74615: module => {
      "use strict";
      module.exports = (string, separator) => {
        if ("string" != typeof string || "string" != typeof separator) throw new TypeError("Expected the arguments to be of type `string`");
        if ("" === separator) return [ string ];
        const separatorIndex = string.indexOf(separator);
        return -1 === separatorIndex ? [ string ] : [ string.slice(0, separatorIndex), string.slice(separatorIndex + separator.length) ];
      };
    },
    87783: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const crypto = __webpack_require__(6113), figgyPudding = __webpack_require__(55212), Transform = __webpack_require__(12781).Transform, SPEC_ALGORITHMS = [ "sha256", "sha384", "sha512" ], BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i, SRI_REGEX = /^([^-]+)-([^?]+)([?\S*]*)$/, STRICT_SRI_REGEX = /^([^-]+)-([A-Za-z0-9+/=]{44,88})(\?[\x21-\x7E]*)?$/, VCHAR_REGEX = /^[\x21-\x7E]+$/, SsriOpts = figgyPudding({
        algorithms: {
          default: [ "sha512" ]
        },
        error: {
          default: !1
        },
        integrity: {},
        options: {
          default: []
        },
        pickAlgorithm: {
          default: () => getPrioritizedHash
        },
        Promise: {
          default: () => Promise
        },
        sep: {
          default: " "
        },
        single: {
          default: !1
        },
        size: {},
        strict: {
          default: !1
        }
      });
      class Hash {
        get isHash() {
          return !0;
        }
        constructor(hash, opts) {
          const strict = !!(opts = SsriOpts(opts)).strict;
          this.source = hash.trim();
          const match = this.source.match(strict ? STRICT_SRI_REGEX : SRI_REGEX);
          if (!match) return;
          if (strict && !SPEC_ALGORITHMS.some((a => a === match[1]))) return;
          this.algorithm = match[1], this.digest = match[2];
          const rawOpts = match[3];
          this.options = rawOpts ? rawOpts.slice(1).split("?") : [];
        }
        hexDigest() {
          return this.digest && Buffer.from(this.digest, "base64").toString("hex");
        }
        toJSON() {
          return this.toString();
        }
        toString(opts) {
          if ((opts = SsriOpts(opts)).strict && !(SPEC_ALGORITHMS.some((x => x === this.algorithm)) && this.digest.match(BASE64_REGEX) && (this.options || []).every((opt => opt.match(VCHAR_REGEX))))) return "";
          const options = this.options && this.options.length ? `?${this.options.join("?")}` : "";
          return `${this.algorithm}-${this.digest}${options}`;
        }
      }
      class Integrity {
        get isIntegrity() {
          return !0;
        }
        toJSON() {
          return this.toString();
        }
        toString(opts) {
          let sep = (opts = SsriOpts(opts)).sep || " ";
          return opts.strict && (sep = sep.replace(/\S+/g, " ")), Object.keys(this).map((k => this[k].map((hash => Hash.prototype.toString.call(hash, opts))).filter((x => x.length)).join(sep))).filter((x => x.length)).join(sep);
        }
        concat(integrity, opts) {
          opts = SsriOpts(opts);
          const other = "string" == typeof integrity ? integrity : stringify(integrity, opts);
          return parse(`${this.toString(opts)} ${other}`, opts);
        }
        hexDigest() {
          return parse(this, {
            single: !0
          }).hexDigest();
        }
        match(integrity, opts) {
          const other = parse(integrity, opts = SsriOpts(opts)), algo = other.pickAlgorithm(opts);
          return this[algo] && other[algo] && this[algo].find((hash => other[algo].find((otherhash => hash.digest === otherhash.digest)))) || !1;
        }
        pickAlgorithm(opts) {
          const pickAlgorithm = (opts = SsriOpts(opts)).pickAlgorithm, keys = Object.keys(this);
          if (!keys.length) throw new Error(`No algorithms available for ${JSON.stringify(this.toString())}`);
          return keys.reduce(((acc, algo) => pickAlgorithm(acc, algo) || acc));
        }
      }
      function parse(sri, opts) {
        if (opts = SsriOpts(opts), "string" == typeof sri) return _parse(sri, opts);
        if (sri.algorithm && sri.digest) {
          const fullSri = new Integrity;
          return fullSri[sri.algorithm] = [ sri ], _parse(stringify(fullSri, opts), opts);
        }
        return _parse(stringify(sri, opts), opts);
      }
      function _parse(integrity, opts) {
        return opts.single ? new Hash(integrity, opts) : integrity.trim().split(/\s+/).reduce(((acc, string) => {
          const hash = new Hash(string, opts);
          if (hash.algorithm && hash.digest) {
            const algo = hash.algorithm;
            acc[algo] || (acc[algo] = []), acc[algo].push(hash);
          }
          return acc;
        }), new Integrity);
      }
      function stringify(obj, opts) {
        return opts = SsriOpts(opts), obj.algorithm && obj.digest ? Hash.prototype.toString.call(obj, opts) : "string" == typeof obj ? stringify(parse(obj, opts), opts) : Integrity.prototype.toString.call(obj, opts);
      }
      function integrityStream(opts) {
        const sri = (opts = SsriOpts(opts)).integrity && parse(opts.integrity, opts), goodSri = sri && Object.keys(sri).length, algorithm = goodSri && sri.pickAlgorithm(opts), digests = goodSri && sri[algorithm], algorithms = Array.from(new Set(opts.algorithms.concat(algorithm ? [ algorithm ] : []))), hashes = algorithms.map(crypto.createHash);
        let streamSize = 0;
        const stream = new Transform({
          transform(chunk, enc, cb) {
            streamSize += chunk.length, hashes.forEach((h => h.update(chunk, enc))), cb(null, chunk, enc);
          }
        }).on("end", (() => {
          const optString = opts.options && opts.options.length ? `?${opts.options.join("?")}` : "", newSri = parse(hashes.map(((h, i) => `${algorithms[i]}-${h.digest("base64")}${optString}`)).join(" "), opts), match = goodSri && newSri.match(sri, opts);
          if ("number" == typeof opts.size && streamSize !== opts.size) {
            const err = new Error(`stream size mismatch when checking ${sri}.\n  Wanted: ${opts.size}\n  Found: ${streamSize}`);
            err.code = "EBADSIZE", err.found = streamSize, err.expected = opts.size, err.sri = sri, 
            stream.emit("error", err);
          } else if (opts.integrity && !match) {
            const err = new Error(`${sri} integrity checksum failed when using ${algorithm}: wanted ${digests} but got ${newSri}. (${streamSize} bytes)`);
            err.code = "EINTEGRITY", err.found = newSri, err.expected = digests, err.algorithm = algorithm, 
            err.sri = sri, stream.emit("error", err);
          } else stream.emit("size", streamSize), stream.emit("integrity", newSri), match && stream.emit("verified", match);
        }));
        return stream;
      }
      module.exports.parse = parse, module.exports.stringify = stringify, module.exports.fromHex = function(hexDigest, algorithm, opts) {
        const optString = (opts = SsriOpts(opts)).options && opts.options.length ? `?${opts.options.join("?")}` : "";
        return parse(`${algorithm}-${Buffer.from(hexDigest, "hex").toString("base64")}${optString}`, opts);
      }, module.exports.fromData = function(data, opts) {
        const algorithms = (opts = SsriOpts(opts)).algorithms, optString = opts.options && opts.options.length ? `?${opts.options.join("?")}` : "";
        return algorithms.reduce(((acc, algo) => {
          const digest = crypto.createHash(algo).update(data).digest("base64"), hash = new Hash(`${algo}-${digest}${optString}`, opts);
          if (hash.algorithm && hash.digest) {
            const algo = hash.algorithm;
            acc[algo] || (acc[algo] = []), acc[algo].push(hash);
          }
          return acc;
        }), new Integrity);
      }, module.exports.fromStream = function(stream, opts) {
        const P = (opts = SsriOpts(opts)).Promise || Promise, istream = integrityStream(opts);
        return new P(((resolve, reject) => {
          let sri;
          stream.pipe(istream), stream.on("error", reject), istream.on("error", reject), istream.on("integrity", (s => {
            sri = s;
          })), istream.on("end", (() => resolve(sri))), istream.on("data", (() => {}));
        }));
      }, module.exports.checkData = function(data, sri, opts) {
        if (opts = SsriOpts(opts), sri = parse(sri, opts), !Object.keys(sri).length) {
          if (opts.error) throw Object.assign(new Error("No valid integrity hashes to check against"), {
            code: "EINTEGRITY"
          });
          return !1;
        }
        const algorithm = sri.pickAlgorithm(opts), digest = crypto.createHash(algorithm).update(data).digest("base64"), newSri = parse({
          algorithm,
          digest
        }), match = newSri.match(sri, opts);
        if (match || !opts.error) return match;
        if ("number" == typeof opts.size && data.length !== opts.size) {
          const err = new Error(`data size mismatch when checking ${sri}.\n  Wanted: ${opts.size}\n  Found: ${data.length}`);
          throw err.code = "EBADSIZE", err.found = data.length, err.expected = opts.size, 
          err.sri = sri, err;
        }
        {
          const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`);
          throw err.code = "EINTEGRITY", err.found = newSri, err.expected = sri, err.algorithm = algorithm, 
          err.sri = sri, err;
        }
      }, module.exports.checkStream = function(stream, sri, opts) {
        const P = (opts = SsriOpts(opts)).Promise || Promise, checker = integrityStream(opts.concat({
          integrity: sri
        }));
        return new P(((resolve, reject) => {
          let sri;
          stream.pipe(checker), stream.on("error", reject), checker.on("error", reject), checker.on("verified", (s => {
            sri = s;
          })), checker.on("end", (() => resolve(sri))), checker.on("data", (() => {}));
        }));
      }, module.exports.integrityStream = integrityStream, module.exports.create = function(opts) {
        const algorithms = (opts = SsriOpts(opts)).algorithms, optString = opts.options.length ? `?${opts.options.join("?")}` : "", hashes = algorithms.map(crypto.createHash);
        return {
          update: function(chunk, enc) {
            return hashes.forEach((h => h.update(chunk, enc))), this;
          },
          digest: function(enc) {
            return algorithms.reduce(((acc, algo) => {
              const digest = hashes.shift().digest("base64"), hash = new Hash(`${algo}-${digest}${optString}`, opts);
              if (hash.algorithm && hash.digest) {
                const algo = hash.algorithm;
                acc[algo] || (acc[algo] = []), acc[algo].push(hash);
              }
              return acc;
            }), new Integrity);
          }
        };
      };
      const NODE_HASHES = new Set(crypto.getHashes()), DEFAULT_PRIORITY = [ "md5", "whirlpool", "sha1", "sha224", "sha256", "sha384", "sha512", "sha3", "sha3-256", "sha3-384", "sha3-512", "sha3_256", "sha3_384", "sha3_512" ].filter((algo => NODE_HASHES.has(algo)));
      function getPrioritizedHash(algo1, algo2) {
        return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase()) ? algo1 : algo2;
      }
    },
    45278: module => {
      "use strict";
      module.exports = str => encodeURIComponent(str).replace(/[!'()*]/g, (x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`));
    },
    41055: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const stripAnsi = __webpack_require__(71741), isFullwidthCodePoint = __webpack_require__(20386);
      module.exports = str => {
        if ("string" != typeof str || 0 === str.length) return 0;
        str = stripAnsi(str);
        let width = 0;
        for (let i = 0; i < str.length; i++) {
          const code = str.codePointAt(i);
          code <= 31 || code >= 127 && code <= 159 || (code >= 768 && code <= 879 || (code > 65535 && i++, 
          width += isFullwidthCodePoint(code) ? 2 : 1));
        }
        return width;
      };
    },
    27273: module => {
      "use strict";
      module.exports = () => {
        const pattern = [ "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))" ].join("|");
        return new RegExp(pattern, "g");
      };
    },
    71741: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const ansiRegex = __webpack_require__(27273);
      module.exports = input => "string" == typeof input ? input.replace(ansiRegex(), "") : input;
    },
    22652: module => {
      "use strict";
      module.exports = function(data, indent, newline) {
        indent = indent || (0 === indent ? 0 : 2);
        const json = JSON.stringify(data, null, indent);
        if ("\r\n" === newline) return json.replace(/\n/g, "\r\n") + "\r\n";
        return json + "\n";
      };
    },
    42935: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var ansiRegex = __webpack_require__(68687)();
      module.exports = function(str) {
        return "string" == typeof str ? str.replace(ansiRegex, "") : str;
      };
    },
    68687: module => {
      "use strict";
      module.exports = function() {
        return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
      };
    },
    5371: module => {
      function dotindex(c) {
        var m = /\.[^.]*$/.exec(c);
        return m ? m.index + 1 : c.length;
      }
      function reduce(xs, f, init) {
        if (xs.reduce) return xs.reduce(f, init);
        for (var i = 0, acc = arguments.length >= 3 ? init : xs[i++]; i < xs.length; i++) f(acc, xs[i], i);
        return acc;
      }
      function forEach(xs, f) {
        if (xs.forEach) return xs.forEach(f);
        for (var i = 0; i < xs.length; i++) f.call(xs, xs[i], i);
      }
      function map(xs, f) {
        if (xs.map) return xs.map(f);
        for (var res = [], i = 0; i < xs.length; i++) res.push(f.call(xs, xs[i], i));
        return res;
      }
      module.exports = function(rows_, opts) {
        opts || (opts = {});
        var hsep = void 0 === opts.hsep ? "  " : opts.hsep, align = opts.align || [], stringLength = opts.stringLength || function(s) {
          return String(s).length;
        }, dotsizes = reduce(rows_, (function(acc, row) {
          return forEach(row, (function(c, ix) {
            var n = dotindex(c);
            (!acc[ix] || n > acc[ix]) && (acc[ix] = n);
          })), acc;
        }), []), rows = map(rows_, (function(row) {
          return map(row, (function(c_, ix) {
            var c = String(c_);
            if ("." === align[ix]) {
              var index = dotindex(c), size = dotsizes[ix] + (/\./.test(c) ? 1 : 2) - (stringLength(c) - index);
              return c + Array(size).join(" ");
            }
            return c;
          }));
        })), sizes = reduce(rows, (function(acc, row) {
          return forEach(row, (function(c, ix) {
            var n = stringLength(c);
            (!acc[ix] || n > acc[ix]) && (acc[ix] = n);
          })), acc;
        }), []);
        return map(rows, (function(row) {
          return map(row, (function(c, ix) {
            var n = sizes[ix] - stringLength(c) || 0, s = Array(Math.max(n + 1, 1)).join(" ");
            return "r" === align[ix] || "." === align[ix] ? s + c : "c" === align[ix] ? Array(Math.ceil(n / 2 + 1)).join(" ") + c + Array(Math.floor(n / 2 + 1)).join(" ") : c + s;
          })).join(hsep).replace(/\s+$/, "");
        })).join("\n");
      };
    },
    49760: (module, exports, __webpack_require__) => {
      var Stream = __webpack_require__(12781);
      function through(write, end, opts) {
        write = write || function(data) {
          this.queue(data);
        }, end = end || function() {
          this.queue(null);
        };
        var ended = !1, destroyed = !1, buffer = [], _ended = !1, stream = new Stream;
        function drain() {
          for (;buffer.length && !stream.paused; ) {
            var data = buffer.shift();
            if (null === data) return stream.emit("end");
            stream.emit("data", data);
          }
        }
        function _end() {
          stream.writable = !1, end.call(stream), !stream.readable && stream.autoDestroy && stream.destroy();
        }
        return stream.readable = stream.writable = !0, stream.paused = !1, stream.autoDestroy = !(opts && !1 === opts.autoDestroy), 
        stream.write = function(data) {
          return write.call(this, data), !stream.paused;
        }, stream.queue = stream.push = function(data) {
          return _ended || (null === data && (_ended = !0), buffer.push(data), drain()), stream;
        }, stream.on("end", (function() {
          stream.readable = !1, !stream.writable && stream.autoDestroy && process.nextTick((function() {
            stream.destroy();
          }));
        })), stream.end = function(data) {
          if (!ended) return ended = !0, arguments.length && stream.write(data), _end(), stream;
        }, stream.destroy = function() {
          if (!destroyed) return destroyed = !0, ended = !0, buffer.length = 0, stream.writable = stream.readable = !1, 
          stream.emit("close"), stream;
        }, stream.pause = function() {
          if (!stream.paused) return stream.paused = !0, stream;
        }, stream.resume = function() {
          return stream.paused && (stream.paused = !1, stream.emit("resume")), drain(), stream.paused || stream.emit("drain"), 
          stream;
        }, stream;
      }
      module.exports = through, through.through = through;
    },
    38100: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      "use strict";
      __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
        default: () => src
      });
      const calculateDelta = (now, date) => Math.round(Math.abs(now - date) / 1e3);
      var en = __webpack_require__(27035);
      const src = (translations = __webpack_require__.n(en)(), function(date, now = new Date) {
        date instanceof Date || (date = new Date(date));
        let delta = null;
        const day = 86400;
        delta = calculateDelta(now, date), delta > day && delta < 604800 && (date = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0), 
        delta = calculateDelta(now, date));
        const translate = (translatePhrase, timeValue) => {
          let key;
          key = "justNow" === translatePhrase ? translatePhrase : now >= date ? `${translatePhrase}Ago` : `${translatePhrase}FromNow`;
          const translation = translations[key];
          return "function" == typeof translation ? translation(timeValue) : translation.replace("{{time}}", timeValue);
        };
        switch (!1) {
         case !(delta < 30):
          return translate("justNow");

         case !(delta < 60):
          return translate("seconds", delta);

         case !(delta < 120):
          return translate("aMinute");

         case !(delta < 3600):
          return translate("minutes", Math.floor(delta / 60));

         case 1 !== Math.floor(delta / 3600):
          return translate("anHour");

         case !(delta < day):
          return translate("hours", Math.floor(delta / 3600));

         case !(delta < 2 * day):
          return translate("aDay");

         case !(delta < 604800):
          return translate("days", Math.floor(delta / day));

         case 1 !== Math.floor(delta / 604800):
          return translate("aWeek");

         case !(delta < 2592e3):
          return translate("weeks", Math.floor(delta / 604800));

         case 1 !== Math.floor(delta / 2592e3):
          return translate("aMonth");

         case !(delta < 31536e3):
          return translate("months", Math.floor(delta / 2592e3));

         case 1 !== Math.floor(delta / 31536e3):
          return translate("aYear");

         default:
          return translate("overAYear");
        }
      });
      var translations;
    },
    27035: module => {
      module.exports = {
        justNow: "just now",
        secondsAgo: "{{time}} seconds ago",
        aMinuteAgo: "a minute ago",
        minutesAgo: "{{time}} minutes ago",
        anHourAgo: "an hour ago",
        hoursAgo: "{{time}} hours ago",
        aDayAgo: "yesterday",
        daysAgo: "{{time}} days ago",
        aWeekAgo: "a week ago",
        weeksAgo: "{{time}} weeks ago",
        aMonthAgo: "a month ago",
        monthsAgo: "{{time}} months ago",
        aYearAgo: "a year ago",
        yearsAgo: "{{time}} years ago",
        overAYearAgo: "over a year ago",
        secondsFromNow: "{{time}} seconds from now",
        aMinuteFromNow: "a minute from now",
        minutesFromNow: "{{time}} minutes from now",
        anHourFromNow: "an hour from now",
        hoursFromNow: "{{time}} hours from now",
        aDayFromNow: "tomorrow",
        daysFromNow: "{{time}} days from now",
        aWeekFromNow: "a week from now",
        weeksFromNow: "{{time}} weeks from now",
        aMonthFromNow: "a month from now",
        monthsFromNow: "{{time}} months from now",
        aYearFromNow: "a year from now",
        yearsFromNow: "{{time}} years from now",
        overAYearFromNow: "over a year from now"
      };
    },
    37289: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      var util = __webpack_require__(73837);
      function toString(val) {
        for (val = val.toString(8); val.length < 4; ) val = "0" + val;
        return val;
      }
      var defaultUmaskString = toString(18);
      exports.toString = toString, exports.fromString = function(val, cb) {
        return function(val, cb) {
          if ("string" == typeof val) if ("0" === val.charAt(0) && /^[0-7]+$/.test(val)) val = parseInt(val, 8); else {
            if ("0" === val.charAt(0) || !/^[0-9]+$/.test(val)) return cb(new Error(util.format("Expected octal string, got %j, defaulting to %j", val, defaultUmaskString)), 18);
            val = parseInt(val, 10);
          } else if ("number" != typeof val) return cb(new Error(util.format("Expected number or octal string, got %j, defaulting to %j", val, defaultUmaskString)), 18);
          if ((val = Math.floor(val)) < 0 || val > 511) return cb(new Error(util.format("Must be in range 0..511 (0000..0777), got %j", val)), 18);
          cb(null, val);
        }(val, cb || function(err, result) {
          val = result;
        }), val;
      }, exports.validate = function(data, k, val) {
        return "number" != typeof val || isNaN(val) ? "string" == typeof val && ("0" === val.charAt(0) && (data[k] = parseInt(val, 8), 
        !0)) : (data[k] = val, !0);
      };
    },
    16003: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var path = __webpack_require__(71017), uniqueSlug = __webpack_require__(36649);
      module.exports = function(filepath, prefix, uniq) {
        return path.join(filepath, (prefix ? prefix + "-" : "") + uniqueSlug(uniq));
      };
    },
    36649: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var crypto = __webpack_require__(6113), MurmurHash3 = __webpack_require__(287);
      module.exports = function(uniq) {
        return uniq ? ("00000000" + new MurmurHash3(uniq).result().toString(16)).substr(-8) : crypto.pseudoRandomBytes(4).toString("hex");
      };
    },
    36719: module => {
      module.exports = function(origin, add) {
        if (!add || "object" != typeof add) return origin;
        var keys = Object.keys(add), i = keys.length;
        for (;i--; ) origin[keys[i]] = add[keys[i]];
        return origin;
      };
    },
    66054: (module, __unused_webpack_exports, __webpack_require__) => {
      var v1 = __webpack_require__(58348), v4 = __webpack_require__(28271), uuid = v4;
      uuid.v1 = v1, uuid.v4 = v4, module.exports = uuid;
    },
    57214: module => {
      for (var byteToHex = [], i = 0; i < 256; ++i) byteToHex[i] = (i + 256).toString(16).substr(1);
      module.exports = function(buf, offset) {
        var i = offset || 0, bth = byteToHex;
        return [ bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]] ].join("");
      };
    },
    83892: (module, __unused_webpack_exports, __webpack_require__) => {
      var crypto = __webpack_require__(6113);
      module.exports = function() {
        return crypto.randomBytes(16);
      };
    },
    58348: (module, __unused_webpack_exports, __webpack_require__) => {
      var _nodeId, _clockseq, rng = __webpack_require__(83892), bytesToUuid = __webpack_require__(57214), _lastMSecs = 0, _lastNSecs = 0;
      module.exports = function(options, buf, offset) {
        var i = buf && offset || 0, b = buf || [], node = (options = options || {}).node || _nodeId, clockseq = void 0 !== options.clockseq ? options.clockseq : _clockseq;
        if (null == node || null == clockseq) {
          var seedBytes = rng();
          null == node && (node = _nodeId = [ 1 | seedBytes[0], seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5] ]), 
          null == clockseq && (clockseq = _clockseq = 16383 & (seedBytes[6] << 8 | seedBytes[7]));
        }
        var msecs = void 0 !== options.msecs ? options.msecs : (new Date).getTime(), nsecs = void 0 !== options.nsecs ? options.nsecs : _lastNSecs + 1, dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
        if (dt < 0 && void 0 === options.clockseq && (clockseq = clockseq + 1 & 16383), 
        (dt < 0 || msecs > _lastMSecs) && void 0 === options.nsecs && (nsecs = 0), nsecs >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
        _lastMSecs = msecs, _lastNSecs = nsecs, _clockseq = clockseq;
        var tl = (1e4 * (268435455 & (msecs += 122192928e5)) + nsecs) % 4294967296;
        b[i++] = tl >>> 24 & 255, b[i++] = tl >>> 16 & 255, b[i++] = tl >>> 8 & 255, b[i++] = 255 & tl;
        var tmh = msecs / 4294967296 * 1e4 & 268435455;
        b[i++] = tmh >>> 8 & 255, b[i++] = 255 & tmh, b[i++] = tmh >>> 24 & 15 | 16, b[i++] = tmh >>> 16 & 255, 
        b[i++] = clockseq >>> 8 | 128, b[i++] = 255 & clockseq;
        for (var n = 0; n < 6; ++n) b[i + n] = node[n];
        return buf || bytesToUuid(b);
      };
    },
    28271: (module, __unused_webpack_exports, __webpack_require__) => {
      var rng = __webpack_require__(83892), bytesToUuid = __webpack_require__(57214);
      module.exports = function(options, buf, offset) {
        var i = buf && offset || 0;
        "string" == typeof options && (buf = "binary" === options ? new Array(16) : null, 
        options = null);
        var rnds = (options = options || {}).random || (options.rng || rng)();
        if (rnds[6] = 15 & rnds[6] | 64, rnds[8] = 63 & rnds[8] | 128, buf) for (var ii = 0; ii < 16; ++ii) buf[i + ii] = rnds[ii];
        return buf || bytesToUuid(rnds);
      };
    },
    70630: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var scopedPackagePattern = new RegExp("^(?:@([^/]+?)[/])?([^/]+?)$"), builtins = __webpack_require__(43732), blacklist = [ "node_modules", "favicon.ico" ];
      (module.exports = function(name) {
        var warnings = [], errors = [];
        if (null === name) return errors.push("name cannot be null"), done(warnings, errors);
        if (void 0 === name) return errors.push("name cannot be undefined"), done(warnings, errors);
        if ("string" != typeof name) return errors.push("name must be a string"), done(warnings, errors);
        if (name.length || errors.push("name length must be greater than zero"), name.match(/^\./) && errors.push("name cannot start with a period"), 
        name.match(/^_/) && errors.push("name cannot start with an underscore"), name.trim() !== name && errors.push("name cannot contain leading or trailing spaces"), 
        blacklist.forEach((function(blacklistedName) {
          name.toLowerCase() === blacklistedName && errors.push(blacklistedName + " is a blacklisted name");
        })), builtins.forEach((function(builtin) {
          name.toLowerCase() === builtin && warnings.push(builtin + " is a core module name");
        })), name.length > 214 && warnings.push("name can no longer contain more than 214 characters"), 
        name.toLowerCase() !== name && warnings.push("name can no longer contain capital letters"), 
        /[~'!()*]/.test(name.split("/").slice(-1)[0]) && warnings.push('name can no longer contain special characters ("~\'!()*")'), 
        encodeURIComponent(name) !== name) {
          var nameMatch = name.match(scopedPackagePattern);
          if (nameMatch) {
            var user = nameMatch[1], pkg = nameMatch[2];
            if (encodeURIComponent(user) === user && encodeURIComponent(pkg) === pkg) return done(warnings, errors);
          }
          errors.push("name can only contain URL-friendly characters");
        }
        return done(warnings, errors);
      }).scopedPackagePattern = scopedPackagePattern;
      var done = function(warnings, errors) {
        var result = {
          validForNewPackages: 0 === errors.length && 0 === warnings.length,
          validForOldPackages: 0 === errors.length,
          warnings,
          errors
        };
        return result.warnings.length || delete result.warnings, result.errors.length || delete result.errors, 
        result;
      };
    },
    96912: module => {
      module.exports = [ [ 768, 879 ], [ 1155, 1158 ], [ 1160, 1161 ], [ 1425, 1469 ], [ 1471, 1471 ], [ 1473, 1474 ], [ 1476, 1477 ], [ 1479, 1479 ], [ 1536, 1539 ], [ 1552, 1557 ], [ 1611, 1630 ], [ 1648, 1648 ], [ 1750, 1764 ], [ 1767, 1768 ], [ 1770, 1773 ], [ 1807, 1807 ], [ 1809, 1809 ], [ 1840, 1866 ], [ 1958, 1968 ], [ 2027, 2035 ], [ 2305, 2306 ], [ 2364, 2364 ], [ 2369, 2376 ], [ 2381, 2381 ], [ 2385, 2388 ], [ 2402, 2403 ], [ 2433, 2433 ], [ 2492, 2492 ], [ 2497, 2500 ], [ 2509, 2509 ], [ 2530, 2531 ], [ 2561, 2562 ], [ 2620, 2620 ], [ 2625, 2626 ], [ 2631, 2632 ], [ 2635, 2637 ], [ 2672, 2673 ], [ 2689, 2690 ], [ 2748, 2748 ], [ 2753, 2757 ], [ 2759, 2760 ], [ 2765, 2765 ], [ 2786, 2787 ], [ 2817, 2817 ], [ 2876, 2876 ], [ 2879, 2879 ], [ 2881, 2883 ], [ 2893, 2893 ], [ 2902, 2902 ], [ 2946, 2946 ], [ 3008, 3008 ], [ 3021, 3021 ], [ 3134, 3136 ], [ 3142, 3144 ], [ 3146, 3149 ], [ 3157, 3158 ], [ 3260, 3260 ], [ 3263, 3263 ], [ 3270, 3270 ], [ 3276, 3277 ], [ 3298, 3299 ], [ 3393, 3395 ], [ 3405, 3405 ], [ 3530, 3530 ], [ 3538, 3540 ], [ 3542, 3542 ], [ 3633, 3633 ], [ 3636, 3642 ], [ 3655, 3662 ], [ 3761, 3761 ], [ 3764, 3769 ], [ 3771, 3772 ], [ 3784, 3789 ], [ 3864, 3865 ], [ 3893, 3893 ], [ 3895, 3895 ], [ 3897, 3897 ], [ 3953, 3966 ], [ 3968, 3972 ], [ 3974, 3975 ], [ 3984, 3991 ], [ 3993, 4028 ], [ 4038, 4038 ], [ 4141, 4144 ], [ 4146, 4146 ], [ 4150, 4151 ], [ 4153, 4153 ], [ 4184, 4185 ], [ 4448, 4607 ], [ 4959, 4959 ], [ 5906, 5908 ], [ 5938, 5940 ], [ 5970, 5971 ], [ 6002, 6003 ], [ 6068, 6069 ], [ 6071, 6077 ], [ 6086, 6086 ], [ 6089, 6099 ], [ 6109, 6109 ], [ 6155, 6157 ], [ 6313, 6313 ], [ 6432, 6434 ], [ 6439, 6440 ], [ 6450, 6450 ], [ 6457, 6459 ], [ 6679, 6680 ], [ 6912, 6915 ], [ 6964, 6964 ], [ 6966, 6970 ], [ 6972, 6972 ], [ 6978, 6978 ], [ 7019, 7027 ], [ 7616, 7626 ], [ 7678, 7679 ], [ 8203, 8207 ], [ 8234, 8238 ], [ 8288, 8291 ], [ 8298, 8303 ], [ 8400, 8431 ], [ 12330, 12335 ], [ 12441, 12442 ], [ 43014, 43014 ], [ 43019, 43019 ], [ 43045, 43046 ], [ 64286, 64286 ], [ 65024, 65039 ], [ 65056, 65059 ], [ 65279, 65279 ], [ 65529, 65531 ], [ 68097, 68099 ], [ 68101, 68102 ], [ 68108, 68111 ], [ 68152, 68154 ], [ 68159, 68159 ], [ 119143, 119145 ], [ 119155, 119170 ], [ 119173, 119179 ], [ 119210, 119213 ], [ 119362, 119364 ], [ 917505, 917505 ], [ 917536, 917631 ], [ 917760, 917999 ] ];
    },
    7656: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var defaults = __webpack_require__(21338), combining = __webpack_require__(96912), DEFAULTS = {
        nul: 0,
        control: 0
      };
      function wcswidth(str, opts) {
        if ("string" != typeof str) return wcwidth(str, opts);
        for (var s = 0, i = 0; i < str.length; i++) {
          var n = wcwidth(str.charCodeAt(i), opts);
          if (n < 0) return -1;
          s += n;
        }
        return s;
      }
      function wcwidth(ucs, opts) {
        return 0 === ucs ? opts.nul : ucs < 32 || ucs >= 127 && ucs < 160 ? opts.control : function(ucs) {
          var mid, min = 0, max = combining.length - 1;
          if (ucs < combining[0][0] || ucs > combining[max][1]) return !1;
          for (;max >= min; ) if (mid = Math.floor((min + max) / 2), ucs > combining[mid][1]) min = mid + 1; else {
            if (!(ucs < combining[mid][0])) return !0;
            max = mid - 1;
          }
          return !1;
        }(ucs) ? 0 : 1 + (ucs >= 4352 && (ucs <= 4447 || 9001 == ucs || 9002 == ucs || ucs >= 11904 && ucs <= 42191 && 12351 != ucs || ucs >= 44032 && ucs <= 55203 || ucs >= 63744 && ucs <= 64255 || ucs >= 65040 && ucs <= 65049 || ucs >= 65072 && ucs <= 65135 || ucs >= 65280 && ucs <= 65376 || ucs >= 65504 && ucs <= 65510 || ucs >= 131072 && ucs <= 196605 || ucs >= 196608 && ucs <= 262141));
      }
      module.exports = function(str) {
        return wcswidth(str, DEFAULTS);
      }, module.exports.config = function(opts) {
        return opts = defaults(opts || {}, DEFAULTS), function(str) {
          return wcswidth(str, opts);
        };
      };
    },
    7017: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = which, which.sync = function(cmd, opt) {
        for (var info = getPathInfo(cmd, opt = opt || {}), pathEnv = info.env, pathExt = info.ext, pathExtExe = info.extExe, found = [], i = 0, l = pathEnv.length; i < l; i++) {
          var pathPart = pathEnv[i];
          '"' === pathPart.charAt(0) && '"' === pathPart.slice(-1) && (pathPart = pathPart.slice(1, -1));
          var p = path.join(pathPart, cmd);
          !pathPart && /^\.[\\\/]/.test(cmd) && (p = cmd.slice(0, 2) + p);
          for (var j = 0, ll = pathExt.length; j < ll; j++) {
            var cur = p + pathExt[j];
            try {
              if (isexe.sync(cur, {
                pathExt: pathExtExe
              })) {
                if (!opt.all) return cur;
                found.push(cur);
              }
            } catch (ex) {}
          }
        }
        if (opt.all && found.length) return found;
        if (opt.nothrow) return null;
        throw getNotFoundError(cmd);
      };
      var isWindows = "win32" === process.platform || "cygwin" === process.env.OSTYPE || "msys" === process.env.OSTYPE, path = __webpack_require__(71017), COLON = isWindows ? ";" : ":", isexe = __webpack_require__(23789);
      function getNotFoundError(cmd) {
        var er = new Error("not found: " + cmd);
        return er.code = "ENOENT", er;
      }
      function getPathInfo(cmd, opt) {
        var colon = opt.colon || COLON, pathEnv = opt.path || process.env.PATH || "", pathExt = [ "" ];
        pathEnv = pathEnv.split(colon);
        var pathExtExe = "";
        return isWindows && (pathEnv.unshift(process.cwd()), pathExt = (pathExtExe = opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM").split(colon), 
        -1 !== cmd.indexOf(".") && "" !== pathExt[0] && pathExt.unshift("")), (cmd.match(/\//) || isWindows && cmd.match(/\\/)) && (pathEnv = [ "" ]), 
        {
          env: pathEnv,
          ext: pathExt,
          extExe: pathExtExe
        };
      }
      function which(cmd, opt, cb) {
        "function" == typeof opt && (cb = opt, opt = {});
        var info = getPathInfo(cmd, opt), pathEnv = info.env, pathExt = info.ext, pathExtExe = info.extExe, found = [];
        !function F(i, l) {
          if (i === l) return opt.all && found.length ? cb(null, found) : cb(getNotFoundError(cmd));
          var pathPart = pathEnv[i];
          '"' === pathPart.charAt(0) && '"' === pathPart.slice(-1) && (pathPart = pathPart.slice(1, -1));
          var p = path.join(pathPart, cmd);
          !pathPart && /^\.[\\\/]/.test(cmd) && (p = cmd.slice(0, 2) + p), function E(ii, ll) {
            if (ii === ll) return F(i + 1, l);
            var ext = pathExt[ii];
            isexe(p + ext, {
              pathExt: pathExtExe
            }, (function(er, is) {
              if (!er && is) {
                if (!opt.all) return cb(null, p + ext);
                found.push(p + ext);
              }
              return E(ii + 1, ll);
            }));
          }(0, pathExt.length);
        }(0, pathEnv.length);
      }
    },
    90696: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const DEFAULT_OPTIONS = {
        workerOptions: {},
        maxCallsPerWorker: 1 / 0,
        maxConcurrentWorkers: (__webpack_require__(22037).cpus() || {
          length: 1
        }).length,
        maxConcurrentCallsPerWorker: 10,
        maxConcurrentCalls: 1 / 0,
        maxCallTime: 1 / 0,
        maxRetries: 1 / 0,
        forcedKillTime: 100,
        autoStart: !1,
        onChild: function() {}
      }, fork = __webpack_require__(47602), TimeoutError = __webpack_require__(24983).create("TimeoutError"), ProcessTerminatedError = __webpack_require__(24983).create("ProcessTerminatedError"), MaxConcurrentCallsError = __webpack_require__(24983).create("MaxConcurrentCallsError");
      function Farm(options, path) {
        this.options = Object.assign({}, DEFAULT_OPTIONS, options), this.path = path, this.activeCalls = 0;
      }
      Farm.prototype.mkhandle = function(method) {
        return function() {
          let args = Array.prototype.slice.call(arguments);
          if (this.activeCalls + this.callQueue.length >= this.options.maxConcurrentCalls) {
            let err = new MaxConcurrentCallsError("Too many concurrent calls (active: " + this.activeCalls + ", queued: " + this.callQueue.length + ")");
            if ("function" == typeof args[args.length - 1]) return process.nextTick(args[args.length - 1].bind(null, err));
            throw err;
          }
          this.addCall({
            method,
            callback: args.pop(),
            args,
            retries: 0
          });
        }.bind(this);
      }, Farm.prototype.setup = function(methods) {
        let iface;
        if (methods ? (iface = {}, methods.forEach(function(m) {
          iface[m] = this.mkhandle(m);
        }.bind(this))) : iface = this.mkhandle(), this.searchStart = -1, this.childId = -1, 
        this.children = {}, this.activeChildren = 0, this.callQueue = [], this.options.autoStart) for (;this.activeChildren < this.options.maxConcurrentWorkers; ) this.startChild();
        return iface;
      }, Farm.prototype.onExit = function(childId) {
        setTimeout(function() {
          let doQueue = !1;
          this.children[childId] && this.children[childId].activeCalls && this.children[childId].calls.forEach(function(call, i) {
            call && (call.retries >= this.options.maxRetries ? this.receive({
              idx: i,
              child: childId,
              args: [ new ProcessTerminatedError("cancel after " + call.retries + " retries!") ]
            }) : (call.retries++, this.callQueue.unshift(call), doQueue = !0));
          }.bind(this)), this.stopChild(childId), doQueue && this.processQueue();
        }.bind(this), 10);
      }, Farm.prototype.startChild = function() {
        this.childId++;
        let forked = fork(this.path, this.options.workerOptions), id = this.childId, c = {
          send: forked.send,
          child: forked.child,
          calls: [],
          activeCalls: 0,
          exitCode: null
        };
        this.options.onChild(forked.child), forked.child.on("message", function(data) {
          "farm" === data.owner && this.receive(data);
        }.bind(this)), forked.child.once("exit", function(code) {
          c.exitCode = code, this.onExit(id);
        }.bind(this)), this.activeChildren++, this.children[id] = c;
      }, Farm.prototype.stopChild = function(childId) {
        let child = this.children[childId];
        child && (child.send({
          owner: "farm",
          event: "die"
        }), setTimeout((function() {
          null === child.exitCode && child.child.kill("SIGKILL");
        }), this.options.forcedKillTime).unref(), delete this.children[childId], this.activeChildren--);
      }, Farm.prototype.receive = function(data) {
        let call, idx = data.idx, childId = data.child, args = data.args, child = this.children[childId];
        if (!child) return console.error("Worker Farm: Received message for unknown child. This is likely as a result of premature child death, the operation will have been re-queued.");
        if (call = child.calls[idx], !call) return console.error("Worker Farm: Received message for unknown index for existing child. This should not happen!");
        if (this.options.maxCallTime !== 1 / 0 && clearTimeout(call.timer), args[0] && "$error" == args[0].$error) {
          let e = args[0];
          switch (e.type) {
           case "TypeError":
            args[0] = new TypeError(e.message);
            break;

           case "RangeError":
            args[0] = new RangeError(e.message);
            break;

           case "EvalError":
            args[0] = new EvalError(e.message);
            break;

           case "ReferenceError":
            args[0] = new ReferenceError(e.message);
            break;

           case "SyntaxError":
            args[0] = new SyntaxError(e.message);
            break;

           case "URIError":
            args[0] = new URIError(e.message);
            break;

           default:
            args[0] = new Error(e.message);
          }
          args[0].type = e.type, args[0].stack = e.stack, Object.keys(e).forEach((function(key) {
            args[0][key] = e[key];
          }));
        }
        process.nextTick((function() {
          call.callback.apply(null, args);
        })), delete child.calls[idx], child.activeCalls--, this.activeCalls--, child.calls.length >= this.options.maxCallsPerWorker && !Object.keys(child.calls).length && this.stopChild(childId), 
        this.processQueue();
      }, Farm.prototype.childTimeout = function(childId) {
        let i, child = this.children[childId];
        if (child) {
          for (i in child.calls) this.receive({
            idx: i,
            child: childId,
            args: [ new TimeoutError("worker call timed out!") ]
          });
          this.stopChild(childId);
        }
      }, Farm.prototype.send = function(childId, call) {
        let child = this.children[childId], idx = child.calls.length;
        child.calls.push(call), child.activeCalls++, this.activeCalls++, child.send({
          owner: "farm",
          idx,
          child: childId,
          method: call.method,
          args: call.args
        }), this.options.maxCallTime !== 1 / 0 && (call.timer = setTimeout(this.childTimeout.bind(this, childId), this.options.maxCallTime));
      }, Farm.prototype.childKeys = function() {
        let cks, cka = Object.keys(this.children);
        return this.searchStart >= cka.length - 1 ? this.searchStart = 0 : this.searchStart++, 
        cks = cka.splice(0, this.searchStart), cka.concat(cks);
      }, Farm.prototype.processQueue = function() {
        let cka, childId, i = 0;
        if (!this.callQueue.length) return this.ending && this.end();
        for (this.activeChildren < this.options.maxConcurrentWorkers && this.startChild(), 
        cka = this.childKeys(); i < cka.length; i++) if (childId = +cka[i], this.children[childId].activeCalls < this.options.maxConcurrentCallsPerWorker && this.children[childId].calls.length < this.options.maxCallsPerWorker && (this.send(childId, this.callQueue.shift()), 
        !this.callQueue.length)) return this.ending && this.end();
        this.ending && this.end();
      }, Farm.prototype.addCall = function(call) {
        if (this.ending) return this.end();
        this.callQueue.push(call), this.processQueue();
      }, Farm.prototype.end = function(callback) {
        let complete = !0;
        !1 !== this.ending && (callback ? this.ending = callback : null == this.ending && (this.ending = !0), 
        Object.keys(this.children).forEach(function(child) {
          this.children[child] && (this.children[child].activeCalls ? complete = !1 : this.stopChild(child));
        }.bind(this)), complete && "function" == typeof this.ending && process.nextTick(function() {
          this.ending(), this.ending = !1;
        }.bind(this)));
      }, module.exports = Farm, module.exports.TimeoutError = TimeoutError;
    },
    54976: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const Farm = __webpack_require__(90696);
      let farms = [];
      module.exports = function(options, path, methods) {
        "string" == typeof options && (methods = path, path = options, options = {});
        let f = new Farm(options, path), api = f.setup(methods);
        return farms.push({
          farm: f,
          api
        }), api;
      }, module.exports.end = function(api, callback) {
        for (let i = 0; i < farms.length; i++) if (farms[i] && farms[i].api === api) return farms[i].farm.end(callback);
        process.nextTick(callback.bind(null, new Error("Worker farm not found!")));
      };
    },
    68839: module => {
      module.exports = function wrappy(fn, cb) {
        if (fn && cb) return wrappy(fn)(cb);
        if ("function" != typeof fn) throw new TypeError("need wrapper function");
        return Object.keys(fn).forEach((function(k) {
          wrapper[k] = fn[k];
        })), wrapper;
        function wrapper() {
          for (var args = new Array(arguments.length), i = 0; i < args.length; i++) args[i] = arguments[i];
          var ret = fn.apply(this, args), cb = args[args.length - 1];
          return "function" == typeof ret && ret !== cb && Object.keys(cb).forEach((function(k) {
            ret[k] = cb[k];
          })), ret;
        }
      };
    },
    19804: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = function(filename, data, options, callback) {
        options ? options instanceof Function ? (callback = options, options = {}) : "string" == typeof options && (options = {
          encoding: options
        }) : options = {};
        var truename, fd, tmpfile, Promise = options.Promise || global.Promise, removeOnExitHandler = onExit(cleanupOnExit((() => tmpfile))), absoluteName = path.resolve(filename);
        new Promise((function(resolve) {
          activeFiles[absoluteName] || (activeFiles[absoluteName] = []), activeFiles[absoluteName].push(resolve), 
          1 === activeFiles[absoluteName].length && resolve();
        })).then((function() {
          return new Promise((function(resolve) {
            fs.realpath(filename, (function(_, realname) {
              tmpfile = getTmpname(truename = realname || filename), resolve();
            }));
          }));
        })).then((function() {
          return new Promise((function(resolve) {
            options.mode && options.chown ? resolve() : fs.stat(truename, (function(err, stats) {
              err || !stats || (null == (options = Object.assign({}, options)).mode && (options.mode = stats.mode), 
              null == options.chown && process.getuid && (options.chown = {
                uid: stats.uid,
                gid: stats.gid
              })), resolve();
            }));
          }));
        })).then((function() {
          return new Promise((function(resolve, reject) {
            fs.open(tmpfile, "w", options.mode, (function(err, _fd) {
              fd = _fd, err ? reject(err) : resolve();
            }));
          }));
        })).then((function() {
          return new Promise((function(resolve, reject) {
            Buffer.isBuffer(data) ? fs.write(fd, data, 0, data.length, 0, (function(err) {
              err ? reject(err) : resolve();
            })) : null != data ? fs.write(fd, String(data), 0, String(options.encoding || "utf8"), (function(err) {
              err ? reject(err) : resolve();
            })) : resolve();
          }));
        })).then((function() {
          return new Promise((function(resolve, reject) {
            !1 !== options.fsync ? fs.fsync(fd, (function(err) {
              err ? fs.close(fd, (() => reject(err))) : fs.close(fd, resolve);
            })) : fs.close(fd, resolve);
          }));
        })).then((function() {
          if (fd = null, options.chown) return new Promise((function(resolve, reject) {
            fs.chown(tmpfile, options.chown.uid, options.chown.gid, (function(err) {
              err ? reject(err) : resolve();
            }));
          }));
        })).then((function() {
          if (options.mode) return new Promise((function(resolve, reject) {
            fs.chmod(tmpfile, options.mode, (function(err) {
              err ? reject(err) : resolve();
            }));
          }));
        })).then((function() {
          return new Promise((function(resolve, reject) {
            fs.rename(tmpfile, truename, (function(err) {
              err ? reject(err) : resolve();
            }));
          }));
        })).then((function() {
          removeOnExitHandler(), callback();
        }), (function(err) {
          return new Promise((resolve => fd ? fs.close(fd, resolve) : resolve())).then((() => {
            removeOnExitHandler(), fs.unlink(tmpfile, (function() {
              callback(err);
            }));
          }));
        })).then((function() {
          activeFiles[absoluteName].shift(), activeFiles[absoluteName].length > 0 ? activeFiles[absoluteName][0]() : delete activeFiles[absoluteName];
        }));
      }, module.exports.sync = function(filename, data, options) {
        "string" == typeof options ? options = {
          encoding: options
        } : options || (options = {});
        try {
          filename = fs.realpathSync(filename);
        } catch (ex) {}
        var fd, tmpfile = getTmpname(filename);
        if (!options.mode || !options.chown) try {
          var stats = fs.statSync(filename);
          (options = Object.assign({}, options)).mode || (options.mode = stats.mode), !options.chown && process.getuid && (options.chown = {
            uid: stats.uid,
            gid: stats.gid
          });
        } catch (ex) {}
        var cleanup = cleanupOnExit(tmpfile), removeOnExitHandler = onExit(cleanup);
        try {
          fd = fs.openSync(tmpfile, "w", options.mode), Buffer.isBuffer(data) ? fs.writeSync(fd, data, 0, data.length, 0) : null != data && fs.writeSync(fd, String(data), 0, String(options.encoding || "utf8")), 
          !1 !== options.fsync && fs.fsyncSync(fd), fs.closeSync(fd), options.chown && fs.chownSync(tmpfile, options.chown.uid, options.chown.gid), 
          options.mode && fs.chmodSync(tmpfile, options.mode), fs.renameSync(tmpfile, filename), 
          removeOnExitHandler();
        } catch (err) {
          if (fd) try {
            fs.closeSync(fd);
          } catch (ex) {}
          throw removeOnExitHandler(), cleanup(), err;
        }
      }, module.exports._getTmpname = getTmpname, module.exports._cleanupOnExit = cleanupOnExit;
      var fs = __webpack_require__(59799), MurmurHash3 = __webpack_require__(287), onExit = __webpack_require__(20459), path = __webpack_require__(71017), activeFiles = {}, threadId = function() {
        try {
          return __webpack_require__(71267).threadId;
        } catch (e) {
          return 0;
        }
      }(), invocations = 0;
      function getTmpname(filename) {
        return filename + "." + MurmurHash3(__filename).hash(String(process.pid)).hash(String(threadId)).hash(String(++invocations)).result();
      }
      function cleanupOnExit(tmpfile) {
        return function() {
          try {
            fs.unlinkSync("function" == typeof tmpfile ? tmpfile() : tmpfile);
          } catch (_) {}
        };
      }
    },
    9220: module => {
      "use strict";
      module.exports = function(Yallist) {
        Yallist.prototype[Symbol.iterator] = function*() {
          for (let walker = this.head; walker; walker = walker.next) yield walker.value;
        };
      };
    },
    33836: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      function Yallist(list) {
        var self = this;
        if (self instanceof Yallist || (self = new Yallist), self.tail = null, self.head = null, 
        self.length = 0, list && "function" == typeof list.forEach) list.forEach((function(item) {
          self.push(item);
        })); else if (arguments.length > 0) for (var i = 0, l = arguments.length; i < l; i++) self.push(arguments[i]);
        return self;
      }
      function insert(self, node, value) {
        var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
        return null === inserted.next && (self.tail = inserted), null === inserted.prev && (self.head = inserted), 
        self.length++, inserted;
      }
      function push(self, item) {
        self.tail = new Node(item, self.tail, null, self), self.head || (self.head = self.tail), 
        self.length++;
      }
      function unshift(self, item) {
        self.head = new Node(item, null, self.head, self), self.tail || (self.tail = self.head), 
        self.length++;
      }
      function Node(value, prev, next, list) {
        if (!(this instanceof Node)) return new Node(value, prev, next, list);
        this.list = list, this.value = value, prev ? (prev.next = this, this.prev = prev) : this.prev = null, 
        next ? (next.prev = this, this.next = next) : this.next = null;
      }
      module.exports = Yallist, Yallist.Node = Node, Yallist.create = Yallist, Yallist.prototype.removeNode = function(node) {
        if (node.list !== this) throw new Error("removing node which does not belong to this list");
        var next = node.next, prev = node.prev;
        return next && (next.prev = prev), prev && (prev.next = next), node === this.head && (this.head = next), 
        node === this.tail && (this.tail = prev), node.list.length--, node.next = null, 
        node.prev = null, node.list = null, next;
      }, Yallist.prototype.unshiftNode = function(node) {
        if (node !== this.head) {
          node.list && node.list.removeNode(node);
          var head = this.head;
          node.list = this, node.next = head, head && (head.prev = node), this.head = node, 
          this.tail || (this.tail = node), this.length++;
        }
      }, Yallist.prototype.pushNode = function(node) {
        if (node !== this.tail) {
          node.list && node.list.removeNode(node);
          var tail = this.tail;
          node.list = this, node.prev = tail, tail && (tail.next = node), this.tail = node, 
          this.head || (this.head = node), this.length++;
        }
      }, Yallist.prototype.push = function() {
        for (var i = 0, l = arguments.length; i < l; i++) push(this, arguments[i]);
        return this.length;
      }, Yallist.prototype.unshift = function() {
        for (var i = 0, l = arguments.length; i < l; i++) unshift(this, arguments[i]);
        return this.length;
      }, Yallist.prototype.pop = function() {
        if (this.tail) {
          var res = this.tail.value;
          return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, 
          this.length--, res;
        }
      }, Yallist.prototype.shift = function() {
        if (this.head) {
          var res = this.head.value;
          return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, 
          this.length--, res;
        }
      }, Yallist.prototype.forEach = function(fn, thisp) {
        thisp = thisp || this;
        for (var walker = this.head, i = 0; null !== walker; i++) fn.call(thisp, walker.value, i, this), 
        walker = walker.next;
      }, Yallist.prototype.forEachReverse = function(fn, thisp) {
        thisp = thisp || this;
        for (var walker = this.tail, i = this.length - 1; null !== walker; i--) fn.call(thisp, walker.value, i, this), 
        walker = walker.prev;
      }, Yallist.prototype.get = function(n) {
        for (var i = 0, walker = this.head; null !== walker && i < n; i++) walker = walker.next;
        if (i === n && null !== walker) return walker.value;
      }, Yallist.prototype.getReverse = function(n) {
        for (var i = 0, walker = this.tail; null !== walker && i < n; i++) walker = walker.prev;
        if (i === n && null !== walker) return walker.value;
      }, Yallist.prototype.map = function(fn, thisp) {
        thisp = thisp || this;
        for (var res = new Yallist, walker = this.head; null !== walker; ) res.push(fn.call(thisp, walker.value, this)), 
        walker = walker.next;
        return res;
      }, Yallist.prototype.mapReverse = function(fn, thisp) {
        thisp = thisp || this;
        for (var res = new Yallist, walker = this.tail; null !== walker; ) res.push(fn.call(thisp, walker.value, this)), 
        walker = walker.prev;
        return res;
      }, Yallist.prototype.reduce = function(fn, initial) {
        var acc, walker = this.head;
        if (arguments.length > 1) acc = initial; else {
          if (!this.head) throw new TypeError("Reduce of empty list with no initial value");
          walker = this.head.next, acc = this.head.value;
        }
        for (var i = 0; null !== walker; i++) acc = fn(acc, walker.value, i), walker = walker.next;
        return acc;
      }, Yallist.prototype.reduceReverse = function(fn, initial) {
        var acc, walker = this.tail;
        if (arguments.length > 1) acc = initial; else {
          if (!this.tail) throw new TypeError("Reduce of empty list with no initial value");
          walker = this.tail.prev, acc = this.tail.value;
        }
        for (var i = this.length - 1; null !== walker; i--) acc = fn(acc, walker.value, i), 
        walker = walker.prev;
        return acc;
      }, Yallist.prototype.toArray = function() {
        for (var arr = new Array(this.length), i = 0, walker = this.head; null !== walker; i++) arr[i] = walker.value, 
        walker = walker.next;
        return arr;
      }, Yallist.prototype.toArrayReverse = function() {
        for (var arr = new Array(this.length), i = 0, walker = this.tail; null !== walker; i++) arr[i] = walker.value, 
        walker = walker.prev;
        return arr;
      }, Yallist.prototype.slice = function(from, to) {
        (to = to || this.length) < 0 && (to += this.length), (from = from || 0) < 0 && (from += this.length);
        var ret = new Yallist;
        if (to < from || to < 0) return ret;
        from < 0 && (from = 0), to > this.length && (to = this.length);
        for (var i = 0, walker = this.head; null !== walker && i < from; i++) walker = walker.next;
        for (;null !== walker && i < to; i++, walker = walker.next) ret.push(walker.value);
        return ret;
      }, Yallist.prototype.sliceReverse = function(from, to) {
        (to = to || this.length) < 0 && (to += this.length), (from = from || 0) < 0 && (from += this.length);
        var ret = new Yallist;
        if (to < from || to < 0) return ret;
        from < 0 && (from = 0), to > this.length && (to = this.length);
        for (var i = this.length, walker = this.tail; null !== walker && i > to; i--) walker = walker.prev;
        for (;null !== walker && i > from; i--, walker = walker.prev) ret.push(walker.value);
        return ret;
      }, Yallist.prototype.splice = function(start, deleteCount) {
        start > this.length && (start = this.length - 1), start < 0 && (start = this.length + start);
        for (var i = 0, walker = this.head; null !== walker && i < start; i++) walker = walker.next;
        var ret = [];
        for (i = 0; walker && i < deleteCount; i++) ret.push(walker.value), walker = this.removeNode(walker);
        null === walker && (walker = this.tail), walker !== this.head && walker !== this.tail && (walker = walker.prev);
        for (i = 2; i < arguments.length; i++) walker = insert(this, walker, arguments[i]);
        return ret;
      }, Yallist.prototype.reverse = function() {
        for (var head = this.head, tail = this.tail, walker = head; null !== walker; walker = walker.prev) {
          var p = walker.prev;
          walker.prev = walker.next, walker.next = p;
        }
        return this.head = tail, this.tail = head, this;
      };
      try {
        __webpack_require__(9220)(Yallist);
      } catch (er) {}
    },
    10398: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const BB = __webpack_require__(41142), figgyPudding = __webpack_require__(55212), stat = BB.promisify(__webpack_require__(59799).stat), gentlyRm = BB.promisify(__webpack_require__(8638)), mkdirp = BB.promisify(__webpack_require__(33169).mkdir), moduleName = __webpack_require__(7802), moduleStagingPath = __webpack_require__(14703), move = __webpack_require__(57459), npa = __webpack_require__(19932);
      __webpack_require__(44874);
      let npmConfig;
      const packageId = __webpack_require__(73531), path = __webpack_require__(71017), localWorker = __webpack_require__(83990);
      __webpack_require__(54976), __webpack_require__(80127), __webpack_require__(35965).resolve("./extract-worker.js");
      const ExtractOpts = figgyPudding({
        log: {}
      }, {
        other: () => !0
      });
      function extract(staging, pkg, log) {
        log.silly("extract", packageId(pkg));
        const extractTo = moduleStagingPath(staging, pkg);
        npmConfig || (npmConfig = __webpack_require__(23300));
        let opts = ExtractOpts(npmConfig()).concat({
          integrity: pkg.package._integrity,
          resolved: pkg.package._resolved
        });
        const args = [ pkg.package._requested, extractTo, opts ];
        return BB.fromNode((cb => {
          let launcher = localWorker, msg = args;
          const spec = "string" == typeof args[0] ? npa(args[0]) : args[0];
          args[0] = spec.raw, launcher(msg, cb);
        })).then((() => {
          if (pkg.package.bundleDependencies || anyBundled(pkg)) return function(pkg, staging, extractTo) {
            return BB.map(pkg.children, (child => {
              if (child.fromBundle) {
                if (child.error) throw child.error;
                return stageBundledModule(pkg, child, staging, extractTo);
              }
            }), {
              concurrency: 10
            });
          }(pkg, staging, extractTo);
        })).then((() => gentlyRm(path.join(extractTo, "node_modules"))));
      }
      function anyBundled(top, pkg) {
        return pkg || (pkg = top), pkg.children.some((child => child.fromBundle === top || anyBundled(top, child)));
      }
      function stageBundledModule(bundler, child, staging, parentPath) {
        const stageFrom = path.join(parentPath, "node_modules", moduleName(child)), stageTo = moduleStagingPath(staging, child);
        return BB.map(child.children, (child => {
          if (child.error) throw child.error;
          return stageBundledModule(bundler, child, staging, stageFrom);
        })).then((() => function(bundler, child, stageTo, stageFrom) {
          return child.fromBundle === bundler ? mkdirp(path.dirname(stageTo)).then((() => move(stageFrom, stageTo))) : stat(stageFrom).then((() => gentlyRm(stageFrom)), (() => {}));
        }(bundler, child, stageTo, stageFrom)));
      }
      extract.init = () => BB.resolve(), extract.teardown = () => BB.resolve(), module.exports = extract;
    },
    69797: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = pack;
      const BB = __webpack_require__(41142), byteSize = __webpack_require__(52822), cacache = __webpack_require__(99269), columnify = __webpack_require__(75231), cp = __webpack_require__(32081), deprCheck = __webpack_require__(8956), fpm = __webpack_require__(3138), fs = __webpack_require__(59799), install = __webpack_require__(70913), lifecycle = BB.promisify(__webpack_require__(4705)), log = __webpack_require__(19334), move = __webpack_require__(25315), npm = __webpack_require__(44874), npmConfig = __webpack_require__(23300), output = __webpack_require__(1015), pacote = __webpack_require__(96770), path = __webpack_require__(71017), PassThrough = __webpack_require__(12781).PassThrough, pathIsInside = __webpack_require__(13468), pipe = BB.promisify(__webpack_require__(30498).pipe), prepublishWarning = __webpack_require__(81158)("prepublish-on-install"), pinflight = __webpack_require__(10978), readJson = BB.promisify(__webpack_require__(92200)), tar = __webpack_require__(39148), packlist = __webpack_require__(68749), ssri = __webpack_require__(87783);
      function pack(args, silent, cb) {
        const cwd = process.cwd();
        "function" != typeof cb && (cb = silent, silent = !1), 0 === args.length && (args = [ "." ]), 
        BB.all(args.map((arg => {
          return pkg = arg, dir = cwd, BB.fromNode((cb => fpm(pkg, dir, cb))).then((mani => {
            const target = `${"@" === mani.name[0] ? mani.name.substr(1).replace(/\//g, "-") : mani.name}-${mani.version}.tgz`;
            return pinflight(target, (() => {
              const dryRun = npm.config.get("dry-run");
              return "directory" === mani._requested.type ? prepareDirectory(mani._resolved).then((() => packDirectory(mani, mani._resolved, target, target, !0, dryRun))) : dryRun ? (log.verbose("pack", "--dry-run mode enabled. Skipping write."), 
              cacache.tmp.withTmp(npm.tmp, {
                tmpPrefix: "packing"
              }, (tmp => {
                const tmpTarget = path.join(tmp, path.basename(target));
                return packFromPackage(pkg, tmpTarget, target);
              }))) : packFromPackage(pkg, target, target);
            }));
          }));
          var pkg, dir;
        }))).then((tarballs => (!silent && npm.config.get("json") ? output(JSON.stringify(tarballs, null, 2)) : silent || (tarballs.forEach(logContents), 
        output(tarballs.map((f => path.relative(cwd, f.filename))).join("\n"))), tarballs))).nodeify(cb);
      }
      function packFromPackage(arg, target, filename) {
        const opts = npmConfig();
        return pacote.tarball.toFile(arg, target, opts).then((() => cacache.tmp.withTmp(npm.tmp, {
          tmpPrefix: "unpacking"
        }, (tmp => {
          const tmpTarget = path.join(tmp, filename);
          return pacote.extract(arg, tmpTarget, opts).then((() => readJson(path.join(tmpTarget, "package.json"))));
        })))).then((pkg => getContents(pkg, target, filename)));
      }
      function prepareDirectory(dir) {
        return readJson(path.join(dir, "package.json")).then((pkg => {
          if (!pkg.name) throw new Error('package.json requires a "name" field');
          if (!pkg.version) throw new Error('package.json requires a valid "version" field');
          return pathIsInside(dir, npm.tmp) ? pkg : (pkg.scripts && pkg.scripts.prepublish && prepublishWarning([ "As of npm@5, `prepublish` scripts are deprecated.", "Use `prepare` for build steps and `prepublishOnly` for upload-only.", "See the deprecation note in `npm help scripts` for more information." ]), 
          npm.config.get("ignore-prepublish") ? lifecycle(pkg, "prepare", dir).then((() => pkg)) : lifecycle(pkg, "prepublish", dir).then((() => lifecycle(pkg, "prepare", dir))).then((() => pkg)));
        }));
      }
      function packDirectory(mani, dir, target, filename, logIt, dryRun) {
        return deprCheck(mani), readJson(path.join(dir, "package.json")).then((pkg => lifecycle(pkg, "prepack", dir))).then((() => readJson(path.join(dir, "package.json")))).then((pkg => cacache.tmp.withTmp(npm.tmp, {
          tmpPrefix: "packing"
        }, (tmp => {
          const tmpTarget = path.join(tmp, path.basename(target)), tarOpt = {
            file: tmpTarget,
            cwd: dir,
            prefix: "package/",
            portable: !0,
            mtime: new Date("1985-10-26T08:15:00.000Z"),
            gzip: !0
          };
          return BB.resolve(packlist({
            path: dir
          })).then((files => tar.create(tarOpt, files.map((f => `./${f}`))))).then((() => getContents(pkg, tmpTarget, filename, logIt))).tap((() => {
            if (!dryRun) return move(tmpTarget, target, {
              Promise: BB,
              fs
            });
            log.verbose("pack", "--dry-run mode enabled. Skipping write.");
          })).tap((() => lifecycle(pkg, "postpack", dir)));
        }))));
      }
      function logContents(tarball) {
        log.notice(""), log.notice("", `${npm.config.get("unicode") ? " " : "package:"} ${tarball.name}@${tarball.version}`), 
        log.notice("=== Tarball Contents ==="), tarball.files.length && log.notice("", columnify(tarball.files.map((f => {
          const bytes = byteSize(f.size);
          return {
            path: f.path,
            size: `${bytes.value}${bytes.unit}`
          };
        })), {
          include: [ "size", "path" ],
          showHeaders: !1
        })), tarball.bundled.length && (log.notice("=== Bundled Dependencies ==="), tarball.bundled.forEach((name => log.notice("", name)))), 
        log.notice("=== Tarball Details ==="), log.notice("", columnify([ {
          name: "name:",
          value: tarball.name
        }, {
          name: "version:",
          value: tarball.version
        }, tarball.filename && {
          name: "filename:",
          value: tarball.filename
        }, {
          name: "package size:",
          value: byteSize(tarball.size)
        }, {
          name: "unpacked size:",
          value: byteSize(tarball.unpackedSize)
        }, {
          name: "shasum:",
          value: tarball.shasum
        }, {
          name: "integrity:",
          value: tarball.integrity.toString().substr(0, 20) + "[...]" + tarball.integrity.toString().substr(80)
        }, tarball.bundled.length && {
          name: "bundled deps:",
          value: tarball.bundled.length
        }, tarball.bundled.length && {
          name: "bundled files:",
          value: tarball.entryCount - tarball.files.length
        }, tarball.bundled.length && {
          name: "own files:",
          value: tarball.files.length
        }, {
          name: "total files:",
          value: tarball.entryCount
        } ].filter((x => x)), {
          include: [ "name", "value" ],
          showHeaders: !1
        })), log.notice("", "");
      }
      function getContents(pkg, target, filename, silent) {
        const bundledWanted = new Set(pkg.bundleDependencies || pkg.bundledDependencies || []), files = [], bundled = new Set;
        let totalEntries = 0, totalEntrySize = 0;
        return tar.t({
          file: target,
          onentry(entry) {
            totalEntries++, totalEntrySize += entry.size;
            const p = entry.path;
            if (p.startsWith("package/node_modules/")) {
              const name = p.match(/^package\/node_modules\/((?:@[^/]+\/)?[^/]+)/)[1];
              bundledWanted.has(name) && bundled.add(name);
            } else files.push({
              path: entry.path.replace(/^package\//, ""),
              size: entry.size,
              mode: entry.mode
            });
          },
          strip: 1
        }).then((() => BB.all([ BB.fromNode((cb => fs.stat(target, cb))), ssri.fromStream(fs.createReadStream(target), {
          algorithms: [ "sha1", "sha512" ]
        }) ]))).then((([stat, integrity]) => {
          const shasum = integrity.sha1[0].hexDigest();
          return {
            id: pkg._id,
            name: pkg.name,
            version: pkg.version,
            from: pkg._from,
            size: stat.size,
            unpackedSize: totalEntrySize,
            shasum,
            integrity: ssri.parse(integrity.sha512[0]),
            filename,
            files,
            entryCount: totalEntries,
            bundled: Array.from(bundled)
          };
        }));
      }
      pack.usage = "npm pack [[<@scope>/]<pkg>...] [--dry-run]", pack.completion = install.completion, 
      module.exports.prepareDirectory = prepareDirectory, module.exports.packDirectory = packDirectory, 
      module.exports.logContents = logContents, module.exports.getContents = getContents;
      const PASSTHROUGH_OPTS = [ "always-auth", "auth-type", "ca", "cafile", "cert", "git", "local-address", "maxsockets", "offline", "prefer-offline", "prefer-online", "proxy", "https-proxy", "registry", "send-metrics", "sso-poll-frequency", "sso-type", "strict-ssl" ];
      module.exports.packGitDep = function(manifest, dir) {
        const stream = new PassThrough;
        return readJson(path.join(dir, "package.json")).then((pkg => {
          if (pkg.scripts && pkg.scripts.prepare) {
            log.verbose("prepareGitDep", `${manifest._spec}: installing devDeps and running prepare script.`);
            const cliArgs = PASSTHROUGH_OPTS.reduce(((acc, opt) => (null != npm.config.get(opt, "cli") && acc.push(`--${opt}=${npm.config.get(opt)}`), 
            acc)), []), child = cp.spawn(process.env.NODE || process.execPath, [ __webpack_require__(35965).resolve("../bin/npm-cli.js"), "install", "--dev", "--prod", "--ignore-prepublish", "--no-progress", "--no-save" ].concat(cliArgs), {
              cwd: dir,
              env: process.env
            });
            let errData = [], errDataLen = 0, outData = [], outDataLen = 0;
            return child.stdout.on("data", (data => {
              outData.push(data), outDataLen += data.length, log.gauge.pulse("preparing git package");
            })), child.stderr.on("data", (data => {
              errData.push(data), errDataLen += data.length, log.gauge.pulse("preparing git package");
            })), BB.fromNode((cb => {
              child.on("error", cb), child.on("exit", ((code, signal) => {
                if (code > 0) {
                  const err = new Error(`${signal}: npm exited with code ${code} while attempting to build ${manifest._requested}. Clone the repository manually and run 'npm install' in it for more information.`);
                  err.code = code, err.signal = signal, cb(err);
                } else cb();
              }));
            })).then((() => {
              outDataLen > 0 && log.silly("prepareGitDep", "1>", Buffer.concat(outData, outDataLen).toString()), 
              errDataLen > 0 && log.silly("prepareGitDep", "2>", Buffer.concat(errData, errDataLen).toString());
            }), (err => {
              throw outDataLen > 0 && log.error("prepareGitDep", "1>", Buffer.concat(outData, outDataLen).toString()), 
              errDataLen > 0 && log.error("prepareGitDep", "2>", Buffer.concat(errData, errDataLen).toString()), 
              err;
            }));
          }
        })).then((() => readJson(path.join(dir, "package.json")))).then((pkg => cacache.tmp.withTmp(npm.tmp, {
          tmpPrefix: "pacote-packing"
        }, (tmp => {
          const tmpTar = path.join(tmp, "package.tgz");
          return packDirectory(manifest, dir, tmpTar).then((() => pipe(fs.createReadStream(tmpTar), stream)));
        })))).catch((err => stream.emit("error", err))), stream;
      };
    },
    7971: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = function(uid, gid, cb) {
        if (!uidSupport) return cb();
        "function" != typeof cb && (cb = gid, gid = null);
        "function" != typeof cb && (cb = uid, uid = null);
        null == gid && (gid = process.getgid());
        null == uid && (uid = process.getuid());
        isNaN(gid) || (gid = gidCache[gid] = +gid);
        isNaN(uid) || (uid = uidCache[uid] = +uid);
        uidCache.hasOwnProperty(uid) && (uid = uidCache[uid]);
        gidCache.hasOwnProperty(gid) && (gid = gidCache[gid]);
        if ("number" == typeof gid && "number" == typeof uid) return process.nextTick(cb.bind(null, null, uid, gid));
        var getter = __webpack_require__(35965).resolve("./get-uid-gid.js");
        child_process.execFile(process.execPath, [ getter, uid, gid ], (function(code, out, stderr) {
          var er;
          if (code) return (er = new Error("could not get uid/gid\n" + stderr)).code = code, 
          cb(er);
          try {
            out = JSON.parse(out + "");
          } catch (ex) {
            return cb(ex);
          }
          return out.error ? ((er = new Error(out.error)).errno = out.errno, cb(er)) : isNaN(out.uid) || isNaN(out.gid) ? cb(new Error("Could not get uid/gid: " + JSON.stringify(out))) : void cb(null, uidCache[uid] = +out.uid, gidCache[gid] = +out.gid);
        }));
      };
      var child_process = __webpack_require__(32081), uidSupport = (__webpack_require__(71017), 
      process.getuid && process.setuid), uidCache = {}, gidCache = {};
    },
    44874: (module, __unused_webpack_exports, __webpack_require__) => {
      module = __webpack_require__.nmd(module), function() {
        if ("undefined" != typeof WScript) return WScript.echo('npm does not work when run\nwith the Windows Scripting Host\n\n"cd" to a different directory,\nor type "npm.cmd <args>",\nor type "node npm <args>".'), 
        void WScript.quit(1);
        var unsupported = __webpack_require__(79625);
        unsupported.checkForBrokenNode();
        var fs = __webpack_require__(59799).gracefulify(__webpack_require__(57147)), EventEmitter = __webpack_require__(82361).EventEmitter, npm = module.exports = new EventEmitter, npmconf = __webpack_require__(25560), log = __webpack_require__(19334), inspect = __webpack_require__(73837).inspect;
        npm._unsupported = unsupported, npm._config = npmconf, Object.defineProperty(npm, "_errorHandler", {
          get: () => __webpack_require__(62978)
        }), Object.defineProperty(npm, "_metrics", {
          get: () => __webpack_require__(21694)
        }), process.on("log", (function(level) {
          try {
            return log[level].apply(log, [].slice.call(arguments, 1));
          } catch (ex) {
            log.verbose("attempt to log " + inspect(arguments) + " crashed: " + ex.message);
          }
        }));
        var path = __webpack_require__(71017), abbrev = __webpack_require__(70143), which = __webpack_require__(7017), glob = __webpack_require__(34436), rimraf = __webpack_require__(68259), parseJSON = __webpack_require__(51686), aliases = __webpack_require__(27572).aliases, cmdList = __webpack_require__(27572).cmdList, plumbing = __webpack_require__(27572).plumbing, output = __webpack_require__(1015), startMetrics = __webpack_require__(21694).start, perf = __webpack_require__(87050);
        perf.emit("time", "npm"), perf.on("timing", (function(name, finished) {
          log.timing(name, "Completed in", finished + "ms");
        })), npm.config = {
          loaded: !1,
          get: function() {
            throw new Error("npm.load() required");
          },
          set: function() {
            throw new Error("npm.load() required");
          }
        }, npm.commands = {}, npm.limit = {
          fetch: 10,
          action: 50
        }, npm.lockfileVersion = 1, npm.rollbacks = [];
        try {
          var j = parseJSON(fs.readFileSync(path.join(__dirname, "../package.json")) + "");
          npm.name = j.name, npm.version = j.version;
        } catch (ex) {
          try {
            log.info("error reading version", ex);
          } catch (er) {}
          npm.version = ex;
        }
        var registryRefer, commandCache = {}, aliasNames = Object.keys(aliases), littleGuys = [ "isntall", "verison" ], fullList = cmdList.concat(aliasNames).filter((function(c) {
          return -1 === plumbing.indexOf(c);
        })), abbrevs = abbrev(fullList);
        function defaultCb(er, data) {
          log.disableProgress(), er ? console.error(er.stack || er.message) : output(data);
        }
        fullList = npm.fullList = fullList.filter((function(c) {
          return -1 === littleGuys.indexOf(c);
        })), Object.keys(abbrevs).concat(plumbing).forEach((function addCommand(c) {
          Object.defineProperty(npm.commands, c, {
            get: function() {
              if (!loaded) throw new Error("Call npm.load(config, cb) before using this command.\nSee the README.md or bin/npm-cli.js for example usage.");
              var a = npm.deref(c);
              if ("la" !== c && "ll" !== c || npm.config.set("long", !0), npm.command = c, commandCache[a]) return commandCache[a];
              var cmd = __webpack_require__(7885)("./" + a + ".js");
              return commandCache[a] = function() {
                var args = Array.prototype.slice.call(arguments, 0);
                "function" != typeof args[args.length - 1] && args.push(defaultCb), 1 === args.length && args.unshift([]), 
                Array(args[0]).forEach((function(arg) {
                  /^[\u2010-\u2015\u2212\uFE58\uFE63\uFF0D]/.test(arg) && log.error("arg", "Argument starts with non-ascii dash, this is probably invalid:", arg);
                })), registryRefer || (registryRefer = [ a ].concat(args[0]).map((function(arg) {
                  return arg && arg.match && arg.match(/\/|\\/) ? "[REDACTED]" : arg;
                })).filter((function(arg) {
                  return arg && arg.match;
                })).join(" "), npm.referer = registryRefer), cmd.apply(npm, args);
              }, Object.keys(cmd).forEach((function(k) {
                commandCache[a][k] = cmd[k];
              })), commandCache[a];
            },
            enumerable: -1 !== fullList.indexOf(c),
            configurable: !0
          }), c.match(/-([a-z])/) && addCommand(c.replace(/-([a-z])/g, (function(a, b) {
            return b.toUpperCase();
          })));
        })), npm.deref = function(c) {
          if (!c) return "";
          if (c.match(/[A-Z]/) && (c = c.replace(/([A-Z])/g, (function(m) {
            return "-" + m.toLowerCase();
          }))), -1 !== plumbing.indexOf(c)) return c;
          for (var a = abbrevs[c]; aliases[a]; ) a = aliases[a];
          return a;
        };
        var tmpFolder, loaded = !1, loading = !1, loadErr = null, loadListeners = [];
        npm.load = function(cli, cb_) {
          if (cb_ || "function" != typeof cli || (cb_ = cli, cli = {}), cb_ || (cb_ = function() {}), 
          cli || (cli = {}), loadListeners.push(cb_), loaded || loadErr) return cb(loadErr);
          if (!loading) {
            loading = !0;
            var onload = !0;
            log.pause(), function(npm, cli, cb) {
              which(process.argv[0], (function(er, node) {
                er || node.toUpperCase() === process.execPath.toUpperCase() || (log.verbose("node symlink", node), 
                process.execPath = node, process.installPrefix = path.resolve(node, "..", ".."));
                var builtin = path.resolve(__dirname, "..", "npmrc");
                npmconf.load(cli, builtin, (function(er, config) {
                  if (er === config && (er = null), npm.config = config, er) return cb(er);
                  !config.get("global") && config.sources.project && "ini" !== config.sources.project.type && log.verbose("config", "Skipping project config: %s. (matches userconfig)", config.localPrefix + "/.npmrc");
                  var ua = config.get("user-agent") || "";
                  ua = (ua = (ua = (ua = ua.replace(/\{node-version\}/gi, process.version)).replace(/\{npm-version\}/gi, npm.version)).replace(/\{platform\}/gi, process.platform)).replace(/\{arch\}/gi, process.arch);
                  const ciName = process.env.GERRIT_PROJECT ? "gerrit" : process.env.GITLAB_CI ? "gitlab" : process.env.APPVEYOR ? "appveyor" : process.env.CIRCLECI ? "circle-ci" : process.env.SEMAPHORE ? "semaphore" : process.env.DRONE ? "drone" : process.env.GITHUB_ACTION ? "github-actions" : process.env.TDDIUM ? "tddium" : process.env.JENKINS_URL ? "jenkins" : process.env["bamboo.buildKey"] ? "bamboo" : process.env.GO_PIPELINE_NAME ? "gocd" : process.env.CI_NAME ? process.env.CI_NAME : process.env.TRAVIS ? "travis-ci" : process.env.CODEBUILD_SRC_DIR ? "aws-codebuild" : "true" === process.env.CI || "1" === process.env.CI ? "custom" : !!process.env.BUILDER_OUTPUT && "builder", ci = ciName ? `ci/${ciName}` : "";
                  ua = ua.replace(/\{ci\}/gi, ci), config.set("user-agent", ua.trim()), null == config.get("metrics-registry") && config.set("metrics-registry", config.get("registry"));
                  var color = config.get("color");
                  switch (npm.config.get("timing") && "notice" === npm.config.get("loglevel") ? log.level = "timing" : log.level = config.get("loglevel"), 
                  log.heading = config.get("heading") || "npm", log.stream = config.get("logstream"), 
                  color) {
                   case "always":
                    npm.color = !0;
                    break;

                   case !1:
                    npm.color = !1;
                    break;

                   default:
                    npm.color = process.stdout.isTTY && "dumb" !== process.env.TERM;
                  }
                  npm.color ? log.enableColor() : log.disableColor(), config.get("unicode") ? log.enableUnicode() : log.disableUnicode(), 
                  config.get("progress") && process.stderr.isTTY && "dumb" !== process.env.TERM ? log.enableProgress() : log.disableProgress(), 
                  glob(path.resolve(npm.cache, "_logs", "*-debug.log"), (function(er, files) {
                    if (er) return cb(er);
                    for (;files.length >= npm.config.get("logs-max"); ) rimraf.sync(files[0]), files.splice(0, 1);
                  })), log.resume();
                  var umask = npm.config.get("umask");
                  npm.modes = {
                    exec: parseInt("0777", 8) & ~umask,
                    file: parseInt("0666", 8) & ~umask,
                    umask
                  };
                  var gp = Object.getOwnPropertyDescriptor(config, "globalPrefix");
                  Object.defineProperty(npm, "globalPrefix", gp);
                  var lp = Object.getOwnPropertyDescriptor(config, "localPrefix");
                  return Object.defineProperty(npm, "localPrefix", lp), config.set("scope", scopeifyScope(config.get("scope"))), 
                  npm.projectScope = config.get("scope") || scopeifyScope(function(prefix) {
                    try {
                      var pkg = JSON.parse(fs.readFileSync(path.join(prefix, "package.json")));
                      if ("string" != typeof pkg.name) return "";
                      var sep = pkg.name.indexOf("/");
                      return -1 === sep ? "" : pkg.name.slice(0, sep);
                    } catch (ex) {
                      return "";
                    }
                  }(npm.prefix)), startMetrics(), cb(null, npm);
                }));
              }));
            }(npm, cli, cb);
          }
          function cb(er) {
            if (!loadErr) {
              if (loadErr = er, er) return cb_(er);
              if (npm.config.get("force") && log.warn("using --force", "I sure hope you know what you are doing."), 
              npm.config.loaded = !0, loaded = !0, function(er) {
                loadListeners.forEach((function(cb) {
                  process.nextTick(cb.bind(npm, er, npm));
                })), loadListeners.length = 0;
              }(loadErr = er), onload = onload && npm.config.get("onload-script")) {
                try {
                  __webpack_require__(35965)(onload);
                } catch (err) {
                  log.warn("onload-script", "failed to require onload script", onload), log.warn("onload-script", err);
                }
                onload = !1;
              }
            }
          }
        }, Object.defineProperty(npm, "prefix", {
          get: function() {
            return npm.config.get("global") ? npm.globalPrefix : npm.localPrefix;
          },
          set: function(r) {
            var k = npm.config.get("global") ? "globalPrefix" : "localPrefix";
            return npm[k] = r, r;
          },
          enumerable: !0
        }), Object.defineProperty(npm, "bin", {
          get: function() {
            return npm.config.get("global") ? npm.globalBin : path.resolve(npm.root, ".bin");
          },
          enumerable: !0
        }), Object.defineProperty(npm, "globalBin", {
          get: function() {
            var b = npm.globalPrefix;
            return "win32" !== process.platform && (b = path.resolve(b, "bin")), b;
          }
        }), Object.defineProperty(npm, "dir", {
          get: function() {
            return npm.config.get("global") ? npm.globalDir : path.resolve(npm.prefix, "node_modules");
          },
          enumerable: !0
        }), Object.defineProperty(npm, "globalDir", {
          get: function() {
            return "win32" !== process.platform ? path.resolve(npm.globalPrefix, "lib", "node_modules") : path.resolve(npm.globalPrefix, "node_modules");
          },
          enumerable: !0
        }), Object.defineProperty(npm, "root", {
          get: function() {
            return npm.dir;
          }
        }), Object.defineProperty(npm, "cache", {
          get: function() {
            return npm.config.get("cache");
          },
          set: function(r) {
            return npm.config.set("cache", r);
          },
          enumerable: !0
        });
        var rand = __webpack_require__(6113).randomBytes(4).toString("hex");
        function scopeifyScope(scope) {
          return scope && "@" !== scope[0] ? "@" + scope : scope;
        }
        Object.defineProperty(npm, "tmp", {
          get: function() {
            return tmpFolder || (tmpFolder = "npm-" + process.pid + "-" + rand), path.resolve(npm.config.get("tmp"), tmpFolder);
          },
          enumerable: !0
        }), Object.getOwnPropertyNames(npm.commands).forEach((function(n) {
          npm.hasOwnProperty(n) || "config" === n || Object.defineProperty(npm, n, {
            get: function() {
              return function() {
                var args = Array.prototype.slice.call(arguments, 0), cb = defaultCb;
                1 === args.length && Array.isArray(args[0]) && (args = args[0]), "function" == typeof args[args.length - 1] && (cb = args.pop()), 
                npm.commands[n](args, cb);
              };
            },
            enumerable: !1,
            configurable: !0
          });
        })), __webpack_require__.c[__webpack_require__.s] === module && __webpack_require__(66419);
      }();
    },
    9424: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = __webpack_require__(96770).extract;
    },
    76111: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = __webpack_require__(96770).packument;
    },
    29668: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = __webpack_require__(27306);
    },
    65713: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = __webpack_require__(68582).publish;
    },
    33731: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = __webpack_require__(96770).tarball;
    },
    25171: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = __webpack_require__(34053);
    },
    88836: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const BB = __webpack_require__(41142), cacache = __webpack_require__(99269), figgyPudding = __webpack_require__(55212), libpub = __webpack_require__(65713), libunpub = __webpack_require__(37805), lifecycle = BB.promisify(__webpack_require__(4705)), log = __webpack_require__(19334), npa = __webpack_require__(4422), npmConfig = __webpack_require__(23300), output = __webpack_require__(1015), otplease = __webpack_require__(83304), pack = __webpack_require__(69797), tarball = __webpack_require__(33731), extract = __webpack_require__(9424), path = __webpack_require__(71017), readFileAsync = BB.promisify(__webpack_require__(59799).readFile), readJson = BB.promisify(__webpack_require__(92200)), semver = __webpack_require__(73107), statAsync = BB.promisify(__webpack_require__(59799).stat);
      publish.usage = "npm publish [<tarball>|<folder>] [--tag <tag>] [--access <public|restricted>] [--dry-run]\n\nPublishes '.' if no argument supplied\n\nSets tag `latest` if no --tag specified", 
      publish.completion = function(opts, cb) {
        return cb();
      };
      const PublishConfig = figgyPudding({
        dryRun: "dry-run",
        "dry-run": {
          default: !1
        },
        force: {
          default: !1
        },
        json: {
          default: !1
        },
        Promise: {
          default: () => Promise
        },
        tag: {
          default: "latest"
        },
        tmp: {}
      });
      function publish(args, isRetry, cb) {
        if ("function" != typeof cb && (cb = isRetry, isRetry = !1), 0 === args.length && (args = [ "." ]), 
        1 !== args.length) return cb(publish.usage);
        log.verbose("publish", args);
        const opts = PublishConfig(npmConfig()), t = opts.tag.trim();
        return semver.validRange(t) ? cb(new Error("Tag name must not be a valid SemVer range: " + t)) : function(arg, opts) {
          return statAsync(arg).then((stat => {
            if (stat.isDirectory()) return stat;
            {
              const err = new Error("not a directory");
              throw err.code = "ENOTDIR", err;
            }
          })).then((() => function(arg, opts) {
            let contents;
            return pack.prepareDirectory(arg).then((() => readJson(path.join(arg, "package.json")))).then((pkg => lifecycle(pkg, "prepublishOnly", arg))).then((() => readJson(path.join(arg, "package.json")))).then((pkg => cacache.tmp.withTmp(opts.tmp, {
              tmpPrefix: "fromDir"
            }, (tmpDir => {
              const target = path.join(tmpDir, "package.tgz");
              return pack.packDirectory(pkg, arg, target, null, !0).tap((c => {
                contents = c;
              })).then((c => !opts.json && pack.logContents(c))).then((() => upload(pkg, !1, target, opts)));
            })))).then((() => readJson(path.join(arg, "package.json")))).tap((pkg => lifecycle(pkg, "publish", arg))).tap((pkg => lifecycle(pkg, "postpublish", arg))).then((() => contents));
          }(arg, opts)), (err => {
            if ("ENOENT" !== err.code && "ENOTDIR" !== err.code) throw err;
            return function(arg, opts) {
              return cacache.tmp.withTmp(opts.tmp, {
                tmpPrefix: "fromPackage"
              }, (tmp => {
                const extracted = path.join(tmp, "package"), target = path.join(tmp, "package.json");
                return tarball.toFile(arg, target, opts).then((() => extract(arg, extracted, opts))).then((() => readJson(path.join(extracted, "package.json")))).then((pkg => BB.resolve(pack.getContents(pkg, target)).tap((c => !opts.json && pack.logContents(c))).tap((() => upload(pkg, !1, target, opts)))));
              }));
            }(arg, opts);
          }));
        }(args[0], opts).then((tarball => {
          const silent = "silent" === log.level;
          !silent && opts.json ? output(JSON.stringify(tarball, null, 2)) : silent || output(`+ ${tarball.id}`);
        })).nodeify(cb);
      }
      function upload(pkg, isRetry, cached, opts) {
        return opts.dryRun ? opts.Promise.resolve(!0) : readFileAsync(cached).then((tarball => otplease(opts, (opts => libpub(pkg, tarball, opts))).catch((err => {
          if ("EPUBLISHCONFLICT" === err.code && opts.force && !isRetry) return log.warn("publish", "Forced publish over " + pkg._id), 
          otplease(opts, (opts => libunpub(npa.resolve(pkg.name, pkg.version), opts))).finally((() => otplease(opts, (opts => upload(pkg, !0, tarball, opts))).catch((() => {
            throw err;
          }))));
          throw err;
        }))));
      }
      module.exports = publish;
    },
    28429: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const ObjectGetOwnPropertyDescriptors = Object.getOwnPropertyDescriptors, util = __webpack_require__(73837), timers = __webpack_require__(39512), kCustomPromisifiedSymbol = util.promisify && util.promisify.custom || Symbol("util.promisify.custom");
      function promisify(orig) {
        if ("function" != typeof orig) {
          var err = TypeError('The "original" argument must be of type function');
          throw err.code = "ERR_INVALID_ARG_TYPE", err.name = `TypeError [${err.code}]`, err;
        }
        if (orig === timers.setTimeout || orig === timers.setImmediate) {
          const _orig = orig;
          orig = function() {
            for (var args = [], i = 0; i < arguments.length; i++) args.push(arguments[i]);
            const _cb = args.pop(), cb = function() {
              for (var args = [], i = 0; i < arguments.length; i++) args.push(arguments[i]);
              _cb.apply(null, [ null ].concat(args));
            };
            _orig.apply(timers, [ cb ].concat(args));
          };
        }
        if (orig[kCustomPromisifiedSymbol]) {
          const fn = orig[kCustomPromisifiedSymbol];
          if ("function" != typeof fn) throw new TypeError("The [util.promisify.custom] property must be a function");
          return Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: !1,
            writable: !1,
            configurable: !0
          }), fn;
        }
        function fn() {
          for (var args = [], i = 0; i < arguments.length; i++) args.push(arguments[i]);
          let resolve, reject;
          const promise = new Promise((function(_resolve, _reject) {
            resolve = _resolve, reject = _reject;
          }));
          try {
            orig.apply(this, args.concat((function(err) {
              for (var values = [], i = 1; i < arguments.length; i++) values.push(arguments[i]);
              err ? reject(err) : resolve(values[0]);
            })));
          } catch (err) {
            reject(err);
          }
          return promise;
        }
        return Object.setPrototypeOf(fn, Object.getPrototypeOf(orig)), Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), ObjectGetOwnPropertyDescriptors ? Object.defineProperties(fn, ObjectGetOwnPropertyDescriptors(orig)) : fn;
      }
      promisify.custom = kCustomPromisifiedSymbol, module.exports = promisify;
    },
    340: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const BB = __webpack_require__(41142), extractionWorker = __webpack_require__(83990), figgyPudding = __webpack_require__(55212), npa = __webpack_require__(19932);
      __webpack_require__(35965).resolve("./extract-worker.js");
      const ExtractOpts = figgyPudding({
        log: {},
        dirPacker: {}
      });
      module.exports = {
        startWorkers() {
          false;
        },
        stopWorkers() {
          false;
        },
        child(name, child, childPath, opts) {
          opts = ExtractOpts(opts);
          const spec = npa.resolve(name, child.version);
          let childOpts = opts.concat({
            integrity: child.integrity,
            resolved: child.resolved
          });
          const args = [ spec, childPath, childOpts ];
          return BB.fromNode((cb => {
            let launcher = extractionWorker, msg = args;
            "string" == typeof args[0] && npa(args[0]);
            launcher(msg, cb);
          }));
        }
      };
    },
    8579: (module, exports, __webpack_require__) => {
      "use strict";
      const path = __webpack_require__(71017), validate = __webpack_require__(6198), fs = __webpack_require__(59799), isInside = __webpack_require__(13468), vacuum = __webpack_require__(8127), chain = __webpack_require__(89009).chain, asyncMap = __webpack_require__(89009).asyncMap, readCmdShim = __webpack_require__(11093), iferr = __webpack_require__(48588);
      function isSafeToRm(parent, target, pkgName, log, cb) {
        if (log.silly("gentlyRm", "parent.path =", parent.path), log.silly("gentlyRm", "parent.managed =", parent.managed && parent.managed.target + " is in " + parent.managed.path), 
        log.silly("gentlyRm", "target.path = ", target.path), log.silly("gentlyRm", "target.symlink =", target.symlink), 
        log.silly("gentlyRm", "target.managed =", target.managed && target.managed.target + " is in " + target.managed.path), 
        log.silly("gentlyRm", "target.inParent = ", target.inParent), !parent.managed) return log.info("gentlyRm", parent.path, "is not contained in any directory " + pkgName + " is known to control or any place they link to"), 
        cb(clobberFail(target.path, "containing path " + parent.path + " isn't under " + pkgName + "'s control"));
        if (target.inParent) {
          var actualTarget = target.inParent.target, targetsParent = target.inParent.path;
          return target.path === actualTarget ? cb(null, target.path, targetsParent) : cb(null, target.path, path.dirname(target.path));
        }
        return target.managed && target.symlink ? (log.warn("rm", "not removing", target.path, "as it wasn't installed by", parent.path), 
        cb()) : target.symlink ? cb(clobberFail(target.path, target.symlink + " symlink target is not controlled by " + pkgName + " " + parent.path)) : cb(clobberFail(target.path, "is outside " + parent.path + " and not a link"));
      }
      function clobberFail(target, msg) {
        validate("SS", arguments);
        var er = new Error("Refusing to delete " + target + ": " + msg);
        return er.code = "EEXIST", er.path = target, er;
      }
      function isENOENT(err) {
        return err && "ENOENT" === err.code;
      }
      function notENOENT(err) {
        return !isENOENT(err);
      }
      function skipENOENT(cb) {
        return function(err, value) {
          return isENOENT(err) ? cb(null, !1) : cb(err, value);
        };
      }
      function errorsToValues(fn) {
        return function() {
          var args = Array.prototype.slice.call(arguments), cb = args.pop();
          args.push((function(err, value) {
            return cb(null, err || value);
          })), fn.apply(null, args);
        };
      }
      function isNotError(value) {
        return !(value instanceof Error);
      }
      function isEverInside(target, paths, log, cb) {
        validate("SAOF", arguments), asyncMap(paths, errorsToValues(readAllLinks), iferr(cb, (function(resolvedPaths) {
          var errorFree = resolvedPaths.filter(isNotError);
          if (0 === errorFree.length) {
            var badErrors = resolvedPaths.filter(notENOENT);
            return 0 === badErrors.length ? cb(null, !1) : cb(badErrors[0]);
          }
          readAllLinks(target, iferr(skipENOENT(cb), (function(targets) {
            cb(null, areAnyInsideAny(targets, errorFree, log));
          })));
        })));
      }
      function areAnyInsideAny(targets, paths, log) {
        validate("AAO", arguments);
        var toCheck = [];
        paths.forEach((function(path) {
          targets.forEach((function(target) {
            toCheck.push([ target, path ]);
          }));
        }));
        for (var ii = 0; ii < toCheck.length; ++ii) {
          var target = toCheck[ii][0], path = toCheck[ii][1], inside = isInside(target, path);
          if (inside || log.silly("isEverInside", target, "is not inside", path), inside && path) return inside && path && {
            target,
            path
          };
        }
        return !1;
      }
      function readAllLinks(path, cb) {
        validate("SF", arguments);
        var seen = {};
        function _readAllLinks(path) {
          if (seen[path]) return cb(null, Object.keys(seen));
          seen[path] = !0, resolveSymlink(path, iferr(cb, _readAllLinks));
        }
        _readAllLinks(path);
      }
      (exports = module.exports = function(target, opts, cb) {
        var targetPath = path.normalize(path.resolve(opts.prefix, target));
        if (-1 !== opts.prefixes.indexOf(targetPath)) return cb(new Error("May not delete: " + targetPath));
        var options = {};
        opts.force && (options.purge = !0);
        opts.base && (options.base = path.normalize(path.resolve(opts.prefix, opts.base)));
        if (!opts.gently) return options.purge = !0, vacuum(targetPath, options, cb);
        var parent = options.base = options.base || path.normalize(opts.prefix);
        chain([ [ isEverInside, parent, opts.prefixes, opts.log ], [ readLinkOrShim, targetPath ], [ isEverInside, targetPath, opts.prefixes, opts.log ], [ isEverInside, targetPath, [ parent ], opts.log ] ], (function(er, results) {
          if (er) return "ENOENT" === er.code ? cb() : cb(er);
          isSafeToRm({
            path: parent,
            managed: results[0]
          }, {
            path: targetPath,
            symlink: results[1],
            managed: results[2],
            inParent: results[3]
          }, opts.name, opts.log, iferr(cb, (function(toRemove, removeBase) {
            if (!toRemove) return cb();
            removeBase && (options.base = removeBase);
            return vacuum(toRemove, options, cb);
          })));
        }));
      })._isSafeToRm = isSafeToRm, exports._isEverInside = isEverInside, exports._areAnyInsideAny = areAnyInsideAny, 
      exports._readAllLinks = readAllLinks, exports._resolveSymlink = resolveSymlink;
      var resolvedPaths = {};
      function resolveSymlink(symlink, cb) {
        validate("SF", arguments);
        var cached = resolvedPaths[symlink];
        if (cached) return cb(null, cached);
        readLinkOrShim(symlink, iferr(cb, (function(symlinkTarget) {
          return resolvedPaths[symlink] = symlinkTarget ? path.resolve(path.dirname(symlink), symlinkTarget) : symlink, 
          cb(null, resolvedPaths[symlink]);
        })));
      }
      function readLinkOrShim(path, cb) {
        validate("SF", arguments), fs.lstat(path, iferr(cb, (function(stat) {
          stat.isSymbolicLink() ? fs.readlink(path, cb) : readCmdShim(path, (function(er, source) {
            return er ? "ENOTASHIM" === er.code || "EISDIR" === er.code ? cb(null, null) : cb(er) : cb(null, source);
          }));
        })));
      }
      exports._readLinkOrShim = readLinkOrShim;
    },
    63322: (module, __unused_webpack_exports, __webpack_require__) => {
      var fs = __webpack_require__(59799), Writable = __webpack_require__(91685).Writable, util = __webpack_require__(73837), MurmurHash3 = __webpack_require__(287), iferr = __webpack_require__(48588), crypto = __webpack_require__(6113);
      var invocations = 0;
      function getTmpname(filename) {
        return filename + "." + function() {
          for (var hash = MurmurHash3(""), ii = 0; ii < arguments.length; ++ii) hash.hash("" + arguments[ii]);
          return hash.result();
        }(__filename, process.pid, ++invocations);
      }
      var setImmediate = global.setImmediate || setTimeout;
      function WriteStreamAtomic(path, options) {
        if (!(this instanceof WriteStreamAtomic)) return new WriteStreamAtomic(path, options);
        var writeStream;
        Writable.call(this, options), this.__isWin = options && options.hasOwnProperty("isWin") ? options.isWin : "win32" === process.platform, 
        this.__atomicTarget = path, this.__atomicTmp = getTmpname(path), this.__atomicChown = options && options.chown, 
        this.__atomicClosed = !1, this.__atomicStream = fs.WriteStream(this.__atomicTmp, options), 
        this.__atomicStream.once("open", (writeStream = this, function(fd) {
          writeStream.emit("open", fd);
        })), this.__atomicStream.once("close", function(writeStream) {
          return function() {
            if (!writeStream.__atomicClosed) {
              if (writeStream.__atomicClosed = !0, writeStream.__atomicChown) {
                var uid = writeStream.__atomicChown.uid, gid = writeStream.__atomicChown.gid;
                return fs.chown(writeStream.__atomicTmp, uid, gid, iferr(cleanup, moveIntoPlace));
              }
              moveIntoPlace();
            }
          };
          function moveIntoPlace() {
            fs.rename(writeStream.__atomicTmp, writeStream.__atomicTarget, iferr(trapWindowsEPERM, end));
          }
          function trapWindowsEPERM(err) {
            writeStream.__isWin && err.syscall && "rename" === err.syscall && err.code && "EPERM" === err.code ? checkFileHashes(err) : cleanup(err);
          }
          function checkFileHashes(eperm) {
            var inprocess = 2, tmpFileHash = crypto.createHash("sha512"), targetFileHash = crypto.createHash("sha512");
            function fileHashError() {
              0 !== inprocess && (inprocess = 0, cleanup(eperm));
            }
            function fileHashComplete() {
              if (0 !== inprocess && !--inprocess) return tmpFileHash.digest("hex") === targetFileHash.digest("hex") ? cleanup() : cleanup(eperm);
            }
            fs.createReadStream(writeStream.__atomicTmp).on("data", (function(data, enc) {
              tmpFileHash.update(data, enc);
            })).on("error", fileHashError).on("end", fileHashComplete), fs.createReadStream(writeStream.__atomicTarget).on("data", (function(data, enc) {
              targetFileHash.update(data, enc);
            })).on("error", fileHashError).on("end", fileHashComplete);
          }
          function cleanup(err) {
            fs.unlink(writeStream.__atomicTmp, (function() {
              err ? (writeStream.emit("error", err), writeStream.emit("close")) : end();
            }));
          }
          function end() {
            Writable.prototype.emit.call(writeStream, "finish"), setImmediate((function() {
              writeStream.emit("close");
            }));
          }
        }(this)), this.__atomicStream.once("error", function(writeStream) {
          return function(er) {
            cleanupSync(), writeStream.emit("error", er), writeStream.__atomicClosed = !0, writeStream.emit("close");
          };
          function cleanupSync() {
            try {
              fs.unlinkSync(writeStream.__atomicTmp);
            } finally {
              return;
            }
          }
        }(this));
      }
      module.exports = WriteStreamAtomic, util.inherits(WriteStreamAtomic, Writable), 
      WriteStreamAtomic.prototype.emit = function(event) {
        return "finish" === event ? this.__atomicStream.end() : Writable.prototype.emit.apply(this, arguments);
      }, WriteStreamAtomic.prototype._write = function(buffer, encoding, cb) {
        if (this.__atomicStream.write(buffer, encoding)) return cb();
        this.__atomicStream.once("drain", cb);
      };
    },
    47602: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const childProcess = __webpack_require__(32081), childModule = __webpack_require__(35965).resolve("./worker-farm-child");
      module.exports = function(forkModule, workerOptions) {
        let filteredArgs = process.execArgv.filter((function(v) {
          return !/^--(debug|inspect)/.test(v);
        })), options = Object.assign({
          execArgv: filteredArgs,
          env: process.env,
          cwd: process.cwd()
        }, workerOptions), child = childProcess.fork(childModule, process.argv, options);
        return child.on("error", (function() {})), child.send({
          owner: "farm",
          module: forkModule
        }), {
          send: child.send.bind(child),
          child
        };
      };
    },
    35975: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = function(dir, input, config, cb) {
        "function" == typeof config && (cb = config, config = {});
        if ("function" != typeof config.get) {
          var data = config;
          config = {
            get: function(k) {
              return data[k];
            },
            toJSON: function() {
              return data;
            }
          };
        }
        var pkg, packageFile = path.resolve(dir, "package.json");
        input = path.resolve(input);
        var ctx = {
          yes: yes(config)
        }, es = readJson.extraSet;
        readJson.extraSet = es.filter((function(fn) {
          return "authors" !== fn.name && "mans" !== fn.name;
        })), readJson(packageFile, (function(er, d) {
          readJson.extraSet = es, pkg = er ? {} : d, ctx.filename = packageFile, ctx.dirname = path.dirname(packageFile), 
          ctx.basename = path.basename(ctx.dirname), pkg.version && semver.valid(pkg.version) || delete pkg.version, 
          ctx.package = pkg, ctx.config = config || {};
          var pz = new PZ(input, ctx);
          pz.backupFile = def, pz.on("error", cb), pz.on("data", (function(data) {
            Object.keys(data).forEach((function(k) {
              void 0 !== data[k] && null !== data[k] && (pkg[k] = data[k]);
            }));
            var es = readJson.extraSet;
            readJson.extraSet = es.filter((function(fn) {
              return "authors" !== fn.name && "mans" !== fn.name;
            })), readJson.extras(packageFile, pkg, (function(er, pkg) {
              if (readJson.extraSet = es, er) return cb(er, pkg);
              pkg = function(data) {
                data.author && (data.author = unParsePerson(data.author));
                return [ "maintainers", "contributors" ].forEach((function(set) {
                  Array.isArray(data[set]) && (data[set] = data[set].map(unParsePerson));
                })), data;
              }(pkg), delete pkg.readme, delete pkg.readmeFilename, delete pkg._id, delete pkg.gitHead, 
              pkg.repository || delete pkg.repository, pkg.description || (pkg.description = data.description);
              var d = JSON.stringify(pkg, null, 2) + "\n";
              function write(yes) {
                fs.writeFile(packageFile, d, "utf8", (function(er) {
                  return er || !yes || config.get("silent") || console.log("Wrote to %s:\n\n%s\n", packageFile, d), 
                  cb(er, pkg);
                }));
              }
              if (ctx.yes) return write(!0);
              console.log("About to write to %s:\n\n%s\n", packageFile, d), read({
                prompt: "Is this OK? ",
                default: "yes"
              }, (function(er, ok) {
                return er ? cb(er) : ok && "y" === ok.toLowerCase().charAt(0) ? write() : void console.log("Aborted.");
              }));
            }));
          }));
        }));
      }, module.exports.yes = yes;
      var PZ = __webpack_require__(854).PromZard, path = __webpack_require__(71017), def = path.join(__dirname, "init-package-json.js"), fs = __webpack_require__(57147), semver = __webpack_require__(73107), read = __webpack_require__(9547), readJson = __webpack_require__(92200);
      function yes(conf) {
        return !!(conf.get("yes") || conf.get("y") || conf.get("force") || conf.get("f"));
      }
      function unParsePerson(person) {
        if ("string" == typeof person) return person;
        var name = person.name || "", u = person.url || person.web, url = u ? " (" + u + ")" : "", e = person.email || person.mail;
        return name + (e ? " <" + e + ">" : "") + url;
      }
    },
    38175: (module, exports, __webpack_require__) => {
      "use strict";
      (exports = module.exports = function(pkg, stage, wd, opts) {
        return new Promise(((resolve, reject) => {
          for (;pkg && pkg._data; ) pkg = pkg._data;
          if (!pkg) return reject(new Error("Invalid package data"));
          opts.log.info("lifecycle", logid(pkg, stage), pkg._id), pkg.scripts || (pkg.scripts = {}), 
          "prepublish" === stage && opts.ignorePrepublish && (opts.log.info("lifecycle", logid(pkg, stage), "ignored because ignore-prepublish is set to true", pkg._id), 
          delete pkg.scripts.prepublish), hookStat(opts.dir, stage, (function(statError) {
            if (!pkg.scripts[stage] && statError) return resolve();
            validWd(wd || path.resolve(opts.dir, pkg.name), (function(er, wd) {
              if (er) return reject(er);
              if ((0 !== wd.indexOf(opts.dir) || _incorrectWorkingDirectory(wd, pkg)) && !opts.unsafePerm && pkg.scripts[stage]) return opts.log.warn("lifecycle", logid(pkg, stage), "cannot run in wd", pkg._id, pkg.scripts[stage], `(wd=${wd})`), 
              resolve();
              var env = makeEnv(pkg, opts);
              env.npm_lifecycle_event = stage, env.npm_node_execpath = env.NODE = env.NODE || process.execPath, 
              env.npm_execpath = __webpack_require__.c[__webpack_require__.s].filename, env.INIT_CWD = process.cwd(), 
              env.npm_config_node_gyp = env.npm_config_node_gyp || DEFAULT_NODE_GYP_PATH, opts.unsafePerm || (env.TMPDIR = wd), 
              function(pkg, stage, wd, opts, env, cb) {
                var pathArr = [], p = wd.split(/[\\/]node_modules[\\/]/), acc = path.resolve(p.shift());
                p.forEach((function(pp) {
                  pathArr.unshift(path.join(acc, "node_modules", ".bin")), acc = path.join(acc, "node_modules", pp);
                })), pathArr.unshift(path.join(acc, "node_modules", ".bin")), pathArr.unshift(path.resolve(__dirname, "../bin/node-gyp-bin")), 
                shouldPrependCurrentNodeDirToPATH(opts) && pathArr.push(path.dirname(process.execPath));
                const existingPath = mergePath(env);
                existingPath && pathArr.push(existingPath);
                const envPath = pathArr.join(isWindows ? ";" : ":");
                setPathEnv(env, envPath);
                var packageLifecycle = pkg.scripts && pkg.scripts.hasOwnProperty(stage);
                opts.ignoreScripts ? (opts.log.info("lifecycle", logid(pkg, stage), "ignored because ignore-scripts is set to true", pkg._id), 
                packageLifecycle = !1) : packageLifecycle ? env.npm_lifecycle_script = pkg.scripts[stage] : opts.log.silly("lifecycle", logid(pkg, stage), "no script for " + stage + ", continuing");
                function done(er) {
                  er && (opts.force ? (opts.log.info("lifecycle", logid(pkg, stage), "forced, continuing", er), 
                  er = null) : opts.failOk && (opts.log.warn("lifecycle", logid(pkg, stage), "continuing anyway", er.message), 
                  er = null)), cb(er);
                }
                chain([ packageLifecycle && [ runPackageLifecycle, pkg, stage, env, wd, opts ], [ runHookLifecycle, pkg, stage, env, wd, opts ] ], done);
              }(pkg, stage, wd, opts, env, (er => er ? reject(er) : resolve()));
            }));
          }));
        }));
      }).makeEnv = makeEnv, exports._incorrectWorkingDirectory = _incorrectWorkingDirectory;
      const isWindows = "win32" === (process.env.__TESTING_FAKE_PLATFORM__ || process.platform), spawn = __webpack_require__(2567), path = __webpack_require__(71017), Stream = __webpack_require__(12781).Stream, fs = __webpack_require__(59799), chain = __webpack_require__(89009).chain, uidNumber = __webpack_require__(7971), umask = __webpack_require__(37289), which = __webpack_require__(7017), byline = __webpack_require__(52854), DEFAULT_NODE_GYP_PATH = path.resolve(__dirname, "../bin/node-gyp.js"), hookStatCache = new Map;
      let PATH = isWindows ? "Path" : "PATH";
      exports._pathEnvName = PATH;
      const delimiter = path.delimiter, mergePath = env => Object.keys(env).filter((p => /^path$/i.test(p) && env[p])).map((p => env[p].split(delimiter))).reduce(((set, p) => set.concat(p.filter((p => !set.includes(p))))), []).join(delimiter);
      exports._mergePath = mergePath;
      const setPathEnv = (env, path) => {
        env[PATH] = path, Object.keys(env).filter((p => p !== PATH && /^path$/i.test(p))).forEach((p => {
          env[p] = path;
        }));
      };
      function logid(pkg, stage) {
        return pkg._id + "~" + stage + ":";
      }
      function hookStat(dir, stage, cb) {
        const hook = path.join(dir, ".hooks", stage), cachedStatError = hookStatCache.get(hook);
        return void 0 === cachedStatError ? fs.stat(hook, (function(statError) {
          hookStatCache.set(hook, statError), cb(statError);
        })) : setImmediate((() => cb(cachedStatError)));
      }
      function _incorrectWorkingDirectory(wd, pkg) {
        return wd.lastIndexOf(pkg.name) !== wd.length - pkg.name.length;
      }
      function shouldPrependCurrentNodeDirToPATH(opts) {
        const cfgsetting = opts.scriptsPrependNodePath;
        if (!1 === cfgsetting) return !1;
        if (!0 === cfgsetting) return !0;
        var isDifferentNodeInPath, foundExecPath;
        try {
          foundExecPath = which.sync(path.basename(process.execPath), {
            pathExt: isWindows ? ";" : ":"
          }), isDifferentNodeInPath = fs.realpathSync(process.execPath).toUpperCase() !== fs.realpathSync(foundExecPath).toUpperCase();
        } catch (e) {
          isDifferentNodeInPath = !0;
        }
        return "warn-only" === cfgsetting ? (isDifferentNodeInPath && !shouldPrependCurrentNodeDirToPATH.hasWarned && (foundExecPath ? opts.log.warn("lifecycle", "The node binary used for scripts is", foundExecPath, "but npm is using", process.execPath, "itself. Use the `--scripts-prepend-node-path` option to include the path for the node binary npm was executed with.") : opts.log.warn("lifecycle", "npm is using", process.execPath, "but there is no node binary in the current PATH. Use the `--scripts-prepend-node-path` option to include the path for the node binary npm was executed with."), 
        shouldPrependCurrentNodeDirToPATH.hasWarned = !0), !1) : isDifferentNodeInPath;
      }
      function validWd(d, cb) {
        fs.stat(d, (function(er, st) {
          if (er || !st.isDirectory()) {
            var p = path.dirname(d);
            return p === d ? cb(new Error("Could not find suitable wd")) : validWd(p, cb);
          }
          return cb(null, d);
        }));
      }
      function runPackageLifecycle(pkg, stage, env, wd, opts, cb) {
        var cmd = env.npm_lifecycle_script;
        runCmd("\n> " + pkg._id + " " + stage + " " + wd + "\n> " + cmd + "\n", cmd, pkg, env, stage, wd, opts, cb);
      }
      exports._setPathEnv = setPathEnv;
      var running = !1, queue = [];
      function dequeue() {
        if (running = !1, queue.length) {
          var r = queue.shift();
          runCmd.apply(null, r);
        }
      }
      function runCmd(note, cmd, pkg, env, stage, wd, opts, cb) {
        if (running) queue.push([ note, cmd, pkg, env, stage, wd, opts, cb ]); else {
          running = !0, opts.log.pause();
          var unsafe = opts.unsafePerm, user = unsafe ? null : opts.user, group = unsafe ? null : opts.group;
          "silent" !== opts.log.level && (opts.log.clearProgress(), console.log(note), opts.log.showProgress()), 
          opts.log.verbose("lifecycle", logid(pkg, stage), "unsafe-perm in lifecycle", unsafe), 
          isWindows && (unsafe = !0), unsafe ? runCmd_(cmd, pkg, env, wd, opts, stage, unsafe, 0, 0, cb) : uidNumber(user, group, (function(er, uid, gid) {
            if (er) return er.code = "EUIDLOOKUP", opts.log.resume(), process.nextTick(dequeue), 
            cb(er);
            runCmd_(cmd, pkg, env, wd, opts, stage, unsafe, uid, gid, cb);
          }));
        }
      }
      const getSpawnArgs = ({cmd, wd, opts, uid, gid, unsafe, env}) => {
        const conf = {
          cwd: wd,
          env,
          stdio: opts.stdio || [ 0, 1, 2 ]
        };
        unsafe || (conf.uid = 0 ^ uid, conf.gid = 0 ^ gid);
        const customShell = opts.scriptShell;
        let sh = "sh", shFlag = "-c";
        return customShell ? sh = customShell : (isWindows || opts._TESTING_FAKE_WINDOWS_) && (sh = process.env.comspec || "cmd", 
        /^(?:.*\\)?cmd(?:\.exe)?$/i.test(sh) && (shFlag = "/d /s /c", conf.windowsVerbatimArguments = !0)), 
        [ sh, [ shFlag, cmd ], conf ];
      };
      function runCmd_(cmd, pkg, env, wd, opts, stage, unsafe, uid, gid, cb_) {
        const [sh, args, conf] = getSpawnArgs({
          cmd,
          wd,
          opts,
          uid,
          gid,
          unsafe,
          env
        });
        opts.log.verbose("lifecycle", logid(pkg, stage), "PATH:", env[PATH]), opts.log.verbose("lifecycle", logid(pkg, stage), "CWD:", wd), 
        opts.log.silly("lifecycle", logid(pkg, stage), "Args:", args);
        var proc = spawn(sh, args, conf, opts.log);
        function procError(er) {
          return er && (opts.log.info("lifecycle", logid(pkg, stage), "Failed to exec " + stage + " script"), 
          er.message = pkg._id + " " + stage + ": `" + cmd + "`\n" + er.message, "EPERM" !== er.code && (er.code = "ELIFECYCLE"), 
          fs.stat(opts.dir, (function(statError, d) {
            statError && "ENOENT" === statError.code && "node_modules" === opts.dir.split(path.sep).slice(-1)[0] && opts.log.warn("", "Local package.json exists, but node_modules missing, did you mean to install?");
          })), er.pkgid = pkg._id, er.stage = stage, er.script = cmd, er.pkgname = pkg.name), 
          process.removeListener("SIGTERM", procKill), process.removeListener("SIGTERM", procInterupt), 
          process.removeListener("SIGINT", procKill), process.removeListener("SIGINT", procInterupt), 
          function(er) {
            cb_.apply(null, arguments), opts.log.resume(), process.nextTick(dequeue);
          }(er);
        }
        function procKill() {
          proc.kill();
        }
        function procInterupt() {
          proc.kill("SIGINT"), proc.on("exit", (function() {
            process.exit();
          })), process.once("SIGINT", procKill);
        }
        proc.on("error", procError), proc.on("close", (function(code, signal) {
          if (opts.log.silly("lifecycle", logid(pkg, stage), "Returned: code:", code, " signal:", signal), 
          signal) process.kill(process.pid, signal); else if (code) {
            var er = new Error("Exit status " + code);
            er.errno = code;
          }
          procError(er);
        })), byline(proc.stdout).on("data", (function(data) {
          opts.log.verbose("lifecycle", logid(pkg, stage), "stdout", data.toString());
        })), byline(proc.stderr).on("data", (function(data) {
          opts.log.verbose("lifecycle", logid(pkg, stage), "stderr", data.toString());
        })), process.once("SIGTERM", procKill), process.once("SIGINT", procInterupt);
      }
      function runHookLifecycle(pkg, stage, env, wd, opts, cb) {
        hookStat(opts.dir, stage, (function(er) {
          if (er) return cb();
          var cmd = path.join(opts.dir, ".hooks", stage);
          runCmd("\n> " + pkg._id + " " + stage + " " + wd + "\n> " + cmd, cmd, pkg, env, stage, wd, opts, cb);
        }));
      }
      function makeEnv(data, opts, prefix, env) {
        if (prefix = prefix || "npm_package_", env) data.hasOwnProperty("_lifecycleEnv") || Object.defineProperty(data, "_lifecycleEnv", {
          value: env,
          enumerable: !1
        }); else {
          for (var i in env = {}, process.env) i.match(/^npm_/) || (env[i] = process.env[i]);
          opts.production && (env.NODE_ENV = "production");
        }
        for (i in opts.nodeOptions && (env.NODE_OPTIONS = opts.nodeOptions), data) if ("_" !== i.charAt(0)) {
          var envKey = (prefix + i).replace(/[^a-zA-Z0-9_]/g, "_");
          if ("readme" === i) continue;
          if (data[i] && "object" == typeof data[i]) try {
            JSON.stringify(data[i]), makeEnv(data[i], opts, envKey + "_", env);
          } catch (ex) {
            var d = data[i];
            makeEnv({
              name: d.name,
              version: d.version,
              path: d.path
            }, opts, envKey + "_", env);
          } else env[envKey] = String(data[i]), env[envKey] = -1 !== env[envKey].indexOf("\n") ? JSON.stringify(env[envKey]) : env[envKey];
        }
        if ("npm_package_" !== prefix) return env;
        prefix = "npm_config_";
        var pkgConfig = {}, pkgVerConfig = {}, namePref = data.name + ":", verPref = data.name + "@" + data.version + ":";
        return Object.keys(opts.config).forEach((function(i) {
          if (!("_" === i.charAt(0) && 0 !== i.indexOf("_" + namePref) || i.match(/:_/))) {
            var value = opts.config[i];
            if (!(value instanceof Stream || Array.isArray(value) || "function" == typeof value) && (i.match(/umask/) && (value = umask.toString(value)), 
            value ? "number" == typeof value ? value = "" + value : "string" != typeof value && (value = JSON.stringify(value)) : value = "", 
            "string" == typeof value)) {
              var k;
              value = -1 !== value.indexOf("\n") ? JSON.stringify(value) : value, 0 === (i = i.replace(/^_+/, "")).indexOf(namePref) ? (k = i.substr(namePref.length).replace(/[^a-zA-Z0-9_]/g, "_"), 
              pkgConfig[k] = value) : 0 === i.indexOf(verPref) && (k = i.substr(verPref.length).replace(/[^a-zA-Z0-9_]/g, "_"), 
              pkgVerConfig[k] = value);
              var envKey = (prefix + i).replace(/[^a-zA-Z0-9_]/g, "_");
              env[envKey] = value;
            }
          }
        })), prefix = "npm_package_config_", [ pkgConfig, pkgVerConfig ].forEach((function(conf) {
          for (var i in conf) {
            env[prefix + i] = conf[i];
          }
        })), env;
      }
      exports._getSpawnArgs = getSpawnArgs;
    },
    73107: module => {
      "use strict";
      module.exports = require("./semver");
    },
    39148: module => {
      "use strict";
      module.exports = require("./tar");
    },
    66419: module => {
      "use strict";
      module.exports = require("../bin/npm-cli");
    },
    99269: module => {
      "use strict";
      module.exports = require("./cacache");
    },
    83990: module => {
      "use strict";
      module.exports = require("./extract-worker");
    },
    2985: module => {
      "use strict";
      module.exports = require("./libnpx");
    },
    25315: module => {
      "use strict";
      module.exports = require("./move-concurrently");
    },
    60166: module => {
      "use strict";
      module.exports = require("./nopt");
    },
    17770: module => {
      "use strict";
      module.exports = require("./normalize-package-data");
    },
    19932: module => {
      "use strict";
      module.exports = require("./npm-package-arg");
    },
    19334: module => {
      "use strict";
      module.exports = require("./npmlog");
    },
    96770: module => {
      "use strict";
      module.exports = require("./pacote");
    },
    91685: module => {
      "use strict";
      module.exports = require("./readable-stream");
    },
    41142: module => {
      "use strict";
      module.exports = require("../vendor/bluebird");
    },
    34436: module => {
      "use strict";
      module.exports = require("../vendor/glob");
    },
    59799: module => {
      "use strict";
      module.exports = require("../vendor/graceful-fs");
    },
    72564: module => {
      "use strict";
      module.exports = require("../vendor/make-fetch-happen");
    },
    30498: module => {
      "use strict";
      module.exports = require("../vendor/mississippi");
    },
    34712: module => {
      "use strict";
      module.exports = require("../vendor/request");
    },
    7195: module => {
      "use strict";
      module.exports = require("../vendor/sorted-union-stream");
    },
    33491: module => {
      "use strict";
      module.exports = require("./metrics-launch");
    },
    35965: module => {
      "use strict";
      module.exports = require;
    },
    39491: module => {
      "use strict";
      module.exports = require("assert");
    },
    14300: module => {
      "use strict";
      module.exports = require("buffer");
    },
    32081: module => {
      "use strict";
      module.exports = require("child_process");
    },
    22057: module => {
      "use strict";
      module.exports = require("constants");
    },
    6113: module => {
      "use strict";
      module.exports = require("crypto");
    },
    13639: module => {
      "use strict";
      module.exports = require("domain");
    },
    82361: module => {
      "use strict";
      module.exports = require("events");
    },
    57147: module => {
      "use strict";
      module.exports = require("fs");
    },
    13685: module => {
      "use strict";
      module.exports = require("http");
    },
    98188: module => {
      "use strict";
      module.exports = require("module");
    },
    22037: module => {
      "use strict";
      module.exports = require("os");
    },
    71017: module => {
      "use strict";
      module.exports = require("path");
    },
    63477: module => {
      "use strict";
      module.exports = require("querystring");
    },
    14521: module => {
      "use strict";
      module.exports = require("readline");
    },
    12781: module => {
      "use strict";
      module.exports = require("stream");
    },
    39512: module => {
      "use strict";
      module.exports = require("timers");
    },
    76224: module => {
      "use strict";
      module.exports = require("tty");
    },
    57310: module => {
      "use strict";
      module.exports = require("url");
    },
    73837: module => {
      "use strict";
      module.exports = require("util");
    },
    26144: module => {
      "use strict";
      module.exports = require("vm");
    },
    71267: module => {
      "use strict";
      module.exports = require("worker_threads");
    },
    59796: module => {
      "use strict";
      module.exports = require("zlib");
    },
    52822: (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
      "use strict";
      __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
        default: () => __WEBPACK_DEFAULT_EXPORT__
      });
      class ByteSize {
        constructor(bytes, options) {
          (options = options || {}).units = options.units || "metric", options.precision = void 0 === options.precision ? 1 : options.precision;
          const table = [ {
            expFrom: 0,
            expTo: 1,
            metric: "B",
            iec: "B",
            metric_octet: "o",
            iec_octet: "o"
          }, {
            expFrom: 1,
            expTo: 2,
            metric: "kB",
            iec: "KiB",
            metric_octet: "ko",
            iec_octet: "Kio"
          }, {
            expFrom: 2,
            expTo: 3,
            metric: "MB",
            iec: "MiB",
            metric_octet: "Mo",
            iec_octet: "Mio"
          }, {
            expFrom: 3,
            expTo: 4,
            metric: "GB",
            iec: "GiB",
            metric_octet: "Go",
            iec_octet: "Gio"
          }, {
            expFrom: 4,
            expTo: 5,
            metric: "TB",
            iec: "TiB",
            metric_octet: "To",
            iec_octet: "Tio"
          }, {
            expFrom: 5,
            expTo: 6,
            metric: "PB",
            iec: "PiB",
            metric_octet: "Po",
            iec_octet: "Pio"
          }, {
            expFrom: 6,
            expTo: 7,
            metric: "EB",
            iec: "EiB",
            metric_octet: "Eo",
            iec_octet: "Eio"
          }, {
            expFrom: 7,
            expTo: 8,
            metric: "ZB",
            iec: "ZiB",
            metric_octet: "Zo",
            iec_octet: "Zio"
          }, {
            expFrom: 8,
            expTo: 9,
            metric: "YB",
            iec: "YiB",
            metric_octet: "Yo",
            iec_octet: "Yio"
          } ], base = "metric" === options.units || "metric_octet" === options.units ? 1e3 : 1024, prefix = bytes < 0 ? "-" : "";
          bytes = Math.abs(bytes);
          for (let i = 0; i < table.length; i++) {
            const lower = Math.pow(base, table[i].expFrom), upper = Math.pow(base, table[i].expTo);
            if (bytes >= lower && bytes < upper) {
              const units = table[i][options.units];
              return 0 === i ? (this.value = prefix + bytes, void (this.unit = units)) : (this.value = prefix + (bytes / lower).toFixed(options.precision), 
              void (this.unit = units));
            }
          }
          this.value = prefix + bytes, this.unit = "";
        }
        toString() {
          return `${this.value} ${this.unit}`.trim();
        }
      }
      const __WEBPACK_DEFAULT_EXPORT__ = function(bytes, options) {
        return new ByteSize(bytes, options);
      };
    },
    43732: module => {
      "use strict";
      module.exports = JSON.parse('["assert","buffer","child_process","cluster","console","constants","crypto","dgram","dns","domain","events","fs","http","https","module","net","os","path","process","punycode","querystring","readline","repl","stream","string_decoder","timers","tls","tty","url","util","v8","vm","zlib"]');
    },
    2401: module => {
      "use strict";
      module.exports = JSON.parse('{"h$":{"d":"6 >=6.2.0 || 8 || >=9.3.0"}}');
    },
    9762: module => {
      "use strict";
      module.exports = JSON.parse('{"name":"npm-registry-fetch","version":"4.0.7","description":"Fetch-based http client for use with npm registry APIs"}');
    }
  }, __webpack_module_cache__ = {};
  function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (void 0 !== cachedModule) return cachedModule.exports;
    var module = __webpack_module_cache__[moduleId] = {
      id: moduleId,
      loaded: !1,
      exports: {}
    };
    return __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
    module.loaded = !0, module.exports;
  }
  __webpack_require__.c = __webpack_module_cache__, __webpack_require__.n = module => {
    var getter = module && module.__esModule ? () => module.default : () => module;
    return __webpack_require__.d(getter, {
      a: getter
    }), getter;
  }, __webpack_require__.d = (exports, definition) => {
    for (var key in definition) __webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key) && Object.defineProperty(exports, key, {
      enumerable: !0,
      get: definition[key]
    });
  }, __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop), 
  __webpack_require__.r = exports => {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(exports, "__esModule", {
      value: !0
    });
  }, __webpack_require__.nmd = module => (module.paths = [], module.children || (module.children = []), 
  module);
  var __webpack_exports__ = __webpack_require__(__webpack_require__.s = 44874);
  module.exports = __webpack_exports__;
})();